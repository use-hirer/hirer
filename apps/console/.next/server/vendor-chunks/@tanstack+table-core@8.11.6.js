"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tanstack+table-core@8.11.6";
exports.ids = ["vendor-chunks/@tanstack+table-core@8.11.6"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@tanstack+table-core@8.11.6/node_modules/@tanstack/table-core/build/lib/index.mjs":
/*!******************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@tanstack+table-core@8.11.6/node_modules/@tanstack/table-core/build/lib/index.mjs ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColumnSizing: () => (/* binding */ ColumnSizing),\n/* harmony export */   Expanding: () => (/* binding */ Expanding),\n/* harmony export */   Filters: () => (/* binding */ Filters),\n/* harmony export */   Grouping: () => (/* binding */ Grouping),\n/* harmony export */   Headers: () => (/* binding */ Headers),\n/* harmony export */   Ordering: () => (/* binding */ Ordering),\n/* harmony export */   Pagination: () => (/* binding */ Pagination),\n/* harmony export */   Pinning: () => (/* binding */ Pinning),\n/* harmony export */   RowSelection: () => (/* binding */ RowSelection),\n/* harmony export */   Sorting: () => (/* binding */ Sorting),\n/* harmony export */   Visibility: () => (/* binding */ Visibility),\n/* harmony export */   aggregationFns: () => (/* binding */ aggregationFns),\n/* harmony export */   buildHeaderGroups: () => (/* binding */ buildHeaderGroups),\n/* harmony export */   createCell: () => (/* binding */ createCell),\n/* harmony export */   createColumn: () => (/* binding */ createColumn),\n/* harmony export */   createColumnHelper: () => (/* binding */ createColumnHelper),\n/* harmony export */   createRow: () => (/* binding */ createRow),\n/* harmony export */   createTable: () => (/* binding */ createTable),\n/* harmony export */   defaultColumnSizing: () => (/* binding */ defaultColumnSizing),\n/* harmony export */   expandRows: () => (/* binding */ expandRows),\n/* harmony export */   filterFns: () => (/* binding */ filterFns),\n/* harmony export */   flattenBy: () => (/* binding */ flattenBy),\n/* harmony export */   functionalUpdate: () => (/* binding */ functionalUpdate),\n/* harmony export */   getCoreRowModel: () => (/* binding */ getCoreRowModel),\n/* harmony export */   getExpandedRowModel: () => (/* binding */ getExpandedRowModel),\n/* harmony export */   getFacetedMinMaxValues: () => (/* binding */ getFacetedMinMaxValues),\n/* harmony export */   getFacetedRowModel: () => (/* binding */ getFacetedRowModel),\n/* harmony export */   getFacetedUniqueValues: () => (/* binding */ getFacetedUniqueValues),\n/* harmony export */   getFilteredRowModel: () => (/* binding */ getFilteredRowModel),\n/* harmony export */   getGroupedRowModel: () => (/* binding */ getGroupedRowModel),\n/* harmony export */   getPaginationRowModel: () => (/* binding */ getPaginationRowModel),\n/* harmony export */   getSortedRowModel: () => (/* binding */ getSortedRowModel),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isNumberArray: () => (/* binding */ isNumberArray),\n/* harmony export */   isRowSelected: () => (/* binding */ isRowSelected),\n/* harmony export */   isSubRowSelected: () => (/* binding */ isSubRowSelected),\n/* harmony export */   makeStateUpdater: () => (/* binding */ makeStateUpdater),\n/* harmony export */   memo: () => (/* binding */ memo),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   orderColumns: () => (/* binding */ orderColumns),\n/* harmony export */   passiveEventSupported: () => (/* binding */ passiveEventSupported),\n/* harmony export */   reSplitAlphaNumeric: () => (/* binding */ reSplitAlphaNumeric),\n/* harmony export */   selectRowsFn: () => (/* binding */ selectRowsFn),\n/* harmony export */   shouldAutoRemoveFilter: () => (/* binding */ shouldAutoRemoveFilter),\n/* harmony export */   sortingFns: () => (/* binding */ sortingFns)\n/* harmony export */ });\n/**\n   * table-core\n   *\n   * Copyright (c) TanStack\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   */ // Is this type a tuple?\n// If this type is a tuple, what indices are allowed?\n///\nfunction functionalUpdate(updater, input) {\n    return typeof updater === \"function\" ? updater(input) : updater;\n}\nfunction noop() {\n//\n}\nfunction makeStateUpdater(key, instance) {\n    return (updater)=>{\n        instance.setState((old)=>{\n            return {\n                ...old,\n                [key]: functionalUpdate(updater, old[key])\n            };\n        });\n    };\n}\nfunction isFunction(d) {\n    return d instanceof Function;\n}\nfunction isNumberArray(d) {\n    return Array.isArray(d) && d.every((val)=>typeof val === \"number\");\n}\nfunction flattenBy(arr, getChildren) {\n    const flat = [];\n    const recurse = (subArr)=>{\n        subArr.forEach((item)=>{\n            flat.push(item);\n            const children = getChildren(item);\n            if (children != null && children.length) {\n                recurse(children);\n            }\n        });\n    };\n    recurse(arr);\n    return flat;\n}\nfunction memo(getDeps, fn, opts) {\n    let deps = [];\n    let result;\n    return ()=>{\n        let depTime;\n        if (opts.key && opts.debug) depTime = Date.now();\n        const newDeps = getDeps();\n        const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index)=>deps[index] !== dep);\n        if (!depsChanged) {\n            return result;\n        }\n        deps = newDeps;\n        let resultTime;\n        if (opts.key && opts.debug) resultTime = Date.now();\n        result = fn(...newDeps);\n        opts == null || opts.onChange == null || opts.onChange(result);\n        if (opts.key && opts.debug) {\n            if (opts != null && opts.debug()) {\n                const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n                const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n                const resultFpsPercentage = resultEndTime / 16;\n                const pad = (str, num)=>{\n                    str = String(str);\n                    while(str.length < num){\n                        str = \" \" + str;\n                    }\n                    return str;\n                };\n                console.info(`%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);\n            }\n        }\n        return result;\n    };\n}\nfunction createColumn(table, columnDef, depth, parent) {\n    var _ref, _resolvedColumnDef$id;\n    const defaultColumn = table._getDefaultColumnDef();\n    const resolvedColumnDef = {\n        ...defaultColumn,\n        ...columnDef\n    };\n    const accessorKey = resolvedColumnDef.accessorKey;\n    let id = (_ref = (_resolvedColumnDef$id = resolvedColumnDef.id) != null ? _resolvedColumnDef$id : accessorKey ? accessorKey.replace(\".\", \"_\") : undefined) != null ? _ref : typeof resolvedColumnDef.header === \"string\" ? resolvedColumnDef.header : undefined;\n    let accessorFn;\n    if (resolvedColumnDef.accessorFn) {\n        accessorFn = resolvedColumnDef.accessorFn;\n    } else if (accessorKey) {\n        // Support deep accessor keys\n        if (accessorKey.includes(\".\")) {\n            accessorFn = (originalRow)=>{\n                let result = originalRow;\n                for (const key of accessorKey.split(\".\")){\n                    var _result;\n                    result = (_result = result) == null ? void 0 : _result[key];\n                    if ( true && result === undefined) {\n                        console.warn(`\"${key}\" in deeply nested key \"${accessorKey}\" returned undefined.`);\n                    }\n                }\n                return result;\n            };\n        } else {\n            accessorFn = (originalRow)=>originalRow[resolvedColumnDef.accessorKey];\n        }\n    }\n    if (!id) {\n        if (true) {\n            throw new Error(resolvedColumnDef.accessorFn ? `Columns require an id when using an accessorFn` : `Columns require an id when using a non-string header`);\n        }\n        throw new Error();\n    }\n    let column = {\n        id: `${String(id)}`,\n        accessorFn,\n        parent: parent,\n        depth,\n        columnDef: resolvedColumnDef,\n        columns: [],\n        getFlatColumns: memo(()=>[\n                true\n            ], ()=>{\n            var _column$columns;\n            return [\n                column,\n                ...(_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap((d)=>d.getFlatColumns())\n            ];\n        }, {\n            key:  false && 0,\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugColumns;\n            }\n        }),\n        getLeafColumns: memo(()=>[\n                table._getOrderColumnsFn()\n            ], (orderColumns)=>{\n            var _column$columns2;\n            if ((_column$columns2 = column.columns) != null && _column$columns2.length) {\n                let leafColumns = column.columns.flatMap((column)=>column.getLeafColumns());\n                return orderColumns(leafColumns);\n            }\n            return [\n                column\n            ];\n        }, {\n            key:  false && 0,\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugColumns;\n            }\n        })\n    };\n    for (const feature of table._features){\n        feature.createColumn == null || feature.createColumn(column, table);\n    }\n    // Yes, we have to convert table to uknown, because we know more than the compiler here.\n    return column;\n}\n//\nfunction createHeader(table, column, options) {\n    var _options$id;\n    const id = (_options$id = options.id) != null ? _options$id : column.id;\n    let header = {\n        id,\n        column,\n        index: options.index,\n        isPlaceholder: !!options.isPlaceholder,\n        placeholderId: options.placeholderId,\n        depth: options.depth,\n        subHeaders: [],\n        colSpan: 0,\n        rowSpan: 0,\n        headerGroup: null,\n        getLeafHeaders: ()=>{\n            const leafHeaders = [];\n            const recurseHeader = (h)=>{\n                if (h.subHeaders && h.subHeaders.length) {\n                    h.subHeaders.map(recurseHeader);\n                }\n                leafHeaders.push(h);\n            };\n            recurseHeader(header);\n            return leafHeaders;\n        },\n        getContext: ()=>({\n                table,\n                header: header,\n                column\n            })\n    };\n    table._features.forEach((feature)=>{\n        feature.createHeader == null || feature.createHeader(header, table);\n    });\n    return header;\n}\nconst Headers = {\n    createTable: (table)=>{\n        // Header Groups\n        table.getHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, left, right)=>{\n            var _left$map$filter, _right$map$filter;\n            const leftColumns = (_left$map$filter = left == null ? void 0 : left.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];\n            const rightColumns = (_right$map$filter = right == null ? void 0 : right.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];\n            const centerColumns = leafColumns.filter((column)=>!(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n            const headerGroups = buildHeaderGroups(allColumns, [\n                ...leftColumns,\n                ...centerColumns,\n                ...rightColumns\n            ], table);\n            return headerGroups;\n        }, {\n            key:  true && \"getHeaderGroups\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugHeaders;\n            }\n        });\n        table.getCenterHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, left, right)=>{\n            leafColumns = leafColumns.filter((column)=>!(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n            return buildHeaderGroups(allColumns, leafColumns, table, \"center\");\n        }, {\n            key:  true && \"getCenterHeaderGroups\",\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugHeaders;\n            }\n        });\n        table.getLeftHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left\n            ], (allColumns, leafColumns, left)=>{\n            var _left$map$filter2;\n            const orderedLeafColumns = (_left$map$filter2 = left == null ? void 0 : left.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];\n            return buildHeaderGroups(allColumns, orderedLeafColumns, table, \"left\");\n        }, {\n            key:  true && \"getLeftHeaderGroups\",\n            debug: ()=>{\n                var _table$options$debugA3;\n                return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugHeaders;\n            }\n        });\n        table.getRightHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, right)=>{\n            var _right$map$filter2;\n            const orderedLeafColumns = (_right$map$filter2 = right == null ? void 0 : right.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];\n            return buildHeaderGroups(allColumns, orderedLeafColumns, table, \"right\");\n        }, {\n            key:  true && \"getRightHeaderGroups\",\n            debug: ()=>{\n                var _table$options$debugA4;\n                return (_table$options$debugA4 = table.options.debugAll) != null ? _table$options$debugA4 : table.options.debugHeaders;\n            }\n        });\n        // Footer Groups\n        table.getFooterGroups = memo(()=>[\n                table.getHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, {\n            key:  true && \"getFooterGroups\",\n            debug: ()=>{\n                var _table$options$debugA5;\n                return (_table$options$debugA5 = table.options.debugAll) != null ? _table$options$debugA5 : table.options.debugHeaders;\n            }\n        });\n        table.getLeftFooterGroups = memo(()=>[\n                table.getLeftHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, {\n            key:  true && \"getLeftFooterGroups\",\n            debug: ()=>{\n                var _table$options$debugA6;\n                return (_table$options$debugA6 = table.options.debugAll) != null ? _table$options$debugA6 : table.options.debugHeaders;\n            }\n        });\n        table.getCenterFooterGroups = memo(()=>[\n                table.getCenterHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, {\n            key:  true && \"getCenterFooterGroups\",\n            debug: ()=>{\n                var _table$options$debugA7;\n                return (_table$options$debugA7 = table.options.debugAll) != null ? _table$options$debugA7 : table.options.debugHeaders;\n            }\n        });\n        table.getRightFooterGroups = memo(()=>[\n                table.getRightHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, {\n            key:  true && \"getRightFooterGroups\",\n            debug: ()=>{\n                var _table$options$debugA8;\n                return (_table$options$debugA8 = table.options.debugAll) != null ? _table$options$debugA8 : table.options.debugHeaders;\n            }\n        });\n        // Flat Headers\n        table.getFlatHeaders = memo(()=>[\n                table.getHeaderGroups()\n            ], (headerGroups)=>{\n            return headerGroups.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, {\n            key:  true && \"getFlatHeaders\",\n            debug: ()=>{\n                var _table$options$debugA9;\n                return (_table$options$debugA9 = table.options.debugAll) != null ? _table$options$debugA9 : table.options.debugHeaders;\n            }\n        });\n        table.getLeftFlatHeaders = memo(()=>[\n                table.getLeftHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, {\n            key:  true && \"getLeftFlatHeaders\",\n            debug: ()=>{\n                var _table$options$debugA10;\n                return (_table$options$debugA10 = table.options.debugAll) != null ? _table$options$debugA10 : table.options.debugHeaders;\n            }\n        });\n        table.getCenterFlatHeaders = memo(()=>[\n                table.getCenterHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, {\n            key:  true && \"getCenterFlatHeaders\",\n            debug: ()=>{\n                var _table$options$debugA11;\n                return (_table$options$debugA11 = table.options.debugAll) != null ? _table$options$debugA11 : table.options.debugHeaders;\n            }\n        });\n        table.getRightFlatHeaders = memo(()=>[\n                table.getRightHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, {\n            key:  true && \"getRightFlatHeaders\",\n            debug: ()=>{\n                var _table$options$debugA12;\n                return (_table$options$debugA12 = table.options.debugAll) != null ? _table$options$debugA12 : table.options.debugHeaders;\n            }\n        });\n        // Leaf Headers\n        table.getCenterLeafHeaders = memo(()=>[\n                table.getCenterFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders;\n                return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);\n            });\n        }, {\n            key:  true && \"getCenterLeafHeaders\",\n            debug: ()=>{\n                var _table$options$debugA13;\n                return (_table$options$debugA13 = table.options.debugAll) != null ? _table$options$debugA13 : table.options.debugHeaders;\n            }\n        });\n        table.getLeftLeafHeaders = memo(()=>[\n                table.getLeftFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders2;\n                return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);\n            });\n        }, {\n            key:  true && \"getLeftLeafHeaders\",\n            debug: ()=>{\n                var _table$options$debugA14;\n                return (_table$options$debugA14 = table.options.debugAll) != null ? _table$options$debugA14 : table.options.debugHeaders;\n            }\n        });\n        table.getRightLeafHeaders = memo(()=>[\n                table.getRightFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders3;\n                return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);\n            });\n        }, {\n            key:  true && \"getRightLeafHeaders\",\n            debug: ()=>{\n                var _table$options$debugA15;\n                return (_table$options$debugA15 = table.options.debugAll) != null ? _table$options$debugA15 : table.options.debugHeaders;\n            }\n        });\n        table.getLeafHeaders = memo(()=>[\n                table.getLeftHeaderGroups(),\n                table.getCenterHeaderGroups(),\n                table.getRightHeaderGroups()\n            ], (left, center, right)=>{\n            var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;\n            return [\n                ...(_left$0$headers = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : [],\n                ...(_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : [],\n                ...(_right$0$headers = (_right$ = right[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : []\n            ].map((header)=>{\n                return header.getLeafHeaders();\n            }).flat();\n        }, {\n            key:  true && \"getLeafHeaders\",\n            debug: ()=>{\n                var _table$options$debugA16;\n                return (_table$options$debugA16 = table.options.debugAll) != null ? _table$options$debugA16 : table.options.debugHeaders;\n            }\n        });\n    }\n};\nfunction buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {\n    var _headerGroups$0$heade, _headerGroups$;\n    // Find the max depth of the columns:\n    // build the leaf column row\n    // build each buffer row going up\n    //    placeholder for non-existent level\n    //    real column for existing level\n    let maxDepth = 0;\n    const findMaxDepth = function(columns, depth) {\n        if (depth === void 0) {\n            depth = 1;\n        }\n        maxDepth = Math.max(maxDepth, depth);\n        columns.filter((column)=>column.getIsVisible()).forEach((column)=>{\n            var _column$columns;\n            if ((_column$columns = column.columns) != null && _column$columns.length) {\n                findMaxDepth(column.columns, depth + 1);\n            }\n        }, 0);\n    };\n    findMaxDepth(allColumns);\n    let headerGroups = [];\n    const createHeaderGroup = (headersToGroup, depth)=>{\n        // The header group we are creating\n        const headerGroup = {\n            depth,\n            id: [\n                headerFamily,\n                `${depth}`\n            ].filter(Boolean).join(\"_\"),\n            headers: []\n        };\n        // The parent columns we're going to scan next\n        const pendingParentHeaders = [];\n        // Scan each column for parents\n        headersToGroup.forEach((headerToGroup)=>{\n            // What is the latest (last) parent column?\n            const latestPendingParentHeader = [\n                ...pendingParentHeaders\n            ].reverse()[0];\n            const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;\n            let column;\n            let isPlaceholder = false;\n            if (isLeafHeader && headerToGroup.column.parent) {\n                // The parent header is new\n                column = headerToGroup.column.parent;\n            } else {\n                // The parent header is repeated\n                column = headerToGroup.column;\n                isPlaceholder = true;\n            }\n            if (latestPendingParentHeader && (latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {\n                // This column is repeated. Add it as a sub header to the next batch\n                latestPendingParentHeader.subHeaders.push(headerToGroup);\n            } else {\n                // This is a new header. Let's create it\n                const header = createHeader(table, column, {\n                    id: [\n                        headerFamily,\n                        depth,\n                        column.id,\n                        headerToGroup == null ? void 0 : headerToGroup.id\n                    ].filter(Boolean).join(\"_\"),\n                    isPlaceholder,\n                    placeholderId: isPlaceholder ? `${pendingParentHeaders.filter((d)=>d.column === column).length}` : undefined,\n                    depth,\n                    index: pendingParentHeaders.length\n                });\n                // Add the headerToGroup as a subHeader of the new header\n                header.subHeaders.push(headerToGroup);\n                // Add the new header to the pendingParentHeaders to get grouped\n                // in the next batch\n                pendingParentHeaders.push(header);\n            }\n            headerGroup.headers.push(headerToGroup);\n            headerToGroup.headerGroup = headerGroup;\n        });\n        headerGroups.push(headerGroup);\n        if (depth > 0) {\n            createHeaderGroup(pendingParentHeaders, depth - 1);\n        }\n    };\n    const bottomHeaders = columnsToGroup.map((column, index)=>createHeader(table, column, {\n            depth: maxDepth,\n            index\n        }));\n    createHeaderGroup(bottomHeaders, maxDepth - 1);\n    headerGroups.reverse();\n    // headerGroups = headerGroups.filter(headerGroup => {\n    //   return !headerGroup.headers.every(header => header.isPlaceholder)\n    // })\n    const recurseHeadersForSpans = (headers)=>{\n        const filteredHeaders = headers.filter((header)=>header.column.getIsVisible());\n        return filteredHeaders.map((header)=>{\n            let colSpan = 0;\n            let rowSpan = 0;\n            let childRowSpans = [\n                0\n            ];\n            if (header.subHeaders && header.subHeaders.length) {\n                childRowSpans = [];\n                recurseHeadersForSpans(header.subHeaders).forEach((_ref)=>{\n                    let { colSpan: childColSpan, rowSpan: childRowSpan } = _ref;\n                    colSpan += childColSpan;\n                    childRowSpans.push(childRowSpan);\n                });\n            } else {\n                colSpan = 1;\n            }\n            const minChildRowSpan = Math.min(...childRowSpans);\n            rowSpan = rowSpan + minChildRowSpan;\n            header.colSpan = colSpan;\n            header.rowSpan = rowSpan;\n            return {\n                colSpan,\n                rowSpan\n            };\n        });\n    };\n    recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);\n    return headerGroups;\n}\n//\n//\nconst defaultColumnSizing = {\n    size: 150,\n    minSize: 20,\n    maxSize: Number.MAX_SAFE_INTEGER\n};\nconst getDefaultColumnSizingInfoState = ()=>({\n        startOffset: null,\n        startSize: null,\n        deltaOffset: null,\n        deltaPercentage: null,\n        isResizingColumn: false,\n        columnSizingStart: []\n    });\nconst ColumnSizing = {\n    getDefaultColumnDef: ()=>{\n        return defaultColumnSizing;\n    },\n    getInitialState: (state)=>{\n        return {\n            columnSizing: {},\n            columnSizingInfo: getDefaultColumnSizingInfoState(),\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            columnResizeMode: \"onEnd\",\n            columnResizeDirection: \"ltr\",\n            onColumnSizingChange: makeStateUpdater(\"columnSizing\", table),\n            onColumnSizingInfoChange: makeStateUpdater(\"columnSizingInfo\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getSize = ()=>{\n            var _column$columnDef$min, _ref, _column$columnDef$max;\n            const columnSize = table.getState().columnSizing[column.id];\n            return Math.min(Math.max((_column$columnDef$min = column.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);\n        };\n        column.getStart = (position)=>{\n            const columns = !position ? table.getVisibleLeafColumns() : position === \"left\" ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();\n            const index = columns.findIndex((d)=>d.id === column.id);\n            if (index > 0) {\n                const prevSiblingColumn = columns[index - 1];\n                return prevSiblingColumn.getStart(position) + prevSiblingColumn.getSize();\n            }\n            return 0;\n        };\n        column.resetSize = ()=>{\n            table.setColumnSizing((_ref2)=>{\n                let { [column.id]: _, ...rest } = _ref2;\n                return rest;\n            });\n        };\n        column.getCanResize = ()=>{\n            var _column$columnDef$ena, _table$options$enable;\n            return ((_column$columnDef$ena = column.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnResizing) != null ? _table$options$enable : true);\n        };\n        column.getIsResizing = ()=>{\n            return table.getState().columnSizingInfo.isResizingColumn === column.id;\n        };\n    },\n    createHeader: (header, table)=>{\n        header.getSize = ()=>{\n            let sum = 0;\n            const recurse = (header)=>{\n                if (header.subHeaders.length) {\n                    header.subHeaders.forEach(recurse);\n                } else {\n                    var _header$column$getSiz;\n                    sum += (_header$column$getSiz = header.column.getSize()) != null ? _header$column$getSiz : 0;\n                }\n            };\n            recurse(header);\n            return sum;\n        };\n        header.getStart = ()=>{\n            if (header.index > 0) {\n                const prevSiblingHeader = header.headerGroup.headers[header.index - 1];\n                return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();\n            }\n            return 0;\n        };\n        header.getResizeHandler = (_contextDocument)=>{\n            const column = table.getColumn(header.column.id);\n            const canResize = column == null ? void 0 : column.getCanResize();\n            return (e)=>{\n                if (!column || !canResize) {\n                    return;\n                }\n                e.persist == null || e.persist();\n                if (isTouchStartEvent(e)) {\n                    // lets not respond to multiple touches (e.g. 2 or 3 fingers)\n                    if (e.touches && e.touches.length > 1) {\n                        return;\n                    }\n                }\n                const startSize = header.getSize();\n                const columnSizingStart = header ? header.getLeafHeaders().map((d)=>[\n                        d.column.id,\n                        d.column.getSize()\n                    ]) : [\n                    [\n                        column.id,\n                        column.getSize()\n                    ]\n                ];\n                const clientX = isTouchStartEvent(e) ? Math.round(e.touches[0].clientX) : e.clientX;\n                const newColumnSizing = {};\n                const updateOffset = (eventType, clientXPos)=>{\n                    if (typeof clientXPos !== \"number\") {\n                        return;\n                    }\n                    table.setColumnSizingInfo((old)=>{\n                        var _old$startOffset, _old$startSize;\n                        const deltaDirection = table.options.columnResizeDirection === \"rtl\" ? -1 : 1;\n                        const deltaOffset = (clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0)) * deltaDirection;\n                        const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -0.999999);\n                        old.columnSizingStart.forEach((_ref3)=>{\n                            let [columnId, headerSize] = _ref3;\n                            newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;\n                        });\n                        return {\n                            ...old,\n                            deltaOffset,\n                            deltaPercentage\n                        };\n                    });\n                    if (table.options.columnResizeMode === \"onChange\" || eventType === \"end\") {\n                        table.setColumnSizing((old)=>({\n                                ...old,\n                                ...newColumnSizing\n                            }));\n                    }\n                };\n                const onMove = (clientXPos)=>updateOffset(\"move\", clientXPos);\n                const onEnd = (clientXPos)=>{\n                    updateOffset(\"end\", clientXPos);\n                    table.setColumnSizingInfo((old)=>({\n                            ...old,\n                            isResizingColumn: false,\n                            startOffset: null,\n                            startSize: null,\n                            deltaOffset: null,\n                            deltaPercentage: null,\n                            columnSizingStart: []\n                        }));\n                };\n                const contextDocument = _contextDocument || typeof document !== \"undefined\" ? document : null;\n                const mouseEvents = {\n                    moveHandler: (e)=>onMove(e.clientX),\n                    upHandler: (e)=>{\n                        contextDocument == null || contextDocument.removeEventListener(\"mousemove\", mouseEvents.moveHandler);\n                        contextDocument == null || contextDocument.removeEventListener(\"mouseup\", mouseEvents.upHandler);\n                        onEnd(e.clientX);\n                    }\n                };\n                const touchEvents = {\n                    moveHandler: (e)=>{\n                        if (e.cancelable) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                        }\n                        onMove(e.touches[0].clientX);\n                        return false;\n                    },\n                    upHandler: (e)=>{\n                        var _e$touches$;\n                        contextDocument == null || contextDocument.removeEventListener(\"touchmove\", touchEvents.moveHandler);\n                        contextDocument == null || contextDocument.removeEventListener(\"touchend\", touchEvents.upHandler);\n                        if (e.cancelable) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                        }\n                        onEnd((_e$touches$ = e.touches[0]) == null ? void 0 : _e$touches$.clientX);\n                    }\n                };\n                const passiveIfSupported = passiveEventSupported() ? {\n                    passive: false\n                } : false;\n                if (isTouchStartEvent(e)) {\n                    contextDocument == null || contextDocument.addEventListener(\"touchmove\", touchEvents.moveHandler, passiveIfSupported);\n                    contextDocument == null || contextDocument.addEventListener(\"touchend\", touchEvents.upHandler, passiveIfSupported);\n                } else {\n                    contextDocument == null || contextDocument.addEventListener(\"mousemove\", mouseEvents.moveHandler, passiveIfSupported);\n                    contextDocument == null || contextDocument.addEventListener(\"mouseup\", mouseEvents.upHandler, passiveIfSupported);\n                }\n                table.setColumnSizingInfo((old)=>({\n                        ...old,\n                        startOffset: clientX,\n                        startSize,\n                        deltaOffset: 0,\n                        deltaPercentage: 0,\n                        columnSizingStart,\n                        isResizingColumn: column.id\n                    }));\n            };\n        };\n    },\n    createTable: (table)=>{\n        table.setColumnSizing = (updater)=>table.options.onColumnSizingChange == null ? void 0 : table.options.onColumnSizingChange(updater);\n        table.setColumnSizingInfo = (updater)=>table.options.onColumnSizingInfoChange == null ? void 0 : table.options.onColumnSizingInfoChange(updater);\n        table.resetColumnSizing = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnSizing(defaultState ? {} : (_table$initialState$c = table.initialState.columnSizing) != null ? _table$initialState$c : {});\n        };\n        table.resetHeaderSizeInfo = (defaultState)=>{\n            var _table$initialState$c2;\n            table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_table$initialState$c2 = table.initialState.columnSizingInfo) != null ? _table$initialState$c2 : getDefaultColumnSizingInfoState());\n        };\n        table.getTotalSize = ()=>{\n            var _table$getHeaderGroup, _table$getHeaderGroup2;\n            return (_table$getHeaderGroup = (_table$getHeaderGroup2 = table.getHeaderGroups()[0]) == null ? void 0 : _table$getHeaderGroup2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getHeaderGroup : 0;\n        };\n        table.getLeftTotalSize = ()=>{\n            var _table$getLeftHeaderG, _table$getLeftHeaderG2;\n            return (_table$getLeftHeaderG = (_table$getLeftHeaderG2 = table.getLeftHeaderGroups()[0]) == null ? void 0 : _table$getLeftHeaderG2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getLeftHeaderG : 0;\n        };\n        table.getCenterTotalSize = ()=>{\n            var _table$getCenterHeade, _table$getCenterHeade2;\n            return (_table$getCenterHeade = (_table$getCenterHeade2 = table.getCenterHeaderGroups()[0]) == null ? void 0 : _table$getCenterHeade2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getCenterHeade : 0;\n        };\n        table.getRightTotalSize = ()=>{\n            var _table$getRightHeader, _table$getRightHeader2;\n            return (_table$getRightHeader = (_table$getRightHeader2 = table.getRightHeaderGroups()[0]) == null ? void 0 : _table$getRightHeader2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getRightHeader : 0;\n        };\n    }\n};\nlet passiveSupported = null;\nfunction passiveEventSupported() {\n    if (typeof passiveSupported === \"boolean\") return passiveSupported;\n    let supported = false;\n    try {\n        const options = {\n            get passive () {\n                supported = true;\n                return false;\n            }\n        };\n        const noop = ()=>{};\n        window.addEventListener(\"test\", noop, options);\n        window.removeEventListener(\"test\", noop);\n    } catch (err) {\n        supported = false;\n    }\n    passiveSupported = supported;\n    return passiveSupported;\n}\nfunction isTouchStartEvent(e) {\n    return e.type === \"touchstart\";\n}\n//\nconst Expanding = {\n    getInitialState: (state)=>{\n        return {\n            expanded: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onExpandedChange: makeStateUpdater(\"expanded\", table),\n            paginateExpandedRows: true\n        };\n    },\n    createTable: (table)=>{\n        let registered = false;\n        let queued = false;\n        table._autoResetExpanded = ()=>{\n            var _ref, _table$options$autoRe;\n            if (!registered) {\n                table._queue(()=>{\n                    registered = true;\n                });\n                return;\n            }\n            if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetExpanded) != null ? _ref : !table.options.manualExpanding) {\n                if (queued) return;\n                queued = true;\n                table._queue(()=>{\n                    table.resetExpanded();\n                    queued = false;\n                });\n            }\n        };\n        table.setExpanded = (updater)=>table.options.onExpandedChange == null ? void 0 : table.options.onExpandedChange(updater);\n        table.toggleAllRowsExpanded = (expanded)=>{\n            if (expanded != null ? expanded : !table.getIsAllRowsExpanded()) {\n                table.setExpanded(true);\n            } else {\n                table.setExpanded({});\n            }\n        };\n        table.resetExpanded = (defaultState)=>{\n            var _table$initialState$e, _table$initialState;\n            table.setExpanded(defaultState ? {} : (_table$initialState$e = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.expanded) != null ? _table$initialState$e : {});\n        };\n        table.getCanSomeRowsExpand = ()=>{\n            return table.getPrePaginationRowModel().flatRows.some((row)=>row.getCanExpand());\n        };\n        table.getToggleAllRowsExpandedHandler = ()=>{\n            return (e)=>{\n                e.persist == null || e.persist();\n                table.toggleAllRowsExpanded();\n            };\n        };\n        table.getIsSomeRowsExpanded = ()=>{\n            const expanded = table.getState().expanded;\n            return expanded === true || Object.values(expanded).some(Boolean);\n        };\n        table.getIsAllRowsExpanded = ()=>{\n            const expanded = table.getState().expanded;\n            // If expanded is true, save some cycles and return true\n            if (typeof expanded === \"boolean\") {\n                return expanded === true;\n            }\n            if (!Object.keys(expanded).length) {\n                return false;\n            }\n            // If any row is not expanded, return false\n            if (table.getRowModel().flatRows.some((row)=>!row.getIsExpanded())) {\n                return false;\n            }\n            // They must all be expanded :shrug:\n            return true;\n        };\n        table.getExpandedDepth = ()=>{\n            let maxDepth = 0;\n            const rowIds = table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded);\n            rowIds.forEach((id)=>{\n                const splitId = id.split(\".\");\n                maxDepth = Math.max(maxDepth, splitId.length);\n            });\n            return maxDepth;\n        };\n        table.getPreExpandedRowModel = ()=>table.getSortedRowModel();\n        table.getExpandedRowModel = ()=>{\n            if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {\n                table._getExpandedRowModel = table.options.getExpandedRowModel(table);\n            }\n            if (table.options.manualExpanding || !table._getExpandedRowModel) {\n                return table.getPreExpandedRowModel();\n            }\n            return table._getExpandedRowModel();\n        };\n    },\n    createRow: (row, table)=>{\n        row.toggleExpanded = (expanded)=>{\n            table.setExpanded((old)=>{\n                var _expanded;\n                const exists = old === true ? true : !!(old != null && old[row.id]);\n                let oldExpanded = {};\n                if (old === true) {\n                    Object.keys(table.getRowModel().rowsById).forEach((rowId)=>{\n                        oldExpanded[rowId] = true;\n                    });\n                } else {\n                    oldExpanded = old;\n                }\n                expanded = (_expanded = expanded) != null ? _expanded : !exists;\n                if (!exists && expanded) {\n                    return {\n                        ...oldExpanded,\n                        [row.id]: true\n                    };\n                }\n                if (exists && !expanded) {\n                    const { [row.id]: _, ...rest } = oldExpanded;\n                    return rest;\n                }\n                return old;\n            });\n        };\n        row.getIsExpanded = ()=>{\n            var _table$options$getIsR;\n            const expanded = table.getState().expanded;\n            return !!((_table$options$getIsR = table.options.getIsRowExpanded == null ? void 0 : table.options.getIsRowExpanded(row)) != null ? _table$options$getIsR : expanded === true || (expanded == null ? void 0 : expanded[row.id]));\n        };\n        row.getCanExpand = ()=>{\n            var _table$options$getRow, _table$options$enable, _row$subRows;\n            return (_table$options$getRow = table.options.getRowCanExpand == null ? void 0 : table.options.getRowCanExpand(row)) != null ? _table$options$getRow : ((_table$options$enable = table.options.enableExpanding) != null ? _table$options$enable : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\n        };\n        row.getIsAllParentsExpanded = ()=>{\n            let isFullyExpanded = true;\n            let currentRow = row;\n            while(isFullyExpanded && currentRow.parentId){\n                currentRow = table.getRow(currentRow.parentId, true);\n                isFullyExpanded = currentRow.getIsExpanded();\n            }\n            return isFullyExpanded;\n        };\n        row.getToggleExpandedHandler = ()=>{\n            const canExpand = row.getCanExpand();\n            return ()=>{\n                if (!canExpand) return;\n                row.toggleExpanded();\n            };\n        };\n    }\n};\nconst includesString = (row, columnId, filterValue)=>{\n    var _row$getValue;\n    const search = filterValue.toLowerCase();\n    return Boolean((_row$getValue = row.getValue(columnId)) == null || (_row$getValue = _row$getValue.toString()) == null || (_row$getValue = _row$getValue.toLowerCase()) == null ? void 0 : _row$getValue.includes(search));\n};\nincludesString.autoRemove = (val)=>testFalsey(val);\nconst includesStringSensitive = (row, columnId, filterValue)=>{\n    var _row$getValue2;\n    return Boolean((_row$getValue2 = row.getValue(columnId)) == null || (_row$getValue2 = _row$getValue2.toString()) == null ? void 0 : _row$getValue2.includes(filterValue));\n};\nincludesStringSensitive.autoRemove = (val)=>testFalsey(val);\nconst equalsString = (row, columnId, filterValue)=>{\n    var _row$getValue3;\n    return ((_row$getValue3 = row.getValue(columnId)) == null || (_row$getValue3 = _row$getValue3.toString()) == null ? void 0 : _row$getValue3.toLowerCase()) === (filterValue == null ? void 0 : filterValue.toLowerCase());\n};\nequalsString.autoRemove = (val)=>testFalsey(val);\nconst arrIncludes = (row, columnId, filterValue)=>{\n    var _row$getValue4;\n    return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);\n};\narrIncludes.autoRemove = (val)=>testFalsey(val) || !(val != null && val.length);\nconst arrIncludesAll = (row, columnId, filterValue)=>{\n    return !filterValue.some((val)=>{\n        var _row$getValue5;\n        return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));\n    });\n};\narrIncludesAll.autoRemove = (val)=>testFalsey(val) || !(val != null && val.length);\nconst arrIncludesSome = (row, columnId, filterValue)=>{\n    return filterValue.some((val)=>{\n        var _row$getValue6;\n        return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);\n    });\n};\narrIncludesSome.autoRemove = (val)=>testFalsey(val) || !(val != null && val.length);\nconst equals = (row, columnId, filterValue)=>{\n    return row.getValue(columnId) === filterValue;\n};\nequals.autoRemove = (val)=>testFalsey(val);\nconst weakEquals = (row, columnId, filterValue)=>{\n    return row.getValue(columnId) == filterValue;\n};\nweakEquals.autoRemove = (val)=>testFalsey(val);\nconst inNumberRange = (row, columnId, filterValue)=>{\n    let [min, max] = filterValue;\n    const rowValue = row.getValue(columnId);\n    return rowValue >= min && rowValue <= max;\n};\ninNumberRange.resolveFilterValue = (val)=>{\n    let [unsafeMin, unsafeMax] = val;\n    let parsedMin = typeof unsafeMin !== \"number\" ? parseFloat(unsafeMin) : unsafeMin;\n    let parsedMax = typeof unsafeMax !== \"number\" ? parseFloat(unsafeMax) : unsafeMax;\n    let min = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;\n    let max = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;\n    if (min > max) {\n        const temp = min;\n        min = max;\n        max = temp;\n    }\n    return [\n        min,\n        max\n    ];\n};\ninNumberRange.autoRemove = (val)=>testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);\n// Export\nconst filterFns = {\n    includesString,\n    includesStringSensitive,\n    equalsString,\n    arrIncludes,\n    arrIncludesAll,\n    arrIncludesSome,\n    equals,\n    weakEquals,\n    inNumberRange\n};\n// Utils\nfunction testFalsey(val) {\n    return val === undefined || val === null || val === \"\";\n}\n//\nconst Filters = {\n    getDefaultColumnDef: ()=>{\n        return {\n            filterFn: \"auto\"\n        };\n    },\n    getInitialState: (state)=>{\n        return {\n            columnFilters: [],\n            globalFilter: undefined,\n            // filtersProgress: 1,\n            // facetProgress: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnFiltersChange: makeStateUpdater(\"columnFilters\", table),\n            onGlobalFilterChange: makeStateUpdater(\"globalFilter\", table),\n            filterFromLeafRows: false,\n            maxLeafRowFilterDepth: 100,\n            globalFilterFn: \"auto\",\n            getColumnCanGlobalFilter: (column)=>{\n                var _table$getCoreRowMode;\n                const value = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null || (_table$getCoreRowMode = _table$getCoreRowMode._getAllCellsByColumnId()[column.id]) == null ? void 0 : _table$getCoreRowMode.getValue();\n                return typeof value === \"string\" || typeof value === \"number\";\n            }\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getAutoFilterFn = ()=>{\n            const firstRow = table.getCoreRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"string\") {\n                return filterFns.includesString;\n            }\n            if (typeof value === \"number\") {\n                return filterFns.inNumberRange;\n            }\n            if (typeof value === \"boolean\") {\n                return filterFns.equals;\n            }\n            if (value !== null && typeof value === \"object\") {\n                return filterFns.equals;\n            }\n            if (Array.isArray(value)) {\n                return filterFns.arrIncludes;\n            }\n            return filterFns.weakEquals;\n        };\n        column.getFilterFn = ()=>{\n            var _table$options$filter, _table$options$filter2;\n            return isFunction(column.columnDef.filterFn) ? column.columnDef.filterFn : column.columnDef.filterFn === \"auto\" ? column.getAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[column.columnDef.filterFn]) != null ? _table$options$filter : filterFns[column.columnDef.filterFn];\n        };\n        column.getCanFilter = ()=>{\n            var _column$columnDef$ena, _table$options$enable, _table$options$enable2;\n            return ((_column$columnDef$ena = column.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnFilters) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && !!column.accessorFn;\n        };\n        column.getCanGlobalFilter = ()=>{\n            var _column$columnDef$ena2, _table$options$enable3, _table$options$enable4, _table$options$getCol;\n            return ((_column$columnDef$ena2 = column.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena2 : true) && ((_table$options$enable3 = table.options.enableGlobalFilter) != null ? _table$options$enable3 : true) && ((_table$options$enable4 = table.options.enableFilters) != null ? _table$options$enable4 : true) && ((_table$options$getCol = table.options.getColumnCanGlobalFilter == null ? void 0 : table.options.getColumnCanGlobalFilter(column)) != null ? _table$options$getCol : true) && !!column.accessorFn;\n        };\n        column.getIsFiltered = ()=>column.getFilterIndex() > -1;\n        column.getFilterValue = ()=>{\n            var _table$getState$colum;\n            return (_table$getState$colum = table.getState().columnFilters) == null || (_table$getState$colum = _table$getState$colum.find((d)=>d.id === column.id)) == null ? void 0 : _table$getState$colum.value;\n        };\n        column.getFilterIndex = ()=>{\n            var _table$getState$colum2, _table$getState$colum3;\n            return (_table$getState$colum2 = (_table$getState$colum3 = table.getState().columnFilters) == null ? void 0 : _table$getState$colum3.findIndex((d)=>d.id === column.id)) != null ? _table$getState$colum2 : -1;\n        };\n        column.setFilterValue = (value)=>{\n            table.setColumnFilters((old)=>{\n                const filterFn = column.getFilterFn();\n                const previousfilter = old == null ? void 0 : old.find((d)=>d.id === column.id);\n                const newFilter = functionalUpdate(value, previousfilter ? previousfilter.value : undefined);\n                //\n                if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {\n                    var _old$filter;\n                    return (_old$filter = old == null ? void 0 : old.filter((d)=>d.id !== column.id)) != null ? _old$filter : [];\n                }\n                const newFilterObj = {\n                    id: column.id,\n                    value: newFilter\n                };\n                if (previousfilter) {\n                    var _old$map;\n                    return (_old$map = old == null ? void 0 : old.map((d)=>{\n                        if (d.id === column.id) {\n                            return newFilterObj;\n                        }\n                        return d;\n                    })) != null ? _old$map : [];\n                }\n                if (old != null && old.length) {\n                    return [\n                        ...old,\n                        newFilterObj\n                    ];\n                }\n                return [\n                    newFilterObj\n                ];\n            });\n        };\n        column._getFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column.id);\n        column.getFacetedRowModel = ()=>{\n            if (!column._getFacetedRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return column._getFacetedRowModel();\n        };\n        column._getFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column.id);\n        column.getFacetedUniqueValues = ()=>{\n            if (!column._getFacetedUniqueValues) {\n                return new Map();\n            }\n            return column._getFacetedUniqueValues();\n        };\n        column._getFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column.id);\n        column.getFacetedMinMaxValues = ()=>{\n            if (!column._getFacetedMinMaxValues) {\n                return undefined;\n            }\n            return column._getFacetedMinMaxValues();\n        };\n    // () => [column.getFacetedRowModel()],\n    // facetedRowModel => getRowModelMinMaxValues(facetedRowModel, column.id),\n    },\n    createRow: (row, table)=>{\n        row.columnFilters = {};\n        row.columnFiltersMeta = {};\n    },\n    createTable: (table)=>{\n        table.getGlobalAutoFilterFn = ()=>{\n            return filterFns.includesString;\n        };\n        table.getGlobalFilterFn = ()=>{\n            var _table$options$filter3, _table$options$filter4;\n            const { globalFilterFn: globalFilterFn } = table.options;\n            return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === \"auto\" ? table.getGlobalAutoFilterFn() : (_table$options$filter3 = (_table$options$filter4 = table.options.filterFns) == null ? void 0 : _table$options$filter4[globalFilterFn]) != null ? _table$options$filter3 : filterFns[globalFilterFn];\n        };\n        table.setColumnFilters = (updater)=>{\n            const leafColumns = table.getAllLeafColumns();\n            const updateFn = (old)=>{\n                var _functionalUpdate;\n                return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter((filter)=>{\n                    const column = leafColumns.find((d)=>d.id === filter.id);\n                    if (column) {\n                        const filterFn = column.getFilterFn();\n                        if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                });\n            };\n            table.options.onColumnFiltersChange == null || table.options.onColumnFiltersChange(updateFn);\n        };\n        table.setGlobalFilter = (updater)=>{\n            table.options.onGlobalFilterChange == null || table.options.onGlobalFilterChange(updater);\n        };\n        table.resetGlobalFilter = (defaultState)=>{\n            table.setGlobalFilter(defaultState ? undefined : table.initialState.globalFilter);\n        };\n        table.resetColumnFilters = (defaultState)=>{\n            var _table$initialState$c, _table$initialState;\n            table.setColumnFilters(defaultState ? [] : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnFilters) != null ? _table$initialState$c : []);\n        };\n        table.getPreFilteredRowModel = ()=>table.getCoreRowModel();\n        table.getFilteredRowModel = ()=>{\n            if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {\n                table._getFilteredRowModel = table.options.getFilteredRowModel(table);\n            }\n            if (table.options.manualFiltering || !table._getFilteredRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return table._getFilteredRowModel();\n        };\n        table._getGlobalFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, \"__global__\");\n        table.getGlobalFacetedRowModel = ()=>{\n            if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return table._getGlobalFacetedRowModel();\n        };\n        table._getGlobalFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, \"__global__\");\n        table.getGlobalFacetedUniqueValues = ()=>{\n            if (!table._getGlobalFacetedUniqueValues) {\n                return new Map();\n            }\n            return table._getGlobalFacetedUniqueValues();\n        };\n        table._getGlobalFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, \"__global__\");\n        table.getGlobalFacetedMinMaxValues = ()=>{\n            if (!table._getGlobalFacetedMinMaxValues) {\n                return;\n            }\n            return table._getGlobalFacetedMinMaxValues();\n        };\n    }\n};\nfunction shouldAutoRemoveFilter(filterFn, value, column) {\n    return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === \"undefined\" || typeof value === \"string\" && !value;\n}\nconst sum = (columnId, _leafRows, childRows)=>{\n    // It's faster to just add the aggregations together instead of\n    // process leaf nodes individually\n    return childRows.reduce((sum, next)=>{\n        const nextValue = next.getValue(columnId);\n        return sum + (typeof nextValue === \"number\" ? nextValue : 0);\n    }, 0);\n};\nconst min = (columnId, _leafRows, childRows)=>{\n    let min;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null && (min > value || min === undefined && value >= value)) {\n            min = value;\n        }\n    });\n    return min;\n};\nconst max = (columnId, _leafRows, childRows)=>{\n    let max;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null && (max < value || max === undefined && value >= value)) {\n            max = value;\n        }\n    });\n    return max;\n};\nconst extent = (columnId, _leafRows, childRows)=>{\n    let min;\n    let max;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null) {\n            if (min === undefined) {\n                if (value >= value) min = max = value;\n            } else {\n                if (min > value) min = value;\n                if (max < value) max = value;\n            }\n        }\n    });\n    return [\n        min,\n        max\n    ];\n};\nconst mean = (columnId, leafRows)=>{\n    let count = 0;\n    let sum = 0;\n    leafRows.forEach((row)=>{\n        let value = row.getValue(columnId);\n        if (value != null && (value = +value) >= value) {\n            ++count, sum += value;\n        }\n    });\n    if (count) return sum / count;\n    return;\n};\nconst median = (columnId, leafRows)=>{\n    if (!leafRows.length) {\n        return;\n    }\n    const values = leafRows.map((row)=>row.getValue(columnId));\n    if (!isNumberArray(values)) {\n        return;\n    }\n    if (values.length === 1) {\n        return values[0];\n    }\n    const mid = Math.floor(values.length / 2);\n    const nums = values.sort((a, b)=>a - b);\n    return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;\n};\nconst unique = (columnId, leafRows)=>{\n    return Array.from(new Set(leafRows.map((d)=>d.getValue(columnId))).values());\n};\nconst uniqueCount = (columnId, leafRows)=>{\n    return new Set(leafRows.map((d)=>d.getValue(columnId))).size;\n};\nconst count = (_columnId, leafRows)=>{\n    return leafRows.length;\n};\nconst aggregationFns = {\n    sum,\n    min,\n    max,\n    extent,\n    mean,\n    median,\n    unique,\n    uniqueCount,\n    count\n};\n//\nconst Grouping = {\n    getDefaultColumnDef: ()=>{\n        return {\n            aggregatedCell: (props)=>{\n                var _toString, _props$getValue;\n                return (_toString = (_props$getValue = props.getValue()) == null || _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _toString : null;\n            },\n            aggregationFn: \"auto\"\n        };\n    },\n    getInitialState: (state)=>{\n        return {\n            grouping: [],\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onGroupingChange: makeStateUpdater(\"grouping\", table),\n            groupedColumnMode: \"reorder\"\n        };\n    },\n    createColumn: (column, table)=>{\n        column.toggleGrouping = ()=>{\n            table.setGrouping((old)=>{\n                // Find any existing grouping for this column\n                if (old != null && old.includes(column.id)) {\n                    return old.filter((d)=>d !== column.id);\n                }\n                return [\n                    ...old != null ? old : [],\n                    column.id\n                ];\n            });\n        };\n        column.getCanGroup = ()=>{\n            var _ref, _ref2, _ref3, _column$columnDef$ena;\n            return (_ref = (_ref2 = (_ref3 = (_column$columnDef$ena = column.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) != null ? _ref3 : table.options.enableGrouping) != null ? _ref2 : true) != null ? _ref : !!column.accessorFn;\n        };\n        column.getIsGrouped = ()=>{\n            var _table$getState$group;\n            return (_table$getState$group = table.getState().grouping) == null ? void 0 : _table$getState$group.includes(column.id);\n        };\n        column.getGroupedIndex = ()=>{\n            var _table$getState$group2;\n            return (_table$getState$group2 = table.getState().grouping) == null ? void 0 : _table$getState$group2.indexOf(column.id);\n        };\n        column.getToggleGroupingHandler = ()=>{\n            const canGroup = column.getCanGroup();\n            return ()=>{\n                if (!canGroup) return;\n                column.toggleGrouping();\n            };\n        };\n        column.getAutoAggregationFn = ()=>{\n            const firstRow = table.getCoreRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"number\") {\n                return aggregationFns.sum;\n            }\n            if (Object.prototype.toString.call(value) === \"[object Date]\") {\n                return aggregationFns.extent;\n            }\n        };\n        column.getAggregationFn = ()=>{\n            var _table$options$aggreg, _table$options$aggreg2;\n            if (!column) {\n                throw new Error();\n            }\n            return isFunction(column.columnDef.aggregationFn) ? column.columnDef.aggregationFn : column.columnDef.aggregationFn === \"auto\" ? column.getAutoAggregationFn() : (_table$options$aggreg = (_table$options$aggreg2 = table.options.aggregationFns) == null ? void 0 : _table$options$aggreg2[column.columnDef.aggregationFn]) != null ? _table$options$aggreg : aggregationFns[column.columnDef.aggregationFn];\n        };\n    },\n    createTable: (table)=>{\n        table.setGrouping = (updater)=>table.options.onGroupingChange == null ? void 0 : table.options.onGroupingChange(updater);\n        table.resetGrouping = (defaultState)=>{\n            var _table$initialState$g, _table$initialState;\n            table.setGrouping(defaultState ? [] : (_table$initialState$g = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.grouping) != null ? _table$initialState$g : []);\n        };\n        table.getPreGroupedRowModel = ()=>table.getFilteredRowModel();\n        table.getGroupedRowModel = ()=>{\n            if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {\n                table._getGroupedRowModel = table.options.getGroupedRowModel(table);\n            }\n            if (table.options.manualGrouping || !table._getGroupedRowModel) {\n                return table.getPreGroupedRowModel();\n            }\n            return table._getGroupedRowModel();\n        };\n    },\n    createRow: (row, table)=>{\n        row.getIsGrouped = ()=>!!row.groupingColumnId;\n        row.getGroupingValue = (columnId)=>{\n            if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n                return row._groupingValuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.columnDef.getGroupingValue)) {\n                return row.getValue(columnId);\n            }\n            row._groupingValuesCache[columnId] = column.columnDef.getGroupingValue(row.original);\n            return row._groupingValuesCache[columnId];\n        };\n        row._groupingValuesCache = {};\n    },\n    createCell: (cell, column, row, table)=>{\n        cell.getIsGrouped = ()=>column.getIsGrouped() && column.id === row.groupingColumnId;\n        cell.getIsPlaceholder = ()=>!cell.getIsGrouped() && column.getIsGrouped();\n        cell.getIsAggregated = ()=>{\n            var _row$subRows;\n            return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\n        };\n    }\n};\nfunction orderColumns(leafColumns, grouping, groupedColumnMode) {\n    if (!(grouping != null && grouping.length) || !groupedColumnMode) {\n        return leafColumns;\n    }\n    const nonGroupingColumns = leafColumns.filter((col)=>!grouping.includes(col.id));\n    if (groupedColumnMode === \"remove\") {\n        return nonGroupingColumns;\n    }\n    const groupingColumns = grouping.map((g)=>leafColumns.find((col)=>col.id === g)).filter(Boolean);\n    return [\n        ...groupingColumns,\n        ...nonGroupingColumns\n    ];\n}\n//\nconst Ordering = {\n    getInitialState: (state)=>{\n        return {\n            columnOrder: [],\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnOrderChange: makeStateUpdater(\"columnOrder\", table)\n        };\n    },\n    createTable: (table)=>{\n        table.setColumnOrder = (updater)=>table.options.onColumnOrderChange == null ? void 0 : table.options.onColumnOrderChange(updater);\n        table.resetColumnOrder = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnOrder(defaultState ? [] : (_table$initialState$c = table.initialState.columnOrder) != null ? _table$initialState$c : []);\n        };\n        table._getOrderColumnsFn = memo(()=>[\n                table.getState().columnOrder,\n                table.getState().grouping,\n                table.options.groupedColumnMode\n            ], (columnOrder, grouping, groupedColumnMode)=>(columns)=>{\n                // Sort grouped columns to the start of the column list\n                // before the headers are built\n                let orderedColumns = [];\n                // If there is no order, return the normal columns\n                if (!(columnOrder != null && columnOrder.length)) {\n                    orderedColumns = columns;\n                } else {\n                    const columnOrderCopy = [\n                        ...columnOrder\n                    ];\n                    // If there is an order, make a copy of the columns\n                    const columnsCopy = [\n                        ...columns\n                    ];\n                    // And make a new ordered array of the columns\n                    // Loop over the columns and place them in order into the new array\n                    while(columnsCopy.length && columnOrderCopy.length){\n                        const targetColumnId = columnOrderCopy.shift();\n                        const foundIndex = columnsCopy.findIndex((d)=>d.id === targetColumnId);\n                        if (foundIndex > -1) {\n                            orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);\n                        }\n                    }\n                    // If there are any columns left, add them to the end\n                    orderedColumns = [\n                        ...orderedColumns,\n                        ...columnsCopy\n                    ];\n                }\n                return orderColumns(orderedColumns, grouping, groupedColumnMode);\n            }, {\n            key:  true && \"getOrderColumnsFn\"\n        });\n    }\n};\n//\nconst defaultPageIndex = 0;\nconst defaultPageSize = 10;\nconst getDefaultPaginationState = ()=>({\n        pageIndex: defaultPageIndex,\n        pageSize: defaultPageSize\n    });\nconst Pagination = {\n    getInitialState: (state)=>{\n        return {\n            ...state,\n            pagination: {\n                ...getDefaultPaginationState(),\n                ...state == null ? void 0 : state.pagination\n            }\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onPaginationChange: makeStateUpdater(\"pagination\", table)\n        };\n    },\n    createTable: (table)=>{\n        let registered = false;\n        let queued = false;\n        table._autoResetPageIndex = ()=>{\n            var _ref, _table$options$autoRe;\n            if (!registered) {\n                table._queue(()=>{\n                    registered = true;\n                });\n                return;\n            }\n            if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetPageIndex) != null ? _ref : !table.options.manualPagination) {\n                if (queued) return;\n                queued = true;\n                table._queue(()=>{\n                    table.resetPageIndex();\n                    queued = false;\n                });\n            }\n        };\n        table.setPagination = (updater)=>{\n            const safeUpdater = (old)=>{\n                let newState = functionalUpdate(updater, old);\n                return newState;\n            };\n            return table.options.onPaginationChange == null ? void 0 : table.options.onPaginationChange(safeUpdater);\n        };\n        table.resetPagination = (defaultState)=>{\n            var _table$initialState$p;\n            table.setPagination(defaultState ? getDefaultPaginationState() : (_table$initialState$p = table.initialState.pagination) != null ? _table$initialState$p : getDefaultPaginationState());\n        };\n        table.setPageIndex = (updater)=>{\n            table.setPagination((old)=>{\n                let pageIndex = functionalUpdate(updater, old.pageIndex);\n                const maxPageIndex = typeof table.options.pageCount === \"undefined\" || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;\n                pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex));\n                return {\n                    ...old,\n                    pageIndex\n                };\n            });\n        };\n        table.resetPageIndex = (defaultState)=>{\n            var _table$initialState$p2, _table$initialState;\n            table.setPageIndex(defaultState ? defaultPageIndex : (_table$initialState$p2 = (_table$initialState = table.initialState) == null || (_table$initialState = _table$initialState.pagination) == null ? void 0 : _table$initialState.pageIndex) != null ? _table$initialState$p2 : defaultPageIndex);\n        };\n        table.resetPageSize = (defaultState)=>{\n            var _table$initialState$p3, _table$initialState2;\n            table.setPageSize(defaultState ? defaultPageSize : (_table$initialState$p3 = (_table$initialState2 = table.initialState) == null || (_table$initialState2 = _table$initialState2.pagination) == null ? void 0 : _table$initialState2.pageSize) != null ? _table$initialState$p3 : defaultPageSize);\n        };\n        table.setPageSize = (updater)=>{\n            table.setPagination((old)=>{\n                const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));\n                const topRowIndex = old.pageSize * old.pageIndex;\n                const pageIndex = Math.floor(topRowIndex / pageSize);\n                return {\n                    ...old,\n                    pageIndex,\n                    pageSize\n                };\n            });\n        };\n        table.setPageCount = (updater)=>table.setPagination((old)=>{\n                var _table$options$pageCo;\n                let newPageCount = functionalUpdate(updater, (_table$options$pageCo = table.options.pageCount) != null ? _table$options$pageCo : -1);\n                if (typeof newPageCount === \"number\") {\n                    newPageCount = Math.max(-1, newPageCount);\n                }\n                return {\n                    ...old,\n                    pageCount: newPageCount\n                };\n            });\n        table.getPageOptions = memo(()=>[\n                table.getPageCount()\n            ], (pageCount)=>{\n            let pageOptions = [];\n            if (pageCount && pageCount > 0) {\n                pageOptions = [\n                    ...new Array(pageCount)\n                ].fill(null).map((_, i)=>i);\n            }\n            return pageOptions;\n        }, {\n            key:  true && \"getPageOptions\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            }\n        });\n        table.getCanPreviousPage = ()=>table.getState().pagination.pageIndex > 0;\n        table.getCanNextPage = ()=>{\n            const { pageIndex } = table.getState().pagination;\n            const pageCount = table.getPageCount();\n            if (pageCount === -1) {\n                return true;\n            }\n            if (pageCount === 0) {\n                return false;\n            }\n            return pageIndex < pageCount - 1;\n        };\n        table.previousPage = ()=>{\n            return table.setPageIndex((old)=>old - 1);\n        };\n        table.nextPage = ()=>{\n            return table.setPageIndex((old)=>{\n                return old + 1;\n            });\n        };\n        table.getPrePaginationRowModel = ()=>table.getExpandedRowModel();\n        table.getPaginationRowModel = ()=>{\n            if (!table._getPaginationRowModel && table.options.getPaginationRowModel) {\n                table._getPaginationRowModel = table.options.getPaginationRowModel(table);\n            }\n            if (table.options.manualPagination || !table._getPaginationRowModel) {\n                return table.getPrePaginationRowModel();\n            }\n            return table._getPaginationRowModel();\n        };\n        table.getPageCount = ()=>{\n            var _table$options$pageCo2;\n            return (_table$options$pageCo2 = table.options.pageCount) != null ? _table$options$pageCo2 : Math.ceil(table.getPrePaginationRowModel().rows.length / table.getState().pagination.pageSize);\n        };\n    }\n};\n//\nconst getDefaultColumnPinningState = ()=>({\n        left: [],\n        right: []\n    });\nconst getDefaultRowPinningState = ()=>({\n        top: [],\n        bottom: []\n    });\nconst Pinning = {\n    getInitialState: (state)=>{\n        return {\n            columnPinning: getDefaultColumnPinningState(),\n            rowPinning: getDefaultRowPinningState(),\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnPinningChange: makeStateUpdater(\"columnPinning\", table),\n            onRowPinningChange: makeStateUpdater(\"rowPinning\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.pin = (position)=>{\n            const columnIds = column.getLeafColumns().map((d)=>d.id).filter(Boolean);\n            table.setColumnPinning((old)=>{\n                var _old$left3, _old$right3;\n                if (position === \"right\") {\n                    var _old$left, _old$right;\n                    return {\n                        left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                        right: [\n                            ...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                            ...columnIds\n                        ]\n                    };\n                }\n                if (position === \"left\") {\n                    var _old$left2, _old$right2;\n                    return {\n                        left: [\n                            ...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                            ...columnIds\n                        ],\n                        right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter((d)=>!(columnIds != null && columnIds.includes(d)))\n                    };\n                }\n                return {\n                    left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                    right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter((d)=>!(columnIds != null && columnIds.includes(d)))\n                };\n            });\n        };\n        column.getCanPin = ()=>{\n            const leafColumns = column.getLeafColumns();\n            return leafColumns.some((d)=>{\n                var _d$columnDef$enablePi, _ref, _table$options$enable;\n                return ((_d$columnDef$enablePi = d.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_ref = (_table$options$enable = table.options.enableColumnPinning) != null ? _table$options$enable : table.options.enablePinning) != null ? _ref : true);\n            });\n        };\n        column.getIsPinned = ()=>{\n            const leafColumnIds = column.getLeafColumns().map((d)=>d.id);\n            const { left, right } = table.getState().columnPinning;\n            const isLeft = leafColumnIds.some((d)=>left == null ? void 0 : left.includes(d));\n            const isRight = leafColumnIds.some((d)=>right == null ? void 0 : right.includes(d));\n            return isLeft ? \"left\" : isRight ? \"right\" : false;\n        };\n        column.getPinnedIndex = ()=>{\n            var _table$getState$colum, _table$getState$colum2;\n            const position = column.getIsPinned();\n            return position ? (_table$getState$colum = (_table$getState$colum2 = table.getState().columnPinning) == null || (_table$getState$colum2 = _table$getState$colum2[position]) == null ? void 0 : _table$getState$colum2.indexOf(column.id)) != null ? _table$getState$colum : -1 : 0;\n        };\n    },\n    createRow: (row, table)=>{\n        row.pin = (position, includeLeafRows, includeParentRows)=>{\n            const leafRowIds = includeLeafRows ? row.getLeafRows().map((_ref2)=>{\n                let { id } = _ref2;\n                return id;\n            }) : [];\n            const parentRowIds = includeParentRows ? row.getParentRows().map((_ref3)=>{\n                let { id } = _ref3;\n                return id;\n            }) : [];\n            const rowIds = new Set([\n                ...parentRowIds,\n                row.id,\n                ...leafRowIds\n            ]);\n            table.setRowPinning((old)=>{\n                var _old$top3, _old$bottom3;\n                if (position === \"bottom\") {\n                    var _old$top, _old$bottom;\n                    return {\n                        top: ((_old$top = old == null ? void 0 : old.top) != null ? _old$top : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                        bottom: [\n                            ...((_old$bottom = old == null ? void 0 : old.bottom) != null ? _old$bottom : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                            ...Array.from(rowIds)\n                        ]\n                    };\n                }\n                if (position === \"top\") {\n                    var _old$top2, _old$bottom2;\n                    return {\n                        top: [\n                            ...((_old$top2 = old == null ? void 0 : old.top) != null ? _old$top2 : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                            ...Array.from(rowIds)\n                        ],\n                        bottom: ((_old$bottom2 = old == null ? void 0 : old.bottom) != null ? _old$bottom2 : []).filter((d)=>!(rowIds != null && rowIds.has(d)))\n                    };\n                }\n                return {\n                    top: ((_old$top3 = old == null ? void 0 : old.top) != null ? _old$top3 : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                    bottom: ((_old$bottom3 = old == null ? void 0 : old.bottom) != null ? _old$bottom3 : []).filter((d)=>!(rowIds != null && rowIds.has(d)))\n                };\n            });\n        };\n        row.getCanPin = ()=>{\n            var _ref4;\n            const { enableRowPinning, enablePinning } = table.options;\n            if (typeof enableRowPinning === \"function\") {\n                return enableRowPinning(row);\n            }\n            return (_ref4 = enableRowPinning != null ? enableRowPinning : enablePinning) != null ? _ref4 : true;\n        };\n        row.getIsPinned = ()=>{\n            const rowIds = [\n                row.id\n            ];\n            const { top, bottom } = table.getState().rowPinning;\n            const isTop = rowIds.some((d)=>top == null ? void 0 : top.includes(d));\n            const isBottom = rowIds.some((d)=>bottom == null ? void 0 : bottom.includes(d));\n            return isTop ? \"top\" : isBottom ? \"bottom\" : false;\n        };\n        row.getPinnedIndex = ()=>{\n            var _table$_getPinnedRows, _visiblePinnedRowIds$;\n            const position = row.getIsPinned();\n            if (!position) return -1;\n            const visiblePinnedRowIds = (_table$_getPinnedRows = table._getPinnedRows(position)) == null ? void 0 : _table$_getPinnedRows.map((_ref5)=>{\n                let { id } = _ref5;\n                return id;\n            });\n            return (_visiblePinnedRowIds$ = visiblePinnedRowIds == null ? void 0 : visiblePinnedRowIds.indexOf(row.id)) != null ? _visiblePinnedRowIds$ : -1;\n        };\n        row.getCenterVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allCells, left, right)=>{\n            const leftAndRight = [\n                ...left != null ? left : [],\n                ...right != null ? right : []\n            ];\n            return allCells.filter((d)=>!leftAndRight.includes(d.column.id));\n        }, {\n            key:  true && \"row.getCenterVisibleCells\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugRows;\n            }\n        });\n        row.getLeftVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.left,\n                , \n            ], (allCells, left)=>{\n            const cells = (left != null ? left : []).map((columnId)=>allCells.find((cell)=>cell.column.id === columnId)).filter(Boolean).map((d)=>({\n                    ...d,\n                    position: \"left\"\n                }));\n            return cells;\n        }, {\n            key:  true && \"row.getLeftVisibleCells\",\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugRows;\n            }\n        });\n        row.getRightVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.right\n            ], (allCells, right)=>{\n            const cells = (right != null ? right : []).map((columnId)=>allCells.find((cell)=>cell.column.id === columnId)).filter(Boolean).map((d)=>({\n                    ...d,\n                    position: \"right\"\n                }));\n            return cells;\n        }, {\n            key:  true && \"row.getRightVisibleCells\",\n            debug: ()=>{\n                var _table$options$debugA3;\n                return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugRows;\n            }\n        });\n    },\n    createTable: (table)=>{\n        table.setColumnPinning = (updater)=>table.options.onColumnPinningChange == null ? void 0 : table.options.onColumnPinningChange(updater);\n        table.resetColumnPinning = (defaultState)=>{\n            var _table$initialState$c, _table$initialState;\n            return table.setColumnPinning(defaultState ? getDefaultColumnPinningState() : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnPinning) != null ? _table$initialState$c : getDefaultColumnPinningState());\n        };\n        table.getIsSomeColumnsPinned = (position)=>{\n            var _pinningState$positio;\n            const pinningState = table.getState().columnPinning;\n            if (!position) {\n                var _pinningState$left, _pinningState$right;\n                return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));\n            }\n            return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);\n        };\n        table.getLeftLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.left\n            ], (allColumns, left)=>{\n            return (left != null ? left : []).map((columnId)=>allColumns.find((column)=>column.id === columnId)).filter(Boolean);\n        }, {\n            key:  true && \"getLeftLeafColumns\",\n            debug: ()=>{\n                var _table$options$debugA4;\n                return (_table$options$debugA4 = table.options.debugAll) != null ? _table$options$debugA4 : table.options.debugColumns;\n            }\n        });\n        table.getRightLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.right\n            ], (allColumns, right)=>{\n            return (right != null ? right : []).map((columnId)=>allColumns.find((column)=>column.id === columnId)).filter(Boolean);\n        }, {\n            key:  true && \"getRightLeafColumns\",\n            debug: ()=>{\n                var _table$options$debugA5;\n                return (_table$options$debugA5 = table.options.debugAll) != null ? _table$options$debugA5 : table.options.debugColumns;\n            }\n        });\n        table.getCenterLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, left, right)=>{\n            const leftAndRight = [\n                ...left != null ? left : [],\n                ...right != null ? right : []\n            ];\n            return allColumns.filter((d)=>!leftAndRight.includes(d.id));\n        }, {\n            key:  true && \"getCenterLeafColumns\",\n            debug: ()=>{\n                var _table$options$debugA6;\n                return (_table$options$debugA6 = table.options.debugAll) != null ? _table$options$debugA6 : table.options.debugColumns;\n            }\n        });\n        table.setRowPinning = (updater)=>table.options.onRowPinningChange == null ? void 0 : table.options.onRowPinningChange(updater);\n        table.resetRowPinning = (defaultState)=>{\n            var _table$initialState$r, _table$initialState2;\n            return table.setRowPinning(defaultState ? getDefaultRowPinningState() : (_table$initialState$r = (_table$initialState2 = table.initialState) == null ? void 0 : _table$initialState2.rowPinning) != null ? _table$initialState$r : getDefaultRowPinningState());\n        };\n        table.getIsSomeRowsPinned = (position)=>{\n            var _pinningState$positio2;\n            const pinningState = table.getState().rowPinning;\n            if (!position) {\n                var _pinningState$top, _pinningState$bottom;\n                return Boolean(((_pinningState$top = pinningState.top) == null ? void 0 : _pinningState$top.length) || ((_pinningState$bottom = pinningState.bottom) == null ? void 0 : _pinningState$bottom.length));\n            }\n            return Boolean((_pinningState$positio2 = pinningState[position]) == null ? void 0 : _pinningState$positio2.length);\n        };\n        table._getPinnedRows = (position)=>memo(()=>[\n                    table.getRowModel().rows,\n                    table.getState().rowPinning[position]\n                ], (visibleRows, pinnedRowIds)=>{\n                var _table$options$keepPi;\n                const rows = ((_table$options$keepPi = table.options.keepPinnedRows) != null ? _table$options$keepPi : true) ? //get all rows that are pinned even if they would not be otherwise visible\n                //account for expanded parent rows, but not pagination or filtering\n                (pinnedRowIds != null ? pinnedRowIds : []).map((rowId)=>{\n                    const row = table.getRow(rowId, true);\n                    return row.getIsAllParentsExpanded() ? row : null;\n                }) : //else get only visible rows that are pinned\n                (pinnedRowIds != null ? pinnedRowIds : []).map((rowId)=>visibleRows.find((row)=>row.id === rowId));\n                return rows.filter(Boolean).map((d)=>({\n                        ...d,\n                        position\n                    }));\n            }, {\n                key:  true && `row.get${position === \"top\" ? \"Top\" : \"Bottom\"}Rows`,\n                debug: ()=>{\n                    var _table$options$debugA7;\n                    return (_table$options$debugA7 = table.options.debugAll) != null ? _table$options$debugA7 : table.options.debugRows;\n                }\n            })();\n        table.getTopRows = ()=>table._getPinnedRows(\"top\");\n        table.getBottomRows = ()=>table._getPinnedRows(\"bottom\");\n        table.getCenterRows = memo(()=>[\n                table.getRowModel().rows,\n                table.getState().rowPinning.top,\n                table.getState().rowPinning.bottom\n            ], (allRows, top, bottom)=>{\n            const topAndBottom = new Set([\n                ...top != null ? top : [],\n                ...bottom != null ? bottom : []\n            ]);\n            return allRows.filter((d)=>!topAndBottom.has(d.id));\n        }, {\n            key:  true && \"row.getCenterRows\",\n            debug: ()=>{\n                var _table$options$debugA8;\n                return (_table$options$debugA8 = table.options.debugAll) != null ? _table$options$debugA8 : table.options.debugRows;\n            }\n        });\n    }\n};\n//\nconst RowSelection = {\n    getInitialState: (state)=>{\n        return {\n            rowSelection: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onRowSelectionChange: makeStateUpdater(\"rowSelection\", table),\n            enableRowSelection: true,\n            enableMultiRowSelection: true,\n            enableSubRowSelection: true\n        };\n    },\n    createTable: (table)=>{\n        table.setRowSelection = (updater)=>table.options.onRowSelectionChange == null ? void 0 : table.options.onRowSelectionChange(updater);\n        table.resetRowSelection = (defaultState)=>{\n            var _table$initialState$r;\n            return table.setRowSelection(defaultState ? {} : (_table$initialState$r = table.initialState.rowSelection) != null ? _table$initialState$r : {});\n        };\n        table.toggleAllRowsSelected = (value)=>{\n            table.setRowSelection((old)=>{\n                value = typeof value !== \"undefined\" ? value : !table.getIsAllRowsSelected();\n                const rowSelection = {\n                    ...old\n                };\n                const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;\n                // We don't use `mutateRowIsSelected` here for performance reasons.\n                // All of the rows are flat already, so it wouldn't be worth it\n                if (value) {\n                    preGroupedFlatRows.forEach((row)=>{\n                        if (!row.getCanSelect()) {\n                            return;\n                        }\n                        rowSelection[row.id] = true;\n                    });\n                } else {\n                    preGroupedFlatRows.forEach((row)=>{\n                        delete rowSelection[row.id];\n                    });\n                }\n                return rowSelection;\n            });\n        };\n        table.toggleAllPageRowsSelected = (value)=>table.setRowSelection((old)=>{\n                const resolvedValue = typeof value !== \"undefined\" ? value : !table.getIsAllPageRowsSelected();\n                const rowSelection = {\n                    ...old\n                };\n                table.getRowModel().rows.forEach((row)=>{\n                    mutateRowIsSelected(rowSelection, row.id, resolvedValue, true, table);\n                });\n                return rowSelection;\n            });\n        // addRowSelectionRange: rowId => {\n        //   const {\n        //     rows,\n        //     rowsById,\n        //     options: { selectGroupingRows, selectSubRows },\n        //   } = table\n        //   const findSelectedRow = (rows: Row[]) => {\n        //     let found\n        //     rows.find(d => {\n        //       if (d.getIsSelected()) {\n        //         found = d\n        //         return true\n        //       }\n        //       const subFound = findSelectedRow(d.subRows || [])\n        //       if (subFound) {\n        //         found = subFound\n        //         return true\n        //       }\n        //       return false\n        //     })\n        //     return found\n        //   }\n        //   const firstRow = findSelectedRow(rows) || rows[0]\n        //   const lastRow = rowsById[rowId]\n        //   let include = false\n        //   const selectedRowIds = {}\n        //   const addRow = (row: Row) => {\n        //     mutateRowIsSelected(selectedRowIds, row.id, true, {\n        //       rowsById,\n        //       selectGroupingRows: selectGroupingRows!,\n        //       selectSubRows: selectSubRows!,\n        //     })\n        //   }\n        //   table.rows.forEach(row => {\n        //     const isFirstRow = row.id === firstRow.id\n        //     const isLastRow = row.id === lastRow.id\n        //     if (isFirstRow || isLastRow) {\n        //       if (!include) {\n        //         include = true\n        //       } else if (include) {\n        //         addRow(row)\n        //         include = false\n        //       }\n        //     }\n        //     if (include) {\n        //       addRow(row)\n        //     }\n        //   })\n        //   table.setRowSelection(selectedRowIds)\n        // },\n        table.getPreSelectedRowModel = ()=>table.getCoreRowModel();\n        table.getSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getCoreRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, {\n            key:  true && \"getSelectedRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            }\n        });\n        table.getFilteredSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getFilteredRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, {\n            key:  false && 0,\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugTable;\n            }\n        });\n        table.getGroupedSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getSortedRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, {\n            key:  false && 0,\n            debug: ()=>{\n                var _table$options$debugA3;\n                return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugTable;\n            }\n        });\n        ///\n        // getGroupingRowCanSelect: rowId => {\n        //   const row = table.getRow(rowId)\n        //   if (!row) {\n        //     throw new Error()\n        //   }\n        //   if (typeof table.options.enableGroupingRowSelection === 'function') {\n        //     return table.options.enableGroupingRowSelection(row)\n        //   }\n        //   return table.options.enableGroupingRowSelection ?? false\n        // },\n        table.getIsAllRowsSelected = ()=>{\n            const preGroupedFlatRows = table.getFilteredRowModel().flatRows;\n            const { rowSelection } = table.getState();\n            let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);\n            if (isAllRowsSelected) {\n                if (preGroupedFlatRows.some((row)=>row.getCanSelect() && !rowSelection[row.id])) {\n                    isAllRowsSelected = false;\n                }\n            }\n            return isAllRowsSelected;\n        };\n        table.getIsAllPageRowsSelected = ()=>{\n            const paginationFlatRows = table.getPaginationRowModel().flatRows.filter((row)=>row.getCanSelect());\n            const { rowSelection } = table.getState();\n            let isAllPageRowsSelected = !!paginationFlatRows.length;\n            if (isAllPageRowsSelected && paginationFlatRows.some((row)=>!rowSelection[row.id])) {\n                isAllPageRowsSelected = false;\n            }\n            return isAllPageRowsSelected;\n        };\n        table.getIsSomeRowsSelected = ()=>{\n            var _table$getState$rowSe;\n            const totalSelected = Object.keys((_table$getState$rowSe = table.getState().rowSelection) != null ? _table$getState$rowSe : {}).length;\n            return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;\n        };\n        table.getIsSomePageRowsSelected = ()=>{\n            const paginationFlatRows = table.getPaginationRowModel().flatRows;\n            return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.filter((row)=>row.getCanSelect()).some((d)=>d.getIsSelected() || d.getIsSomeSelected());\n        };\n        table.getToggleAllRowsSelectedHandler = ()=>{\n            return (e)=>{\n                table.toggleAllRowsSelected(e.target.checked);\n            };\n        };\n        table.getToggleAllPageRowsSelectedHandler = ()=>{\n            return (e)=>{\n                table.toggleAllPageRowsSelected(e.target.checked);\n            };\n        };\n    },\n    createRow: (row, table)=>{\n        row.toggleSelected = (value, opts)=>{\n            const isSelected = row.getIsSelected();\n            table.setRowSelection((old)=>{\n                var _opts$selectChildren;\n                value = typeof value !== \"undefined\" ? value : !isSelected;\n                if (row.getCanSelect() && isSelected === value) {\n                    return old;\n                }\n                const selectedRowIds = {\n                    ...old\n                };\n                mutateRowIsSelected(selectedRowIds, row.id, value, (_opts$selectChildren = opts == null ? void 0 : opts.selectChildren) != null ? _opts$selectChildren : true, table);\n                return selectedRowIds;\n            });\n        };\n        row.getIsSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isRowSelected(row, rowSelection);\n        };\n        row.getIsSomeSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isSubRowSelected(row, rowSelection) === \"some\";\n        };\n        row.getIsAllSubRowsSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isSubRowSelected(row, rowSelection) === \"all\";\n        };\n        row.getCanSelect = ()=>{\n            var _table$options$enable;\n            if (typeof table.options.enableRowSelection === \"function\") {\n                return table.options.enableRowSelection(row);\n            }\n            return (_table$options$enable = table.options.enableRowSelection) != null ? _table$options$enable : true;\n        };\n        row.getCanSelectSubRows = ()=>{\n            var _table$options$enable2;\n            if (typeof table.options.enableSubRowSelection === \"function\") {\n                return table.options.enableSubRowSelection(row);\n            }\n            return (_table$options$enable2 = table.options.enableSubRowSelection) != null ? _table$options$enable2 : true;\n        };\n        row.getCanMultiSelect = ()=>{\n            var _table$options$enable3;\n            if (typeof table.options.enableMultiRowSelection === \"function\") {\n                return table.options.enableMultiRowSelection(row);\n            }\n            return (_table$options$enable3 = table.options.enableMultiRowSelection) != null ? _table$options$enable3 : true;\n        };\n        row.getToggleSelectedHandler = ()=>{\n            const canSelect = row.getCanSelect();\n            return (e)=>{\n                var _target;\n                if (!canSelect) return;\n                row.toggleSelected((_target = e.target) == null ? void 0 : _target.checked);\n            };\n        };\n    }\n};\nconst mutateRowIsSelected = (selectedRowIds, id, value, includeChildren, table)=>{\n    var _row$subRows;\n    const row = table.getRow(id, true);\n    // const isGrouped = row.getIsGrouped()\n    // if ( // TODO: enforce grouping row selection rules\n    //   !isGrouped ||\n    //   (isGrouped && table.options.enableGroupingRowSelection)\n    // ) {\n    if (value) {\n        if (!row.getCanMultiSelect()) {\n            Object.keys(selectedRowIds).forEach((key)=>delete selectedRowIds[key]);\n        }\n        if (row.getCanSelect()) {\n            selectedRowIds[id] = true;\n        }\n    } else {\n        delete selectedRowIds[id];\n    }\n    // }\n    if (includeChildren && (_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {\n        row.subRows.forEach((row)=>mutateRowIsSelected(selectedRowIds, row.id, value, includeChildren, table));\n    }\n};\nfunction selectRowsFn(table, rowModel) {\n    const rowSelection = table.getState().rowSelection;\n    const newSelectedFlatRows = [];\n    const newSelectedRowsById = {};\n    // Filters top level and nested rows\n    const recurseRows = function(rows, depth) {\n        return rows.map((row)=>{\n            var _row$subRows2;\n            const isSelected = isRowSelected(row, rowSelection);\n            if (isSelected) {\n                newSelectedFlatRows.push(row);\n                newSelectedRowsById[row.id] = row;\n            }\n            if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {\n                row = {\n                    ...row,\n                    subRows: recurseRows(row.subRows)\n                };\n            }\n            if (isSelected) {\n                return row;\n            }\n        }).filter(Boolean);\n    };\n    return {\n        rows: recurseRows(rowModel.rows),\n        flatRows: newSelectedFlatRows,\n        rowsById: newSelectedRowsById\n    };\n}\nfunction isRowSelected(row, selection) {\n    var _selection$row$id;\n    return (_selection$row$id = selection[row.id]) != null ? _selection$row$id : false;\n}\nfunction isSubRowSelected(row, selection, table) {\n    var _row$subRows3;\n    if (!((_row$subRows3 = row.subRows) != null && _row$subRows3.length)) return false;\n    let allChildrenSelected = true;\n    let someSelected = false;\n    row.subRows.forEach((subRow)=>{\n        // Bail out early if we know both of these\n        if (someSelected && !allChildrenSelected) {\n            return;\n        }\n        if (subRow.getCanSelect()) {\n            if (isRowSelected(subRow, selection)) {\n                someSelected = true;\n            } else {\n                allChildrenSelected = false;\n            }\n        }\n        // Check row selection of nested subrows\n        if (subRow.subRows && subRow.subRows.length) {\n            const subRowChildrenSelected = isSubRowSelected(subRow, selection);\n            if (subRowChildrenSelected === \"all\") {\n                someSelected = true;\n            } else if (subRowChildrenSelected === \"some\") {\n                someSelected = true;\n                allChildrenSelected = false;\n            } else {\n                allChildrenSelected = false;\n            }\n        }\n    });\n    return allChildrenSelected ? \"all\" : someSelected ? \"some\" : false;\n}\nconst reSplitAlphaNumeric = /([0-9]+)/gm;\nconst alphanumeric = (rowA, rowB, columnId)=>{\n    return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n};\nconst alphanumericCaseSensitive = (rowA, rowB, columnId)=>{\n    return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n};\n// The text filter is more basic (less numeric support)\n// but is much faster\nconst text = (rowA, rowB, columnId)=>{\n    return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n};\n// The text filter is more basic (less numeric support)\n// but is much faster\nconst textCaseSensitive = (rowA, rowB, columnId)=>{\n    return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n};\nconst datetime = (rowA, rowB, columnId)=>{\n    const a = rowA.getValue(columnId);\n    const b = rowB.getValue(columnId);\n    // Can handle nullish values\n    // Use > and < because == (and ===) doesn't work with\n    // Date objects (would require calling getTime()).\n    return a > b ? 1 : a < b ? -1 : 0;\n};\nconst basic = (rowA, rowB, columnId)=>{\n    return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));\n};\n// Utils\nfunction compareBasic(a, b) {\n    return a === b ? 0 : a > b ? 1 : -1;\n}\nfunction toString(a) {\n    if (typeof a === \"number\") {\n        if (isNaN(a) || a === Infinity || a === -Infinity) {\n            return \"\";\n        }\n        return String(a);\n    }\n    if (typeof a === \"string\") {\n        return a;\n    }\n    return \"\";\n}\n// Mixed sorting is slow, but very inclusive of many edge cases.\n// It handles numbers, mixed alphanumeric combinations, and even\n// null, undefined, and Infinity\nfunction compareAlphanumeric(aStr, bStr) {\n    // Split on number groups, but keep the delimiter\n    // Then remove falsey split values\n    const a = aStr.split(reSplitAlphaNumeric).filter(Boolean);\n    const b = bStr.split(reSplitAlphaNumeric).filter(Boolean);\n    // While\n    while(a.length && b.length){\n        const aa = a.shift();\n        const bb = b.shift();\n        const an = parseInt(aa, 10);\n        const bn = parseInt(bb, 10);\n        const combo = [\n            an,\n            bn\n        ].sort();\n        // Both are string\n        if (isNaN(combo[0])) {\n            if (aa > bb) {\n                return 1;\n            }\n            if (bb > aa) {\n                return -1;\n            }\n            continue;\n        }\n        // One is a string, one is a number\n        if (isNaN(combo[1])) {\n            return isNaN(an) ? -1 : 1;\n        }\n        // Both are numbers\n        if (an > bn) {\n            return 1;\n        }\n        if (bn > an) {\n            return -1;\n        }\n    }\n    return a.length - b.length;\n}\n// Exports\nconst sortingFns = {\n    alphanumeric,\n    alphanumericCaseSensitive,\n    text,\n    textCaseSensitive,\n    datetime,\n    basic\n};\n//\nconst Sorting = {\n    getInitialState: (state)=>{\n        return {\n            sorting: [],\n            ...state\n        };\n    },\n    getDefaultColumnDef: ()=>{\n        return {\n            sortingFn: \"auto\",\n            sortUndefined: 1\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onSortingChange: makeStateUpdater(\"sorting\", table),\n            isMultiSortEvent: (e)=>{\n                return e.shiftKey;\n            }\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getAutoSortingFn = ()=>{\n            const firstRows = table.getFilteredRowModel().flatRows.slice(10);\n            let isString = false;\n            for (const row of firstRows){\n                const value = row == null ? void 0 : row.getValue(column.id);\n                if (Object.prototype.toString.call(value) === \"[object Date]\") {\n                    return sortingFns.datetime;\n                }\n                if (typeof value === \"string\") {\n                    isString = true;\n                    if (value.split(reSplitAlphaNumeric).length > 1) {\n                        return sortingFns.alphanumeric;\n                    }\n                }\n            }\n            if (isString) {\n                return sortingFns.text;\n            }\n            return sortingFns.basic;\n        };\n        column.getAutoSortDir = ()=>{\n            const firstRow = table.getFilteredRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"string\") {\n                return \"asc\";\n            }\n            return \"desc\";\n        };\n        column.getSortingFn = ()=>{\n            var _table$options$sortin, _table$options$sortin2;\n            if (!column) {\n                throw new Error();\n            }\n            return isFunction(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === \"auto\" ? column.getAutoSortingFn() : (_table$options$sortin = (_table$options$sortin2 = table.options.sortingFns) == null ? void 0 : _table$options$sortin2[column.columnDef.sortingFn]) != null ? _table$options$sortin : sortingFns[column.columnDef.sortingFn];\n        };\n        column.toggleSorting = (desc, multi)=>{\n            // if (column.columns.length) {\n            //   column.columns.forEach((c, i) => {\n            //     if (c.id) {\n            //       table.toggleColumnSorting(c.id, undefined, multi || !!i)\n            //     }\n            //   })\n            //   return\n            // }\n            // this needs to be outside of table.setSorting to be in sync with rerender\n            const nextSortingOrder = column.getNextSortingOrder();\n            const hasManualValue = typeof desc !== \"undefined\" && desc !== null;\n            table.setSorting((old)=>{\n                // Find any existing sorting for this column\n                const existingSorting = old == null ? void 0 : old.find((d)=>d.id === column.id);\n                const existingIndex = old == null ? void 0 : old.findIndex((d)=>d.id === column.id);\n                let newSorting = [];\n                // What should we do with this sort action?\n                let sortAction;\n                let nextDesc = hasManualValue ? desc : nextSortingOrder === \"desc\";\n                // Multi-mode\n                if (old != null && old.length && column.getCanMultiSort() && multi) {\n                    if (existingSorting) {\n                        sortAction = \"toggle\";\n                    } else {\n                        sortAction = \"add\";\n                    }\n                } else {\n                    // Normal mode\n                    if (old != null && old.length && existingIndex !== old.length - 1) {\n                        sortAction = \"replace\";\n                    } else if (existingSorting) {\n                        sortAction = \"toggle\";\n                    } else {\n                        sortAction = \"replace\";\n                    }\n                }\n                // Handle toggle states that will remove the sorting\n                if (sortAction === \"toggle\") {\n                    // If we are \"actually\" toggling (not a manual set value), should we remove the sorting?\n                    if (!hasManualValue) {\n                        // Is our intention to remove?\n                        if (!nextSortingOrder) {\n                            sortAction = \"remove\";\n                        }\n                    }\n                }\n                if (sortAction === \"add\") {\n                    var _table$options$maxMul;\n                    newSorting = [\n                        ...old,\n                        {\n                            id: column.id,\n                            desc: nextDesc\n                        }\n                    ];\n                    // Take latest n columns\n                    newSorting.splice(0, newSorting.length - ((_table$options$maxMul = table.options.maxMultiSortColCount) != null ? _table$options$maxMul : Number.MAX_SAFE_INTEGER));\n                } else if (sortAction === \"toggle\") {\n                    // This flips (or sets) the\n                    newSorting = old.map((d)=>{\n                        if (d.id === column.id) {\n                            return {\n                                ...d,\n                                desc: nextDesc\n                            };\n                        }\n                        return d;\n                    });\n                } else if (sortAction === \"remove\") {\n                    newSorting = old.filter((d)=>d.id !== column.id);\n                } else {\n                    newSorting = [\n                        {\n                            id: column.id,\n                            desc: nextDesc\n                        }\n                    ];\n                }\n                return newSorting;\n            });\n        };\n        column.getFirstSortDir = ()=>{\n            var _ref, _column$columnDef$sor;\n            const sortDescFirst = (_ref = (_column$columnDef$sor = column.columnDef.sortDescFirst) != null ? _column$columnDef$sor : table.options.sortDescFirst) != null ? _ref : column.getAutoSortDir() === \"desc\";\n            return sortDescFirst ? \"desc\" : \"asc\";\n        };\n        column.getNextSortingOrder = (multi)=>{\n            var _table$options$enable, _table$options$enable2;\n            const firstSortDirection = column.getFirstSortDir();\n            const isSorted = column.getIsSorted();\n            if (!isSorted) {\n                return firstSortDirection;\n            }\n            if (isSorted !== firstSortDirection && ((_table$options$enable = table.options.enableSortingRemoval) != null ? _table$options$enable : true) && // If enableSortRemove, enable in general\n            (multi ? (_table$options$enable2 = table.options.enableMultiRemove) != null ? _table$options$enable2 : true : true // If multi, don't allow if enableMultiRemove))\n            )) {\n                return false;\n            }\n            return isSorted === \"desc\" ? \"asc\" : \"desc\";\n        };\n        column.getCanSort = ()=>{\n            var _column$columnDef$ena, _table$options$enable3;\n            return ((_column$columnDef$ena = column.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_table$options$enable3 = table.options.enableSorting) != null ? _table$options$enable3 : true) && !!column.accessorFn;\n        };\n        column.getCanMultiSort = ()=>{\n            var _ref2, _column$columnDef$ena2;\n            return (_ref2 = (_column$columnDef$ena2 = column.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : table.options.enableMultiSort) != null ? _ref2 : !!column.accessorFn;\n        };\n        column.getIsSorted = ()=>{\n            var _table$getState$sorti;\n            const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? void 0 : _table$getState$sorti.find((d)=>d.id === column.id);\n            return !columnSort ? false : columnSort.desc ? \"desc\" : \"asc\";\n        };\n        column.getSortIndex = ()=>{\n            var _table$getState$sorti2, _table$getState$sorti3;\n            return (_table$getState$sorti2 = (_table$getState$sorti3 = table.getState().sorting) == null ? void 0 : _table$getState$sorti3.findIndex((d)=>d.id === column.id)) != null ? _table$getState$sorti2 : -1;\n        };\n        column.clearSorting = ()=>{\n            //clear sorting for just 1 column\n            table.setSorting((old)=>old != null && old.length ? old.filter((d)=>d.id !== column.id) : []);\n        };\n        column.getToggleSortingHandler = ()=>{\n            const canSort = column.getCanSort();\n            return (e)=>{\n                if (!canSort) return;\n                e.persist == null || e.persist();\n                column.toggleSorting == null || column.toggleSorting(undefined, column.getCanMultiSort() ? table.options.isMultiSortEvent == null ? void 0 : table.options.isMultiSortEvent(e) : false);\n            };\n        };\n    },\n    createTable: (table)=>{\n        table.setSorting = (updater)=>table.options.onSortingChange == null ? void 0 : table.options.onSortingChange(updater);\n        table.resetSorting = (defaultState)=>{\n            var _table$initialState$s, _table$initialState;\n            table.setSorting(defaultState ? [] : (_table$initialState$s = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.sorting) != null ? _table$initialState$s : []);\n        };\n        table.getPreSortedRowModel = ()=>table.getGroupedRowModel();\n        table.getSortedRowModel = ()=>{\n            if (!table._getSortedRowModel && table.options.getSortedRowModel) {\n                table._getSortedRowModel = table.options.getSortedRowModel(table);\n            }\n            if (table.options.manualSorting || !table._getSortedRowModel) {\n                return table.getPreSortedRowModel();\n            }\n            return table._getSortedRowModel();\n        };\n    }\n};\n//\nconst Visibility = {\n    getInitialState: (state)=>{\n        return {\n            columnVisibility: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnVisibilityChange: makeStateUpdater(\"columnVisibility\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.toggleVisibility = (value)=>{\n            if (column.getCanHide()) {\n                table.setColumnVisibility((old)=>({\n                        ...old,\n                        [column.id]: value != null ? value : !column.getIsVisible()\n                    }));\n            }\n        };\n        column.getIsVisible = ()=>{\n            var _table$getState$colum, _table$getState$colum2;\n            return (_table$getState$colum = (_table$getState$colum2 = table.getState().columnVisibility) == null ? void 0 : _table$getState$colum2[column.id]) != null ? _table$getState$colum : true;\n        };\n        column.getCanHide = ()=>{\n            var _column$columnDef$ena, _table$options$enable;\n            return ((_column$columnDef$ena = column.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableHiding) != null ? _table$options$enable : true);\n        };\n        column.getToggleVisibilityHandler = ()=>{\n            return (e)=>{\n                column.toggleVisibility == null || column.toggleVisibility(e.target.checked);\n            };\n        };\n    },\n    createRow: (row, table)=>{\n        row._getAllVisibleCells = memo(()=>[\n                row.getAllCells(),\n                table.getState().columnVisibility\n            ], (cells)=>{\n            return cells.filter((cell)=>cell.column.getIsVisible());\n        }, {\n            key:  false && 0,\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugRows;\n            }\n        });\n        row.getVisibleCells = memo(()=>[\n                row.getLeftVisibleCells(),\n                row.getCenterVisibleCells(),\n                row.getRightVisibleCells()\n            ], (left, center, right)=>[\n                ...left,\n                ...center,\n                ...right\n            ], {\n            key:  true && \"row.getVisibleCells\",\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugRows;\n            }\n        });\n    },\n    createTable: (table)=>{\n        const makeVisibleColumnsMethod = (key, getColumns)=>{\n            return memo(()=>[\n                    getColumns(),\n                    getColumns().filter((d)=>d.getIsVisible()).map((d)=>d.id).join(\"_\")\n                ], (columns)=>{\n                return columns.filter((d)=>d.getIsVisible == null ? void 0 : d.getIsVisible());\n            }, {\n                key,\n                debug: ()=>{\n                    var _table$options$debugA3;\n                    return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugColumns;\n                }\n            });\n        };\n        table.getVisibleFlatColumns = makeVisibleColumnsMethod(\"getVisibleFlatColumns\", ()=>table.getAllFlatColumns());\n        table.getVisibleLeafColumns = makeVisibleColumnsMethod(\"getVisibleLeafColumns\", ()=>table.getAllLeafColumns());\n        table.getLeftVisibleLeafColumns = makeVisibleColumnsMethod(\"getLeftVisibleLeafColumns\", ()=>table.getLeftLeafColumns());\n        table.getRightVisibleLeafColumns = makeVisibleColumnsMethod(\"getRightVisibleLeafColumns\", ()=>table.getRightLeafColumns());\n        table.getCenterVisibleLeafColumns = makeVisibleColumnsMethod(\"getCenterVisibleLeafColumns\", ()=>table.getCenterLeafColumns());\n        table.setColumnVisibility = (updater)=>table.options.onColumnVisibilityChange == null ? void 0 : table.options.onColumnVisibilityChange(updater);\n        table.resetColumnVisibility = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnVisibility(defaultState ? {} : (_table$initialState$c = table.initialState.columnVisibility) != null ? _table$initialState$c : {});\n        };\n        table.toggleAllColumnsVisible = (value)=>{\n            var _value;\n            value = (_value = value) != null ? _value : !table.getIsAllColumnsVisible();\n            table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column)=>({\n                    ...obj,\n                    [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value\n                }), {}));\n        };\n        table.getIsAllColumnsVisible = ()=>!table.getAllLeafColumns().some((column)=>!(column.getIsVisible != null && column.getIsVisible()));\n        table.getIsSomeColumnsVisible = ()=>table.getAllLeafColumns().some((column)=>column.getIsVisible == null ? void 0 : column.getIsVisible());\n        table.getToggleAllColumnsVisibilityHandler = ()=>{\n            return (e)=>{\n                var _target;\n                table.toggleAllColumnsVisible((_target = e.target) == null ? void 0 : _target.checked);\n            };\n        };\n    }\n};\nconst features = [\n    Headers,\n    Visibility,\n    Ordering,\n    Pinning,\n    Filters,\n    Sorting,\n    Grouping,\n    Expanding,\n    Pagination,\n    RowSelection,\n    ColumnSizing\n];\n//\nfunction createTable(options) {\n    var _options$initialState;\n    if (options.debugAll || options.debugTable) {\n        console.info(\"Creating Table Instance...\");\n    }\n    let table = {\n        _features: features\n    };\n    const defaultOptions = table._features.reduce((obj, feature)=>{\n        return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(table));\n    }, {});\n    const mergeOptions = (options)=>{\n        if (table.options.mergeOptions) {\n            return table.options.mergeOptions(defaultOptions, options);\n        }\n        return {\n            ...defaultOptions,\n            ...options\n        };\n    };\n    const coreInitialState = {};\n    let initialState = {\n        ...coreInitialState,\n        ...(_options$initialState = options.initialState) != null ? _options$initialState : {}\n    };\n    table._features.forEach((feature)=>{\n        var _feature$getInitialSt;\n        initialState = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState)) != null ? _feature$getInitialSt : initialState;\n    });\n    const queued = [];\n    let queuedTimeout = false;\n    const coreInstance = {\n        _features: features,\n        options: {\n            ...defaultOptions,\n            ...options\n        },\n        initialState,\n        _queue: (cb)=>{\n            queued.push(cb);\n            if (!queuedTimeout) {\n                queuedTimeout = true;\n                // Schedule a microtask to run the queued callbacks after\n                // the current call stack (render, etc) has finished.\n                Promise.resolve().then(()=>{\n                    while(queued.length){\n                        queued.shift()();\n                    }\n                    queuedTimeout = false;\n                }).catch((error)=>setTimeout(()=>{\n                        throw error;\n                    }));\n            }\n        },\n        reset: ()=>{\n            table.setState(table.initialState);\n        },\n        setOptions: (updater)=>{\n            const newOptions = functionalUpdate(updater, table.options);\n            table.options = mergeOptions(newOptions);\n        },\n        getState: ()=>{\n            return table.options.state;\n        },\n        setState: (updater)=>{\n            table.options.onStateChange == null || table.options.onStateChange(updater);\n        },\n        _getRowId: (row, index, parent)=>{\n            var _table$options$getRow;\n            return (_table$options$getRow = table.options.getRowId == null ? void 0 : table.options.getRowId(row, index, parent)) != null ? _table$options$getRow : `${parent ? [\n                parent.id,\n                index\n            ].join(\".\") : index}`;\n        },\n        getCoreRowModel: ()=>{\n            if (!table._getCoreRowModel) {\n                table._getCoreRowModel = table.options.getCoreRowModel(table);\n            }\n            return table._getCoreRowModel();\n        },\n        // The final calls start at the bottom of the model,\n        // expanded rows, which then work their way up\n        getRowModel: ()=>{\n            return table.getPaginationRowModel();\n        },\n        //in next version, we should just pass in the row model as the optional 2nd arg\n        getRow: (id, searchAll)=>{\n            let row = (searchAll ? table.getPrePaginationRowModel() : table.getRowModel()).rowsById[id];\n            if (!row) {\n                row = table.getCoreRowModel().rowsById[id];\n                if (!row) {\n                    if (true) {\n                        throw new Error(`getRow could not find row with ID: ${id}`);\n                    }\n                    throw new Error();\n                }\n            }\n            return row;\n        },\n        _getDefaultColumnDef: memo(()=>[\n                table.options.defaultColumn\n            ], (defaultColumn)=>{\n            var _defaultColumn;\n            defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};\n            return {\n                header: (props)=>{\n                    const resolvedColumnDef = props.header.column.columnDef;\n                    if (resolvedColumnDef.accessorKey) {\n                        return resolvedColumnDef.accessorKey;\n                    }\n                    if (resolvedColumnDef.accessorFn) {\n                        return resolvedColumnDef.id;\n                    }\n                    return null;\n                },\n                // footer: props => props.header.column.id,\n                cell: (props)=>{\n                    var _props$renderValue$to, _props$renderValue;\n                    return (_props$renderValue$to = (_props$renderValue = props.renderValue()) == null || _props$renderValue.toString == null ? void 0 : _props$renderValue.toString()) != null ? _props$renderValue$to : null;\n                },\n                ...table._features.reduce((obj, feature)=>{\n                    return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());\n                }, {}),\n                ...defaultColumn\n            };\n        }, {\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugColumns;\n            },\n            key:  true && \"getDefaultColumnDef\"\n        }),\n        _getColumnDefs: ()=>table.options.columns,\n        getAllColumns: memo(()=>[\n                table._getColumnDefs()\n            ], (columnDefs)=>{\n            const recurseColumns = function(columnDefs, parent, depth) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                return columnDefs.map((columnDef)=>{\n                    const column = createColumn(table, columnDef, depth, parent);\n                    const groupingColumnDef = columnDef;\n                    column.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column, depth + 1) : [];\n                    return column;\n                });\n            };\n            return recurseColumns(columnDefs);\n        }, {\n            key:  true && \"getAllColumns\",\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugColumns;\n            }\n        }),\n        getAllFlatColumns: memo(()=>[\n                table.getAllColumns()\n            ], (allColumns)=>{\n            return allColumns.flatMap((column)=>{\n                return column.getFlatColumns();\n            });\n        }, {\n            key:  true && \"getAllFlatColumns\",\n            debug: ()=>{\n                var _table$options$debugA3;\n                return (_table$options$debugA3 = table.options.debugAll) != null ? _table$options$debugA3 : table.options.debugColumns;\n            }\n        }),\n        _getAllFlatColumnsById: memo(()=>[\n                table.getAllFlatColumns()\n            ], (flatColumns)=>{\n            return flatColumns.reduce((acc, column)=>{\n                acc[column.id] = column;\n                return acc;\n            }, {});\n        }, {\n            key:  true && \"getAllFlatColumnsById\",\n            debug: ()=>{\n                var _table$options$debugA4;\n                return (_table$options$debugA4 = table.options.debugAll) != null ? _table$options$debugA4 : table.options.debugColumns;\n            }\n        }),\n        getAllLeafColumns: memo(()=>[\n                table.getAllColumns(),\n                table._getOrderColumnsFn()\n            ], (allColumns, orderColumns)=>{\n            let leafColumns = allColumns.flatMap((column)=>column.getLeafColumns());\n            return orderColumns(leafColumns);\n        }, {\n            key:  true && \"getAllLeafColumns\",\n            debug: ()=>{\n                var _table$options$debugA5;\n                return (_table$options$debugA5 = table.options.debugAll) != null ? _table$options$debugA5 : table.options.debugColumns;\n            }\n        }),\n        getColumn: (columnId)=>{\n            const column = table._getAllFlatColumnsById()[columnId];\n            if ( true && !column) {\n                console.error(`[Table] Column with id '${columnId}' does not exist.`);\n            }\n            return column;\n        }\n    };\n    Object.assign(table, coreInstance);\n    for(let index = 0; index < table._features.length; index++){\n        const feature = table._features[index];\n        feature == null || feature.createTable == null || feature.createTable(table);\n    }\n    return table;\n}\nfunction createCell(table, row, column, columnId) {\n    const getRenderValue = ()=>{\n        var _cell$getValue;\n        return (_cell$getValue = cell.getValue()) != null ? _cell$getValue : table.options.renderFallbackValue;\n    };\n    const cell = {\n        id: `${row.id}_${column.id}`,\n        row,\n        column,\n        getValue: ()=>row.getValue(columnId),\n        renderValue: getRenderValue,\n        getContext: memo(()=>[\n                table,\n                column,\n                row,\n                cell\n            ], (table, column, row, cell)=>({\n                table,\n                column,\n                row,\n                cell: cell,\n                getValue: cell.getValue,\n                renderValue: cell.renderValue\n            }), {\n            key:  true && \"cell.getContext\",\n            debug: ()=>table.options.debugAll\n        })\n    };\n    table._features.forEach((feature)=>{\n        feature.createCell == null || feature.createCell(cell, column, row, table);\n    }, {});\n    return cell;\n}\nconst createRow = (table, id, original, rowIndex, depth, subRows, parentId)=>{\n    let row = {\n        id,\n        index: rowIndex,\n        original,\n        depth,\n        parentId,\n        _valuesCache: {},\n        _uniqueValuesCache: {},\n        getValue: (columnId)=>{\n            if (row._valuesCache.hasOwnProperty(columnId)) {\n                return row._valuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.accessorFn)) {\n                return undefined;\n            }\n            row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);\n            return row._valuesCache[columnId];\n        },\n        getUniqueValues: (columnId)=>{\n            if (row._uniqueValuesCache.hasOwnProperty(columnId)) {\n                return row._uniqueValuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.accessorFn)) {\n                return undefined;\n            }\n            if (!column.columnDef.getUniqueValues) {\n                row._uniqueValuesCache[columnId] = [\n                    row.getValue(columnId)\n                ];\n                return row._uniqueValuesCache[columnId];\n            }\n            row._uniqueValuesCache[columnId] = column.columnDef.getUniqueValues(row.original, rowIndex);\n            return row._uniqueValuesCache[columnId];\n        },\n        renderValue: (columnId)=>{\n            var _row$getValue;\n            return (_row$getValue = row.getValue(columnId)) != null ? _row$getValue : table.options.renderFallbackValue;\n        },\n        subRows: subRows != null ? subRows : [],\n        getLeafRows: ()=>flattenBy(row.subRows, (d)=>d.subRows),\n        getParentRow: ()=>row.parentId ? table.getRow(row.parentId, true) : undefined,\n        getParentRows: ()=>{\n            let parentRows = [];\n            let currentRow = row;\n            while(true){\n                const parentRow = currentRow.getParentRow();\n                if (!parentRow) break;\n                parentRows.push(parentRow);\n                currentRow = parentRow;\n            }\n            return parentRows.reverse();\n        },\n        getAllCells: memo(()=>[\n                table.getAllLeafColumns()\n            ], (leafColumns)=>{\n            return leafColumns.map((column)=>{\n                return createCell(table, row, column, column.id);\n            });\n        }, {\n            key:  true && \"row.getAllCells\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugRows;\n            }\n        }),\n        _getAllCellsByColumnId: memo(()=>[\n                row.getAllCells()\n            ], (allCells)=>{\n            return allCells.reduce((acc, cell)=>{\n                acc[cell.column.id] = cell;\n                return acc;\n            }, {});\n        }, {\n            key:  false && 0,\n            debug: ()=>{\n                var _table$options$debugA2;\n                return (_table$options$debugA2 = table.options.debugAll) != null ? _table$options$debugA2 : table.options.debugRows;\n            }\n        })\n    };\n    for(let i = 0; i < table._features.length; i++){\n        const feature = table._features[i];\n        feature == null || feature.createRow == null || feature.createRow(row, table);\n    }\n    return row;\n};\n// type Person = {\n//   firstName: string\n//   lastName: string\n//   age: number\n//   visits: number\n//   status: string\n//   progress: number\n//   createdAt: Date\n//   nested: {\n//     foo: [\n//       {\n//         bar: 'bar'\n//       }\n//     ]\n//     bar: { subBar: boolean }[]\n//     baz: {\n//       foo: 'foo'\n//       bar: {\n//         baz: 'baz'\n//       }\n//     }\n//   }\n// }\n// const test: DeepKeys<Person> = 'nested.foo.0.bar'\n// const test2: DeepKeys<Person> = 'nested.bar'\n// const helper = createColumnHelper<Person>()\n// helper.accessor('nested.foo', {\n//   cell: info => info.getValue(),\n// })\n// helper.accessor('nested.foo.0.bar', {\n//   cell: info => info.getValue(),\n// })\n// helper.accessor('nested.bar', {\n//   cell: info => info.getValue(),\n// })\nfunction createColumnHelper() {\n    return {\n        accessor: (accessor, column)=>{\n            return typeof accessor === \"function\" ? {\n                ...column,\n                accessorFn: accessor\n            } : {\n                ...column,\n                accessorKey: accessor\n            };\n        },\n        display: (column)=>column,\n        group: (column)=>column\n    };\n}\nfunction getCoreRowModel() {\n    return (table)=>memo(()=>[\n                table.options.data\n            ], (data)=>{\n            const rowModel = {\n                rows: [],\n                flatRows: [],\n                rowsById: {}\n            };\n            const accessRows = function(originalRows, depth, parentRow) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                const rows = [];\n                for(let i = 0; i < originalRows.length; i++){\n                    // This could be an expensive check at scale, so we should move it somewhere else, but where?\n                    // if (!id) {\n                    //   if (process.env.NODE_ENV !== 'production') {\n                    //     throw new Error(`getRowId expected an ID, but got ${id}`)\n                    //   }\n                    // }\n                    // Make the row\n                    const row = createRow(table, table._getRowId(originalRows[i], i, parentRow), originalRows[i], i, depth, undefined, parentRow == null ? void 0 : parentRow.id);\n                    // Keep track of every row in a flat array\n                    rowModel.flatRows.push(row);\n                    // Also keep track of every row by its ID\n                    rowModel.rowsById[row.id] = row;\n                    // Push table row into parent\n                    rows.push(row);\n                    // Get the original subrows\n                    if (table.options.getSubRows) {\n                        var _row$originalSubRows;\n                        row.originalSubRows = table.options.getSubRows(originalRows[i], i);\n                        // Then recursively access them\n                        if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {\n                            row.subRows = accessRows(row.originalSubRows, depth + 1, row);\n                        }\n                    }\n                }\n                return rows;\n            };\n            rowModel.rows = accessRows(data);\n            return rowModel;\n        }, {\n            key:  true && \"getRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{\n                table._autoResetPageIndex();\n            }\n        });\n}\nfunction filterRows(rows, filterRowImpl, table) {\n    if (table.options.filterFromLeafRows) {\n        return filterRowModelFromLeafs(rows, filterRowImpl, table);\n    }\n    return filterRowModelFromRoot(rows, filterRowImpl, table);\n}\nfunction filterRowModelFromLeafs(rowsToFilter, filterRow, table) {\n    var _table$options$maxLea;\n    const newFilteredFlatRows = [];\n    const newFilteredRowsById = {};\n    const maxDepth = (_table$options$maxLea = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea : 100;\n    const recurseFilterRows = function(rowsToFilter, depth) {\n        if (depth === void 0) {\n            depth = 0;\n        }\n        const rows = [];\n        // Filter from children up first\n        for(let i = 0; i < rowsToFilter.length; i++){\n            var _row$subRows;\n            let row = rowsToFilter[i];\n            const newRow = createRow(table, row.id, row.original, row.index, row.depth, undefined, row.parentId);\n            newRow.columnFilters = row.columnFilters;\n            if ((_row$subRows = row.subRows) != null && _row$subRows.length && depth < maxDepth) {\n                newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n                row = newRow;\n                if (filterRow(row) && !newRow.subRows.length) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                    continue;\n                }\n                if (filterRow(row) || newRow.subRows.length) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                    continue;\n                }\n            } else {\n                row = newRow;\n                if (filterRow(row)) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                }\n            }\n        }\n        return rows;\n    };\n    return {\n        rows: recurseFilterRows(rowsToFilter),\n        flatRows: newFilteredFlatRows,\n        rowsById: newFilteredRowsById\n    };\n}\nfunction filterRowModelFromRoot(rowsToFilter, filterRow, table) {\n    var _table$options$maxLea2;\n    const newFilteredFlatRows = [];\n    const newFilteredRowsById = {};\n    const maxDepth = (_table$options$maxLea2 = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea2 : 100;\n    // Filters top level and nested rows\n    const recurseFilterRows = function(rowsToFilter, depth) {\n        if (depth === void 0) {\n            depth = 0;\n        }\n        // Filter from parents downward first\n        const rows = [];\n        // Apply the filter to any subRows\n        for(let i = 0; i < rowsToFilter.length; i++){\n            let row = rowsToFilter[i];\n            const pass = filterRow(row);\n            if (pass) {\n                var _row$subRows2;\n                if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length && depth < maxDepth) {\n                    const newRow = createRow(table, row.id, row.original, row.index, row.depth, undefined, row.parentId);\n                    newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n                    row = newRow;\n                }\n                rows.push(row);\n                newFilteredFlatRows.push(row);\n                newFilteredRowsById[row.id] = row;\n            }\n        }\n        return rows;\n    };\n    return {\n        rows: recurseFilterRows(rowsToFilter),\n        flatRows: newFilteredFlatRows,\n        rowsById: newFilteredRowsById\n    };\n}\nfunction getFilteredRowModel() {\n    return (table)=>memo(()=>[\n                table.getPreFilteredRowModel(),\n                table.getState().columnFilters,\n                table.getState().globalFilter\n            ], (rowModel, columnFilters, globalFilter)=>{\n            if (!rowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n                for(let i = 0; i < rowModel.flatRows.length; i++){\n                    rowModel.flatRows[i].columnFilters = {};\n                    rowModel.flatRows[i].columnFiltersMeta = {};\n                }\n                return rowModel;\n            }\n            const resolvedColumnFilters = [];\n            const resolvedGlobalFilters = [];\n            (columnFilters != null ? columnFilters : []).forEach((d)=>{\n                var _filterFn$resolveFilt;\n                const column = table.getColumn(d.id);\n                if (!column) {\n                    return;\n                }\n                const filterFn = column.getFilterFn();\n                if (!filterFn) {\n                    if (true) {\n                        console.warn(`Could not find a valid 'column.filterFn' for column with the ID: ${column.id}.`);\n                    }\n                    return;\n                }\n                resolvedColumnFilters.push({\n                    id: d.id,\n                    filterFn,\n                    resolvedValue: (_filterFn$resolveFilt = filterFn.resolveFilterValue == null ? void 0 : filterFn.resolveFilterValue(d.value)) != null ? _filterFn$resolveFilt : d.value\n                });\n            });\n            const filterableIds = columnFilters.map((d)=>d.id);\n            const globalFilterFn = table.getGlobalFilterFn();\n            const globallyFilterableColumns = table.getAllLeafColumns().filter((column)=>column.getCanGlobalFilter());\n            if (globalFilter && globalFilterFn && globallyFilterableColumns.length) {\n                filterableIds.push(\"__global__\");\n                globallyFilterableColumns.forEach((column)=>{\n                    var _globalFilterFn$resol;\n                    resolvedGlobalFilters.push({\n                        id: column.id,\n                        filterFn: globalFilterFn,\n                        resolvedValue: (_globalFilterFn$resol = globalFilterFn.resolveFilterValue == null ? void 0 : globalFilterFn.resolveFilterValue(globalFilter)) != null ? _globalFilterFn$resol : globalFilter\n                    });\n                });\n            }\n            let currentColumnFilter;\n            let currentGlobalFilter;\n            // Flag the prefiltered row model with each filter state\n            for(let j = 0; j < rowModel.flatRows.length; j++){\n                const row = rowModel.flatRows[j];\n                row.columnFilters = {};\n                if (resolvedColumnFilters.length) {\n                    for(let i = 0; i < resolvedColumnFilters.length; i++){\n                        currentColumnFilter = resolvedColumnFilters[i];\n                        const id = currentColumnFilter.id;\n                        // Tag the row with the column filter state\n                        row.columnFilters[id] = currentColumnFilter.filterFn(row, id, currentColumnFilter.resolvedValue, (filterMeta)=>{\n                            row.columnFiltersMeta[id] = filterMeta;\n                        });\n                    }\n                }\n                if (resolvedGlobalFilters.length) {\n                    for(let i = 0; i < resolvedGlobalFilters.length; i++){\n                        currentGlobalFilter = resolvedGlobalFilters[i];\n                        const id = currentGlobalFilter.id;\n                        // Tag the row with the first truthy global filter state\n                        if (currentGlobalFilter.filterFn(row, id, currentGlobalFilter.resolvedValue, (filterMeta)=>{\n                            row.columnFiltersMeta[id] = filterMeta;\n                        })) {\n                            row.columnFilters.__global__ = true;\n                            break;\n                        }\n                    }\n                    if (row.columnFilters.__global__ !== true) {\n                        row.columnFilters.__global__ = false;\n                    }\n                }\n            }\n            const filterRowsImpl = (row)=>{\n                // Horizontally filter rows through each column\n                for(let i = 0; i < filterableIds.length; i++){\n                    if (row.columnFilters[filterableIds[i]] === false) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n            // Filter final rows using all of the active filters\n            return filterRows(rowModel.rows, filterRowsImpl, table);\n        }, {\n            key:  true && \"getFilteredRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{\n                table._autoResetPageIndex();\n            }\n        });\n}\nfunction getFacetedRowModel() {\n    return (table, columnId)=>memo(()=>[\n                table.getPreFilteredRowModel(),\n                table.getState().columnFilters,\n                table.getState().globalFilter,\n                table.getFilteredRowModel()\n            ], (preRowModel, columnFilters, globalFilter)=>{\n            if (!preRowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n                return preRowModel;\n            }\n            const filterableIds = [\n                ...columnFilters.map((d)=>d.id).filter((d)=>d !== columnId),\n                globalFilter ? \"__global__\" : undefined\n            ].filter(Boolean);\n            const filterRowsImpl = (row)=>{\n                // Horizontally filter rows through each column\n                for(let i = 0; i < filterableIds.length; i++){\n                    if (row.columnFilters[filterableIds[i]] === false) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n            return filterRows(preRowModel.rows, filterRowsImpl, table);\n        }, {\n            key:  true && \"getFacetedRowModel_\" + columnId,\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{}\n        });\n}\nfunction getFacetedUniqueValues() {\n    return (table, columnId)=>memo(()=>{\n            var _table$getColumn;\n            return [\n                (_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()\n            ];\n        }, (facetedRowModel)=>{\n            if (!facetedRowModel) return new Map();\n            let facetedUniqueValues = new Map();\n            for(let i = 0; i < facetedRowModel.flatRows.length; i++){\n                const values = facetedRowModel.flatRows[i].getUniqueValues(columnId);\n                for(let j = 0; j < values.length; j++){\n                    const value = values[j];\n                    if (facetedUniqueValues.has(value)) {\n                        var _facetedUniqueValues$;\n                        facetedUniqueValues.set(value, ((_facetedUniqueValues$ = facetedUniqueValues.get(value)) != null ? _facetedUniqueValues$ : 0) + 1);\n                    } else {\n                        facetedUniqueValues.set(value, 1);\n                    }\n                }\n            }\n            return facetedUniqueValues;\n        }, {\n            key:  true && \"getFacetedUniqueValues_\" + columnId,\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{}\n        });\n}\nfunction getFacetedMinMaxValues() {\n    return (table, columnId)=>memo(()=>{\n            var _table$getColumn;\n            return [\n                (_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()\n            ];\n        }, (facetedRowModel)=>{\n            var _facetedRowModel$flat;\n            if (!facetedRowModel) return undefined;\n            const firstValue = (_facetedRowModel$flat = facetedRowModel.flatRows[0]) == null ? void 0 : _facetedRowModel$flat.getUniqueValues(columnId);\n            if (typeof firstValue === \"undefined\") {\n                return undefined;\n            }\n            let facetedMinMaxValues = [\n                firstValue,\n                firstValue\n            ];\n            for(let i = 0; i < facetedRowModel.flatRows.length; i++){\n                const values = facetedRowModel.flatRows[i].getUniqueValues(columnId);\n                for(let j = 0; j < values.length; j++){\n                    const value = values[j];\n                    if (value < facetedMinMaxValues[0]) {\n                        facetedMinMaxValues[0] = value;\n                    } else if (value > facetedMinMaxValues[1]) {\n                        facetedMinMaxValues[1] = value;\n                    }\n                }\n            }\n            return facetedMinMaxValues;\n        }, {\n            key:  true && \"getFacetedMinMaxValues_\" + columnId,\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{}\n        });\n}\nfunction getSortedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().sorting,\n                table.getPreSortedRowModel()\n            ], (sorting, rowModel)=>{\n            if (!rowModel.rows.length || !(sorting != null && sorting.length)) {\n                return rowModel;\n            }\n            const sortingState = table.getState().sorting;\n            const sortedFlatRows = [];\n            // Filter out sortings that correspond to non existing columns\n            const availableSorting = sortingState.filter((sort)=>{\n                var _table$getColumn;\n                return (_table$getColumn = table.getColumn(sort.id)) == null ? void 0 : _table$getColumn.getCanSort();\n            });\n            const columnInfoById = {};\n            availableSorting.forEach((sortEntry)=>{\n                const column = table.getColumn(sortEntry.id);\n                if (!column) return;\n                columnInfoById[sortEntry.id] = {\n                    sortUndefined: column.columnDef.sortUndefined,\n                    invertSorting: column.columnDef.invertSorting,\n                    sortingFn: column.getSortingFn()\n                };\n            });\n            const sortData = (rows)=>{\n                // This will also perform a stable sorting using the row index\n                // if needed.\n                const sortedData = rows.map((row)=>({\n                        ...row\n                    }));\n                sortedData.sort((rowA, rowB)=>{\n                    for(let i = 0; i < availableSorting.length; i += 1){\n                        var _sortEntry$desc;\n                        const sortEntry = availableSorting[i];\n                        const columnInfo = columnInfoById[sortEntry.id];\n                        const isDesc = (_sortEntry$desc = sortEntry == null ? void 0 : sortEntry.desc) != null ? _sortEntry$desc : false;\n                        let sortInt = 0;\n                        // All sorting ints should always return in ascending order\n                        if (columnInfo.sortUndefined) {\n                            const aValue = rowA.getValue(sortEntry.id);\n                            const bValue = rowB.getValue(sortEntry.id);\n                            const aUndefined = aValue === undefined;\n                            const bUndefined = bValue === undefined;\n                            if (aUndefined || bUndefined) {\n                                sortInt = aUndefined && bUndefined ? 0 : aUndefined ? columnInfo.sortUndefined : -columnInfo.sortUndefined;\n                            }\n                        }\n                        if (sortInt === 0) {\n                            sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id);\n                        }\n                        // If sorting is non-zero, take care of desc and inversion\n                        if (sortInt !== 0) {\n                            if (isDesc) {\n                                sortInt *= -1;\n                            }\n                            if (columnInfo.invertSorting) {\n                                sortInt *= -1;\n                            }\n                            return sortInt;\n                        }\n                    }\n                    return rowA.index - rowB.index;\n                });\n                // If there are sub-rows, sort them\n                sortedData.forEach((row)=>{\n                    var _row$subRows;\n                    sortedFlatRows.push(row);\n                    if ((_row$subRows = row.subRows) != null && _row$subRows.length) {\n                        row.subRows = sortData(row.subRows);\n                    }\n                });\n                return sortedData;\n            };\n            return {\n                rows: sortData(rowModel.rows),\n                flatRows: sortedFlatRows,\n                rowsById: rowModel.rowsById\n            };\n        }, {\n            key:  true && \"getSortedRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{\n                table._autoResetPageIndex();\n            }\n        });\n}\nfunction getGroupedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().grouping,\n                table.getPreGroupedRowModel()\n            ], (grouping, rowModel)=>{\n            if (!rowModel.rows.length || !grouping.length) {\n                return rowModel;\n            }\n            // Filter the grouping list down to columns that exist\n            const existingGrouping = grouping.filter((columnId)=>table.getColumn(columnId));\n            const groupedFlatRows = [];\n            const groupedRowsById = {};\n            // const onlyGroupedFlatRows: Row[] = [];\n            // const onlyGroupedRowsById: Record<RowId, Row> = {};\n            // const nonGroupedFlatRows: Row[] = [];\n            // const nonGroupedRowsById: Record<RowId, Row> = {};\n            // Recursively group the data\n            const groupUpRecursively = function(rows, depth, parentId) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                // Grouping depth has been been met\n                // Stop grouping and simply rewrite thd depth and row relationships\n                if (depth >= existingGrouping.length) {\n                    return rows.map((row)=>{\n                        row.depth = depth;\n                        groupedFlatRows.push(row);\n                        groupedRowsById[row.id] = row;\n                        if (row.subRows) {\n                            row.subRows = groupUpRecursively(row.subRows, depth + 1, row.id);\n                        }\n                        return row;\n                    });\n                }\n                const columnId = existingGrouping[depth];\n                // Group the rows together for this level\n                const rowGroupsMap = groupBy(rows, columnId);\n                // Peform aggregations for each group\n                const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map((_ref, index)=>{\n                    let [groupingValue, groupedRows] = _ref;\n                    let id = `${columnId}:${groupingValue}`;\n                    id = parentId ? `${parentId}>${id}` : id;\n                    // First, Recurse to group sub rows before aggregation\n                    const subRows = groupUpRecursively(groupedRows, depth + 1, id);\n                    // Flatten the leaf rows of the rows in this group\n                    const leafRows = depth ? flattenBy(groupedRows, (row)=>row.subRows) : groupedRows;\n                    const row = createRow(table, id, leafRows[0].original, index, depth, undefined, parentId);\n                    Object.assign(row, {\n                        groupingColumnId: columnId,\n                        groupingValue,\n                        subRows,\n                        leafRows,\n                        getValue: (columnId)=>{\n                            // Don't aggregate columns that are in the grouping\n                            if (existingGrouping.includes(columnId)) {\n                                if (row._valuesCache.hasOwnProperty(columnId)) {\n                                    return row._valuesCache[columnId];\n                                }\n                                if (groupedRows[0]) {\n                                    var _groupedRows$0$getVal;\n                                    row._valuesCache[columnId] = (_groupedRows$0$getVal = groupedRows[0].getValue(columnId)) != null ? _groupedRows$0$getVal : undefined;\n                                }\n                                return row._valuesCache[columnId];\n                            }\n                            if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n                                return row._groupingValuesCache[columnId];\n                            }\n                            // Aggregate the values\n                            const column = table.getColumn(columnId);\n                            const aggregateFn = column == null ? void 0 : column.getAggregationFn();\n                            if (aggregateFn) {\n                                row._groupingValuesCache[columnId] = aggregateFn(columnId, leafRows, groupedRows);\n                                return row._groupingValuesCache[columnId];\n                            }\n                        }\n                    });\n                    subRows.forEach((subRow)=>{\n                        groupedFlatRows.push(subRow);\n                        groupedRowsById[subRow.id] = subRow;\n                    // if (subRow.getIsGrouped?.()) {\n                    //   onlyGroupedFlatRows.push(subRow);\n                    //   onlyGroupedRowsById[subRow.id] = subRow;\n                    // } else {\n                    //   nonGroupedFlatRows.push(subRow);\n                    //   nonGroupedRowsById[subRow.id] = subRow;\n                    // }\n                    });\n                    return row;\n                });\n                return aggregatedGroupedRows;\n            };\n            const groupedRows = groupUpRecursively(rowModel.rows, 0);\n            groupedRows.forEach((subRow)=>{\n                groupedFlatRows.push(subRow);\n                groupedRowsById[subRow.id] = subRow;\n            // if (subRow.getIsGrouped?.()) {\n            //   onlyGroupedFlatRows.push(subRow);\n            //   onlyGroupedRowsById[subRow.id] = subRow;\n            // } else {\n            //   nonGroupedFlatRows.push(subRow);\n            //   nonGroupedRowsById[subRow.id] = subRow;\n            // }\n            });\n            return {\n                rows: groupedRows,\n                flatRows: groupedFlatRows,\n                rowsById: groupedRowsById\n            };\n        }, {\n            key:  true && \"getGroupedRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            },\n            onChange: ()=>{\n                table._queue(()=>{\n                    table._autoResetExpanded();\n                    table._autoResetPageIndex();\n                });\n            }\n        });\n}\nfunction groupBy(rows, columnId) {\n    const groupMap = new Map();\n    return rows.reduce((map, row)=>{\n        const resKey = `${row.getGroupingValue(columnId)}`;\n        const previous = map.get(resKey);\n        if (!previous) {\n            map.set(resKey, [\n                row\n            ]);\n        } else {\n            previous.push(row);\n        }\n        return map;\n    }, groupMap);\n}\nfunction getExpandedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().expanded,\n                table.getPreExpandedRowModel(),\n                table.options.paginateExpandedRows\n            ], (expanded, rowModel, paginateExpandedRows)=>{\n            if (!rowModel.rows.length || expanded !== true && !Object.keys(expanded != null ? expanded : {}).length) {\n                return rowModel;\n            }\n            if (!paginateExpandedRows) {\n                // Only expand rows at this point if they are being paginated\n                return rowModel;\n            }\n            return expandRows(rowModel);\n        }, {\n            key:  true && \"getExpandedRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            }\n        });\n}\nfunction expandRows(rowModel) {\n    const expandedRows = [];\n    const handleRow = (row)=>{\n        var _row$subRows;\n        expandedRows.push(row);\n        if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getIsExpanded()) {\n            row.subRows.forEach(handleRow);\n        }\n    };\n    rowModel.rows.forEach(handleRow);\n    return {\n        rows: expandedRows,\n        flatRows: rowModel.flatRows,\n        rowsById: rowModel.rowsById\n    };\n}\nfunction getPaginationRowModel(opts) {\n    return (table)=>memo(()=>[\n                table.getState().pagination,\n                table.getPrePaginationRowModel(),\n                table.options.paginateExpandedRows ? undefined : table.getState().expanded\n            ], (pagination, rowModel)=>{\n            if (!rowModel.rows.length) {\n                return rowModel;\n            }\n            const { pageSize, pageIndex } = pagination;\n            let { rows, flatRows, rowsById } = rowModel;\n            const pageStart = pageSize * pageIndex;\n            const pageEnd = pageStart + pageSize;\n            rows = rows.slice(pageStart, pageEnd);\n            let paginatedRowModel;\n            if (!table.options.paginateExpandedRows) {\n                paginatedRowModel = expandRows({\n                    rows,\n                    flatRows,\n                    rowsById\n                });\n            } else {\n                paginatedRowModel = {\n                    rows,\n                    flatRows,\n                    rowsById\n                };\n            }\n            paginatedRowModel.flatRows = [];\n            const handleRow = (row)=>{\n                paginatedRowModel.flatRows.push(row);\n                if (row.subRows.length) {\n                    row.subRows.forEach(handleRow);\n                }\n            };\n            paginatedRowModel.rows.forEach(handleRow);\n            return paginatedRowModel;\n        }, {\n            key:  true && \"getPaginationRowModel\",\n            debug: ()=>{\n                var _table$options$debugA;\n                return (_table$options$debugA = table.options.debugAll) != null ? _table$options$debugA : table.options.debugTable;\n            }\n        });\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0YW5zdGFjayt0YWJsZS1jb3JlQDguMTEuNi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3RhYmxlLWNvcmUvYnVpbGQvbGliL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7O0dBU0csR0FDSCx3QkFBd0I7QUFFeEIscURBQXFEO0FBRXJELEdBQUc7QUFFSCxTQUFTQSxpQkFBaUJDLE9BQU8sRUFBRUMsS0FBSztJQUN0QyxPQUFPLE9BQU9ELFlBQVksYUFBYUEsUUFBUUMsU0FBU0Q7QUFDMUQ7QUFDQSxTQUFTRTtBQUNQLEVBQUU7QUFDSjtBQUNBLFNBQVNDLGlCQUFpQkMsR0FBRyxFQUFFQyxRQUFRO0lBQ3JDLE9BQU9MLENBQUFBO1FBQ0xLLFNBQVNDLFFBQVEsQ0FBQ0MsQ0FBQUE7WUFDaEIsT0FBTztnQkFDTCxHQUFHQSxHQUFHO2dCQUNOLENBQUNILElBQUksRUFBRUwsaUJBQWlCQyxTQUFTTyxHQUFHLENBQUNILElBQUk7WUFDM0M7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxTQUFTSSxXQUFXQyxDQUFDO0lBQ25CLE9BQU9BLGFBQWFDO0FBQ3RCO0FBQ0EsU0FBU0MsY0FBY0YsQ0FBQztJQUN0QixPQUFPRyxNQUFNQyxPQUFPLENBQUNKLE1BQU1BLEVBQUVLLEtBQUssQ0FBQ0MsQ0FBQUEsTUFBTyxPQUFPQSxRQUFRO0FBQzNEO0FBQ0EsU0FBU0MsVUFBVUMsR0FBRyxFQUFFQyxXQUFXO0lBQ2pDLE1BQU1DLE9BQU8sRUFBRTtJQUNmLE1BQU1DLFVBQVVDLENBQUFBO1FBQ2RBLE9BQU9DLE9BQU8sQ0FBQ0MsQ0FBQUE7WUFDYkosS0FBS0ssSUFBSSxDQUFDRDtZQUNWLE1BQU1FLFdBQVdQLFlBQVlLO1lBQzdCLElBQUlFLFlBQVksUUFBUUEsU0FBU0MsTUFBTSxFQUFFO2dCQUN2Q04sUUFBUUs7WUFDVjtR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LFVBQVVELFlBQVlqWjtZQUM1QnVDLE9BQU9BLEtBQUsySyxLQUFLLENBQUMrTCxXQUFXQztZQUM3QixJQUFJQztZQUNKLElBQUksQ0FBQ2g0QixNQUFNNEIsT0FBTyxDQUFDK04sb0JBQW9CLEVBQUU7Z0JBQ3ZDcW9CLG9CQUFvQkwsV0FBVztvQkFDN0J2VztvQkFDQXhRO29CQUNBWTtnQkFDRjtZQUNGLE9BQU87Z0JBQ0x3bUIsb0JBQW9CO29CQUNsQjVXO29CQUNBeFE7b0JBQ0FZO2dCQUNGO1lBQ0Y7WUFDQXdtQixrQkFBa0JwbkIsUUFBUSxHQUFHLEVBQUU7WUFDL0IsTUFBTWluQixZQUFZaG5CLENBQUFBO2dCQUNoQm1uQixrQkFBa0JwbkIsUUFBUSxDQUFDOVMsSUFBSSxDQUFDK1M7Z0JBQ2hDLElBQUlBLElBQUk2QixPQUFPLENBQUMxVSxNQUFNLEVBQUU7b0JBQ3RCNlMsSUFBSTZCLE9BQU8sQ0FBQzlVLE9BQU8sQ0FBQ2k2QjtnQkFDdEI7WUFDRjtZQUNBRyxrQkFBa0I1VyxJQUFJLENBQUN4akIsT0FBTyxDQUFDaTZCO1lBQy9CLE9BQU9HO1FBQ1QsR0FBRztZQUNEdDdCLEtBQUt5RSxLQUF5QixJQUFpQjtZQUMvQzNDLE9BQU87Z0JBQ0wsSUFBSW1EO2dCQUNKLE9BQU8sQ0FBQ0Esd0JBQXdCM0IsTUFBTTRCLE9BQU8sQ0FBQ0MsUUFBUSxLQUFLLE9BQU9GLHdCQUF3QjNCLE1BQU00QixPQUFPLENBQUMrZSxVQUFVO1lBQ3BIO1FBQ0Y7QUFDRjtBQUVzckIsQ0FDdHJCLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hpcmVyLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AdGFuc3RhY2srdGFibGUtY29yZUA4LjExLjYvbm9kZV9tb2R1bGVzL0B0YW5zdGFjay90YWJsZS1jb3JlL2J1aWxkL2xpYi9pbmRleC5tanM/YTM4NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAgICogdGFibGUtY29yZVxuICAgKlxuICAgKiBDb3B5cmlnaHQgKGMpIFRhblN0YWNrXG4gICAqXG4gICAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICAgKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gICAqXG4gICAqIEBsaWNlbnNlIE1JVFxuICAgKi9cbi8vIElzIHRoaXMgdHlwZSBhIHR1cGxlP1xuXG4vLyBJZiB0aGlzIHR5cGUgaXMgYSB0dXBsZSwgd2hhdCBpbmRpY2VzIGFyZSBhbGxvd2VkP1xuXG4vLy9cblxuZnVuY3Rpb24gZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCBpbnB1dCkge1xuICByZXR1cm4gdHlwZW9mIHVwZGF0ZXIgPT09ICdmdW5jdGlvbicgPyB1cGRhdGVyKGlucHV0KSA6IHVwZGF0ZXI7XG59XG5mdW5jdGlvbiBub29wKCkge1xuICAvL1xufVxuZnVuY3Rpb24gbWFrZVN0YXRlVXBkYXRlcihrZXksIGluc3RhbmNlKSB7XG4gIHJldHVybiB1cGRhdGVyID0+IHtcbiAgICBpbnN0YW5jZS5zZXRTdGF0ZShvbGQgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ub2xkLFxuICAgICAgICBba2V5XTogZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCBvbGRba2V5XSlcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGQpIHtcbiAgcmV0dXJuIGQgaW5zdGFuY2VvZiBGdW5jdGlvbjtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyQXJyYXkoZCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShkKSAmJiBkLmV2ZXJ5KHZhbCA9PiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyk7XG59XG5mdW5jdGlvbiBmbGF0dGVuQnkoYXJyLCBnZXRDaGlsZHJlbikge1xuICBjb25zdCBmbGF0ID0gW107XG4gIGNvbnN0IHJlY3Vyc2UgPSBzdWJBcnIgPT4ge1xuICAgIHN1YkFyci5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgZmxhdC5wdXNoKGl0ZW0pO1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbihpdGVtKTtcbiAgICAgIGlmIChjaGlsZHJlbiAhPSBudWxsICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICByZWN1cnNlKGNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgcmVjdXJzZShhcnIpO1xuICByZXR1cm4gZmxhdDtcbn1cbmZ1bmN0aW9uIG1lbW8oZ2V0RGVwcywgZm4sIG9wdHMpIHtcbiAgbGV0IGRlcHMgPSBbXTtcbiAgbGV0IHJlc3VsdDtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsZXQgZGVwVGltZTtcbiAgICBpZiAob3B0cy5rZXkgJiYgb3B0cy5kZWJ1ZykgZGVwVGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgbmV3RGVwcyA9IGdldERlcHMoKTtcbiAgICBjb25zdCBkZXBzQ2hhbmdlZCA9IG5ld0RlcHMubGVuZ3RoICE9PSBkZXBzLmxlbmd0aCB8fCBuZXdEZXBzLnNvbWUoKGRlcCwgaW5kZXgpID0+IGRlcHNbaW5kZXhdICE9PSBkZXApO1xuICAgIGlmICghZGVwc0NoYW5nZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGRlcHMgPSBuZXdEZXBzO1xuICAgIGxldCByZXN1bHRUaW1lO1xuICAgIGlmIChvcHRzLmtleSAmJiBvcHRzLmRlYnVnKSByZXN1bHRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICByZXN1bHQgPSBmbiguLi5uZXdEZXBzKTtcbiAgICBvcHRzID09IG51bGwgfHwgb3B0cy5vbkNoYW5nZSA9PSBudWxsIHx8IG9wdHMub25DaGFuZ2UocmVzdWx0KTtcbiAgICBpZiAob3B0cy5rZXkgJiYgb3B0cy5kZWJ1Zykge1xuICAgICAgaWYgKG9wdHMgIT0gbnVsbCAmJiBvcHRzLmRlYnVnKCkpIHtcbiAgICAgICAgY29uc3QgZGVwRW5kVGltZSA9IE1hdGgucm91bmQoKERhdGUubm93KCkgLSBkZXBUaW1lKSAqIDEwMCkgLyAxMDA7XG4gICAgICAgIGNvbnN0IHJlc3VsdEVuZFRpbWUgPSBNYXRoLnJvdW5kKChEYXRlLm5vdygpIC0gcmVzdWx0VGltZSkgKiAxMDApIC8gMTAwO1xuICAgICAgICBjb25zdCByZXN1bHRGcHNQZXJjZW50YWdlID0gcmVzdWx0RW5kVGltZSAvIDE2O1xuICAgICAgICBjb25zdCBwYWQgPSAoc3RyLCBudW0pID0+IHtcbiAgICAgICAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IG51bSkge1xuICAgICAgICAgICAgc3RyID0gJyAnICsgc3RyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLmluZm8oYCVj4o+xICR7cGFkKHJlc3VsdEVuZFRpbWUsIDUpfSAvJHtwYWQoZGVwRW5kVGltZSwgNSl9IG1zYCwgYFxuICAgICAgICAgICAgZm9udC1zaXplOiAuNnJlbTtcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgICAgY29sb3I6IGhzbCgke01hdGgubWF4KDAsIE1hdGgubWluKDEyMCAtIDEyMCAqIHJlc3VsdEZwc1BlcmNlbnRhZ2UsIDEyMCkpfWRlZyAxMDAlIDMxJSk7YCwgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5rZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb2x1bW4odGFibGUsIGNvbHVtbkRlZiwgZGVwdGgsIHBhcmVudCkge1xuICB2YXIgX3JlZiwgX3Jlc29sdmVkQ29sdW1uRGVmJGlkO1xuICBjb25zdCBkZWZhdWx0Q29sdW1uID0gdGFibGUuX2dldERlZmF1bHRDb2x1bW5EZWYoKTtcbiAgY29uc3QgcmVzb2x2ZWRDb2x1bW5EZWYgPSB7XG4gICAgLi4uZGVmYXVsdENvbHVtbixcbiAgICAuLi5jb2x1bW5EZWZcbiAgfTtcbiAgY29uc3QgYWNjZXNzb3JLZXkgPSByZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvcktleTtcbiAgbGV0IGlkID0gKF9yZWYgPSAoX3Jlc29sdmVkQ29sdW1uRGVmJGlkID0gcmVzb2x2ZWRDb2x1bW5EZWYuaWQpICE9IG51bGwgPyBfcmVzb2x2ZWRDb2x1bW5EZWYkaWQgOiBhY2Nlc3NvcktleSA/IGFjY2Vzc29yS2V5LnJlcGxhY2UoJy4nLCAnXycpIDogdW5kZWZpbmVkKSAhPSBudWxsID8gX3JlZiA6IHR5cGVvZiByZXNvbHZlZENvbHVtbkRlZi5oZWFkZXIgPT09ICdzdHJpbmcnID8gcmVzb2x2ZWRDb2x1bW5EZWYuaGVhZGVyIDogdW5kZWZpbmVkO1xuICBsZXQgYWNjZXNzb3JGbjtcbiAgaWYgKHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yRm4pIHtcbiAgICBhY2Nlc3NvckZuID0gcmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JGbjtcbiAgfSBlbHNlIGlmIChhY2Nlc3NvcktleSkge1xuICAgIC8vIFN1cHBvcnQgZGVlcCBhY2Nlc3NvciBrZXlzXG4gICAgaWYgKGFjY2Vzc29yS2V5LmluY2x1ZGVzKCcuJykpIHtcbiAgICAgIGFjY2Vzc29yRm4gPSBvcmlnaW5hbFJvdyA9PiB7XG4gICAgICAgIGxldCByZXN1bHQgPSBvcmlnaW5hbFJvdztcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgYWNjZXNzb3JLZXkuc3BsaXQoJy4nKSkge1xuICAgICAgICAgIHZhciBfcmVzdWx0O1xuICAgICAgICAgIHJlc3VsdCA9IChfcmVzdWx0ID0gcmVzdWx0KSA9PSBudWxsID8gdm9pZCAwIDogX3Jlc3VsdFtrZXldO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFwiJHtrZXl9XCIgaW4gZGVlcGx5IG5lc3RlZCBrZXkgXCIke2FjY2Vzc29yS2V5fVwiIHJldHVybmVkIHVuZGVmaW5lZC5gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY2Vzc29yRm4gPSBvcmlnaW5hbFJvdyA9PiBvcmlnaW5hbFJvd1tyZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvcktleV07XG4gICAgfVxuICB9XG4gIGlmICghaWQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yRm4gPyBgQ29sdW1ucyByZXF1aXJlIGFuIGlkIHdoZW4gdXNpbmcgYW4gYWNjZXNzb3JGbmAgOiBgQ29sdW1ucyByZXF1aXJlIGFuIGlkIHdoZW4gdXNpbmcgYSBub24tc3RyaW5nIGhlYWRlcmApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgfVxuICBsZXQgY29sdW1uID0ge1xuICAgIGlkOiBgJHtTdHJpbmcoaWQpfWAsXG4gICAgYWNjZXNzb3JGbixcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBkZXB0aCxcbiAgICBjb2x1bW5EZWY6IHJlc29sdmVkQ29sdW1uRGVmLFxuICAgIGNvbHVtbnM6IFtdLFxuICAgIGdldEZsYXRDb2x1bW5zOiBtZW1vKCgpID0+IFt0cnVlXSwgKCkgPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1ucztcbiAgICAgIHJldHVybiBbY29sdW1uLCAuLi4oKF9jb2x1bW4kY29sdW1ucyA9IGNvbHVtbi5jb2x1bW5zKSA9PSBudWxsID8gdm9pZCAwIDogX2NvbHVtbiRjb2x1bW5zLmZsYXRNYXAoZCA9PiBkLmdldEZsYXRDb2x1bW5zKCkpKV07XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nICYmICdjb2x1bW4uZ2V0RmxhdENvbHVtbnMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBIDogdGFibGUub3B0aW9ucy5kZWJ1Z0NvbHVtbnM7XG4gICAgICB9XG4gICAgfSksXG4gICAgZ2V0TGVhZkNvbHVtbnM6IG1lbW8oKCkgPT4gW3RhYmxlLl9nZXRPcmRlckNvbHVtbnNGbigpXSwgb3JkZXJDb2x1bW5zID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbnMyO1xuICAgICAgaWYgKChfY29sdW1uJGNvbHVtbnMyID0gY29sdW1uLmNvbHVtbnMpICE9IG51bGwgJiYgX2NvbHVtbiRjb2x1bW5zMi5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGxlYWZDb2x1bW5zID0gY29sdW1uLmNvbHVtbnMuZmxhdE1hcChjb2x1bW4gPT4gY29sdW1uLmdldExlYWZDb2x1bW5zKCkpO1xuICAgICAgICByZXR1cm4gb3JkZXJDb2x1bW5zKGxlYWZDb2x1bW5zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbY29sdW1uXTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiYgJ2NvbHVtbi5nZXRMZWFmQ29sdW1ucycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMjtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTIgOiB0YWJsZS5vcHRpb25zLmRlYnVnQ29sdW1ucztcbiAgICAgIH1cbiAgICB9KVxuICB9O1xuICBmb3IgKGNvbnN0IGZlYXR1cmUgb2YgdGFibGUuX2ZlYXR1cmVzKSB7XG4gICAgZmVhdHVyZS5jcmVhdGVDb2x1bW4gPT0gbnVsbCB8fCBmZWF0dXJlLmNyZWF0ZUNvbHVtbihjb2x1bW4sIHRhYmxlKTtcbiAgfVxuXG4gIC8vIFllcywgd2UgaGF2ZSB0byBjb252ZXJ0IHRhYmxlIHRvIHVrbm93biwgYmVjYXVzZSB3ZSBrbm93IG1vcmUgdGhhbiB0aGUgY29tcGlsZXIgaGVyZS5cbiAgcmV0dXJuIGNvbHVtbjtcbn1cblxuLy9cblxuZnVuY3Rpb24gY3JlYXRlSGVhZGVyKHRhYmxlLCBjb2x1bW4sIG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJGlkO1xuICBjb25zdCBpZCA9IChfb3B0aW9ucyRpZCA9IG9wdGlvbnMuaWQpICE9IG51bGwgPyBfb3B0aW9ucyRpZCA6IGNvbHVtbi5pZDtcbiAgbGV0IGhlYWRlciA9IHtcbiAgICBpZCxcbiAgICBjb2x1bW4sXG4gICAgaW5kZXg6IG9wdGlvbnMuaW5kZXgsXG4gICAgaXNQbGFjZWhvbGRlcjogISFvcHRpb25zLmlzUGxhY2Vob2xkZXIsXG4gICAgcGxhY2Vob2xkZXJJZDogb3B0aW9ucy5wbGFjZWhvbGRlcklkLFxuICAgIGRlcHRoOiBvcHRpb25zLmRlcHRoLFxuICAgIHN1YkhlYWRlcnM6IFtdLFxuICAgIGNvbFNwYW46IDAsXG4gICAgcm93U3BhbjogMCxcbiAgICBoZWFkZXJHcm91cDogbnVsbCxcbiAgICBnZXRMZWFmSGVhZGVyczogKCkgPT4ge1xuICAgICAgY29uc3QgbGVhZkhlYWRlcnMgPSBbXTtcbiAgICAgIGNvbnN0IHJlY3Vyc2VIZWFkZXIgPSBoID0+IHtcbiAgICAgICAgaWYgKGguc3ViSGVhZGVycyAmJiBoLnN1YkhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgaC5zdWJIZWFkZXJzLm1hcChyZWN1cnNlSGVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBsZWFmSGVhZGVycy5wdXNoKGgpO1xuICAgICAgfTtcbiAgICAgIHJlY3Vyc2VIZWFkZXIoaGVhZGVyKTtcbiAgICAgIHJldHVybiBsZWFmSGVhZGVycztcbiAgICB9LFxuICAgIGdldENvbnRleHQ6ICgpID0+ICh7XG4gICAgICB0YWJsZSxcbiAgICAgIGhlYWRlcjogaGVhZGVyLFxuICAgICAgY29sdW1uXG4gICAgfSlcbiAgfTtcbiAgdGFibGUuX2ZlYXR1cmVzLmZvckVhY2goZmVhdHVyZSA9PiB7XG4gICAgZmVhdHVyZS5jcmVhdGVIZWFkZXIgPT0gbnVsbCB8fCBmZWF0dXJlLmNyZWF0ZUhlYWRlcihoZWFkZXIsIHRhYmxlKTtcbiAgfSk7XG4gIHJldHVybiBoZWFkZXI7XG59XG5jb25zdCBIZWFkZXJzID0ge1xuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIC8vIEhlYWRlciBHcm91cHNcblxuICAgIHRhYmxlLmdldEhlYWRlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbENvbHVtbnMoKSwgdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0LCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ29sdW1ucywgbGVhZkNvbHVtbnMsIGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICB2YXIgX2xlZnQkbWFwJGZpbHRlciwgX3JpZ2h0JG1hcCRmaWx0ZXI7XG4gICAgICBjb25zdCBsZWZ0Q29sdW1ucyA9IChfbGVmdCRtYXAkZmlsdGVyID0gbGVmdCA9PSBudWxsID8gdm9pZCAwIDogbGVmdC5tYXAoY29sdW1uSWQgPT4gbGVhZkNvbHVtbnMuZmluZChkID0+IGQuaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pKSAhPSBudWxsID8gX2xlZnQkbWFwJGZpbHRlciA6IFtdO1xuICAgICAgY29uc3QgcmlnaHRDb2x1bW5zID0gKF9yaWdodCRtYXAkZmlsdGVyID0gcmlnaHQgPT0gbnVsbCA/IHZvaWQgMCA6IHJpZ2h0Lm1hcChjb2x1bW5JZCA9PiBsZWFmQ29sdW1ucy5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbikpICE9IG51bGwgPyBfcmlnaHQkbWFwJGZpbHRlciA6IFtdO1xuICAgICAgY29uc3QgY2VudGVyQ29sdW1ucyA9IGxlYWZDb2x1bW5zLmZpbHRlcihjb2x1bW4gPT4gIShsZWZ0ICE9IG51bGwgJiYgbGVmdC5pbmNsdWRlcyhjb2x1bW4uaWQpKSAmJiAhKHJpZ2h0ICE9IG51bGwgJiYgcmlnaHQuaW5jbHVkZXMoY29sdW1uLmlkKSkpO1xuICAgICAgY29uc3QgaGVhZGVyR3JvdXBzID0gYnVpbGRIZWFkZXJHcm91cHMoYWxsQ29sdW1ucywgWy4uLmxlZnRDb2x1bW5zLCAuLi5jZW50ZXJDb2x1bW5zLCAuLi5yaWdodENvbHVtbnNdLCB0YWJsZSk7XG4gICAgICByZXR1cm4gaGVhZGVyR3JvdXBzO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldEhlYWRlckdyb3VwcycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnSGVhZGVycztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJsZS5nZXRDZW50ZXJIZWFkZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxDb2x1bW5zKCksIHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdCwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0XSwgKGFsbENvbHVtbnMsIGxlYWZDb2x1bW5zLCBsZWZ0LCByaWdodCkgPT4ge1xuICAgICAgbGVhZkNvbHVtbnMgPSBsZWFmQ29sdW1ucy5maWx0ZXIoY29sdW1uID0+ICEobGVmdCAhPSBudWxsICYmIGxlZnQuaW5jbHVkZXMoY29sdW1uLmlkKSkgJiYgIShyaWdodCAhPSBudWxsICYmIHJpZ2h0LmluY2x1ZGVzKGNvbHVtbi5pZCkpKTtcbiAgICAgIHJldHVybiBidWlsZEhlYWRlckdyb3VwcyhhbGxDb2x1bW5zLCBsZWFmQ29sdW1ucywgdGFibGUsICdjZW50ZXInKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRDZW50ZXJIZWFkZXJHcm91cHMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTI7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBMiA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyIDogdGFibGUub3B0aW9ucy5kZWJ1Z0hlYWRlcnM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0TGVmdEhlYWRlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbENvbHVtbnMoKSwgdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0XSwgKGFsbENvbHVtbnMsIGxlYWZDb2x1bW5zLCBsZWZ0KSA9PiB7XG4gICAgICB2YXIgX2xlZnQkbWFwJGZpbHRlcjI7XG4gICAgICBjb25zdCBvcmRlcmVkTGVhZkNvbHVtbnMgPSAoX2xlZnQkbWFwJGZpbHRlcjIgPSBsZWZ0ID09IG51bGwgPyB2b2lkIDAgOiBsZWZ0Lm1hcChjb2x1bW5JZCA9PiBsZWFmQ29sdW1ucy5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbikpICE9IG51bGwgPyBfbGVmdCRtYXAkZmlsdGVyMiA6IFtdO1xuICAgICAgcmV0dXJuIGJ1aWxkSGVhZGVyR3JvdXBzKGFsbENvbHVtbnMsIG9yZGVyZWRMZWFmQ29sdW1ucywgdGFibGUsICdsZWZ0Jyk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0TGVmdEhlYWRlckdyb3VwcycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMztcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EzID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTMgOiB0YWJsZS5vcHRpb25zLmRlYnVnSGVhZGVycztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJsZS5nZXRSaWdodEhlYWRlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbENvbHVtbnMoKSwgdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodF0sIChhbGxDb2x1bW5zLCBsZWFmQ29sdW1ucywgcmlnaHQpID0+IHtcbiAgICAgIHZhciBfcmlnaHQkbWFwJGZpbHRlcjI7XG4gICAgICBjb25zdCBvcmRlcmVkTGVhZkNvbHVtbnMgPSAoX3JpZ2h0JG1hcCRmaWx0ZXIyID0gcmlnaHQgPT0gbnVsbCA/IHZvaWQgMCA6IHJpZ2h0Lm1hcChjb2x1bW5JZCA9PiBsZWFmQ29sdW1ucy5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbikpICE9IG51bGwgPyBfcmlnaHQkbWFwJGZpbHRlcjIgOiBbXTtcbiAgICAgIHJldHVybiBidWlsZEhlYWRlckdyb3VwcyhhbGxDb2x1bW5zLCBvcmRlcmVkTGVhZkNvbHVtbnMsIHRhYmxlLCAncmlnaHQnKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRSaWdodEhlYWRlckdyb3VwcycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBNDtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0E0ID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTQgOiB0YWJsZS5vcHRpb25zLmRlYnVnSGVhZGVycztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEZvb3RlciBHcm91cHNcblxuICAgIHRhYmxlLmdldEZvb3Rlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEhlYWRlckdyb3VwcygpXSwgaGVhZGVyR3JvdXBzID0+IHtcbiAgICAgIHJldHVybiBbLi4uaGVhZGVyR3JvdXBzXS5yZXZlcnNlKCk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0Rm9vdGVyR3JvdXBzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E1O1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTUgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBNSA6IHRhYmxlLm9wdGlvbnMuZGVidWdIZWFkZXJzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRhYmxlLmdldExlZnRGb290ZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRMZWZ0SGVhZGVyR3JvdXBzKCldLCBoZWFkZXJHcm91cHMgPT4ge1xuICAgICAgcmV0dXJuIFsuLi5oZWFkZXJHcm91cHNdLnJldmVyc2UoKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRMZWZ0Rm9vdGVyR3JvdXBzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E2O1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTYgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBNiA6IHRhYmxlLm9wdGlvbnMuZGVidWdIZWFkZXJzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRhYmxlLmdldENlbnRlckZvb3Rlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldENlbnRlckhlYWRlckdyb3VwcygpXSwgaGVhZGVyR3JvdXBzID0+IHtcbiAgICAgIHJldHVybiBbLi4uaGVhZGVyR3JvdXBzXS5yZXZlcnNlKCk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0Q2VudGVyRm9vdGVyR3JvdXBzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E3O1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTcgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBNyA6IHRhYmxlLm9wdGlvbnMuZGVidWdIZWFkZXJzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRhYmxlLmdldFJpZ2h0Rm9vdGVyR3JvdXBzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMoKV0sIGhlYWRlckdyb3VwcyA9PiB7XG4gICAgICByZXR1cm4gWy4uLmhlYWRlckdyb3Vwc10ucmV2ZXJzZSgpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldFJpZ2h0Rm9vdGVyR3JvdXBzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E4O1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTggPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBOCA6IHRhYmxlLm9wdGlvbnMuZGVidWdIZWFkZXJzO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRmxhdCBIZWFkZXJzXG5cbiAgICB0YWJsZS5nZXRGbGF0SGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEhlYWRlckdyb3VwcygpXSwgaGVhZGVyR3JvdXBzID0+IHtcbiAgICAgIHJldHVybiBoZWFkZXJHcm91cHMubWFwKGhlYWRlckdyb3VwID0+IHtcbiAgICAgICAgcmV0dXJuIGhlYWRlckdyb3VwLmhlYWRlcnM7XG4gICAgICB9KS5mbGF0KCk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0RmxhdEhlYWRlcnMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTk7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBOSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E5IDogdGFibGUub3B0aW9ucy5kZWJ1Z0hlYWRlcnM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0TGVmdEZsYXRIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0TGVmdEhlYWRlckdyb3VwcygpXSwgbGVmdCA9PiB7XG4gICAgICByZXR1cm4gbGVmdC5tYXAoaGVhZGVyR3JvdXAgPT4ge1xuICAgICAgICByZXR1cm4gaGVhZGVyR3JvdXAuaGVhZGVycztcbiAgICAgIH0pLmZsYXQoKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRMZWZ0RmxhdEhlYWRlcnMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTEwO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTEwID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTEwIDogdGFibGUub3B0aW9ucy5kZWJ1Z0hlYWRlcnM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0Q2VudGVyRmxhdEhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRDZW50ZXJIZWFkZXJHcm91cHMoKV0sIGxlZnQgPT4ge1xuICAgICAgcmV0dXJuIGxlZnQubWFwKGhlYWRlckdyb3VwID0+IHtcbiAgICAgICAgcmV0dXJuIGhlYWRlckdyb3VwLmhlYWRlcnM7XG4gICAgICB9KS5mbGF0KCk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0Q2VudGVyRmxhdEhlYWRlcnMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTExO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTExID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTExIDogdGFibGUub3B0aW9ucy5kZWJ1Z0hlYWRlcnM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0UmlnaHRGbGF0SGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFJpZ2h0SGVhZGVyR3JvdXBzKCldLCBsZWZ0ID0+IHtcbiAgICAgIHJldHVybiBsZWZ0Lm1hcChoZWFkZXJHcm91cCA9PiB7XG4gICAgICAgIHJldHVybiBoZWFkZXJHcm91cC5oZWFkZXJzO1xuICAgICAgfSkuZmxhdCgpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldFJpZ2h0RmxhdEhlYWRlcnMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTEyO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTEyID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTEyIDogdGFibGUub3B0aW9ucy5kZWJ1Z0hlYWRlcnM7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMZWFmIEhlYWRlcnNcblxuICAgIHRhYmxlLmdldENlbnRlckxlYWZIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0Q2VudGVyRmxhdEhlYWRlcnMoKV0sIGZsYXRIZWFkZXJzID0+IHtcbiAgICAgIHJldHVybiBmbGF0SGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IHtcbiAgICAgICAgdmFyIF9oZWFkZXIkc3ViSGVhZGVycztcbiAgICAgICAgcmV0dXJuICEoKF9oZWFkZXIkc3ViSGVhZGVycyA9IGhlYWRlci5zdWJIZWFkZXJzKSAhPSBudWxsICYmIF9oZWFkZXIkc3ViSGVhZGVycy5sZW5ndGgpO1xuICAgICAgfSk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0Q2VudGVyTGVhZkhlYWRlcnMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTEzO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTEzID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTEzIDogdGFibGUub3B0aW9ucy5kZWJ1Z0hlYWRlcnM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0TGVmdExlYWZIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0TGVmdEZsYXRIZWFkZXJzKCldLCBmbGF0SGVhZGVycyA9PiB7XG4gICAgICByZXR1cm4gZmxhdEhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiB7XG4gICAgICAgIHZhciBfaGVhZGVyJHN1YkhlYWRlcnMyO1xuICAgICAgICByZXR1cm4gISgoX2hlYWRlciRzdWJIZWFkZXJzMiA9IGhlYWRlci5zdWJIZWFkZXJzKSAhPSBudWxsICYmIF9oZWFkZXIkc3ViSGVhZGVyczIubGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldExlZnRMZWFmSGVhZGVycycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMTQ7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBMTQgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMTQgOiB0YWJsZS5vcHRpb25zLmRlYnVnSGVhZGVycztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJsZS5nZXRSaWdodExlYWZIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0UmlnaHRGbGF0SGVhZGVycygpXSwgZmxhdEhlYWRlcnMgPT4ge1xuICAgICAgcmV0dXJuIGZsYXRIZWFkZXJzLmZpbHRlcihoZWFkZXIgPT4ge1xuICAgICAgICB2YXIgX2hlYWRlciRzdWJIZWFkZXJzMztcbiAgICAgICAgcmV0dXJuICEoKF9oZWFkZXIkc3ViSGVhZGVyczMgPSBoZWFkZXIuc3ViSGVhZGVycykgIT0gbnVsbCAmJiBfaGVhZGVyJHN1YkhlYWRlcnMzLmxlbmd0aCk7XG4gICAgICB9KTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRSaWdodExlYWZIZWFkZXJzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExNTtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExNSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExNSA6IHRhYmxlLm9wdGlvbnMuZGVidWdIZWFkZXJzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRhYmxlLmdldExlYWZIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0TGVmdEhlYWRlckdyb3VwcygpLCB0YWJsZS5nZXRDZW50ZXJIZWFkZXJHcm91cHMoKSwgdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMoKV0sIChsZWZ0LCBjZW50ZXIsIHJpZ2h0KSA9PiB7XG4gICAgICB2YXIgX2xlZnQkMCRoZWFkZXJzLCBfbGVmdCQsIF9jZW50ZXIkMCRoZWFkZXJzLCBfY2VudGVyJCwgX3JpZ2h0JDAkaGVhZGVycywgX3JpZ2h0JDtcbiAgICAgIHJldHVybiBbLi4uKChfbGVmdCQwJGhlYWRlcnMgPSAoX2xlZnQkID0gbGVmdFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9sZWZ0JC5oZWFkZXJzKSAhPSBudWxsID8gX2xlZnQkMCRoZWFkZXJzIDogW10pLCAuLi4oKF9jZW50ZXIkMCRoZWFkZXJzID0gKF9jZW50ZXIkID0gY2VudGVyWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2NlbnRlciQuaGVhZGVycykgIT0gbnVsbCA/IF9jZW50ZXIkMCRoZWFkZXJzIDogW10pLCAuLi4oKF9yaWdodCQwJGhlYWRlcnMgPSAoX3JpZ2h0JCA9IHJpZ2h0WzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3JpZ2h0JC5oZWFkZXJzKSAhPSBudWxsID8gX3JpZ2h0JDAkaGVhZGVycyA6IFtdKV0ubWFwKGhlYWRlciA9PiB7XG4gICAgICAgIHJldHVybiBoZWFkZXIuZ2V0TGVhZkhlYWRlcnMoKTtcbiAgICAgIH0pLmZsYXQoKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRMZWFmSGVhZGVycycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMTY7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBMTYgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMTYgOiB0YWJsZS5vcHRpb25zLmRlYnVnSGVhZGVycztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGJ1aWxkSGVhZGVyR3JvdXBzKGFsbENvbHVtbnMsIGNvbHVtbnNUb0dyb3VwLCB0YWJsZSwgaGVhZGVyRmFtaWx5KSB7XG4gIHZhciBfaGVhZGVyR3JvdXBzJDAkaGVhZGUsIF9oZWFkZXJHcm91cHMkO1xuICAvLyBGaW5kIHRoZSBtYXggZGVwdGggb2YgdGhlIGNvbHVtbnM6XG4gIC8vIGJ1aWxkIHRoZSBsZWFmIGNvbHVtbiByb3dcbiAgLy8gYnVpbGQgZWFjaCBidWZmZXIgcm93IGdvaW5nIHVwXG4gIC8vICAgIHBsYWNlaG9sZGVyIGZvciBub24tZXhpc3RlbnQgbGV2ZWxcbiAgLy8gICAgcmVhbCBjb2x1bW4gZm9yIGV4aXN0aW5nIGxldmVsXG5cbiAgbGV0IG1heERlcHRoID0gMDtcbiAgY29uc3QgZmluZE1heERlcHRoID0gZnVuY3Rpb24gKGNvbHVtbnMsIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICAgIGRlcHRoID0gMTtcbiAgICB9XG4gICAgbWF4RGVwdGggPSBNYXRoLm1heChtYXhEZXB0aCwgZGVwdGgpO1xuICAgIGNvbHVtbnMuZmlsdGVyKGNvbHVtbiA9PiBjb2x1bW4uZ2V0SXNWaXNpYmxlKCkpLmZvckVhY2goY29sdW1uID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbnM7XG4gICAgICBpZiAoKF9jb2x1bW4kY29sdW1ucyA9IGNvbHVtbi5jb2x1bW5zKSAhPSBudWxsICYmIF9jb2x1bW4kY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgZmluZE1heERlcHRoKGNvbHVtbi5jb2x1bW5zLCBkZXB0aCArIDEpO1xuICAgICAgfVxuICAgIH0sIDApO1xuICB9O1xuICBmaW5kTWF4RGVwdGgoYWxsQ29sdW1ucyk7XG4gIGxldCBoZWFkZXJHcm91cHMgPSBbXTtcbiAgY29uc3QgY3JlYXRlSGVhZGVyR3JvdXAgPSAoaGVhZGVyc1RvR3JvdXAsIGRlcHRoKSA9PiB7XG4gICAgLy8gVGhlIGhlYWRlciBncm91cCB3ZSBhcmUgY3JlYXRpbmdcbiAgICBjb25zdCBoZWFkZXJHcm91cCA9IHtcbiAgICAgIGRlcHRoLFxuICAgICAgaWQ6IFtoZWFkZXJGYW1pbHksIGAke2RlcHRofWBdLmZpbHRlcihCb29sZWFuKS5qb2luKCdfJyksXG4gICAgICBoZWFkZXJzOiBbXVxuICAgIH07XG5cbiAgICAvLyBUaGUgcGFyZW50IGNvbHVtbnMgd2UncmUgZ29pbmcgdG8gc2NhbiBuZXh0XG4gICAgY29uc3QgcGVuZGluZ1BhcmVudEhlYWRlcnMgPSBbXTtcblxuICAgIC8vIFNjYW4gZWFjaCBjb2x1bW4gZm9yIHBhcmVudHNcbiAgICBoZWFkZXJzVG9Hcm91cC5mb3JFYWNoKGhlYWRlclRvR3JvdXAgPT4ge1xuICAgICAgLy8gV2hhdCBpcyB0aGUgbGF0ZXN0IChsYXN0KSBwYXJlbnQgY29sdW1uP1xuXG4gICAgICBjb25zdCBsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyID0gWy4uLnBlbmRpbmdQYXJlbnRIZWFkZXJzXS5yZXZlcnNlKClbMF07XG4gICAgICBjb25zdCBpc0xlYWZIZWFkZXIgPSBoZWFkZXJUb0dyb3VwLmNvbHVtbi5kZXB0aCA9PT0gaGVhZGVyR3JvdXAuZGVwdGg7XG4gICAgICBsZXQgY29sdW1uO1xuICAgICAgbGV0IGlzUGxhY2Vob2xkZXIgPSBmYWxzZTtcbiAgICAgIGlmIChpc0xlYWZIZWFkZXIgJiYgaGVhZGVyVG9Hcm91cC5jb2x1bW4ucGFyZW50KSB7XG4gICAgICAgIC8vIFRoZSBwYXJlbnQgaGVhZGVyIGlzIG5ld1xuICAgICAgICBjb2x1bW4gPSBoZWFkZXJUb0dyb3VwLmNvbHVtbi5wYXJlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgcGFyZW50IGhlYWRlciBpcyByZXBlYXRlZFxuICAgICAgICBjb2x1bW4gPSBoZWFkZXJUb0dyb3VwLmNvbHVtbjtcbiAgICAgICAgaXNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAobGF0ZXN0UGVuZGluZ1BhcmVudEhlYWRlciAmJiAobGF0ZXN0UGVuZGluZ1BhcmVudEhlYWRlciA9PSBudWxsID8gdm9pZCAwIDogbGF0ZXN0UGVuZGluZ1BhcmVudEhlYWRlci5jb2x1bW4pID09PSBjb2x1bW4pIHtcbiAgICAgICAgLy8gVGhpcyBjb2x1bW4gaXMgcmVwZWF0ZWQuIEFkZCBpdCBhcyBhIHN1YiBoZWFkZXIgdG8gdGhlIG5leHQgYmF0Y2hcbiAgICAgICAgbGF0ZXN0UGVuZGluZ1BhcmVudEhlYWRlci5zdWJIZWFkZXJzLnB1c2goaGVhZGVyVG9Hcm91cCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbmV3IGhlYWRlci4gTGV0J3MgY3JlYXRlIGl0XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGNyZWF0ZUhlYWRlcih0YWJsZSwgY29sdW1uLCB7XG4gICAgICAgICAgaWQ6IFtoZWFkZXJGYW1pbHksIGRlcHRoLCBjb2x1bW4uaWQsIGhlYWRlclRvR3JvdXAgPT0gbnVsbCA/IHZvaWQgMCA6IGhlYWRlclRvR3JvdXAuaWRdLmZpbHRlcihCb29sZWFuKS5qb2luKCdfJyksXG4gICAgICAgICAgaXNQbGFjZWhvbGRlcixcbiAgICAgICAgICBwbGFjZWhvbGRlcklkOiBpc1BsYWNlaG9sZGVyID8gYCR7cGVuZGluZ1BhcmVudEhlYWRlcnMuZmlsdGVyKGQgPT4gZC5jb2x1bW4gPT09IGNvbHVtbikubGVuZ3RofWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgZGVwdGgsXG4gICAgICAgICAgaW5kZXg6IHBlbmRpbmdQYXJlbnRIZWFkZXJzLmxlbmd0aFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBZGQgdGhlIGhlYWRlclRvR3JvdXAgYXMgYSBzdWJIZWFkZXIgb2YgdGhlIG5ldyBoZWFkZXJcbiAgICAgICAgaGVhZGVyLnN1YkhlYWRlcnMucHVzaChoZWFkZXJUb0dyb3VwKTtcbiAgICAgICAgLy8gQWRkIHRoZSBuZXcgaGVhZGVyIHRvIHRoZSBwZW5kaW5nUGFyZW50SGVhZGVycyB0byBnZXQgZ3JvdXBlZFxuICAgICAgICAvLyBpbiB0aGUgbmV4dCBiYXRjaFxuICAgICAgICBwZW5kaW5nUGFyZW50SGVhZGVycy5wdXNoKGhlYWRlcik7XG4gICAgICB9XG4gICAgICBoZWFkZXJHcm91cC5oZWFkZXJzLnB1c2goaGVhZGVyVG9Hcm91cCk7XG4gICAgICBoZWFkZXJUb0dyb3VwLmhlYWRlckdyb3VwID0gaGVhZGVyR3JvdXA7XG4gICAgfSk7XG4gICAgaGVhZGVyR3JvdXBzLnB1c2goaGVhZGVyR3JvdXApO1xuICAgIGlmIChkZXB0aCA+IDApIHtcbiAgICAgIGNyZWF0ZUhlYWRlckdyb3VwKHBlbmRpbmdQYXJlbnRIZWFkZXJzLCBkZXB0aCAtIDEpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgYm90dG9tSGVhZGVycyA9IGNvbHVtbnNUb0dyb3VwLm1hcCgoY29sdW1uLCBpbmRleCkgPT4gY3JlYXRlSGVhZGVyKHRhYmxlLCBjb2x1bW4sIHtcbiAgICBkZXB0aDogbWF4RGVwdGgsXG4gICAgaW5kZXhcbiAgfSkpO1xuICBjcmVhdGVIZWFkZXJHcm91cChib3R0b21IZWFkZXJzLCBtYXhEZXB0aCAtIDEpO1xuICBoZWFkZXJHcm91cHMucmV2ZXJzZSgpO1xuXG4gIC8vIGhlYWRlckdyb3VwcyA9IGhlYWRlckdyb3Vwcy5maWx0ZXIoaGVhZGVyR3JvdXAgPT4ge1xuICAvLyAgIHJldHVybiAhaGVhZGVyR3JvdXAuaGVhZGVycy5ldmVyeShoZWFkZXIgPT4gaGVhZGVyLmlzUGxhY2Vob2xkZXIpXG4gIC8vIH0pXG5cbiAgY29uc3QgcmVjdXJzZUhlYWRlcnNGb3JTcGFucyA9IGhlYWRlcnMgPT4ge1xuICAgIGNvbnN0IGZpbHRlcmVkSGVhZGVycyA9IGhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiBoZWFkZXIuY29sdW1uLmdldElzVmlzaWJsZSgpKTtcbiAgICByZXR1cm4gZmlsdGVyZWRIZWFkZXJzLm1hcChoZWFkZXIgPT4ge1xuICAgICAgbGV0IGNvbFNwYW4gPSAwO1xuICAgICAgbGV0IHJvd1NwYW4gPSAwO1xuICAgICAgbGV0IGNoaWxkUm93U3BhbnMgPSBbMF07XG4gICAgICBpZiAoaGVhZGVyLnN1YkhlYWRlcnMgJiYgaGVhZGVyLnN1YkhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICAgIGNoaWxkUm93U3BhbnMgPSBbXTtcbiAgICAgICAgcmVjdXJzZUhlYWRlcnNGb3JTcGFucyhoZWFkZXIuc3ViSGVhZGVycykuZm9yRWFjaChfcmVmID0+IHtcbiAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgY29sU3BhbjogY2hpbGRDb2xTcGFuLFxuICAgICAgICAgICAgcm93U3BhbjogY2hpbGRSb3dTcGFuXG4gICAgICAgICAgfSA9IF9yZWY7XG4gICAgICAgICAgY29sU3BhbiArPSBjaGlsZENvbFNwYW47XG4gICAgICAgICAgY2hpbGRSb3dTcGFucy5wdXNoKGNoaWxkUm93U3Bhbik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sU3BhbiA9IDE7XG4gICAgICB9XG4gICAgICBjb25zdCBtaW5DaGlsZFJvd1NwYW4gPSBNYXRoLm1pbiguLi5jaGlsZFJvd1NwYW5zKTtcbiAgICAgIHJvd1NwYW4gPSByb3dTcGFuICsgbWluQ2hpbGRSb3dTcGFuO1xuICAgICAgaGVhZGVyLmNvbFNwYW4gPSBjb2xTcGFuO1xuICAgICAgaGVhZGVyLnJvd1NwYW4gPSByb3dTcGFuO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29sU3BhbixcbiAgICAgICAgcm93U3BhblxuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcbiAgcmVjdXJzZUhlYWRlcnNGb3JTcGFucygoX2hlYWRlckdyb3VwcyQwJGhlYWRlID0gKF9oZWFkZXJHcm91cHMkID0gaGVhZGVyR3JvdXBzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2hlYWRlckdyb3VwcyQuaGVhZGVycykgIT0gbnVsbCA/IF9oZWFkZXJHcm91cHMkMCRoZWFkZSA6IFtdKTtcbiAgcmV0dXJuIGhlYWRlckdyb3Vwcztcbn1cblxuLy9cblxuLy9cblxuY29uc3QgZGVmYXVsdENvbHVtblNpemluZyA9IHtcbiAgc2l6ZTogMTUwLFxuICBtaW5TaXplOiAyMCxcbiAgbWF4U2l6ZTogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbn07XG5jb25zdCBnZXREZWZhdWx0Q29sdW1uU2l6aW5nSW5mb1N0YXRlID0gKCkgPT4gKHtcbiAgc3RhcnRPZmZzZXQ6IG51bGwsXG4gIHN0YXJ0U2l6ZTogbnVsbCxcbiAgZGVsdGFPZmZzZXQ6IG51bGwsXG4gIGRlbHRhUGVyY2VudGFnZTogbnVsbCxcbiAgaXNSZXNpemluZ0NvbHVtbjogZmFsc2UsXG4gIGNvbHVtblNpemluZ1N0YXJ0OiBbXVxufSk7XG5jb25zdCBDb2x1bW5TaXppbmcgPSB7XG4gIGdldERlZmF1bHRDb2x1bW5EZWY6ICgpID0+IHtcbiAgICByZXR1cm4gZGVmYXVsdENvbHVtblNpemluZztcbiAgfSxcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtblNpemluZzoge30sXG4gICAgICBjb2x1bW5TaXppbmdJbmZvOiBnZXREZWZhdWx0Q29sdW1uU2l6aW5nSW5mb1N0YXRlKCksXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtblJlc2l6ZU1vZGU6ICdvbkVuZCcsXG4gICAgICBjb2x1bW5SZXNpemVEaXJlY3Rpb246ICdsdHInLFxuICAgICAgb25Db2x1bW5TaXppbmdDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2NvbHVtblNpemluZycsIHRhYmxlKSxcbiAgICAgIG9uQ29sdW1uU2l6aW5nSW5mb0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uU2l6aW5nSW5mbycsIHRhYmxlKVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUNvbHVtbjogKGNvbHVtbiwgdGFibGUpID0+IHtcbiAgICBjb2x1bW4uZ2V0U2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbkRlZiRtaW4sIF9yZWYsIF9jb2x1bW4kY29sdW1uRGVmJG1heDtcbiAgICAgIGNvbnN0IGNvbHVtblNpemUgPSB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblNpemluZ1tjb2x1bW4uaWRdO1xuICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KChfY29sdW1uJGNvbHVtbkRlZiRtaW4gPSBjb2x1bW4uY29sdW1uRGVmLm1pblNpemUpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRtaW4gOiBkZWZhdWx0Q29sdW1uU2l6aW5nLm1pblNpemUsIChfcmVmID0gY29sdW1uU2l6ZSAhPSBudWxsID8gY29sdW1uU2l6ZSA6IGNvbHVtbi5jb2x1bW5EZWYuc2l6ZSkgIT0gbnVsbCA/IF9yZWYgOiBkZWZhdWx0Q29sdW1uU2l6aW5nLnNpemUpLCAoX2NvbHVtbiRjb2x1bW5EZWYkbWF4ID0gY29sdW1uLmNvbHVtbkRlZi5tYXhTaXplKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkbWF4IDogZGVmYXVsdENvbHVtblNpemluZy5tYXhTaXplKTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRTdGFydCA9IHBvc2l0aW9uID0+IHtcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSAhcG9zaXRpb24gPyB0YWJsZS5nZXRWaXNpYmxlTGVhZkNvbHVtbnMoKSA6IHBvc2l0aW9uID09PSAnbGVmdCcgPyB0YWJsZS5nZXRMZWZ0VmlzaWJsZUxlYWZDb2x1bW5zKCkgOiB0YWJsZS5nZXRSaWdodFZpc2libGVMZWFmQ29sdW1ucygpO1xuICAgICAgY29uc3QgaW5kZXggPSBjb2x1bW5zLmZpbmRJbmRleChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCk7XG4gICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgIGNvbnN0IHByZXZTaWJsaW5nQ29sdW1uID0gY29sdW1uc1tpbmRleCAtIDFdO1xuICAgICAgICByZXR1cm4gcHJldlNpYmxpbmdDb2x1bW4uZ2V0U3RhcnQocG9zaXRpb24pICsgcHJldlNpYmxpbmdDb2x1bW4uZ2V0U2l6ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBjb2x1bW4ucmVzZXRTaXplID0gKCkgPT4ge1xuICAgICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nKF9yZWYyID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBbY29sdW1uLmlkXTogXyxcbiAgICAgICAgICAuLi5yZXN0XG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIHJlc3Q7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5SZXNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5EZWYkZW5hLCBfdGFibGUkb3B0aW9ucyRlbmFibGU7XG4gICAgICByZXR1cm4gKChfY29sdW1uJGNvbHVtbkRlZiRlbmEgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZVJlc2l6aW5nKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUNvbHVtblJlc2l6aW5nKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNSZXNpemluZyA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblNpemluZ0luZm8uaXNSZXNpemluZ0NvbHVtbiA9PT0gY29sdW1uLmlkO1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUhlYWRlcjogKGhlYWRlciwgdGFibGUpID0+IHtcbiAgICBoZWFkZXIuZ2V0U2l6ZSA9ICgpID0+IHtcbiAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgY29uc3QgcmVjdXJzZSA9IGhlYWRlciA9PiB7XG4gICAgICAgIGlmIChoZWFkZXIuc3ViSGVhZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICBoZWFkZXIuc3ViSGVhZGVycy5mb3JFYWNoKHJlY3Vyc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfaGVhZGVyJGNvbHVtbiRnZXRTaXo7XG4gICAgICAgICAgc3VtICs9IChfaGVhZGVyJGNvbHVtbiRnZXRTaXogPSBoZWFkZXIuY29sdW1uLmdldFNpemUoKSkgIT0gbnVsbCA/IF9oZWFkZXIkY29sdW1uJGdldFNpeiA6IDA7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZWN1cnNlKGhlYWRlcik7XG4gICAgICByZXR1cm4gc3VtO1xuICAgIH07XG4gICAgaGVhZGVyLmdldFN0YXJ0ID0gKCkgPT4ge1xuICAgICAgaWYgKGhlYWRlci5pbmRleCA+IDApIHtcbiAgICAgICAgY29uc3QgcHJldlNpYmxpbmdIZWFkZXIgPSBoZWFkZXIuaGVhZGVyR3JvdXAuaGVhZGVyc1toZWFkZXIuaW5kZXggLSAxXTtcbiAgICAgICAgcmV0dXJuIHByZXZTaWJsaW5nSGVhZGVyLmdldFN0YXJ0KCkgKyBwcmV2U2libGluZ0hlYWRlci5nZXRTaXplKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIGhlYWRlci5nZXRSZXNpemVIYW5kbGVyID0gX2NvbnRleHREb2N1bWVudCA9PiB7XG4gICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oaGVhZGVyLmNvbHVtbi5pZCk7XG4gICAgICBjb25zdCBjYW5SZXNpemUgPSBjb2x1bW4gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbHVtbi5nZXRDYW5SZXNpemUoKTtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgaWYgKCFjb2x1bW4gfHwgIWNhblJlc2l6ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlLnBlcnNpc3QgPT0gbnVsbCB8fCBlLnBlcnNpc3QoKTtcbiAgICAgICAgaWYgKGlzVG91Y2hTdGFydEV2ZW50KGUpKSB7XG4gICAgICAgICAgLy8gbGV0cyBub3QgcmVzcG9uZCB0byBtdWx0aXBsZSB0b3VjaGVzIChlLmcuIDIgb3IgMyBmaW5nZXJzKVxuICAgICAgICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRTaXplID0gaGVhZGVyLmdldFNpemUoKTtcbiAgICAgICAgY29uc3QgY29sdW1uU2l6aW5nU3RhcnQgPSBoZWFkZXIgPyBoZWFkZXIuZ2V0TGVhZkhlYWRlcnMoKS5tYXAoZCA9PiBbZC5jb2x1bW4uaWQsIGQuY29sdW1uLmdldFNpemUoKV0pIDogW1tjb2x1bW4uaWQsIGNvbHVtbi5nZXRTaXplKCldXTtcbiAgICAgICAgY29uc3QgY2xpZW50WCA9IGlzVG91Y2hTdGFydEV2ZW50KGUpID8gTWF0aC5yb3VuZChlLnRvdWNoZXNbMF0uY2xpZW50WCkgOiBlLmNsaWVudFg7XG4gICAgICAgIGNvbnN0IG5ld0NvbHVtblNpemluZyA9IHt9O1xuICAgICAgICBjb25zdCB1cGRhdGVPZmZzZXQgPSAoZXZlbnRUeXBlLCBjbGllbnRYUG9zKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjbGllbnRYUG9zICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmdJbmZvKG9sZCA9PiB7XG4gICAgICAgICAgICB2YXIgX29sZCRzdGFydE9mZnNldCwgX29sZCRzdGFydFNpemU7XG4gICAgICAgICAgICBjb25zdCBkZWx0YURpcmVjdGlvbiA9IHRhYmxlLm9wdGlvbnMuY29sdW1uUmVzaXplRGlyZWN0aW9uID09PSAncnRsJyA/IC0xIDogMTtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhT2Zmc2V0ID0gKGNsaWVudFhQb3MgLSAoKF9vbGQkc3RhcnRPZmZzZXQgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5zdGFydE9mZnNldCkgIT0gbnVsbCA/IF9vbGQkc3RhcnRPZmZzZXQgOiAwKSkgKiBkZWx0YURpcmVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhUGVyY2VudGFnZSA9IE1hdGgubWF4KGRlbHRhT2Zmc2V0IC8gKChfb2xkJHN0YXJ0U2l6ZSA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLnN0YXJ0U2l6ZSkgIT0gbnVsbCA/IF9vbGQkc3RhcnRTaXplIDogMCksIC0wLjk5OTk5OSk7XG4gICAgICAgICAgICBvbGQuY29sdW1uU2l6aW5nU3RhcnQuZm9yRWFjaChfcmVmMyA9PiB7XG4gICAgICAgICAgICAgIGxldCBbY29sdW1uSWQsIGhlYWRlclNpemVdID0gX3JlZjM7XG4gICAgICAgICAgICAgIG5ld0NvbHVtblNpemluZ1tjb2x1bW5JZF0gPSBNYXRoLnJvdW5kKE1hdGgubWF4KGhlYWRlclNpemUgKyBoZWFkZXJTaXplICogZGVsdGFQZXJjZW50YWdlLCAwKSAqIDEwMCkgLyAxMDA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLm9sZCxcbiAgICAgICAgICAgICAgZGVsdGFPZmZzZXQsXG4gICAgICAgICAgICAgIGRlbHRhUGVyY2VudGFnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodGFibGUub3B0aW9ucy5jb2x1bW5SZXNpemVNb2RlID09PSAnb25DaGFuZ2UnIHx8IGV2ZW50VHlwZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgIHRhYmxlLnNldENvbHVtblNpemluZyhvbGQgPT4gKHtcbiAgICAgICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgICAgICAuLi5uZXdDb2x1bW5TaXppbmdcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uTW92ZSA9IGNsaWVudFhQb3MgPT4gdXBkYXRlT2Zmc2V0KCdtb3ZlJywgY2xpZW50WFBvcyk7XG4gICAgICAgIGNvbnN0IG9uRW5kID0gY2xpZW50WFBvcyA9PiB7XG4gICAgICAgICAgdXBkYXRlT2Zmc2V0KCdlbmQnLCBjbGllbnRYUG9zKTtcbiAgICAgICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmdJbmZvKG9sZCA9PiAoe1xuICAgICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgICAgaXNSZXNpemluZ0NvbHVtbjogZmFsc2UsXG4gICAgICAgICAgICBzdGFydE9mZnNldDogbnVsbCxcbiAgICAgICAgICAgIHN0YXJ0U2l6ZTogbnVsbCxcbiAgICAgICAgICAgIGRlbHRhT2Zmc2V0OiBudWxsLFxuICAgICAgICAgICAgZGVsdGFQZXJjZW50YWdlOiBudWxsLFxuICAgICAgICAgICAgY29sdW1uU2l6aW5nU3RhcnQ6IFtdXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb250ZXh0RG9jdW1lbnQgPSBfY29udGV4dERvY3VtZW50IHx8IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IG51bGw7XG4gICAgICAgIGNvbnN0IG1vdXNlRXZlbnRzID0ge1xuICAgICAgICAgIG1vdmVIYW5kbGVyOiBlID0+IG9uTW92ZShlLmNsaWVudFgpLFxuICAgICAgICAgIHVwSGFuZGxlcjogZSA9PiB7XG4gICAgICAgICAgICBjb250ZXh0RG9jdW1lbnQgPT0gbnVsbCB8fCBjb250ZXh0RG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2VFdmVudHMubW92ZUhhbmRsZXIpO1xuICAgICAgICAgICAgY29udGV4dERvY3VtZW50ID09IG51bGwgfHwgY29udGV4dERvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBtb3VzZUV2ZW50cy51cEhhbmRsZXIpO1xuICAgICAgICAgICAgb25FbmQoZS5jbGllbnRYKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRvdWNoRXZlbnRzID0ge1xuICAgICAgICAgIG1vdmVIYW5kbGVyOiBlID0+IHtcbiAgICAgICAgICAgIGlmIChlLmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25Nb3ZlKGUudG91Y2hlc1swXS5jbGllbnRYKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVwSGFuZGxlcjogZSA9PiB7XG4gICAgICAgICAgICB2YXIgX2UkdG91Y2hlcyQ7XG4gICAgICAgICAgICBjb250ZXh0RG9jdW1lbnQgPT0gbnVsbCB8fCBjb250ZXh0RG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdG91Y2hFdmVudHMubW92ZUhhbmRsZXIpO1xuICAgICAgICAgICAgY29udGV4dERvY3VtZW50ID09IG51bGwgfHwgY29udGV4dERvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hFdmVudHMudXBIYW5kbGVyKTtcbiAgICAgICAgICAgIGlmIChlLmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25FbmQoKF9lJHRvdWNoZXMkID0gZS50b3VjaGVzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2UkdG91Y2hlcyQuY2xpZW50WCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwYXNzaXZlSWZTdXBwb3J0ZWQgPSBwYXNzaXZlRXZlbnRTdXBwb3J0ZWQoKSA/IHtcbiAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICB9IDogZmFsc2U7XG4gICAgICAgIGlmIChpc1RvdWNoU3RhcnRFdmVudChlKSkge1xuICAgICAgICAgIGNvbnRleHREb2N1bWVudCA9PSBudWxsIHx8IGNvbnRleHREb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0b3VjaEV2ZW50cy5tb3ZlSGFuZGxlciwgcGFzc2l2ZUlmU3VwcG9ydGVkKTtcbiAgICAgICAgICBjb250ZXh0RG9jdW1lbnQgPT0gbnVsbCB8fCBjb250ZXh0RG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0b3VjaEV2ZW50cy51cEhhbmRsZXIsIHBhc3NpdmVJZlN1cHBvcnRlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dERvY3VtZW50ID09IG51bGwgfHwgY29udGV4dERvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdXNlRXZlbnRzLm1vdmVIYW5kbGVyLCBwYXNzaXZlSWZTdXBwb3J0ZWQpO1xuICAgICAgICAgIGNvbnRleHREb2N1bWVudCA9PSBudWxsIHx8IGNvbnRleHREb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2VFdmVudHMudXBIYW5kbGVyLCBwYXNzaXZlSWZTdXBwb3J0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlLnNldENvbHVtblNpemluZ0luZm8ob2xkID0+ICh7XG4gICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBjbGllbnRYLFxuICAgICAgICAgIHN0YXJ0U2l6ZSxcbiAgICAgICAgICBkZWx0YU9mZnNldDogMCxcbiAgICAgICAgICBkZWx0YVBlcmNlbnRhZ2U6IDAsXG4gICAgICAgICAgY29sdW1uU2l6aW5nU3RhcnQsXG4gICAgICAgICAgaXNSZXNpemluZ0NvbHVtbjogY29sdW1uLmlkXG4gICAgICAgIH0pKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmcgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Db2x1bW5TaXppbmdDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Db2x1bW5TaXppbmdDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nSW5mbyA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkNvbHVtblNpemluZ0luZm9DaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Db2x1bW5TaXppbmdJbmZvQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnJlc2V0Q29sdW1uU2l6aW5nID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGM7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmcoZGVmYXVsdFN0YXRlID8ge30gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRjID0gdGFibGUuaW5pdGlhbFN0YXRlLmNvbHVtblNpemluZykgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkYyA6IHt9KTtcbiAgICB9O1xuICAgIHRhYmxlLnJlc2V0SGVhZGVyU2l6ZUluZm8gPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkYzI7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmdJbmZvKGRlZmF1bHRTdGF0ZSA/IGdldERlZmF1bHRDb2x1bW5TaXppbmdJbmZvU3RhdGUoKSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGMyID0gdGFibGUuaW5pdGlhbFN0YXRlLmNvbHVtblNpemluZ0luZm8pICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGMyIDogZ2V0RGVmYXVsdENvbHVtblNpemluZ0luZm9TdGF0ZSgpKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFRvdGFsU2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0SGVhZGVyR3JvdXAsIF90YWJsZSRnZXRIZWFkZXJHcm91cDI7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRIZWFkZXJHcm91cCA9IChfdGFibGUkZ2V0SGVhZGVyR3JvdXAyID0gdGFibGUuZ2V0SGVhZGVyR3JvdXBzKClbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0SGVhZGVyR3JvdXAyLmhlYWRlcnMucmVkdWNlKChzdW0sIGhlYWRlcikgPT4ge1xuICAgICAgICByZXR1cm4gc3VtICsgaGVhZGVyLmdldFNpemUoKTtcbiAgICAgIH0sIDApKSAhPSBudWxsID8gX3RhYmxlJGdldEhlYWRlckdyb3VwIDogMDtcbiAgICB9O1xuICAgIHRhYmxlLmdldExlZnRUb3RhbFNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldExlZnRIZWFkZXJHLCBfdGFibGUkZ2V0TGVmdEhlYWRlckcyO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0TGVmdEhlYWRlckcgPSAoX3RhYmxlJGdldExlZnRIZWFkZXJHMiA9IHRhYmxlLmdldExlZnRIZWFkZXJHcm91cHMoKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRMZWZ0SGVhZGVyRzIuaGVhZGVycy5yZWR1Y2UoKHN1bSwgaGVhZGVyKSA9PiB7XG4gICAgICAgIHJldHVybiBzdW0gKyBoZWFkZXIuZ2V0U2l6ZSgpO1xuICAgICAgfSwgMCkpICE9IG51bGwgPyBfdGFibGUkZ2V0TGVmdEhlYWRlckcgOiAwO1xuICAgIH07XG4gICAgdGFibGUuZ2V0Q2VudGVyVG90YWxTaXplID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRDZW50ZXJIZWFkZSwgX3RhYmxlJGdldENlbnRlckhlYWRlMjtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldENlbnRlckhlYWRlID0gKF90YWJsZSRnZXRDZW50ZXJIZWFkZTIgPSB0YWJsZS5nZXRDZW50ZXJIZWFkZXJHcm91cHMoKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRDZW50ZXJIZWFkZTIuaGVhZGVycy5yZWR1Y2UoKHN1bSwgaGVhZGVyKSA9PiB7XG4gICAgICAgIHJldHVybiBzdW0gKyBoZWFkZXIuZ2V0U2l6ZSgpO1xuICAgICAgfSwgMCkpICE9IG51bGwgPyBfdGFibGUkZ2V0Q2VudGVySGVhZGUgOiAwO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UmlnaHRUb3RhbFNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFJpZ2h0SGVhZGVyLCBfdGFibGUkZ2V0UmlnaHRIZWFkZXIyO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0UmlnaHRIZWFkZXIgPSAoX3RhYmxlJGdldFJpZ2h0SGVhZGVyMiA9IHRhYmxlLmdldFJpZ2h0SGVhZGVyR3JvdXBzKClbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0UmlnaHRIZWFkZXIyLmhlYWRlcnMucmVkdWNlKChzdW0sIGhlYWRlcikgPT4ge1xuICAgICAgICByZXR1cm4gc3VtICsgaGVhZGVyLmdldFNpemUoKTtcbiAgICAgIH0sIDApKSAhPSBudWxsID8gX3RhYmxlJGdldFJpZ2h0SGVhZGVyIDogMDtcbiAgICB9O1xuICB9XG59O1xubGV0IHBhc3NpdmVTdXBwb3J0ZWQgPSBudWxsO1xuZnVuY3Rpb24gcGFzc2l2ZUV2ZW50U3VwcG9ydGVkKCkge1xuICBpZiAodHlwZW9mIHBhc3NpdmVTdXBwb3J0ZWQgPT09ICdib29sZWFuJykgcmV0dXJuIHBhc3NpdmVTdXBwb3J0ZWQ7XG4gIGxldCBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgZ2V0IHBhc3NpdmUoKSB7XG4gICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG5vb3AsIG9wdGlvbnMpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0Jywgbm9vcCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xuICB9XG4gIHBhc3NpdmVTdXBwb3J0ZWQgPSBzdXBwb3J0ZWQ7XG4gIHJldHVybiBwYXNzaXZlU3VwcG9ydGVkO1xufVxuZnVuY3Rpb24gaXNUb3VjaFN0YXJ0RXZlbnQoZSkge1xuICByZXR1cm4gZS50eXBlID09PSAndG91Y2hzdGFydCc7XG59XG5cbi8vXG5cbmNvbnN0IEV4cGFuZGluZyA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cGFuZGVkOiB7fSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25FeHBhbmRlZENoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignZXhwYW5kZWQnLCB0YWJsZSksXG4gICAgICBwYWdpbmF0ZUV4cGFuZGVkUm93czogdHJ1ZVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgbGV0IHJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICBsZXQgcXVldWVkID0gZmFsc2U7XG4gICAgdGFibGUuX2F1dG9SZXNldEV4cGFuZGVkID0gKCkgPT4ge1xuICAgICAgdmFyIF9yZWYsIF90YWJsZSRvcHRpb25zJGF1dG9SZTtcbiAgICAgIGlmICghcmVnaXN0ZXJlZCkge1xuICAgICAgICB0YWJsZS5fcXVldWUoKCkgPT4ge1xuICAgICAgICAgIHJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKChfcmVmID0gKF90YWJsZSRvcHRpb25zJGF1dG9SZSA9IHRhYmxlLm9wdGlvbnMuYXV0b1Jlc2V0QWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkYXV0b1JlIDogdGFibGUub3B0aW9ucy5hdXRvUmVzZXRFeHBhbmRlZCkgIT0gbnVsbCA/IF9yZWYgOiAhdGFibGUub3B0aW9ucy5tYW51YWxFeHBhbmRpbmcpIHtcbiAgICAgICAgaWYgKHF1ZXVlZCkgcmV0dXJuO1xuICAgICAgICBxdWV1ZWQgPSB0cnVlO1xuICAgICAgICB0YWJsZS5fcXVldWUoKCkgPT4ge1xuICAgICAgICAgIHRhYmxlLnJlc2V0RXhwYW5kZWQoKTtcbiAgICAgICAgICBxdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0YWJsZS5zZXRFeHBhbmRlZCA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkV4cGFuZGVkQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uRXhwYW5kZWRDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUudG9nZ2xlQWxsUm93c0V4cGFuZGVkID0gZXhwYW5kZWQgPT4ge1xuICAgICAgaWYgKGV4cGFuZGVkICE9IG51bGwgPyBleHBhbmRlZCA6ICF0YWJsZS5nZXRJc0FsbFJvd3NFeHBhbmRlZCgpKSB7XG4gICAgICAgIHRhYmxlLnNldEV4cGFuZGVkKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFibGUuc2V0RXhwYW5kZWQoe30pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGFibGUucmVzZXRFeHBhbmRlZCA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRlLCBfdGFibGUkaW5pdGlhbFN0YXRlO1xuICAgICAgdGFibGUuc2V0RXhwYW5kZWQoZGVmYXVsdFN0YXRlID8ge30gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRlID0gKF90YWJsZSRpbml0aWFsU3RhdGUgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlLmV4cGFuZGVkKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRlIDoge30pO1xuICAgIH07XG4gICAgdGFibGUuZ2V0Q2FuU29tZVJvd3NFeHBhbmQgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsKCkuZmxhdFJvd3Muc29tZShyb3cgPT4gcm93LmdldENhbkV4cGFuZCgpKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFRvZ2dsZUFsbFJvd3NFeHBhbmRlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIGUucGVyc2lzdCA9PSBudWxsIHx8IGUucGVyc2lzdCgpO1xuICAgICAgICB0YWJsZS50b2dnbGVBbGxSb3dzRXhwYW5kZWQoKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc1NvbWVSb3dzRXhwYW5kZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBleHBhbmRlZCA9IHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQ7XG4gICAgICByZXR1cm4gZXhwYW5kZWQgPT09IHRydWUgfHwgT2JqZWN0LnZhbHVlcyhleHBhbmRlZCkuc29tZShCb29sZWFuKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzQWxsUm93c0V4cGFuZGVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgZXhwYW5kZWQgPSB0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkO1xuXG4gICAgICAvLyBJZiBleHBhbmRlZCBpcyB0cnVlLCBzYXZlIHNvbWUgY3ljbGVzIGFuZCByZXR1cm4gdHJ1ZVxuICAgICAgaWYgKHR5cGVvZiBleHBhbmRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBleHBhbmRlZCA9PT0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghT2JqZWN0LmtleXMoZXhwYW5kZWQpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGFueSByb3cgaXMgbm90IGV4cGFuZGVkLCByZXR1cm4gZmFsc2VcbiAgICAgIGlmICh0YWJsZS5nZXRSb3dNb2RlbCgpLmZsYXRSb3dzLnNvbWUocm93ID0+ICFyb3cuZ2V0SXNFeHBhbmRlZCgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZXkgbXVzdCBhbGwgYmUgZXhwYW5kZWQgOnNocnVnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRFeHBhbmRlZERlcHRoID0gKCkgPT4ge1xuICAgICAgbGV0IG1heERlcHRoID0gMDtcbiAgICAgIGNvbnN0IHJvd0lkcyA9IHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQgPT09IHRydWUgPyBPYmplY3Qua2V5cyh0YWJsZS5nZXRSb3dNb2RlbCgpLnJvd3NCeUlkKSA6IE9iamVjdC5rZXlzKHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQpO1xuICAgICAgcm93SWRzLmZvckVhY2goaWQgPT4ge1xuICAgICAgICBjb25zdCBzcGxpdElkID0gaWQuc3BsaXQoJy4nKTtcbiAgICAgICAgbWF4RGVwdGggPSBNYXRoLm1heChtYXhEZXB0aCwgc3BsaXRJZC5sZW5ndGgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWF4RGVwdGg7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRQcmVFeHBhbmRlZFJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0U29ydGVkUm93TW9kZWwoKTtcbiAgICB0YWJsZS5nZXRFeHBhbmRlZFJvd01vZGVsID0gKCkgPT4ge1xuICAgICAgaWYgKCF0YWJsZS5fZ2V0RXhwYW5kZWRSb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldEV4cGFuZGVkUm93TW9kZWwpIHtcbiAgICAgICAgdGFibGUuX2dldEV4cGFuZGVkUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldEV4cGFuZGVkUm93TW9kZWwodGFibGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRhYmxlLm9wdGlvbnMubWFudWFsRXhwYW5kaW5nIHx8ICF0YWJsZS5fZ2V0RXhwYW5kZWRSb3dNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlRXhwYW5kZWRSb3dNb2RlbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRFeHBhbmRlZFJvd01vZGVsKCk7XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlUm93OiAocm93LCB0YWJsZSkgPT4ge1xuICAgIHJvdy50b2dnbGVFeHBhbmRlZCA9IGV4cGFuZGVkID0+IHtcbiAgICAgIHRhYmxlLnNldEV4cGFuZGVkKG9sZCA9PiB7XG4gICAgICAgIHZhciBfZXhwYW5kZWQ7XG4gICAgICAgIGNvbnN0IGV4aXN0cyA9IG9sZCA9PT0gdHJ1ZSA/IHRydWUgOiAhIShvbGQgIT0gbnVsbCAmJiBvbGRbcm93LmlkXSk7XG4gICAgICAgIGxldCBvbGRFeHBhbmRlZCA9IHt9O1xuICAgICAgICBpZiAob2xkID09PSB0cnVlKSB7XG4gICAgICAgICAgT2JqZWN0LmtleXModGFibGUuZ2V0Um93TW9kZWwoKS5yb3dzQnlJZCkuZm9yRWFjaChyb3dJZCA9PiB7XG4gICAgICAgICAgICBvbGRFeHBhbmRlZFtyb3dJZF0gPSB0cnVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9sZEV4cGFuZGVkID0gb2xkO1xuICAgICAgICB9XG4gICAgICAgIGV4cGFuZGVkID0gKF9leHBhbmRlZCA9IGV4cGFuZGVkKSAhPSBudWxsID8gX2V4cGFuZGVkIDogIWV4aXN0cztcbiAgICAgICAgaWYgKCFleGlzdHMgJiYgZXhwYW5kZWQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ub2xkRXhwYW5kZWQsXG4gICAgICAgICAgICBbcm93LmlkXTogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4aXN0cyAmJiAhZXhwYW5kZWQpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBbcm93LmlkXTogXyxcbiAgICAgICAgICAgIC4uLnJlc3RcbiAgICAgICAgICB9ID0gb2xkRXhwYW5kZWQ7XG4gICAgICAgICAgcmV0dXJuIHJlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9sZDtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcm93LmdldElzRXhwYW5kZWQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZ2V0SXNSO1xuICAgICAgY29uc3QgZXhwYW5kZWQgPSB0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkO1xuICAgICAgcmV0dXJuICEhKChfdGFibGUkb3B0aW9ucyRnZXRJc1IgPSB0YWJsZS5vcHRpb25zLmdldElzUm93RXhwYW5kZWQgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMuZ2V0SXNSb3dFeHBhbmRlZChyb3cpKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZ2V0SXNSIDogZXhwYW5kZWQgPT09IHRydWUgfHwgKGV4cGFuZGVkID09IG51bGwgPyB2b2lkIDAgOiBleHBhbmRlZFtyb3cuaWRdKSk7XG4gICAgfTtcbiAgICByb3cuZ2V0Q2FuRXhwYW5kID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGdldFJvdywgX3RhYmxlJG9wdGlvbnMkZW5hYmxlLCBfcm93JHN1YlJvd3M7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGdldFJvdyA9IHRhYmxlLm9wdGlvbnMuZ2V0Um93Q2FuRXhwYW5kID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLmdldFJvd0NhbkV4cGFuZChyb3cpKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZ2V0Um93IDogKChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUV4cGFuZGluZykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWUpICYmICEhKChfcm93JHN1YlJvd3MgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MubGVuZ3RoKTtcbiAgICB9O1xuICAgIHJvdy5nZXRJc0FsbFBhcmVudHNFeHBhbmRlZCA9ICgpID0+IHtcbiAgICAgIGxldCBpc0Z1bGx5RXhwYW5kZWQgPSB0cnVlO1xuICAgICAgbGV0IGN1cnJlbnRSb3cgPSByb3c7XG4gICAgICB3aGlsZSAoaXNGdWxseUV4cGFuZGVkICYmIGN1cnJlbnRSb3cucGFyZW50SWQpIHtcbiAgICAgICAgY3VycmVudFJvdyA9IHRhYmxlLmdldFJvdyhjdXJyZW50Um93LnBhcmVudElkLCB0cnVlKTtcbiAgICAgICAgaXNGdWxseUV4cGFuZGVkID0gY3VycmVudFJvdy5nZXRJc0V4cGFuZGVkKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNGdWxseUV4cGFuZGVkO1xuICAgIH07XG4gICAgcm93LmdldFRvZ2dsZUV4cGFuZGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbkV4cGFuZCA9IHJvdy5nZXRDYW5FeHBhbmQoKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmICghY2FuRXhwYW5kKSByZXR1cm47XG4gICAgICAgIHJvdy50b2dnbGVFeHBhbmRlZCgpO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG59O1xuXG5jb25zdCBpbmNsdWRlc1N0cmluZyA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICB2YXIgX3JvdyRnZXRWYWx1ZTtcbiAgY29uc3Qgc2VhcmNoID0gZmlsdGVyVmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIEJvb2xlYW4oKF9yb3ckZ2V0VmFsdWUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKSA9PSBudWxsIHx8IChfcm93JGdldFZhbHVlID0gX3JvdyRnZXRWYWx1ZS50b1N0cmluZygpKSA9PSBudWxsIHx8IChfcm93JGdldFZhbHVlID0gX3JvdyRnZXRWYWx1ZS50b0xvd2VyQ2FzZSgpKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdyRnZXRWYWx1ZS5pbmNsdWRlcyhzZWFyY2gpKTtcbn07XG5pbmNsdWRlc1N0cmluZy5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKTtcbmNvbnN0IGluY2x1ZGVzU3RyaW5nU2Vuc2l0aXZlID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHZhciBfcm93JGdldFZhbHVlMjtcbiAgcmV0dXJuIEJvb2xlYW4oKF9yb3ckZ2V0VmFsdWUyID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgPT0gbnVsbCB8fCAoX3JvdyRnZXRWYWx1ZTIgPSBfcm93JGdldFZhbHVlMi50b1N0cmluZygpKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdyRnZXRWYWx1ZTIuaW5jbHVkZXMoZmlsdGVyVmFsdWUpKTtcbn07XG5pbmNsdWRlc1N0cmluZ1NlbnNpdGl2ZS5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKTtcbmNvbnN0IGVxdWFsc1N0cmluZyA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICB2YXIgX3JvdyRnZXRWYWx1ZTM7XG4gIHJldHVybiAoKF9yb3ckZ2V0VmFsdWUzID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgPT0gbnVsbCB8fCAoX3JvdyRnZXRWYWx1ZTMgPSBfcm93JGdldFZhbHVlMy50b1N0cmluZygpKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdyRnZXRWYWx1ZTMudG9Mb3dlckNhc2UoKSkgPT09IChmaWx0ZXJWYWx1ZSA9PSBudWxsID8gdm9pZCAwIDogZmlsdGVyVmFsdWUudG9Mb3dlckNhc2UoKSk7XG59O1xuZXF1YWxzU3RyaW5nLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpO1xuY29uc3QgYXJySW5jbHVkZXMgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcbiAgdmFyIF9yb3ckZ2V0VmFsdWU0O1xuICByZXR1cm4gKF9yb3ckZ2V0VmFsdWU0ID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3ckZ2V0VmFsdWU0LmluY2x1ZGVzKGZpbHRlclZhbHVlKTtcbn07XG5hcnJJbmNsdWRlcy5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKSB8fCAhKHZhbCAhPSBudWxsICYmIHZhbC5sZW5ndGgpO1xuY29uc3QgYXJySW5jbHVkZXNBbGwgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcbiAgcmV0dXJuICFmaWx0ZXJWYWx1ZS5zb21lKHZhbCA9PiB7XG4gICAgdmFyIF9yb3ckZ2V0VmFsdWU1O1xuICAgIHJldHVybiAhKChfcm93JGdldFZhbHVlNSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpICE9IG51bGwgJiYgX3JvdyRnZXRWYWx1ZTUuaW5jbHVkZXModmFsKSk7XG4gIH0pO1xufTtcbmFyckluY2x1ZGVzQWxsLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpIHx8ICEodmFsICE9IG51bGwgJiYgdmFsLmxlbmd0aCk7XG5jb25zdCBhcnJJbmNsdWRlc1NvbWUgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcbiAgcmV0dXJuIGZpbHRlclZhbHVlLnNvbWUodmFsID0+IHtcbiAgICB2YXIgX3JvdyRnZXRWYWx1ZTY7XG4gICAgcmV0dXJuIChfcm93JGdldFZhbHVlNiA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpID09IG51bGwgPyB2b2lkIDAgOiBfcm93JGdldFZhbHVlNi5pbmNsdWRlcyh2YWwpO1xuICB9KTtcbn07XG5hcnJJbmNsdWRlc1NvbWUuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCkgfHwgISh2YWwgIT0gbnVsbCAmJiB2YWwubGVuZ3RoKTtcbmNvbnN0IGVxdWFscyA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICByZXR1cm4gcm93LmdldFZhbHVlKGNvbHVtbklkKSA9PT0gZmlsdGVyVmFsdWU7XG59O1xuZXF1YWxzLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpO1xuY29uc3Qgd2Vha0VxdWFscyA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICByZXR1cm4gcm93LmdldFZhbHVlKGNvbHVtbklkKSA9PSBmaWx0ZXJWYWx1ZTtcbn07XG53ZWFrRXF1YWxzLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpO1xuY29uc3QgaW5OdW1iZXJSYW5nZSA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICBsZXQgW21pbiwgbWF4XSA9IGZpbHRlclZhbHVlO1xuICBjb25zdCByb3dWYWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gIHJldHVybiByb3dWYWx1ZSA+PSBtaW4gJiYgcm93VmFsdWUgPD0gbWF4O1xufTtcbmluTnVtYmVyUmFuZ2UucmVzb2x2ZUZpbHRlclZhbHVlID0gdmFsID0+IHtcbiAgbGV0IFt1bnNhZmVNaW4sIHVuc2FmZU1heF0gPSB2YWw7XG4gIGxldCBwYXJzZWRNaW4gPSB0eXBlb2YgdW5zYWZlTWluICE9PSAnbnVtYmVyJyA/IHBhcnNlRmxvYXQodW5zYWZlTWluKSA6IHVuc2FmZU1pbjtcbiAgbGV0IHBhcnNlZE1heCA9IHR5cGVvZiB1bnNhZmVNYXggIT09ICdudW1iZXInID8gcGFyc2VGbG9hdCh1bnNhZmVNYXgpIDogdW5zYWZlTWF4O1xuICBsZXQgbWluID0gdW5zYWZlTWluID09PSBudWxsIHx8IE51bWJlci5pc05hTihwYXJzZWRNaW4pID8gLUluZmluaXR5IDogcGFyc2VkTWluO1xuICBsZXQgbWF4ID0gdW5zYWZlTWF4ID09PSBudWxsIHx8IE51bWJlci5pc05hTihwYXJzZWRNYXgpID8gSW5maW5pdHkgOiBwYXJzZWRNYXg7XG4gIGlmIChtaW4gPiBtYXgpIHtcbiAgICBjb25zdCB0ZW1wID0gbWluO1xuICAgIG1pbiA9IG1heDtcbiAgICBtYXggPSB0ZW1wO1xuICB9XG4gIHJldHVybiBbbWluLCBtYXhdO1xufTtcbmluTnVtYmVyUmFuZ2UuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCkgfHwgdGVzdEZhbHNleSh2YWxbMF0pICYmIHRlc3RGYWxzZXkodmFsWzFdKTtcblxuLy8gRXhwb3J0XG5cbmNvbnN0IGZpbHRlckZucyA9IHtcbiAgaW5jbHVkZXNTdHJpbmcsXG4gIGluY2x1ZGVzU3RyaW5nU2Vuc2l0aXZlLFxuICBlcXVhbHNTdHJpbmcsXG4gIGFyckluY2x1ZGVzLFxuICBhcnJJbmNsdWRlc0FsbCxcbiAgYXJySW5jbHVkZXNTb21lLFxuICBlcXVhbHMsXG4gIHdlYWtFcXVhbHMsXG4gIGluTnVtYmVyUmFuZ2Vcbn07XG4vLyBVdGlsc1xuXG5mdW5jdGlvbiB0ZXN0RmFsc2V5KHZhbCkge1xuICByZXR1cm4gdmFsID09PSB1bmRlZmluZWQgfHwgdmFsID09PSBudWxsIHx8IHZhbCA9PT0gJyc7XG59XG5cbi8vXG5cbmNvbnN0IEZpbHRlcnMgPSB7XG4gIGdldERlZmF1bHRDb2x1bW5EZWY6ICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsdGVyRm46ICdhdXRvJ1xuICAgIH07XG4gIH0sXG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjb2x1bW5GaWx0ZXJzOiBbXSxcbiAgICAgIGdsb2JhbEZpbHRlcjogdW5kZWZpbmVkLFxuICAgICAgLy8gZmlsdGVyc1Byb2dyZXNzOiAxLFxuICAgICAgLy8gZmFjZXRQcm9ncmVzczoge30sXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ29sdW1uRmlsdGVyc0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uRmlsdGVycycsIHRhYmxlKSxcbiAgICAgIG9uR2xvYmFsRmlsdGVyQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdnbG9iYWxGaWx0ZXInLCB0YWJsZSksXG4gICAgICBmaWx0ZXJGcm9tTGVhZlJvd3M6IGZhbHNlLFxuICAgICAgbWF4TGVhZlJvd0ZpbHRlckRlcHRoOiAxMDAsXG4gICAgICBnbG9iYWxGaWx0ZXJGbjogJ2F1dG8nLFxuICAgICAgZ2V0Q29sdW1uQ2FuR2xvYmFsRmlsdGVyOiBjb2x1bW4gPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJGdldENvcmVSb3dNb2RlO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IChfdGFibGUkZ2V0Q29yZVJvd01vZGUgPSB0YWJsZS5nZXRDb3JlUm93TW9kZWwoKS5mbGF0Um93c1swXSkgPT0gbnVsbCB8fCAoX3RhYmxlJGdldENvcmVSb3dNb2RlID0gX3RhYmxlJGdldENvcmVSb3dNb2RlLl9nZXRBbGxDZWxsc0J5Q29sdW1uSWQoKVtjb2x1bW4uaWRdKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldENvcmVSb3dNb2RlLmdldFZhbHVlKCk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlQ29sdW1uOiAoY29sdW1uLCB0YWJsZSkgPT4ge1xuICAgIGNvbHVtbi5nZXRBdXRvRmlsdGVyRm4gPSAoKSA9PiB7XG4gICAgICBjb25zdCBmaXJzdFJvdyA9IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpLmZsYXRSb3dzWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBmaXJzdFJvdyA9PSBudWxsID8gdm9pZCAwIDogZmlyc3RSb3cuZ2V0VmFsdWUoY29sdW1uLmlkKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJGbnMuaW5jbHVkZXNTdHJpbmc7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gZmlsdGVyRm5zLmluTnVtYmVyUmFuZ2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlckZucy5lcXVhbHM7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmlsdGVyRm5zLmVxdWFscztcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmlsdGVyRm5zLmFyckluY2x1ZGVzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbHRlckZucy53ZWFrRXF1YWxzO1xuICAgIH07XG4gICAgY29sdW1uLmdldEZpbHRlckZuID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGZpbHRlciwgX3RhYmxlJG9wdGlvbnMkZmlsdGVyMjtcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGNvbHVtbi5jb2x1bW5EZWYuZmlsdGVyRm4pID8gY29sdW1uLmNvbHVtbkRlZi5maWx0ZXJGbiA6IGNvbHVtbi5jb2x1bW5EZWYuZmlsdGVyRm4gPT09ICdhdXRvJyA/IGNvbHVtbi5nZXRBdXRvRmlsdGVyRm4oKSA6IC8vIEB0cy1pZ25vcmVcbiAgICAgIChfdGFibGUkb3B0aW9ucyRmaWx0ZXIgPSAoX3RhYmxlJG9wdGlvbnMkZmlsdGVyMiA9IHRhYmxlLm9wdGlvbnMuZmlsdGVyRm5zKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJG9wdGlvbnMkZmlsdGVyMltjb2x1bW4uY29sdW1uRGVmLmZpbHRlckZuXSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGZpbHRlciA6IGZpbHRlckZuc1tjb2x1bW4uY29sdW1uRGVmLmZpbHRlckZuXTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5GaWx0ZXIgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5EZWYkZW5hLCBfdGFibGUkb3B0aW9ucyRlbmFibGUsIF90YWJsZSRvcHRpb25zJGVuYWJsZTI7XG4gICAgICByZXR1cm4gKChfY29sdW1uJGNvbHVtbkRlZiRlbmEgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZUNvbHVtbkZpbHRlcikgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJGVuYSA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlID0gdGFibGUub3B0aW9ucy5lbmFibGVDb2x1bW5GaWx0ZXJzKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUyID0gdGFibGUub3B0aW9ucy5lbmFibGVGaWx0ZXJzKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA6IHRydWUpICYmICEhY29sdW1uLmFjY2Vzc29yRm47XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Q2FuR2xvYmFsRmlsdGVyID0gKCkgPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1uRGVmJGVuYTIsIF90YWJsZSRvcHRpb25zJGVuYWJsZTMsIF90YWJsZSRvcHRpb25zJGVuYWJsZTQsIF90YWJsZSRvcHRpb25zJGdldENvbDtcbiAgICAgIHJldHVybiAoKF9jb2x1bW4kY29sdW1uRGVmJGVuYTIgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZUdsb2JhbEZpbHRlcikgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJGVuYTIgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZTMgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUdsb2JhbEZpbHRlcikgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZTMgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZTQgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUZpbHRlcnMpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGU0IDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRnZXRDb2wgPSB0YWJsZS5vcHRpb25zLmdldENvbHVtbkNhbkdsb2JhbEZpbHRlciA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5nZXRDb2x1bW5DYW5HbG9iYWxGaWx0ZXIoY29sdW1uKSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGdldENvbCA6IHRydWUpICYmICEhY29sdW1uLmFjY2Vzc29yRm47XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNGaWx0ZXJlZCA9ICgpID0+IGNvbHVtbi5nZXRGaWx0ZXJJbmRleCgpID4gLTE7XG4gICAgY29sdW1uLmdldEZpbHRlclZhbHVlID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRjb2x1bTtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldFN0YXRlJGNvbHVtID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5GaWx0ZXJzKSA9PSBudWxsIHx8IChfdGFibGUkZ2V0U3RhdGUkY29sdW0gPSBfdGFibGUkZ2V0U3RhdGUkY29sdW0uZmluZChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCkpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkY29sdW0udmFsdWU7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0RmlsdGVySW5kZXggPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJGNvbHVtMiwgX3RhYmxlJGdldFN0YXRlJGNvbHVtMztcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldFN0YXRlJGNvbHVtMiA9IChfdGFibGUkZ2V0U3RhdGUkY29sdW0zID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5GaWx0ZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldFN0YXRlJGNvbHVtMy5maW5kSW5kZXgoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpKSAhPSBudWxsID8gX3RhYmxlJGdldFN0YXRlJGNvbHVtMiA6IC0xO1xuICAgIH07XG4gICAgY29sdW1uLnNldEZpbHRlclZhbHVlID0gdmFsdWUgPT4ge1xuICAgICAgdGFibGUuc2V0Q29sdW1uRmlsdGVycyhvbGQgPT4ge1xuICAgICAgICBjb25zdCBmaWx0ZXJGbiA9IGNvbHVtbi5nZXRGaWx0ZXJGbigpO1xuICAgICAgICBjb25zdCBwcmV2aW91c2ZpbHRlciA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpO1xuICAgICAgICBjb25zdCBuZXdGaWx0ZXIgPSBmdW5jdGlvbmFsVXBkYXRlKHZhbHVlLCBwcmV2aW91c2ZpbHRlciA/IHByZXZpb3VzZmlsdGVyLnZhbHVlIDogdW5kZWZpbmVkKTtcblxuICAgICAgICAvL1xuICAgICAgICBpZiAoc2hvdWxkQXV0b1JlbW92ZUZpbHRlcihmaWx0ZXJGbiwgbmV3RmlsdGVyLCBjb2x1bW4pKSB7XG4gICAgICAgICAgdmFyIF9vbGQkZmlsdGVyO1xuICAgICAgICAgIHJldHVybiAoX29sZCRmaWx0ZXIgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5maWx0ZXIoZCA9PiBkLmlkICE9PSBjb2x1bW4uaWQpKSAhPSBudWxsID8gX29sZCRmaWx0ZXIgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdGaWx0ZXJPYmogPSB7XG4gICAgICAgICAgaWQ6IGNvbHVtbi5pZCxcbiAgICAgICAgICB2YWx1ZTogbmV3RmlsdGVyXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcmV2aW91c2ZpbHRlcikge1xuICAgICAgICAgIHZhciBfb2xkJG1hcDtcbiAgICAgICAgICByZXR1cm4gKF9vbGQkbWFwID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQubWFwKGQgPT4ge1xuICAgICAgICAgICAgaWYgKGQuaWQgPT09IGNvbHVtbi5pZCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3RmlsdGVyT2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgfSkpICE9IG51bGwgPyBfb2xkJG1hcCA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGQgIT0gbnVsbCAmJiBvbGQubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIFsuLi5vbGQsIG5ld0ZpbHRlck9ial07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtuZXdGaWx0ZXJPYmpdO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb2x1bW4uX2dldEZhY2V0ZWRSb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFJvd01vZGVsKHRhYmxlLCBjb2x1bW4uaWQpO1xuICAgIGNvbHVtbi5nZXRGYWNldGVkUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAoIWNvbHVtbi5fZ2V0RmFjZXRlZFJvd01vZGVsKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVGaWx0ZXJlZFJvd01vZGVsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sdW1uLl9nZXRGYWNldGVkUm93TW9kZWwoKTtcbiAgICB9O1xuICAgIGNvbHVtbi5fZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyA9IHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyAmJiB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRVbmlxdWVWYWx1ZXModGFibGUsIGNvbHVtbi5pZCk7XG4gICAgY29sdW1uLmdldEZhY2V0ZWRVbmlxdWVWYWx1ZXMgPSAoKSA9PiB7XG4gICAgICBpZiAoIWNvbHVtbi5fZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcykge1xuICAgICAgICByZXR1cm4gbmV3IE1hcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbHVtbi5fZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcygpO1xuICAgIH07XG4gICAgY29sdW1uLl9nZXRGYWNldGVkTWluTWF4VmFsdWVzID0gdGFibGUub3B0aW9ucy5nZXRGYWNldGVkTWluTWF4VmFsdWVzICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyh0YWJsZSwgY29sdW1uLmlkKTtcbiAgICBjb2x1bW4uZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyA9ICgpID0+IHtcbiAgICAgIGlmICghY29sdW1uLl9nZXRGYWNldGVkTWluTWF4VmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sdW1uLl9nZXRGYWNldGVkTWluTWF4VmFsdWVzKCk7XG4gICAgfTtcbiAgICAvLyAoKSA9PiBbY29sdW1uLmdldEZhY2V0ZWRSb3dNb2RlbCgpXSxcbiAgICAvLyBmYWNldGVkUm93TW9kZWwgPT4gZ2V0Um93TW9kZWxNaW5NYXhWYWx1ZXMoZmFjZXRlZFJvd01vZGVsLCBjb2x1bW4uaWQpLFxuICB9LFxuICBjcmVhdGVSb3c6IChyb3csIHRhYmxlKSA9PiB7XG4gICAgcm93LmNvbHVtbkZpbHRlcnMgPSB7fTtcbiAgICByb3cuY29sdW1uRmlsdGVyc01ldGEgPSB7fTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5nZXRHbG9iYWxBdXRvRmlsdGVyRm4gPSAoKSA9PiB7XG4gICAgICByZXR1cm4gZmlsdGVyRm5zLmluY2x1ZGVzU3RyaW5nO1xuICAgIH07XG4gICAgdGFibGUuZ2V0R2xvYmFsRmlsdGVyRm4gPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZmlsdGVyMywgX3RhYmxlJG9wdGlvbnMkZmlsdGVyNDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZ2xvYmFsRmlsdGVyRm46IGdsb2JhbEZpbHRlckZuXG4gICAgICB9ID0gdGFibGUub3B0aW9ucztcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGdsb2JhbEZpbHRlckZuKSA/IGdsb2JhbEZpbHRlckZuIDogZ2xvYmFsRmlsdGVyRm4gPT09ICdhdXRvJyA/IHRhYmxlLmdldEdsb2JhbEF1dG9GaWx0ZXJGbigpIDogLy8gQHRzLWlnbm9yZVxuICAgICAgKF90YWJsZSRvcHRpb25zJGZpbHRlcjMgPSAoX3RhYmxlJG9wdGlvbnMkZmlsdGVyNCA9IHRhYmxlLm9wdGlvbnMuZmlsdGVyRm5zKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJG9wdGlvbnMkZmlsdGVyNFtnbG9iYWxGaWx0ZXJGbl0pICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRmaWx0ZXIzIDogZmlsdGVyRm5zW2dsb2JhbEZpbHRlckZuXTtcbiAgICB9O1xuICAgIHRhYmxlLnNldENvbHVtbkZpbHRlcnMgPSB1cGRhdGVyID0+IHtcbiAgICAgIGNvbnN0IGxlYWZDb2x1bW5zID0gdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKTtcbiAgICAgIGNvbnN0IHVwZGF0ZUZuID0gb2xkID0+IHtcbiAgICAgICAgdmFyIF9mdW5jdGlvbmFsVXBkYXRlO1xuICAgICAgICByZXR1cm4gKF9mdW5jdGlvbmFsVXBkYXRlID0gZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCBvbGQpKSA9PSBudWxsID8gdm9pZCAwIDogX2Z1bmN0aW9uYWxVcGRhdGUuZmlsdGVyKGZpbHRlciA9PiB7XG4gICAgICAgICAgY29uc3QgY29sdW1uID0gbGVhZkNvbHVtbnMuZmluZChkID0+IGQuaWQgPT09IGZpbHRlci5pZCk7XG4gICAgICAgICAgaWYgKGNvbHVtbikge1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyRm4gPSBjb2x1bW4uZ2V0RmlsdGVyRm4oKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRBdXRvUmVtb3ZlRmlsdGVyKGZpbHRlckZuLCBmaWx0ZXIudmFsdWUsIGNvbHVtbikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgdGFibGUub3B0aW9ucy5vbkNvbHVtbkZpbHRlcnNDaGFuZ2UgPT0gbnVsbCB8fCB0YWJsZS5vcHRpb25zLm9uQ29sdW1uRmlsdGVyc0NoYW5nZSh1cGRhdGVGbik7XG4gICAgfTtcbiAgICB0YWJsZS5zZXRHbG9iYWxGaWx0ZXIgPSB1cGRhdGVyID0+IHtcbiAgICAgIHRhYmxlLm9wdGlvbnMub25HbG9iYWxGaWx0ZXJDaGFuZ2UgPT0gbnVsbCB8fCB0YWJsZS5vcHRpb25zLm9uR2xvYmFsRmlsdGVyQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIH07XG4gICAgdGFibGUucmVzZXRHbG9iYWxGaWx0ZXIgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdGFibGUuc2V0R2xvYmFsRmlsdGVyKGRlZmF1bHRTdGF0ZSA/IHVuZGVmaW5lZCA6IHRhYmxlLmluaXRpYWxTdGF0ZS5nbG9iYWxGaWx0ZXIpO1xuICAgIH07XG4gICAgdGFibGUucmVzZXRDb2x1bW5GaWx0ZXJzID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGMsIF90YWJsZSRpbml0aWFsU3RhdGU7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5GaWx0ZXJzKGRlZmF1bHRTdGF0ZSA/IFtdIDogKF90YWJsZSRpbml0aWFsU3RhdGUkYyA9IChfdGFibGUkaW5pdGlhbFN0YXRlID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZS5jb2x1bW5GaWx0ZXJzKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRjIDogW10pO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UHJlRmlsdGVyZWRSb3dNb2RlbCA9ICgpID0+IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpO1xuICAgIHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRGaWx0ZXJlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmlsdGVyZWRSb3dNb2RlbCkge1xuICAgICAgICB0YWJsZS5fZ2V0RmlsdGVyZWRSb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0RmlsdGVyZWRSb3dNb2RlbCh0YWJsZSk7XG4gICAgICB9XG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxGaWx0ZXJpbmcgfHwgIXRhYmxlLl9nZXRGaWx0ZXJlZFJvd01vZGVsKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVGaWx0ZXJlZFJvd01vZGVsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGUuX2dldEZpbHRlcmVkUm93TW9kZWwoKTtcbiAgICB9O1xuICAgIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRSb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRSb3dNb2RlbCh0YWJsZSwgJ19fZ2xvYmFsX18nKTtcbiAgICB0YWJsZS5nZXRHbG9iYWxGYWNldGVkUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxGaWx0ZXJpbmcgfHwgIXRhYmxlLl9nZXRHbG9iYWxGYWNldGVkUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZUZpbHRlcmVkUm93TW9kZWwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZFJvd01vZGVsKCk7XG4gICAgfTtcbiAgICB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcyA9IHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyAmJiB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRVbmlxdWVWYWx1ZXModGFibGUsICdfX2dsb2JhbF9fJyk7XG4gICAgdGFibGUuZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcyA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRVbmlxdWVWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcygpO1xuICAgIH07XG4gICAgdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMgJiYgdGFibGUub3B0aW9ucy5nZXRGYWNldGVkTWluTWF4VmFsdWVzKHRhYmxlLCAnX19nbG9iYWxfXycpO1xuICAgIHRhYmxlLmdldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRHbG9iYWxGYWNldGVkTWluTWF4VmFsdWVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZE1pbk1heFZhbHVlcygpO1xuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBzaG91bGRBdXRvUmVtb3ZlRmlsdGVyKGZpbHRlckZuLCB2YWx1ZSwgY29sdW1uKSB7XG4gIHJldHVybiAoZmlsdGVyRm4gJiYgZmlsdGVyRm4uYXV0b1JlbW92ZSA/IGZpbHRlckZuLmF1dG9SZW1vdmUodmFsdWUsIGNvbHVtbikgOiBmYWxzZSkgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmICF2YWx1ZTtcbn1cblxuY29uc3Qgc3VtID0gKGNvbHVtbklkLCBfbGVhZlJvd3MsIGNoaWxkUm93cykgPT4ge1xuICAvLyBJdCdzIGZhc3RlciB0byBqdXN0IGFkZCB0aGUgYWdncmVnYXRpb25zIHRvZ2V0aGVyIGluc3RlYWQgb2ZcbiAgLy8gcHJvY2VzcyBsZWFmIG5vZGVzIGluZGl2aWR1YWxseVxuICByZXR1cm4gY2hpbGRSb3dzLnJlZHVjZSgoc3VtLCBuZXh0KSA9PiB7XG4gICAgY29uc3QgbmV4dFZhbHVlID0gbmV4dC5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gICAgcmV0dXJuIHN1bSArICh0eXBlb2YgbmV4dFZhbHVlID09PSAnbnVtYmVyJyA/IG5leHRWYWx1ZSA6IDApO1xuICB9LCAwKTtcbn07XG5jb25zdCBtaW4gPSAoY29sdW1uSWQsIF9sZWFmUm93cywgY2hpbGRSb3dzKSA9PiB7XG4gIGxldCBtaW47XG4gIGNoaWxkUm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIChtaW4gPiB2YWx1ZSB8fCBtaW4gPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpIHtcbiAgICAgIG1pbiA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtaW47XG59O1xuY29uc3QgbWF4ID0gKGNvbHVtbklkLCBfbGVhZlJvd3MsIGNoaWxkUm93cykgPT4ge1xuICBsZXQgbWF4O1xuICBjaGlsZFJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gcm93LmdldFZhbHVlKGNvbHVtbklkKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiAobWF4IDwgdmFsdWUgfHwgbWF4ID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSB7XG4gICAgICBtYXggPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbWF4O1xufTtcbmNvbnN0IGV4dGVudCA9IChjb2x1bW5JZCwgX2xlYWZSb3dzLCBjaGlsZFJvd3MpID0+IHtcbiAgbGV0IG1pbjtcbiAgbGV0IG1heDtcbiAgY2hpbGRSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGlmIChtaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodmFsdWUgPj0gdmFsdWUpIG1pbiA9IG1heCA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG1pbiA+IHZhbHVlKSBtaW4gPSB2YWx1ZTtcbiAgICAgICAgaWYgKG1heCA8IHZhbHVlKSBtYXggPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gW21pbiwgbWF4XTtcbn07XG5jb25zdCBtZWFuID0gKGNvbHVtbklkLCBsZWFmUm93cykgPT4ge1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgc3VtID0gMDtcbiAgbGVhZlJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgIGxldCB2YWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgKHZhbHVlID0gK3ZhbHVlKSA+PSB2YWx1ZSkge1xuICAgICAgKytjb3VudCwgc3VtICs9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIGlmIChjb3VudCkgcmV0dXJuIHN1bSAvIGNvdW50O1xuICByZXR1cm47XG59O1xuY29uc3QgbWVkaWFuID0gKGNvbHVtbklkLCBsZWFmUm93cykgPT4ge1xuICBpZiAoIWxlYWZSb3dzLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB2YWx1ZXMgPSBsZWFmUm93cy5tYXAocm93ID0+IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpO1xuICBpZiAoIWlzTnVtYmVyQXJyYXkodmFsdWVzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB2YWx1ZXNbMF07XG4gIH1cbiAgY29uc3QgbWlkID0gTWF0aC5mbG9vcih2YWx1ZXMubGVuZ3RoIC8gMik7XG4gIGNvbnN0IG51bXMgPSB2YWx1ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICByZXR1cm4gdmFsdWVzLmxlbmd0aCAlIDIgIT09IDAgPyBudW1zW21pZF0gOiAobnVtc1ttaWQgLSAxXSArIG51bXNbbWlkXSkgLyAyO1xufTtcbmNvbnN0IHVuaXF1ZSA9IChjb2x1bW5JZCwgbGVhZlJvd3MpID0+IHtcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChsZWFmUm93cy5tYXAoZCA9PiBkLmdldFZhbHVlKGNvbHVtbklkKSkpLnZhbHVlcygpKTtcbn07XG5jb25zdCB1bmlxdWVDb3VudCA9IChjb2x1bW5JZCwgbGVhZlJvd3MpID0+IHtcbiAgcmV0dXJuIG5ldyBTZXQobGVhZlJvd3MubWFwKGQgPT4gZC5nZXRWYWx1ZShjb2x1bW5JZCkpKS5zaXplO1xufTtcbmNvbnN0IGNvdW50ID0gKF9jb2x1bW5JZCwgbGVhZlJvd3MpID0+IHtcbiAgcmV0dXJuIGxlYWZSb3dzLmxlbmd0aDtcbn07XG5jb25zdCBhZ2dyZWdhdGlvbkZucyA9IHtcbiAgc3VtLFxuICBtaW4sXG4gIG1heCxcbiAgZXh0ZW50LFxuICBtZWFuLFxuICBtZWRpYW4sXG4gIHVuaXF1ZSxcbiAgdW5pcXVlQ291bnQsXG4gIGNvdW50XG59O1xuXG4vL1xuXG5jb25zdCBHcm91cGluZyA9IHtcbiAgZ2V0RGVmYXVsdENvbHVtbkRlZjogKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBhZ2dyZWdhdGVkQ2VsbDogcHJvcHMgPT4ge1xuICAgICAgICB2YXIgX3RvU3RyaW5nLCBfcHJvcHMkZ2V0VmFsdWU7XG4gICAgICAgIHJldHVybiAoX3RvU3RyaW5nID0gKF9wcm9wcyRnZXRWYWx1ZSA9IHByb3BzLmdldFZhbHVlKCkpID09IG51bGwgfHwgX3Byb3BzJGdldFZhbHVlLnRvU3RyaW5nID09IG51bGwgPyB2b2lkIDAgOiBfcHJvcHMkZ2V0VmFsdWUudG9TdHJpbmcoKSkgIT0gbnVsbCA/IF90b1N0cmluZyA6IG51bGw7XG4gICAgICB9LFxuICAgICAgYWdncmVnYXRpb25GbjogJ2F1dG8nXG4gICAgfTtcbiAgfSxcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdyb3VwaW5nOiBbXSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Hcm91cGluZ0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignZ3JvdXBpbmcnLCB0YWJsZSksXG4gICAgICBncm91cGVkQ29sdW1uTW9kZTogJ3Jlb3JkZXInXG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlQ29sdW1uOiAoY29sdW1uLCB0YWJsZSkgPT4ge1xuICAgIGNvbHVtbi50b2dnbGVHcm91cGluZyA9ICgpID0+IHtcbiAgICAgIHRhYmxlLnNldEdyb3VwaW5nKG9sZCA9PiB7XG4gICAgICAgIC8vIEZpbmQgYW55IGV4aXN0aW5nIGdyb3VwaW5nIGZvciB0aGlzIGNvbHVtblxuICAgICAgICBpZiAob2xkICE9IG51bGwgJiYgb2xkLmluY2x1ZGVzKGNvbHVtbi5pZCkpIHtcbiAgICAgICAgICByZXR1cm4gb2xkLmZpbHRlcihkID0+IGQgIT09IGNvbHVtbi5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsuLi4ob2xkICE9IG51bGwgPyBvbGQgOiBbXSksIGNvbHVtbi5pZF07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5Hcm91cCA9ICgpID0+IHtcbiAgICAgIHZhciBfcmVmLCBfcmVmMiwgX3JlZjMsIF9jb2x1bW4kY29sdW1uRGVmJGVuYTtcbiAgICAgIHJldHVybiAoX3JlZiA9IChfcmVmMiA9IChfcmVmMyA9IChfY29sdW1uJGNvbHVtbkRlZiRlbmEgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZUdyb3VwaW5nKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hIDogdHJ1ZSkgIT0gbnVsbCA/IF9yZWYzIDogdGFibGUub3B0aW9ucy5lbmFibGVHcm91cGluZykgIT0gbnVsbCA/IF9yZWYyIDogdHJ1ZSkgIT0gbnVsbCA/IF9yZWYgOiAhIWNvbHVtbi5hY2Nlc3NvckZuO1xuICAgIH07XG4gICAgY29sdW1uLmdldElzR3JvdXBlZCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkZ3JvdXA7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRTdGF0ZSRncm91cCA9IHRhYmxlLmdldFN0YXRlKCkuZ3JvdXBpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkZ3JvdXAuaW5jbHVkZXMoY29sdW1uLmlkKTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRHcm91cGVkSW5kZXggPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJGdyb3VwMjtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldFN0YXRlJGdyb3VwMiA9IHRhYmxlLmdldFN0YXRlKCkuZ3JvdXBpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkZ3JvdXAyLmluZGV4T2YoY29sdW1uLmlkKTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRUb2dnbGVHcm91cGluZ0hhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYW5Hcm91cCA9IGNvbHVtbi5nZXRDYW5Hcm91cCgpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKCFjYW5Hcm91cCkgcmV0dXJuO1xuICAgICAgICBjb2x1bW4udG9nZ2xlR3JvdXBpbmcoKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0QXV0b0FnZ3JlZ2F0aW9uRm4gPSAoKSA9PiB7XG4gICAgICBjb25zdCBmaXJzdFJvdyA9IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpLmZsYXRSb3dzWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBmaXJzdFJvdyA9PSBudWxsID8gdm9pZCAwIDogZmlyc3RSb3cuZ2V0VmFsdWUoY29sdW1uLmlkKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBhZ2dyZWdhdGlvbkZucy5zdW07XG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0ZV0nKSB7XG4gICAgICAgIHJldHVybiBhZ2dyZWdhdGlvbkZucy5leHRlbnQ7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0QWdncmVnYXRpb25GbiA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRhZ2dyZWcsIF90YWJsZSRvcHRpb25zJGFnZ3JlZzI7XG4gICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGNvbHVtbi5jb2x1bW5EZWYuYWdncmVnYXRpb25GbikgPyBjb2x1bW4uY29sdW1uRGVmLmFnZ3JlZ2F0aW9uRm4gOiBjb2x1bW4uY29sdW1uRGVmLmFnZ3JlZ2F0aW9uRm4gPT09ICdhdXRvJyA/IGNvbHVtbi5nZXRBdXRvQWdncmVnYXRpb25GbigpIDogKF90YWJsZSRvcHRpb25zJGFnZ3JlZyA9IChfdGFibGUkb3B0aW9ucyRhZ2dyZWcyID0gdGFibGUub3B0aW9ucy5hZ2dyZWdhdGlvbkZucykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRvcHRpb25zJGFnZ3JlZzJbY29sdW1uLmNvbHVtbkRlZi5hZ2dyZWdhdGlvbkZuXSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGFnZ3JlZyA6IGFnZ3JlZ2F0aW9uRm5zW2NvbHVtbi5jb2x1bW5EZWYuYWdncmVnYXRpb25Gbl07XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5zZXRHcm91cGluZyA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkdyb3VwaW5nQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uR3JvdXBpbmdDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRHcm91cGluZyA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRnLCBfdGFibGUkaW5pdGlhbFN0YXRlO1xuICAgICAgdGFibGUuc2V0R3JvdXBpbmcoZGVmYXVsdFN0YXRlID8gW10gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRnID0gKF90YWJsZSRpbml0aWFsU3RhdGUgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlLmdyb3VwaW5nKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRnIDogW10pO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UHJlR3JvdXBlZFJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpO1xuICAgIHRhYmxlLmdldEdyb3VwZWRSb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldEdyb3VwZWRSb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldEdyb3VwZWRSb3dNb2RlbCkge1xuICAgICAgICB0YWJsZS5fZ2V0R3JvdXBlZFJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRHcm91cGVkUm93TW9kZWwodGFibGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRhYmxlLm9wdGlvbnMubWFudWFsR3JvdXBpbmcgfHwgIXRhYmxlLl9nZXRHcm91cGVkUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZUdyb3VwZWRSb3dNb2RlbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRHcm91cGVkUm93TW9kZWwoKTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVSb3c6IChyb3csIHRhYmxlKSA9PiB7XG4gICAgcm93LmdldElzR3JvdXBlZCA9ICgpID0+ICEhcm93Lmdyb3VwaW5nQ29sdW1uSWQ7XG4gICAgcm93LmdldEdyb3VwaW5nVmFsdWUgPSBjb2x1bW5JZCA9PiB7XG4gICAgICBpZiAocm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlLmhhc093blByb3BlcnR5KGNvbHVtbklkKSkge1xuICAgICAgICByZXR1cm4gcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCk7XG4gICAgICBpZiAoIShjb2x1bW4gIT0gbnVsbCAmJiBjb2x1bW4uY29sdW1uRGVmLmdldEdyb3VwaW5nVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiByb3cuZ2V0VmFsdWUoY29sdW1uSWQpO1xuICAgICAgfVxuICAgICAgcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXSA9IGNvbHVtbi5jb2x1bW5EZWYuZ2V0R3JvdXBpbmdWYWx1ZShyb3cub3JpZ2luYWwpO1xuICAgICAgcmV0dXJuIHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgfTtcbiAgICByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGUgPSB7fTtcbiAgfSxcbiAgY3JlYXRlQ2VsbDogKGNlbGwsIGNvbHVtbiwgcm93LCB0YWJsZSkgPT4ge1xuICAgIGNlbGwuZ2V0SXNHcm91cGVkID0gKCkgPT4gY29sdW1uLmdldElzR3JvdXBlZCgpICYmIGNvbHVtbi5pZCA9PT0gcm93Lmdyb3VwaW5nQ29sdW1uSWQ7XG4gICAgY2VsbC5nZXRJc1BsYWNlaG9sZGVyID0gKCkgPT4gIWNlbGwuZ2V0SXNHcm91cGVkKCkgJiYgY29sdW1uLmdldElzR3JvdXBlZCgpO1xuICAgIGNlbGwuZ2V0SXNBZ2dyZWdhdGVkID0gKCkgPT4ge1xuICAgICAgdmFyIF9yb3ckc3ViUm93cztcbiAgICAgIHJldHVybiAhY2VsbC5nZXRJc0dyb3VwZWQoKSAmJiAhY2VsbC5nZXRJc1BsYWNlaG9sZGVyKCkgJiYgISEoKF9yb3ckc3ViUm93cyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93cy5sZW5ndGgpO1xuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBvcmRlckNvbHVtbnMobGVhZkNvbHVtbnMsIGdyb3VwaW5nLCBncm91cGVkQ29sdW1uTW9kZSkge1xuICBpZiAoIShncm91cGluZyAhPSBudWxsICYmIGdyb3VwaW5nLmxlbmd0aCkgfHwgIWdyb3VwZWRDb2x1bW5Nb2RlKSB7XG4gICAgcmV0dXJuIGxlYWZDb2x1bW5zO1xuICB9XG4gIGNvbnN0IG5vbkdyb3VwaW5nQ29sdW1ucyA9IGxlYWZDb2x1bW5zLmZpbHRlcihjb2wgPT4gIWdyb3VwaW5nLmluY2x1ZGVzKGNvbC5pZCkpO1xuICBpZiAoZ3JvdXBlZENvbHVtbk1vZGUgPT09ICdyZW1vdmUnKSB7XG4gICAgcmV0dXJuIG5vbkdyb3VwaW5nQ29sdW1ucztcbiAgfVxuICBjb25zdCBncm91cGluZ0NvbHVtbnMgPSBncm91cGluZy5tYXAoZyA9PiBsZWFmQ29sdW1ucy5maW5kKGNvbCA9PiBjb2wuaWQgPT09IGcpKS5maWx0ZXIoQm9vbGVhbik7XG4gIHJldHVybiBbLi4uZ3JvdXBpbmdDb2x1bW5zLCAuLi5ub25Hcm91cGluZ0NvbHVtbnNdO1xufVxuXG4vL1xuXG5jb25zdCBPcmRlcmluZyA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtbk9yZGVyOiBbXSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Db2x1bW5PcmRlckNoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uT3JkZXInLCB0YWJsZSlcbiAgICB9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLnNldENvbHVtbk9yZGVyID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uT3JkZXJDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Db2x1bW5PcmRlckNoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldENvbHVtbk9yZGVyID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGM7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5PcmRlcihkZWZhdWx0U3RhdGUgPyBbXSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGMgPSB0YWJsZS5pbml0aWFsU3RhdGUuY29sdW1uT3JkZXIpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGMgOiBbXSk7XG4gICAgfTtcbiAgICB0YWJsZS5fZ2V0T3JkZXJDb2x1bW5zRm4gPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtbk9yZGVyLCB0YWJsZS5nZXRTdGF0ZSgpLmdyb3VwaW5nLCB0YWJsZS5vcHRpb25zLmdyb3VwZWRDb2x1bW5Nb2RlXSwgKGNvbHVtbk9yZGVyLCBncm91cGluZywgZ3JvdXBlZENvbHVtbk1vZGUpID0+IGNvbHVtbnMgPT4ge1xuICAgICAgLy8gU29ydCBncm91cGVkIGNvbHVtbnMgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb2x1bW4gbGlzdFxuICAgICAgLy8gYmVmb3JlIHRoZSBoZWFkZXJzIGFyZSBidWlsdFxuICAgICAgbGV0IG9yZGVyZWRDb2x1bW5zID0gW107XG5cbiAgICAgIC8vIElmIHRoZXJlIGlzIG5vIG9yZGVyLCByZXR1cm4gdGhlIG5vcm1hbCBjb2x1bW5zXG4gICAgICBpZiAoIShjb2x1bW5PcmRlciAhPSBudWxsICYmIGNvbHVtbk9yZGVyLmxlbmd0aCkpIHtcbiAgICAgICAgb3JkZXJlZENvbHVtbnMgPSBjb2x1bW5zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29sdW1uT3JkZXJDb3B5ID0gWy4uLmNvbHVtbk9yZGVyXTtcblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBvcmRlciwgbWFrZSBhIGNvcHkgb2YgdGhlIGNvbHVtbnNcbiAgICAgICAgY29uc3QgY29sdW1uc0NvcHkgPSBbLi4uY29sdW1uc107XG5cbiAgICAgICAgLy8gQW5kIG1ha2UgYSBuZXcgb3JkZXJlZCBhcnJheSBvZiB0aGUgY29sdW1uc1xuXG4gICAgICAgIC8vIExvb3Agb3ZlciB0aGUgY29sdW1ucyBhbmQgcGxhY2UgdGhlbSBpbiBvcmRlciBpbnRvIHRoZSBuZXcgYXJyYXlcbiAgICAgICAgd2hpbGUgKGNvbHVtbnNDb3B5Lmxlbmd0aCAmJiBjb2x1bW5PcmRlckNvcHkubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0Q29sdW1uSWQgPSBjb2x1bW5PcmRlckNvcHkuc2hpZnQoKTtcbiAgICAgICAgICBjb25zdCBmb3VuZEluZGV4ID0gY29sdW1uc0NvcHkuZmluZEluZGV4KGQgPT4gZC5pZCA9PT0gdGFyZ2V0Q29sdW1uSWQpO1xuICAgICAgICAgIGlmIChmb3VuZEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIG9yZGVyZWRDb2x1bW5zLnB1c2goY29sdW1uc0NvcHkuc3BsaWNlKGZvdW5kSW5kZXgsIDEpWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYW55IGNvbHVtbnMgbGVmdCwgYWRkIHRoZW0gdG8gdGhlIGVuZFxuICAgICAgICBvcmRlcmVkQ29sdW1ucyA9IFsuLi5vcmRlcmVkQ29sdW1ucywgLi4uY29sdW1uc0NvcHldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yZGVyQ29sdW1ucyhvcmRlcmVkQ29sdW1ucywgZ3JvdXBpbmcsIGdyb3VwZWRDb2x1bW5Nb2RlKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRPcmRlckNvbHVtbnNGbidcbiAgICAgIC8vIGRlYnVnOiAoKSA9PiB0YWJsZS5vcHRpb25zLmRlYnVnQWxsID8/IHRhYmxlLm9wdGlvbnMuZGVidWdUYWJsZSxcbiAgICB9KTtcbiAgfVxufTtcblxuLy9cblxuY29uc3QgZGVmYXVsdFBhZ2VJbmRleCA9IDA7XG5jb25zdCBkZWZhdWx0UGFnZVNpemUgPSAxMDtcbmNvbnN0IGdldERlZmF1bHRQYWdpbmF0aW9uU3RhdGUgPSAoKSA9PiAoe1xuICBwYWdlSW5kZXg6IGRlZmF1bHRQYWdlSW5kZXgsXG4gIHBhZ2VTaXplOiBkZWZhdWx0UGFnZVNpemVcbn0pO1xuY29uc3QgUGFnaW5hdGlvbiA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgcGFnaW5hdGlvbjoge1xuICAgICAgICAuLi5nZXREZWZhdWx0UGFnaW5hdGlvblN0YXRlKCksXG4gICAgICAgIC4uLihzdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUucGFnaW5hdGlvbilcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvblBhZ2luYXRpb25DaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ3BhZ2luYXRpb24nLCB0YWJsZSlcbiAgICB9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIGxldCByZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgbGV0IHF1ZXVlZCA9IGZhbHNlO1xuICAgIHRhYmxlLl9hdXRvUmVzZXRQYWdlSW5kZXggPSAoKSA9PiB7XG4gICAgICB2YXIgX3JlZiwgX3RhYmxlJG9wdGlvbnMkYXV0b1JlO1xuICAgICAgaWYgKCFyZWdpc3RlcmVkKSB7XG4gICAgICAgIHRhYmxlLl9xdWV1ZSgoKSA9PiB7XG4gICAgICAgICAgcmVnaXN0ZXJlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoKF9yZWYgPSAoX3RhYmxlJG9wdGlvbnMkYXV0b1JlID0gdGFibGUub3B0aW9ucy5hdXRvUmVzZXRBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRhdXRvUmUgOiB0YWJsZS5vcHRpb25zLmF1dG9SZXNldFBhZ2VJbmRleCkgIT0gbnVsbCA/IF9yZWYgOiAhdGFibGUub3B0aW9ucy5tYW51YWxQYWdpbmF0aW9uKSB7XG4gICAgICAgIGlmIChxdWV1ZWQpIHJldHVybjtcbiAgICAgICAgcXVldWVkID0gdHJ1ZTtcbiAgICAgICAgdGFibGUuX3F1ZXVlKCgpID0+IHtcbiAgICAgICAgICB0YWJsZS5yZXNldFBhZ2VJbmRleCgpO1xuICAgICAgICAgIHF1ZXVlZCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRhYmxlLnNldFBhZ2luYXRpb24gPSB1cGRhdGVyID0+IHtcbiAgICAgIGNvbnN0IHNhZmVVcGRhdGVyID0gb2xkID0+IHtcbiAgICAgICAgbGV0IG5ld1N0YXRlID0gZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCBvbGQpO1xuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMub25QYWdpbmF0aW9uQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uUGFnaW5hdGlvbkNoYW5nZShzYWZlVXBkYXRlcik7XG4gICAgfTtcbiAgICB0YWJsZS5yZXNldFBhZ2luYXRpb24gPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkcDtcbiAgICAgIHRhYmxlLnNldFBhZ2luYXRpb24oZGVmYXVsdFN0YXRlID8gZ2V0RGVmYXVsdFBhZ2luYXRpb25TdGF0ZSgpIDogKF90YWJsZSRpbml0aWFsU3RhdGUkcCA9IHRhYmxlLmluaXRpYWxTdGF0ZS5wYWdpbmF0aW9uKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRwIDogZ2V0RGVmYXVsdFBhZ2luYXRpb25TdGF0ZSgpKTtcbiAgICB9O1xuICAgIHRhYmxlLnNldFBhZ2VJbmRleCA9IHVwZGF0ZXIgPT4ge1xuICAgICAgdGFibGUuc2V0UGFnaW5hdGlvbihvbGQgPT4ge1xuICAgICAgICBsZXQgcGFnZUluZGV4ID0gZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCBvbGQucGFnZUluZGV4KTtcbiAgICAgICAgY29uc3QgbWF4UGFnZUluZGV4ID0gdHlwZW9mIHRhYmxlLm9wdGlvbnMucGFnZUNvdW50ID09PSAndW5kZWZpbmVkJyB8fCB0YWJsZS5vcHRpb25zLnBhZ2VDb3VudCA9PT0gLTEgPyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA6IHRhYmxlLm9wdGlvbnMucGFnZUNvdW50IC0gMTtcbiAgICAgICAgcGFnZUluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocGFnZUluZGV4LCBtYXhQYWdlSW5kZXgpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5vbGQsXG4gICAgICAgICAgcGFnZUluZGV4XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRhYmxlLnJlc2V0UGFnZUluZGV4ID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJHAyLCBfdGFibGUkaW5pdGlhbFN0YXRlO1xuICAgICAgdGFibGUuc2V0UGFnZUluZGV4KGRlZmF1bHRTdGF0ZSA/IGRlZmF1bHRQYWdlSW5kZXggOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRwMiA9IChfdGFibGUkaW5pdGlhbFN0YXRlID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsIHx8IChfdGFibGUkaW5pdGlhbFN0YXRlID0gX3RhYmxlJGluaXRpYWxTdGF0ZS5wYWdpbmF0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZS5wYWdlSW5kZXgpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJHAyIDogZGVmYXVsdFBhZ2VJbmRleCk7XG4gICAgfTtcbiAgICB0YWJsZS5yZXNldFBhZ2VTaXplID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJHAzLCBfdGFibGUkaW5pdGlhbFN0YXRlMjtcbiAgICAgIHRhYmxlLnNldFBhZ2VTaXplKGRlZmF1bHRTdGF0ZSA/IGRlZmF1bHRQYWdlU2l6ZSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJHAzID0gKF90YWJsZSRpbml0aWFsU3RhdGUyID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsIHx8IChfdGFibGUkaW5pdGlhbFN0YXRlMiA9IF90YWJsZSRpbml0aWFsU3RhdGUyLnBhZ2luYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlMi5wYWdlU2l6ZSkgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkcDMgOiBkZWZhdWx0UGFnZVNpemUpO1xuICAgIH07XG4gICAgdGFibGUuc2V0UGFnZVNpemUgPSB1cGRhdGVyID0+IHtcbiAgICAgIHRhYmxlLnNldFBhZ2luYXRpb24ob2xkID0+IHtcbiAgICAgICAgY29uc3QgcGFnZVNpemUgPSBNYXRoLm1heCgxLCBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIG9sZC5wYWdlU2l6ZSkpO1xuICAgICAgICBjb25zdCB0b3BSb3dJbmRleCA9IG9sZC5wYWdlU2l6ZSAqIG9sZC5wYWdlSW5kZXg7XG4gICAgICAgIGNvbnN0IHBhZ2VJbmRleCA9IE1hdGguZmxvb3IodG9wUm93SW5kZXggLyBwYWdlU2l6ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgIHBhZ2VJbmRleCxcbiAgICAgICAgICBwYWdlU2l6ZVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0YWJsZS5zZXRQYWdlQ291bnQgPSB1cGRhdGVyID0+IHRhYmxlLnNldFBhZ2luYXRpb24ob2xkID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRwYWdlQ287XG4gICAgICBsZXQgbmV3UGFnZUNvdW50ID0gZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCAoX3RhYmxlJG9wdGlvbnMkcGFnZUNvID0gdGFibGUub3B0aW9ucy5wYWdlQ291bnQpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRwYWdlQ28gOiAtMSk7XG4gICAgICBpZiAodHlwZW9mIG5ld1BhZ2VDb3VudCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbmV3UGFnZUNvdW50ID0gTWF0aC5tYXgoLTEsIG5ld1BhZ2VDb3VudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5vbGQsXG4gICAgICAgIHBhZ2VDb3VudDogbmV3UGFnZUNvdW50XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHRhYmxlLmdldFBhZ2VPcHRpb25zID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0UGFnZUNvdW50KCldLCBwYWdlQ291bnQgPT4ge1xuICAgICAgbGV0IHBhZ2VPcHRpb25zID0gW107XG4gICAgICBpZiAocGFnZUNvdW50ICYmIHBhZ2VDb3VudCA+IDApIHtcbiAgICAgICAgcGFnZU9wdGlvbnMgPSBbLi4ubmV3IEFycmF5KHBhZ2VDb3VudCldLmZpbGwobnVsbCkubWFwKChfLCBpKSA9PiBpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYWdlT3B0aW9ucztcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRQYWdlT3B0aW9ucycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnVGFibGU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0Q2FuUHJldmlvdXNQYWdlID0gKCkgPT4gdGFibGUuZ2V0U3RhdGUoKS5wYWdpbmF0aW9uLnBhZ2VJbmRleCA+IDA7XG4gICAgdGFibGUuZ2V0Q2FuTmV4dFBhZ2UgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhZ2VJbmRleFxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCkucGFnaW5hdGlvbjtcbiAgICAgIGNvbnN0IHBhZ2VDb3VudCA9IHRhYmxlLmdldFBhZ2VDb3VudCgpO1xuICAgICAgaWYgKHBhZ2VDb3VudCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocGFnZUNvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYWdlSW5kZXggPCBwYWdlQ291bnQgLSAxO1xuICAgIH07XG4gICAgdGFibGUucHJldmlvdXNQYWdlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlLnNldFBhZ2VJbmRleChvbGQgPT4gb2xkIC0gMSk7XG4gICAgfTtcbiAgICB0YWJsZS5uZXh0UGFnZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZS5zZXRQYWdlSW5kZXgob2xkID0+IHtcbiAgICAgICAgcmV0dXJuIG9sZCArIDE7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCA9ICgpID0+IHRhYmxlLmdldEV4cGFuZGVkUm93TW9kZWwoKTtcbiAgICB0YWJsZS5nZXRQYWdpbmF0aW9uUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRQYWdpbmF0aW9uUm93TW9kZWwgJiYgdGFibGUub3B0aW9ucy5nZXRQYWdpbmF0aW9uUm93TW9kZWwpIHtcbiAgICAgICAgdGFibGUuX2dldFBhZ2luYXRpb25Sb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0UGFnaW5hdGlvblJvd01vZGVsKHRhYmxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0YWJsZS5vcHRpb25zLm1hbnVhbFBhZ2luYXRpb24gfHwgIXRhYmxlLl9nZXRQYWdpbmF0aW9uUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRQYWdpbmF0aW9uUm93TW9kZWwoKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFBhZ2VDb3VudCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRwYWdlQ28yO1xuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRwYWdlQ28yID0gdGFibGUub3B0aW9ucy5wYWdlQ291bnQpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRwYWdlQ28yIDogTWF0aC5jZWlsKHRhYmxlLmdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCgpLnJvd3MubGVuZ3RoIC8gdGFibGUuZ2V0U3RhdGUoKS5wYWdpbmF0aW9uLnBhZ2VTaXplKTtcbiAgICB9O1xuICB9XG59O1xuXG4vL1xuXG5jb25zdCBnZXREZWZhdWx0Q29sdW1uUGlubmluZ1N0YXRlID0gKCkgPT4gKHtcbiAgbGVmdDogW10sXG4gIHJpZ2h0OiBbXVxufSk7XG5jb25zdCBnZXREZWZhdWx0Um93UGlubmluZ1N0YXRlID0gKCkgPT4gKHtcbiAgdG9wOiBbXSxcbiAgYm90dG9tOiBbXVxufSk7XG5jb25zdCBQaW5uaW5nID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uUGlubmluZzogZ2V0RGVmYXVsdENvbHVtblBpbm5pbmdTdGF0ZSgpLFxuICAgICAgcm93UGlubmluZzogZ2V0RGVmYXVsdFJvd1Bpbm5pbmdTdGF0ZSgpLFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvbkNvbHVtblBpbm5pbmdDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2NvbHVtblBpbm5pbmcnLCB0YWJsZSksXG4gICAgICBvblJvd1Bpbm5pbmdDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ3Jvd1Bpbm5pbmcnLCB0YWJsZSlcbiAgICB9O1xuICB9LFxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XG4gICAgY29sdW1uLnBpbiA9IHBvc2l0aW9uID0+IHtcbiAgICAgIGNvbnN0IGNvbHVtbklkcyA9IGNvbHVtbi5nZXRMZWFmQ29sdW1ucygpLm1hcChkID0+IGQuaWQpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIHRhYmxlLnNldENvbHVtblBpbm5pbmcob2xkID0+IHtcbiAgICAgICAgdmFyIF9vbGQkbGVmdDMsIF9vbGQkcmlnaHQzO1xuICAgICAgICBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICB2YXIgX29sZCRsZWZ0LCBfb2xkJHJpZ2h0O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiAoKF9vbGQkbGVmdCA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmxlZnQpICE9IG51bGwgPyBfb2xkJGxlZnQgOiBbXSkuZmlsdGVyKGQgPT4gIShjb2x1bW5JZHMgIT0gbnVsbCAmJiBjb2x1bW5JZHMuaW5jbHVkZXMoZCkpKSxcbiAgICAgICAgICAgIHJpZ2h0OiBbLi4uKChfb2xkJHJpZ2h0ID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQucmlnaHQpICE9IG51bGwgPyBfb2xkJHJpZ2h0IDogW10pLmZpbHRlcihkID0+ICEoY29sdW1uSWRzICE9IG51bGwgJiYgY29sdW1uSWRzLmluY2x1ZGVzKGQpKSksIC4uLmNvbHVtbklkc11cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgdmFyIF9vbGQkbGVmdDIsIF9vbGQkcmlnaHQyO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiBbLi4uKChfb2xkJGxlZnQyID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQubGVmdCkgIT0gbnVsbCA/IF9vbGQkbGVmdDIgOiBbXSkuZmlsdGVyKGQgPT4gIShjb2x1bW5JZHMgIT0gbnVsbCAmJiBjb2x1bW5JZHMuaW5jbHVkZXMoZCkpKSwgLi4uY29sdW1uSWRzXSxcbiAgICAgICAgICAgIHJpZ2h0OiAoKF9vbGQkcmlnaHQyID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQucmlnaHQpICE9IG51bGwgPyBfb2xkJHJpZ2h0MiA6IFtdKS5maWx0ZXIoZCA9PiAhKGNvbHVtbklkcyAhPSBudWxsICYmIGNvbHVtbklkcy5pbmNsdWRlcyhkKSkpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxlZnQ6ICgoX29sZCRsZWZ0MyA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmxlZnQpICE9IG51bGwgPyBfb2xkJGxlZnQzIDogW10pLmZpbHRlcihkID0+ICEoY29sdW1uSWRzICE9IG51bGwgJiYgY29sdW1uSWRzLmluY2x1ZGVzKGQpKSksXG4gICAgICAgICAgcmlnaHQ6ICgoX29sZCRyaWdodDMgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5yaWdodCkgIT0gbnVsbCA/IF9vbGQkcmlnaHQzIDogW10pLmZpbHRlcihkID0+ICEoY29sdW1uSWRzICE9IG51bGwgJiYgY29sdW1uSWRzLmluY2x1ZGVzKGQpKSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29sdW1uLmdldENhblBpbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGxlYWZDb2x1bW5zID0gY29sdW1uLmdldExlYWZDb2x1bW5zKCk7XG4gICAgICByZXR1cm4gbGVhZkNvbHVtbnMuc29tZShkID0+IHtcbiAgICAgICAgdmFyIF9kJGNvbHVtbkRlZiRlbmFibGVQaSwgX3JlZiwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlO1xuICAgICAgICByZXR1cm4gKChfZCRjb2x1bW5EZWYkZW5hYmxlUGkgPSBkLmNvbHVtbkRlZi5lbmFibGVQaW5uaW5nKSAhPSBudWxsID8gX2QkY29sdW1uRGVmJGVuYWJsZVBpIDogdHJ1ZSkgJiYgKChfcmVmID0gKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlQ29sdW1uUGlubmluZykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRhYmxlLm9wdGlvbnMuZW5hYmxlUGlubmluZykgIT0gbnVsbCA/IF9yZWYgOiB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29sdW1uLmdldElzUGlubmVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgbGVhZkNvbHVtbklkcyA9IGNvbHVtbi5nZXRMZWFmQ29sdW1ucygpLm1hcChkID0+IGQuaWQpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBsZWZ0LFxuICAgICAgICByaWdodFxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZztcbiAgICAgIGNvbnN0IGlzTGVmdCA9IGxlYWZDb2x1bW5JZHMuc29tZShkID0+IGxlZnQgPT0gbnVsbCA/IHZvaWQgMCA6IGxlZnQuaW5jbHVkZXMoZCkpO1xuICAgICAgY29uc3QgaXNSaWdodCA9IGxlYWZDb2x1bW5JZHMuc29tZShkID0+IHJpZ2h0ID09IG51bGwgPyB2b2lkIDAgOiByaWdodC5pbmNsdWRlcyhkKSk7XG4gICAgICByZXR1cm4gaXNMZWZ0ID8gJ2xlZnQnIDogaXNSaWdodCA/ICdyaWdodCcgOiBmYWxzZTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRQaW5uZWRJbmRleCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkY29sdW0sIF90YWJsZSRnZXRTdGF0ZSRjb2x1bTI7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGNvbHVtbi5nZXRJc1Bpbm5lZCgpO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uID8gKF90YWJsZSRnZXRTdGF0ZSRjb2x1bSA9IChfdGFibGUkZ2V0U3RhdGUkY29sdW0yID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nKSA9PSBudWxsIHx8IChfdGFibGUkZ2V0U3RhdGUkY29sdW0yID0gX3RhYmxlJGdldFN0YXRlJGNvbHVtMltwb3NpdGlvbl0pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkY29sdW0yLmluZGV4T2YoY29sdW1uLmlkKSkgIT0gbnVsbCA/IF90YWJsZSRnZXRTdGF0ZSRjb2x1bSA6IC0xIDogMDtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVSb3c6IChyb3csIHRhYmxlKSA9PiB7XG4gICAgcm93LnBpbiA9IChwb3NpdGlvbiwgaW5jbHVkZUxlYWZSb3dzLCBpbmNsdWRlUGFyZW50Um93cykgPT4ge1xuICAgICAgY29uc3QgbGVhZlJvd0lkcyA9IGluY2x1ZGVMZWFmUm93cyA/IHJvdy5nZXRMZWFmUm93cygpLm1hcChfcmVmMiA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IF9yZWYyO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9KSA6IFtdO1xuICAgICAgY29uc3QgcGFyZW50Um93SWRzID0gaW5jbHVkZVBhcmVudFJvd3MgPyByb3cuZ2V0UGFyZW50Um93cygpLm1hcChfcmVmMyA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IF9yZWYzO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9KSA6IFtdO1xuICAgICAgY29uc3Qgcm93SWRzID0gbmV3IFNldChbLi4ucGFyZW50Um93SWRzLCByb3cuaWQsIC4uLmxlYWZSb3dJZHNdKTtcbiAgICAgIHRhYmxlLnNldFJvd1Bpbm5pbmcob2xkID0+IHtcbiAgICAgICAgdmFyIF9vbGQkdG9wMywgX29sZCRib3R0b20zO1xuICAgICAgICBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgdmFyIF9vbGQkdG9wLCBfb2xkJGJvdHRvbTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiAoKF9vbGQkdG9wID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQudG9wKSAhPSBudWxsID8gX29sZCR0b3AgOiBbXSkuZmlsdGVyKGQgPT4gIShyb3dJZHMgIT0gbnVsbCAmJiByb3dJZHMuaGFzKGQpKSksXG4gICAgICAgICAgICBib3R0b206IFsuLi4oKF9vbGQkYm90dG9tID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuYm90dG9tKSAhPSBudWxsID8gX29sZCRib3R0b20gOiBbXSkuZmlsdGVyKGQgPT4gIShyb3dJZHMgIT0gbnVsbCAmJiByb3dJZHMuaGFzKGQpKSksIC4uLkFycmF5LmZyb20ocm93SWRzKV1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICB2YXIgX29sZCR0b3AyLCBfb2xkJGJvdHRvbTI7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogWy4uLigoX29sZCR0b3AyID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQudG9wKSAhPSBudWxsID8gX29sZCR0b3AyIDogW10pLmZpbHRlcihkID0+ICEocm93SWRzICE9IG51bGwgJiYgcm93SWRzLmhhcyhkKSkpLCAuLi5BcnJheS5mcm9tKHJvd0lkcyldLFxuICAgICAgICAgICAgYm90dG9tOiAoKF9vbGQkYm90dG9tMiA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmJvdHRvbSkgIT0gbnVsbCA/IF9vbGQkYm90dG9tMiA6IFtdKS5maWx0ZXIoZCA9PiAhKHJvd0lkcyAhPSBudWxsICYmIHJvd0lkcy5oYXMoZCkpKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b3A6ICgoX29sZCR0b3AzID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQudG9wKSAhPSBudWxsID8gX29sZCR0b3AzIDogW10pLmZpbHRlcihkID0+ICEocm93SWRzICE9IG51bGwgJiYgcm93SWRzLmhhcyhkKSkpLFxuICAgICAgICAgIGJvdHRvbTogKChfb2xkJGJvdHRvbTMgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5ib3R0b20pICE9IG51bGwgPyBfb2xkJGJvdHRvbTMgOiBbXSkuZmlsdGVyKGQgPT4gIShyb3dJZHMgIT0gbnVsbCAmJiByb3dJZHMuaGFzKGQpKSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcm93LmdldENhblBpbiA9ICgpID0+IHtcbiAgICAgIHZhciBfcmVmNDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZW5hYmxlUm93UGlubmluZyxcbiAgICAgICAgZW5hYmxlUGlubmluZ1xuICAgICAgfSA9IHRhYmxlLm9wdGlvbnM7XG4gICAgICBpZiAodHlwZW9mIGVuYWJsZVJvd1Bpbm5pbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGVuYWJsZVJvd1Bpbm5pbmcocm93KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoX3JlZjQgPSBlbmFibGVSb3dQaW5uaW5nICE9IG51bGwgPyBlbmFibGVSb3dQaW5uaW5nIDogZW5hYmxlUGlubmluZykgIT0gbnVsbCA/IF9yZWY0IDogdHJ1ZTtcbiAgICB9O1xuICAgIHJvdy5nZXRJc1Bpbm5lZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHJvd0lkcyA9IFtyb3cuaWRdO1xuICAgICAgY29uc3Qge1xuICAgICAgICB0b3AsXG4gICAgICAgIGJvdHRvbVxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCkucm93UGlubmluZztcbiAgICAgIGNvbnN0IGlzVG9wID0gcm93SWRzLnNvbWUoZCA9PiB0b3AgPT0gbnVsbCA/IHZvaWQgMCA6IHRvcC5pbmNsdWRlcyhkKSk7XG4gICAgICBjb25zdCBpc0JvdHRvbSA9IHJvd0lkcy5zb21lKGQgPT4gYm90dG9tID09IG51bGwgPyB2b2lkIDAgOiBib3R0b20uaW5jbHVkZXMoZCkpO1xuICAgICAgcmV0dXJuIGlzVG9wID8gJ3RvcCcgOiBpc0JvdHRvbSA/ICdib3R0b20nIDogZmFsc2U7XG4gICAgfTtcbiAgICByb3cuZ2V0UGlubmVkSW5kZXggPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJF9nZXRQaW5uZWRSb3dzLCBfdmlzaWJsZVBpbm5lZFJvd0lkcyQ7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHJvdy5nZXRJc1Bpbm5lZCgpO1xuICAgICAgaWYgKCFwb3NpdGlvbikgcmV0dXJuIC0xO1xuICAgICAgY29uc3QgdmlzaWJsZVBpbm5lZFJvd0lkcyA9IChfdGFibGUkX2dldFBpbm5lZFJvd3MgPSB0YWJsZS5fZ2V0UGlubmVkUm93cyhwb3NpdGlvbikpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkX2dldFBpbm5lZFJvd3MubWFwKF9yZWY1ID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gX3JlZjU7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIChfdmlzaWJsZVBpbm5lZFJvd0lkcyQgPSB2aXNpYmxlUGlubmVkUm93SWRzID09IG51bGwgPyB2b2lkIDAgOiB2aXNpYmxlUGlubmVkUm93SWRzLmluZGV4T2Yocm93LmlkKSkgIT0gbnVsbCA/IF92aXNpYmxlUGlubmVkUm93SWRzJCA6IC0xO1xuICAgIH07XG4gICAgcm93LmdldENlbnRlclZpc2libGVDZWxscyA9IG1lbW8oKCkgPT4gW3Jvdy5fZ2V0QWxsVmlzaWJsZUNlbGxzKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0LCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ2VsbHMsIGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICBjb25zdCBsZWZ0QW5kUmlnaHQgPSBbLi4uKGxlZnQgIT0gbnVsbCA/IGxlZnQgOiBbXSksIC4uLihyaWdodCAhPSBudWxsID8gcmlnaHQgOiBbXSldO1xuICAgICAgcmV0dXJuIGFsbENlbGxzLmZpbHRlcihkID0+ICFsZWZ0QW5kUmlnaHQuaW5jbHVkZXMoZC5jb2x1bW4uaWQpKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdyb3cuZ2V0Q2VudGVyVmlzaWJsZUNlbGxzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQSA6IHRhYmxlLm9wdGlvbnMuZGVidWdSb3dzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJvdy5nZXRMZWZ0VmlzaWJsZUNlbGxzID0gbWVtbygoKSA9PiBbcm93Ll9nZXRBbGxWaXNpYmxlQ2VsbHMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnQsLF0sIChhbGxDZWxscywgbGVmdCkgPT4ge1xuICAgICAgY29uc3QgY2VsbHMgPSAobGVmdCAhPSBudWxsID8gbGVmdCA6IFtdKS5tYXAoY29sdW1uSWQgPT4gYWxsQ2VsbHMuZmluZChjZWxsID0+IGNlbGwuY29sdW1uLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKS5tYXAoZCA9PiAoe1xuICAgICAgICAuLi5kLFxuICAgICAgICBwb3NpdGlvbjogJ2xlZnQnXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gY2VsbHM7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAncm93LmdldExlZnRWaXNpYmxlQ2VsbHMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTI7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBMiA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyIDogdGFibGUub3B0aW9ucy5kZWJ1Z1Jvd3M7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcm93LmdldFJpZ2h0VmlzaWJsZUNlbGxzID0gbWVtbygoKSA9PiBbcm93Ll9nZXRBbGxWaXNpYmxlQ2VsbHMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0XSwgKGFsbENlbGxzLCByaWdodCkgPT4ge1xuICAgICAgY29uc3QgY2VsbHMgPSAocmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogW10pLm1hcChjb2x1bW5JZCA9PiBhbGxDZWxscy5maW5kKGNlbGwgPT4gY2VsbC5jb2x1bW4uaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pLm1hcChkID0+ICh7XG4gICAgICAgIC4uLmQsXG4gICAgICAgIHBvc2l0aW9uOiAncmlnaHQnXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gY2VsbHM7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAncm93LmdldFJpZ2h0VmlzaWJsZUNlbGxzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EzO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTMgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMyA6IHRhYmxlLm9wdGlvbnMuZGVidWdSb3dzO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLnNldENvbHVtblBpbm5pbmcgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Db2x1bW5QaW5uaW5nQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uUGlubmluZ0NoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldENvbHVtblBpbm5pbmcgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkYywgX3RhYmxlJGluaXRpYWxTdGF0ZTtcbiAgICAgIHJldHVybiB0YWJsZS5zZXRDb2x1bW5QaW5uaW5nKGRlZmF1bHRTdGF0ZSA/IGdldERlZmF1bHRDb2x1bW5QaW5uaW5nU3RhdGUoKSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGMgPSAoX3RhYmxlJGluaXRpYWxTdGF0ZSA9IHRhYmxlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUuY29sdW1uUGlubmluZykgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkYyA6IGdldERlZmF1bHRDb2x1bW5QaW5uaW5nU3RhdGUoKSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc1NvbWVDb2x1bW5zUGlubmVkID0gcG9zaXRpb24gPT4ge1xuICAgICAgdmFyIF9waW5uaW5nU3RhdGUkcG9zaXRpbztcbiAgICAgIGNvbnN0IHBpbm5pbmdTdGF0ZSA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZztcbiAgICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIF9waW5uaW5nU3RhdGUkbGVmdCwgX3Bpbm5pbmdTdGF0ZSRyaWdodDtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oKChfcGlubmluZ1N0YXRlJGxlZnQgPSBwaW5uaW5nU3RhdGUubGVmdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkbGVmdC5sZW5ndGgpIHx8ICgoX3Bpbm5pbmdTdGF0ZSRyaWdodCA9IHBpbm5pbmdTdGF0ZS5yaWdodCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkcmlnaHQubGVuZ3RoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQm9vbGVhbigoX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvID0gcGlubmluZ1N0YXRlW3Bvc2l0aW9uXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkcG9zaXRpby5sZW5ndGgpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0TGVmdExlYWZDb2x1bW5zID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnRdLCAoYWxsQ29sdW1ucywgbGVmdCkgPT4ge1xuICAgICAgcmV0dXJuIChsZWZ0ICE9IG51bGwgPyBsZWZ0IDogW10pLm1hcChjb2x1bW5JZCA9PiBhbGxDb2x1bW5zLmZpbmQoY29sdW1uID0+IGNvbHVtbi5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0TGVmdExlYWZDb2x1bW5zJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E0O1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTQgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBNCA6IHRhYmxlLm9wdGlvbnMuZGVidWdDb2x1bW5zO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRhYmxlLmdldFJpZ2h0TGVhZkNvbHVtbnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ29sdW1ucywgcmlnaHQpID0+IHtcbiAgICAgIHJldHVybiAocmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogW10pLm1hcChjb2x1bW5JZCA9PiBhbGxDb2x1bW5zLmZpbmQoY29sdW1uID0+IGNvbHVtbi5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0UmlnaHRMZWFmQ29sdW1ucycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBNTtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0E1ID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTUgOiB0YWJsZS5vcHRpb25zLmRlYnVnQ29sdW1ucztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJsZS5nZXRDZW50ZXJMZWFmQ29sdW1ucyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbExlYWZDb2x1bW5zKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0LCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ29sdW1ucywgbGVmdCwgcmlnaHQpID0+IHtcbiAgICAgIGNvbnN0IGxlZnRBbmRSaWdodCA9IFsuLi4obGVmdCAhPSBudWxsID8gbGVmdCA6IFtdKSwgLi4uKHJpZ2h0ICE9IG51bGwgPyByaWdodCA6IFtdKV07XG4gICAgICByZXR1cm4gYWxsQ29sdW1ucy5maWx0ZXIoZCA9PiAhbGVmdEFuZFJpZ2h0LmluY2x1ZGVzKGQuaWQpKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRDZW50ZXJMZWFmQ29sdW1ucycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBNjtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0E2ID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTYgOiB0YWJsZS5vcHRpb25zLmRlYnVnQ29sdW1ucztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWJsZS5zZXRSb3dQaW5uaW5nID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uUm93UGlubmluZ0NoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vblJvd1Bpbm5pbmdDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRSb3dQaW5uaW5nID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJHIsIF90YWJsZSRpbml0aWFsU3RhdGUyO1xuICAgICAgcmV0dXJuIHRhYmxlLnNldFJvd1Bpbm5pbmcoZGVmYXVsdFN0YXRlID8gZ2V0RGVmYXVsdFJvd1Bpbm5pbmdTdGF0ZSgpIDogKF90YWJsZSRpbml0aWFsU3RhdGUkciA9IChfdGFibGUkaW5pdGlhbFN0YXRlMiA9IHRhYmxlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUyLnJvd1Bpbm5pbmcpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJHIgOiBnZXREZWZhdWx0Um93UGlubmluZ1N0YXRlKCkpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0SXNTb21lUm93c1Bpbm5lZCA9IHBvc2l0aW9uID0+IHtcbiAgICAgIHZhciBfcGlubmluZ1N0YXRlJHBvc2l0aW8yO1xuICAgICAgY29uc3QgcGlubmluZ1N0YXRlID0gdGFibGUuZ2V0U3RhdGUoKS5yb3dQaW5uaW5nO1xuICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICB2YXIgX3Bpbm5pbmdTdGF0ZSR0b3AsIF9waW5uaW5nU3RhdGUkYm90dG9tO1xuICAgICAgICByZXR1cm4gQm9vbGVhbigoKF9waW5uaW5nU3RhdGUkdG9wID0gcGlubmluZ1N0YXRlLnRvcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkdG9wLmxlbmd0aCkgfHwgKChfcGlubmluZ1N0YXRlJGJvdHRvbSA9IHBpbm5pbmdTdGF0ZS5ib3R0b20pID09IG51bGwgPyB2b2lkIDAgOiBfcGlubmluZ1N0YXRlJGJvdHRvbS5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBCb29sZWFuKChfcGlubmluZ1N0YXRlJHBvc2l0aW8yID0gcGlubmluZ1N0YXRlW3Bvc2l0aW9uXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkcG9zaXRpbzIubGVuZ3RoKTtcbiAgICB9O1xuICAgIHRhYmxlLl9nZXRQaW5uZWRSb3dzID0gcG9zaXRpb24gPT4gbWVtbygoKSA9PiBbdGFibGUuZ2V0Um93TW9kZWwoKS5yb3dzLCB0YWJsZS5nZXRTdGF0ZSgpLnJvd1Bpbm5pbmdbcG9zaXRpb25dXSwgKHZpc2libGVSb3dzLCBwaW5uZWRSb3dJZHMpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRrZWVwUGk7XG4gICAgICBjb25zdCByb3dzID0gKChfdGFibGUkb3B0aW9ucyRrZWVwUGkgPSB0YWJsZS5vcHRpb25zLmtlZXBQaW5uZWRSb3dzKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMka2VlcFBpIDogdHJ1ZSkgP1xuICAgICAgLy9nZXQgYWxsIHJvd3MgdGhhdCBhcmUgcGlubmVkIGV2ZW4gaWYgdGhleSB3b3VsZCBub3QgYmUgb3RoZXJ3aXNlIHZpc2libGVcbiAgICAgIC8vYWNjb3VudCBmb3IgZXhwYW5kZWQgcGFyZW50IHJvd3MsIGJ1dCBub3QgcGFnaW5hdGlvbiBvciBmaWx0ZXJpbmdcbiAgICAgIChwaW5uZWRSb3dJZHMgIT0gbnVsbCA/IHBpbm5lZFJvd0lkcyA6IFtdKS5tYXAocm93SWQgPT4ge1xuICAgICAgICBjb25zdCByb3cgPSB0YWJsZS5nZXRSb3cocm93SWQsIHRydWUpO1xuICAgICAgICByZXR1cm4gcm93LmdldElzQWxsUGFyZW50c0V4cGFuZGVkKCkgPyByb3cgOiBudWxsO1xuICAgICAgfSkgOlxuICAgICAgLy9lbHNlIGdldCBvbmx5IHZpc2libGUgcm93cyB0aGF0IGFyZSBwaW5uZWRcbiAgICAgIChwaW5uZWRSb3dJZHMgIT0gbnVsbCA/IHBpbm5lZFJvd0lkcyA6IFtdKS5tYXAocm93SWQgPT4gdmlzaWJsZVJvd3MuZmluZChyb3cgPT4gcm93LmlkID09PSByb3dJZCkpO1xuICAgICAgcmV0dXJuIHJvd3MuZmlsdGVyKEJvb2xlYW4pLm1hcChkID0+ICh7XG4gICAgICAgIC4uLmQsXG4gICAgICAgIHBvc2l0aW9uXG4gICAgICB9KSk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBgcm93LmdldCR7cG9zaXRpb24gPT09ICd0b3AnID8gJ1RvcCcgOiAnQm90dG9tJ31Sb3dzYCxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E3O1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTcgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBNyA6IHRhYmxlLm9wdGlvbnMuZGVidWdSb3dzO1xuICAgICAgfVxuICAgIH0pKCk7XG4gICAgdGFibGUuZ2V0VG9wUm93cyA9ICgpID0+IHRhYmxlLl9nZXRQaW5uZWRSb3dzKCd0b3AnKTtcbiAgICB0YWJsZS5nZXRCb3R0b21Sb3dzID0gKCkgPT4gdGFibGUuX2dldFBpbm5lZFJvd3MoJ2JvdHRvbScpO1xuICAgIHRhYmxlLmdldENlbnRlclJvd3MgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRSb3dNb2RlbCgpLnJvd3MsIHRhYmxlLmdldFN0YXRlKCkucm93UGlubmluZy50b3AsIHRhYmxlLmdldFN0YXRlKCkucm93UGlubmluZy5ib3R0b21dLCAoYWxsUm93cywgdG9wLCBib3R0b20pID0+IHtcbiAgICAgIGNvbnN0IHRvcEFuZEJvdHRvbSA9IG5ldyBTZXQoWy4uLih0b3AgIT0gbnVsbCA/IHRvcCA6IFtdKSwgLi4uKGJvdHRvbSAhPSBudWxsID8gYm90dG9tIDogW10pXSk7XG4gICAgICByZXR1cm4gYWxsUm93cy5maWx0ZXIoZCA9PiAhdG9wQW5kQm90dG9tLmhhcyhkLmlkKSk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAncm93LmdldENlbnRlclJvd3MnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTg7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBOCA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E4IDogdGFibGUub3B0aW9ucy5kZWJ1Z1Jvd3M7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vXG5cbmNvbnN0IFJvd1NlbGVjdGlvbiA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvd1NlbGVjdGlvbjoge30sXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uUm93U2VsZWN0aW9uQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdyb3dTZWxlY3Rpb24nLCB0YWJsZSksXG4gICAgICBlbmFibGVSb3dTZWxlY3Rpb246IHRydWUsXG4gICAgICBlbmFibGVNdWx0aVJvd1NlbGVjdGlvbjogdHJ1ZSxcbiAgICAgIGVuYWJsZVN1YlJvd1NlbGVjdGlvbjogdHJ1ZVxuICAgICAgLy8gZW5hYmxlR3JvdXBpbmdSb3dTZWxlY3Rpb246IGZhbHNlLFxuICAgICAgLy8gaXNBZGRpdGl2ZVNlbGVjdEV2ZW50OiAoZTogdW5rbm93bikgPT4gISFlLm1ldGFLZXksXG4gICAgICAvLyBpc0luY2x1c2l2ZVNlbGVjdEV2ZW50OiAoZTogdW5rbm93bikgPT4gISFlLnNoaWZ0S2V5LFxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgdGFibGUuc2V0Um93U2VsZWN0aW9uID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uUm93U2VsZWN0aW9uQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uUm93U2VsZWN0aW9uQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnJlc2V0Um93U2VsZWN0aW9uID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJHI7XG4gICAgICByZXR1cm4gdGFibGUuc2V0Um93U2VsZWN0aW9uKGRlZmF1bHRTdGF0ZSA/IHt9IDogKF90YWJsZSRpbml0aWFsU3RhdGUkciA9IHRhYmxlLmluaXRpYWxTdGF0ZS5yb3dTZWxlY3Rpb24pICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJHIgOiB7fSk7XG4gICAgfTtcbiAgICB0YWJsZS50b2dnbGVBbGxSb3dzU2VsZWN0ZWQgPSB2YWx1ZSA9PiB7XG4gICAgICB0YWJsZS5zZXRSb3dTZWxlY3Rpb24ob2xkID0+IHtcbiAgICAgICAgdmFsdWUgPSB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnID8gdmFsdWUgOiAhdGFibGUuZ2V0SXNBbGxSb3dzU2VsZWN0ZWQoKTtcbiAgICAgICAgY29uc3Qgcm93U2VsZWN0aW9uID0ge1xuICAgICAgICAgIC4uLm9sZFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwcmVHcm91cGVkRmxhdFJvd3MgPSB0YWJsZS5nZXRQcmVHcm91cGVkUm93TW9kZWwoKS5mbGF0Um93cztcblxuICAgICAgICAvLyBXZSBkb24ndCB1c2UgYG11dGF0ZVJvd0lzU2VsZWN0ZWRgIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gICAgICAgIC8vIEFsbCBvZiB0aGUgcm93cyBhcmUgZmxhdCBhbHJlYWR5LCBzbyBpdCB3b3VsZG4ndCBiZSB3b3J0aCBpdFxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBwcmVHcm91cGVkRmxhdFJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICAgICAgaWYgKCFyb3cuZ2V0Q2FuU2VsZWN0KCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93U2VsZWN0aW9uW3Jvdy5pZF0gPSB0cnVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZUdyb3VwZWRGbGF0Um93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgICAgICBkZWxldGUgcm93U2VsZWN0aW9uW3Jvdy5pZF07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvd1NlbGVjdGlvbjtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGFibGUudG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZCA9IHZhbHVlID0+IHRhYmxlLnNldFJvd1NlbGVjdGlvbihvbGQgPT4ge1xuICAgICAgY29uc3QgcmVzb2x2ZWRWYWx1ZSA9IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgPyB2YWx1ZSA6ICF0YWJsZS5nZXRJc0FsbFBhZ2VSb3dzU2VsZWN0ZWQoKTtcbiAgICAgIGNvbnN0IHJvd1NlbGVjdGlvbiA9IHtcbiAgICAgICAgLi4ub2xkXG4gICAgICB9O1xuICAgICAgdGFibGUuZ2V0Um93TW9kZWwoKS5yb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgbXV0YXRlUm93SXNTZWxlY3RlZChyb3dTZWxlY3Rpb24sIHJvdy5pZCwgcmVzb2x2ZWRWYWx1ZSwgdHJ1ZSwgdGFibGUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcm93U2VsZWN0aW9uO1xuICAgIH0pO1xuXG4gICAgLy8gYWRkUm93U2VsZWN0aW9uUmFuZ2U6IHJvd0lkID0+IHtcbiAgICAvLyAgIGNvbnN0IHtcbiAgICAvLyAgICAgcm93cyxcbiAgICAvLyAgICAgcm93c0J5SWQsXG4gICAgLy8gICAgIG9wdGlvbnM6IHsgc2VsZWN0R3JvdXBpbmdSb3dzLCBzZWxlY3RTdWJSb3dzIH0sXG4gICAgLy8gICB9ID0gdGFibGVcblxuICAgIC8vICAgY29uc3QgZmluZFNlbGVjdGVkUm93ID0gKHJvd3M6IFJvd1tdKSA9PiB7XG4gICAgLy8gICAgIGxldCBmb3VuZFxuICAgIC8vICAgICByb3dzLmZpbmQoZCA9PiB7XG4gICAgLy8gICAgICAgaWYgKGQuZ2V0SXNTZWxlY3RlZCgpKSB7XG4gICAgLy8gICAgICAgICBmb3VuZCA9IGRcbiAgICAvLyAgICAgICAgIHJldHVybiB0cnVlXG4gICAgLy8gICAgICAgfVxuICAgIC8vICAgICAgIGNvbnN0IHN1YkZvdW5kID0gZmluZFNlbGVjdGVkUm93KGQuc3ViUm93cyB8fCBbXSlcbiAgICAvLyAgICAgICBpZiAoc3ViRm91bmQpIHtcbiAgICAvLyAgICAgICAgIGZvdW5kID0gc3ViRm91bmRcbiAgICAvLyAgICAgICAgIHJldHVybiB0cnVlXG4gICAgLy8gICAgICAgfVxuICAgIC8vICAgICAgIHJldHVybiBmYWxzZVxuICAgIC8vICAgICB9KVxuICAgIC8vICAgICByZXR1cm4gZm91bmRcbiAgICAvLyAgIH1cblxuICAgIC8vICAgY29uc3QgZmlyc3RSb3cgPSBmaW5kU2VsZWN0ZWRSb3cocm93cykgfHwgcm93c1swXVxuICAgIC8vICAgY29uc3QgbGFzdFJvdyA9IHJvd3NCeUlkW3Jvd0lkXVxuXG4gICAgLy8gICBsZXQgaW5jbHVkZSA9IGZhbHNlXG4gICAgLy8gICBjb25zdCBzZWxlY3RlZFJvd0lkcyA9IHt9XG5cbiAgICAvLyAgIGNvbnN0IGFkZFJvdyA9IChyb3c6IFJvdykgPT4ge1xuICAgIC8vICAgICBtdXRhdGVSb3dJc1NlbGVjdGVkKHNlbGVjdGVkUm93SWRzLCByb3cuaWQsIHRydWUsIHtcbiAgICAvLyAgICAgICByb3dzQnlJZCxcbiAgICAvLyAgICAgICBzZWxlY3RHcm91cGluZ1Jvd3M6IHNlbGVjdEdyb3VwaW5nUm93cyEsXG4gICAgLy8gICAgICAgc2VsZWN0U3ViUm93czogc2VsZWN0U3ViUm93cyEsXG4gICAgLy8gICAgIH0pXG4gICAgLy8gICB9XG5cbiAgICAvLyAgIHRhYmxlLnJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgIC8vICAgICBjb25zdCBpc0ZpcnN0Um93ID0gcm93LmlkID09PSBmaXJzdFJvdy5pZFxuICAgIC8vICAgICBjb25zdCBpc0xhc3RSb3cgPSByb3cuaWQgPT09IGxhc3RSb3cuaWRcblxuICAgIC8vICAgICBpZiAoaXNGaXJzdFJvdyB8fCBpc0xhc3RSb3cpIHtcbiAgICAvLyAgICAgICBpZiAoIWluY2x1ZGUpIHtcbiAgICAvLyAgICAgICAgIGluY2x1ZGUgPSB0cnVlXG4gICAgLy8gICAgICAgfSBlbHNlIGlmIChpbmNsdWRlKSB7XG4gICAgLy8gICAgICAgICBhZGRSb3cocm93KVxuICAgIC8vICAgICAgICAgaW5jbHVkZSA9IGZhbHNlXG4gICAgLy8gICAgICAgfVxuICAgIC8vICAgICB9XG5cbiAgICAvLyAgICAgaWYgKGluY2x1ZGUpIHtcbiAgICAvLyAgICAgICBhZGRSb3cocm93KVxuICAgIC8vICAgICB9XG4gICAgLy8gICB9KVxuXG4gICAgLy8gICB0YWJsZS5zZXRSb3dTZWxlY3Rpb24oc2VsZWN0ZWRSb3dJZHMpXG4gICAgLy8gfSxcbiAgICB0YWJsZS5nZXRQcmVTZWxlY3RlZFJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0Q29yZVJvd01vZGVsKCk7XG4gICAgdGFibGUuZ2V0U2VsZWN0ZWRSb3dNb2RlbCA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkucm93U2VsZWN0aW9uLCB0YWJsZS5nZXRDb3JlUm93TW9kZWwoKV0sIChyb3dTZWxlY3Rpb24sIHJvd01vZGVsKSA9PiB7XG4gICAgICBpZiAoIU9iamVjdC5rZXlzKHJvd1NlbGVjdGlvbikubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm93czogW10sXG4gICAgICAgICAgZmxhdFJvd3M6IFtdLFxuICAgICAgICAgIHJvd3NCeUlkOiB7fVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGVjdFJvd3NGbih0YWJsZSwgcm93TW9kZWwpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldFNlbGVjdGVkUm93TW9kZWwnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBIDogdGFibGUub3B0aW9ucy5kZWJ1Z1RhYmxlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRhYmxlLmdldEZpbHRlcmVkU2VsZWN0ZWRSb3dNb2RlbCA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkucm93U2VsZWN0aW9uLCB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCldLCAocm93U2VsZWN0aW9uLCByb3dNb2RlbCkgPT4ge1xuICAgICAgaWYgKCFPYmplY3Qua2V5cyhyb3dTZWxlY3Rpb24pLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJvd3M6IFtdLFxuICAgICAgICAgIGZsYXRSb3dzOiBbXSxcbiAgICAgICAgICByb3dzQnlJZDoge31cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3RSb3dzRm4odGFibGUsIHJvd01vZGVsKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiYgJ2dldEZpbHRlcmVkU2VsZWN0ZWRSb3dNb2RlbCcsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMjtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTIgOiB0YWJsZS5vcHRpb25zLmRlYnVnVGFibGU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0R3JvdXBlZFNlbGVjdGVkUm93TW9kZWwgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLnJvd1NlbGVjdGlvbiwgdGFibGUuZ2V0U29ydGVkUm93TW9kZWwoKV0sIChyb3dTZWxlY3Rpb24sIHJvd01vZGVsKSA9PiB7XG4gICAgICBpZiAoIU9iamVjdC5rZXlzKHJvd1NlbGVjdGlvbikubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm93czogW10sXG4gICAgICAgICAgZmxhdFJvd3M6IFtdLFxuICAgICAgICAgIHJvd3NCeUlkOiB7fVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGVjdFJvd3NGbih0YWJsZSwgcm93TW9kZWwpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJiAnZ2V0R3JvdXBlZFNlbGVjdGVkUm93TW9kZWwnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTM7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBMyA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EzIDogdGFibGUub3B0aW9ucy5kZWJ1Z1RhYmxlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8vXG5cbiAgICAvLyBnZXRHcm91cGluZ1Jvd0NhblNlbGVjdDogcm93SWQgPT4ge1xuICAgIC8vICAgY29uc3Qgcm93ID0gdGFibGUuZ2V0Um93KHJvd0lkKVxuXG4gICAgLy8gICBpZiAoIXJvdykge1xuICAgIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoKVxuICAgIC8vICAgfVxuXG4gICAgLy8gICBpZiAodHlwZW9mIHRhYmxlLm9wdGlvbnMuZW5hYmxlR3JvdXBpbmdSb3dTZWxlY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMuZW5hYmxlR3JvdXBpbmdSb3dTZWxlY3Rpb24ocm93KVxuICAgIC8vICAgfVxuXG4gICAgLy8gICByZXR1cm4gdGFibGUub3B0aW9ucy5lbmFibGVHcm91cGluZ1Jvd1NlbGVjdGlvbiA/PyBmYWxzZVxuICAgIC8vIH0sXG5cbiAgICB0YWJsZS5nZXRJc0FsbFJvd3NTZWxlY3RlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHByZUdyb3VwZWRGbGF0Um93cyA9IHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwoKS5mbGF0Um93cztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcm93U2VsZWN0aW9uXG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKTtcbiAgICAgIGxldCBpc0FsbFJvd3NTZWxlY3RlZCA9IEJvb2xlYW4ocHJlR3JvdXBlZEZsYXRSb3dzLmxlbmd0aCAmJiBPYmplY3Qua2V5cyhyb3dTZWxlY3Rpb24pLmxlbmd0aCk7XG4gICAgICBpZiAoaXNBbGxSb3dzU2VsZWN0ZWQpIHtcbiAgICAgICAgaWYgKHByZUdyb3VwZWRGbGF0Um93cy5zb21lKHJvdyA9PiByb3cuZ2V0Q2FuU2VsZWN0KCkgJiYgIXJvd1NlbGVjdGlvbltyb3cuaWRdKSkge1xuICAgICAgICAgIGlzQWxsUm93c1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0FsbFJvd3NTZWxlY3RlZDtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzQWxsUGFnZVJvd3NTZWxlY3RlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHBhZ2luYXRpb25GbGF0Um93cyA9IHRhYmxlLmdldFBhZ2luYXRpb25Sb3dNb2RlbCgpLmZsYXRSb3dzLmZpbHRlcihyb3cgPT4gcm93LmdldENhblNlbGVjdCgpKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcm93U2VsZWN0aW9uXG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKTtcbiAgICAgIGxldCBpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQgPSAhIXBhZ2luYXRpb25GbGF0Um93cy5sZW5ndGg7XG4gICAgICBpZiAoaXNBbGxQYWdlUm93c1NlbGVjdGVkICYmIHBhZ2luYXRpb25GbGF0Um93cy5zb21lKHJvdyA9PiAhcm93U2VsZWN0aW9uW3Jvdy5pZF0pKSB7XG4gICAgICAgIGlzQWxsUGFnZVJvd3NTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQWxsUGFnZVJvd3NTZWxlY3RlZDtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzU29tZVJvd3NTZWxlY3RlZCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkcm93U2U7XG4gICAgICBjb25zdCB0b3RhbFNlbGVjdGVkID0gT2JqZWN0LmtleXMoKF90YWJsZSRnZXRTdGF0ZSRyb3dTZSA9IHRhYmxlLmdldFN0YXRlKCkucm93U2VsZWN0aW9uKSAhPSBudWxsID8gX3RhYmxlJGdldFN0YXRlJHJvd1NlIDoge30pLmxlbmd0aDtcbiAgICAgIHJldHVybiB0b3RhbFNlbGVjdGVkID4gMCAmJiB0b3RhbFNlbGVjdGVkIDwgdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpLmZsYXRSb3dzLmxlbmd0aDtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzU29tZVBhZ2VSb3dzU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBwYWdpbmF0aW9uRmxhdFJvd3MgPSB0YWJsZS5nZXRQYWdpbmF0aW9uUm93TW9kZWwoKS5mbGF0Um93cztcbiAgICAgIHJldHVybiB0YWJsZS5nZXRJc0FsbFBhZ2VSb3dzU2VsZWN0ZWQoKSA/IGZhbHNlIDogcGFnaW5hdGlvbkZsYXRSb3dzLmZpbHRlcihyb3cgPT4gcm93LmdldENhblNlbGVjdCgpKS5zb21lKGQgPT4gZC5nZXRJc1NlbGVjdGVkKCkgfHwgZC5nZXRJc1NvbWVTZWxlY3RlZCgpKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFRvZ2dsZUFsbFJvd3NTZWxlY3RlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIHRhYmxlLnRvZ2dsZUFsbFJvd3NTZWxlY3RlZChlLnRhcmdldC5jaGVja2VkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB0YWJsZS5nZXRUb2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgdGFibGUudG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZChlLnRhcmdldC5jaGVja2VkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlUm93OiAocm93LCB0YWJsZSkgPT4ge1xuICAgIHJvdy50b2dnbGVTZWxlY3RlZCA9ICh2YWx1ZSwgb3B0cykgPT4ge1xuICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IHJvdy5nZXRJc1NlbGVjdGVkKCk7XG4gICAgICB0YWJsZS5zZXRSb3dTZWxlY3Rpb24ob2xkID0+IHtcbiAgICAgICAgdmFyIF9vcHRzJHNlbGVjdENoaWxkcmVuO1xuICAgICAgICB2YWx1ZSA9IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgPyB2YWx1ZSA6ICFpc1NlbGVjdGVkO1xuICAgICAgICBpZiAocm93LmdldENhblNlbGVjdCgpICYmIGlzU2VsZWN0ZWQgPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWxlY3RlZFJvd0lkcyA9IHtcbiAgICAgICAgICAuLi5vbGRcbiAgICAgICAgfTtcbiAgICAgICAgbXV0YXRlUm93SXNTZWxlY3RlZChzZWxlY3RlZFJvd0lkcywgcm93LmlkLCB2YWx1ZSwgKF9vcHRzJHNlbGVjdENoaWxkcmVuID0gb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5zZWxlY3RDaGlsZHJlbikgIT0gbnVsbCA/IF9vcHRzJHNlbGVjdENoaWxkcmVuIDogdHJ1ZSwgdGFibGUpO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWRSb3dJZHM7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJvdy5nZXRJc1NlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICByb3dTZWxlY3Rpb25cbiAgICAgIH0gPSB0YWJsZS5nZXRTdGF0ZSgpO1xuICAgICAgcmV0dXJuIGlzUm93U2VsZWN0ZWQocm93LCByb3dTZWxlY3Rpb24pO1xuICAgIH07XG4gICAgcm93LmdldElzU29tZVNlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICByb3dTZWxlY3Rpb25cbiAgICAgIH0gPSB0YWJsZS5nZXRTdGF0ZSgpO1xuICAgICAgcmV0dXJuIGlzU3ViUm93U2VsZWN0ZWQocm93LCByb3dTZWxlY3Rpb24pID09PSAnc29tZSc7XG4gICAgfTtcbiAgICByb3cuZ2V0SXNBbGxTdWJSb3dzU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvd1NlbGVjdGlvblxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCk7XG4gICAgICByZXR1cm4gaXNTdWJSb3dTZWxlY3RlZChyb3csIHJvd1NlbGVjdGlvbikgPT09ICdhbGwnO1xuICAgIH07XG4gICAgcm93LmdldENhblNlbGVjdCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRlbmFibGU7XG4gICAgICBpZiAodHlwZW9mIHRhYmxlLm9wdGlvbnMuZW5hYmxlUm93U2VsZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5vcHRpb25zLmVuYWJsZVJvd1NlbGVjdGlvbihyb3cpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZVJvd1NlbGVjdGlvbikgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWU7XG4gICAgfTtcbiAgICByb3cuZ2V0Q2FuU2VsZWN0U3ViUm93cyA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRlbmFibGUyO1xuICAgICAgaWYgKHR5cGVvZiB0YWJsZS5vcHRpb25zLmVuYWJsZVN1YlJvd1NlbGVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5lbmFibGVTdWJSb3dTZWxlY3Rpb24ocm93KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlU3ViUm93U2VsZWN0aW9uKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA6IHRydWU7XG4gICAgfTtcbiAgICByb3cuZ2V0Q2FuTXVsdGlTZWxlY3QgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZW5hYmxlMztcbiAgICAgIGlmICh0eXBlb2YgdGFibGUub3B0aW9ucy5lbmFibGVNdWx0aVJvd1NlbGVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5lbmFibGVNdWx0aVJvd1NlbGVjdGlvbihyb3cpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRlbmFibGUzID0gdGFibGUub3B0aW9ucy5lbmFibGVNdWx0aVJvd1NlbGVjdGlvbikgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZTMgOiB0cnVlO1xuICAgIH07XG4gICAgcm93LmdldFRvZ2dsZVNlbGVjdGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhblNlbGVjdCA9IHJvdy5nZXRDYW5TZWxlY3QoKTtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgdmFyIF90YXJnZXQ7XG4gICAgICAgIGlmICghY2FuU2VsZWN0KSByZXR1cm47XG4gICAgICAgIHJvdy50b2dnbGVTZWxlY3RlZCgoX3RhcmdldCA9IGUudGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX3RhcmdldC5jaGVja2VkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufTtcbmNvbnN0IG11dGF0ZVJvd0lzU2VsZWN0ZWQgPSAoc2VsZWN0ZWRSb3dJZHMsIGlkLCB2YWx1ZSwgaW5jbHVkZUNoaWxkcmVuLCB0YWJsZSkgPT4ge1xuICB2YXIgX3JvdyRzdWJSb3dzO1xuICBjb25zdCByb3cgPSB0YWJsZS5nZXRSb3coaWQsIHRydWUpO1xuXG4gIC8vIGNvbnN0IGlzR3JvdXBlZCA9IHJvdy5nZXRJc0dyb3VwZWQoKVxuXG4gIC8vIGlmICggLy8gVE9ETzogZW5mb3JjZSBncm91cGluZyByb3cgc2VsZWN0aW9uIHJ1bGVzXG4gIC8vICAgIWlzR3JvdXBlZCB8fFxuICAvLyAgIChpc0dyb3VwZWQgJiYgdGFibGUub3B0aW9ucy5lbmFibGVHcm91cGluZ1Jvd1NlbGVjdGlvbilcbiAgLy8gKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghcm93LmdldENhbk11bHRpU2VsZWN0KCkpIHtcbiAgICAgIE9iamVjdC5rZXlzKHNlbGVjdGVkUm93SWRzKS5mb3JFYWNoKGtleSA9PiBkZWxldGUgc2VsZWN0ZWRSb3dJZHNba2V5XSk7XG4gICAgfVxuICAgIGlmIChyb3cuZ2V0Q2FuU2VsZWN0KCkpIHtcbiAgICAgIHNlbGVjdGVkUm93SWRzW2lkXSA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSBzZWxlY3RlZFJvd0lkc1tpZF07XG4gIH1cbiAgLy8gfVxuXG4gIGlmIChpbmNsdWRlQ2hpbGRyZW4gJiYgKF9yb3ckc3ViUm93cyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93cy5sZW5ndGggJiYgcm93LmdldENhblNlbGVjdFN1YlJvd3MoKSkge1xuICAgIHJvdy5zdWJSb3dzLmZvckVhY2gocm93ID0+IG11dGF0ZVJvd0lzU2VsZWN0ZWQoc2VsZWN0ZWRSb3dJZHMsIHJvdy5pZCwgdmFsdWUsIGluY2x1ZGVDaGlsZHJlbiwgdGFibGUpKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNlbGVjdFJvd3NGbih0YWJsZSwgcm93TW9kZWwpIHtcbiAgY29uc3Qgcm93U2VsZWN0aW9uID0gdGFibGUuZ2V0U3RhdGUoKS5yb3dTZWxlY3Rpb247XG4gIGNvbnN0IG5ld1NlbGVjdGVkRmxhdFJvd3MgPSBbXTtcbiAgY29uc3QgbmV3U2VsZWN0ZWRSb3dzQnlJZCA9IHt9O1xuXG4gIC8vIEZpbHRlcnMgdG9wIGxldmVsIGFuZCBuZXN0ZWQgcm93c1xuICBjb25zdCByZWN1cnNlUm93cyA9IGZ1bmN0aW9uIChyb3dzLCBkZXB0aCkge1xuICAgIHJldHVybiByb3dzLm1hcChyb3cgPT4ge1xuICAgICAgdmFyIF9yb3ckc3ViUm93czI7XG4gICAgICBjb25zdCBpc1NlbGVjdGVkID0gaXNSb3dTZWxlY3RlZChyb3csIHJvd1NlbGVjdGlvbik7XG4gICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICBuZXdTZWxlY3RlZEZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgbmV3U2VsZWN0ZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgfVxuICAgICAgaWYgKChfcm93JHN1YlJvd3MyID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzMi5sZW5ndGgpIHtcbiAgICAgICAgcm93ID0ge1xuICAgICAgICAgIC4uLnJvdyxcbiAgICAgICAgICBzdWJSb3dzOiByZWN1cnNlUm93cyhyb3cuc3ViUm93cylcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICAgIHJldHVybiByb3c7XG4gICAgICB9XG4gICAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHJvd3M6IHJlY3Vyc2VSb3dzKHJvd01vZGVsLnJvd3MpLFxuICAgIGZsYXRSb3dzOiBuZXdTZWxlY3RlZEZsYXRSb3dzLFxuICAgIHJvd3NCeUlkOiBuZXdTZWxlY3RlZFJvd3NCeUlkXG4gIH07XG59XG5mdW5jdGlvbiBpc1Jvd1NlbGVjdGVkKHJvdywgc2VsZWN0aW9uKSB7XG4gIHZhciBfc2VsZWN0aW9uJHJvdyRpZDtcbiAgcmV0dXJuIChfc2VsZWN0aW9uJHJvdyRpZCA9IHNlbGVjdGlvbltyb3cuaWRdKSAhPSBudWxsID8gX3NlbGVjdGlvbiRyb3ckaWQgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzU3ViUm93U2VsZWN0ZWQocm93LCBzZWxlY3Rpb24sIHRhYmxlKSB7XG4gIHZhciBfcm93JHN1YlJvd3MzO1xuICBpZiAoISgoX3JvdyRzdWJSb3dzMyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93czMubGVuZ3RoKSkgcmV0dXJuIGZhbHNlO1xuICBsZXQgYWxsQ2hpbGRyZW5TZWxlY3RlZCA9IHRydWU7XG4gIGxldCBzb21lU2VsZWN0ZWQgPSBmYWxzZTtcbiAgcm93LnN1YlJvd3MuZm9yRWFjaChzdWJSb3cgPT4ge1xuICAgIC8vIEJhaWwgb3V0IGVhcmx5IGlmIHdlIGtub3cgYm90aCBvZiB0aGVzZVxuICAgIGlmIChzb21lU2VsZWN0ZWQgJiYgIWFsbENoaWxkcmVuU2VsZWN0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN1YlJvdy5nZXRDYW5TZWxlY3QoKSkge1xuICAgICAgaWYgKGlzUm93U2VsZWN0ZWQoc3ViUm93LCBzZWxlY3Rpb24pKSB7XG4gICAgICAgIHNvbWVTZWxlY3RlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxDaGlsZHJlblNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgcm93IHNlbGVjdGlvbiBvZiBuZXN0ZWQgc3Vicm93c1xuICAgIGlmIChzdWJSb3cuc3ViUm93cyAmJiBzdWJSb3cuc3ViUm93cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHN1YlJvd0NoaWxkcmVuU2VsZWN0ZWQgPSBpc1N1YlJvd1NlbGVjdGVkKHN1YlJvdywgc2VsZWN0aW9uKTtcbiAgICAgIGlmIChzdWJSb3dDaGlsZHJlblNlbGVjdGVkID09PSAnYWxsJykge1xuICAgICAgICBzb21lU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChzdWJSb3dDaGlsZHJlblNlbGVjdGVkID09PSAnc29tZScpIHtcbiAgICAgICAgc29tZVNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgYWxsQ2hpbGRyZW5TZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxsQ2hpbGRyZW5TZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhbGxDaGlsZHJlblNlbGVjdGVkID8gJ2FsbCcgOiBzb21lU2VsZWN0ZWQgPyAnc29tZScgOiBmYWxzZTtcbn1cblxuY29uc3QgcmVTcGxpdEFscGhhTnVtZXJpYyA9IC8oWzAtOV0rKS9nbTtcbmNvbnN0IGFscGhhbnVtZXJpYyA9IChyb3dBLCByb3dCLCBjb2x1bW5JZCkgPT4ge1xuICByZXR1cm4gY29tcGFyZUFscGhhbnVtZXJpYyh0b1N0cmluZyhyb3dBLmdldFZhbHVlKGNvbHVtbklkKSkudG9Mb3dlckNhc2UoKSwgdG9TdHJpbmcocm93Qi5nZXRWYWx1ZShjb2x1bW5JZCkpLnRvTG93ZXJDYXNlKCkpO1xufTtcbmNvbnN0IGFscGhhbnVtZXJpY0Nhc2VTZW5zaXRpdmUgPSAocm93QSwgcm93QiwgY29sdW1uSWQpID0+IHtcbiAgcmV0dXJuIGNvbXBhcmVBbHBoYW51bWVyaWModG9TdHJpbmcocm93QS5nZXRWYWx1ZShjb2x1bW5JZCkpLCB0b1N0cmluZyhyb3dCLmdldFZhbHVlKGNvbHVtbklkKSkpO1xufTtcblxuLy8gVGhlIHRleHQgZmlsdGVyIGlzIG1vcmUgYmFzaWMgKGxlc3MgbnVtZXJpYyBzdXBwb3J0KVxuLy8gYnV0IGlzIG11Y2ggZmFzdGVyXG5jb25zdCB0ZXh0ID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XG4gIHJldHVybiBjb21wYXJlQmFzaWModG9TdHJpbmcocm93QS5nZXRWYWx1ZShjb2x1bW5JZCkpLnRvTG93ZXJDYXNlKCksIHRvU3RyaW5nKHJvd0IuZ2V0VmFsdWUoY29sdW1uSWQpKS50b0xvd2VyQ2FzZSgpKTtcbn07XG5cbi8vIFRoZSB0ZXh0IGZpbHRlciBpcyBtb3JlIGJhc2ljIChsZXNzIG51bWVyaWMgc3VwcG9ydClcbi8vIGJ1dCBpcyBtdWNoIGZhc3RlclxuY29uc3QgdGV4dENhc2VTZW5zaXRpdmUgPSAocm93QSwgcm93QiwgY29sdW1uSWQpID0+IHtcbiAgcmV0dXJuIGNvbXBhcmVCYXNpYyh0b1N0cmluZyhyb3dBLmdldFZhbHVlKGNvbHVtbklkKSksIHRvU3RyaW5nKHJvd0IuZ2V0VmFsdWUoY29sdW1uSWQpKSk7XG59O1xuY29uc3QgZGF0ZXRpbWUgPSAocm93QSwgcm93QiwgY29sdW1uSWQpID0+IHtcbiAgY29uc3QgYSA9IHJvd0EuZ2V0VmFsdWUoY29sdW1uSWQpO1xuICBjb25zdCBiID0gcm93Qi5nZXRWYWx1ZShjb2x1bW5JZCk7XG5cbiAgLy8gQ2FuIGhhbmRsZSBudWxsaXNoIHZhbHVlc1xuICAvLyBVc2UgPiBhbmQgPCBiZWNhdXNlID09IChhbmQgPT09KSBkb2Vzbid0IHdvcmsgd2l0aFxuICAvLyBEYXRlIG9iamVjdHMgKHdvdWxkIHJlcXVpcmUgY2FsbGluZyBnZXRUaW1lKCkpLlxuICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDA7XG59O1xuY29uc3QgYmFzaWMgPSAocm93QSwgcm93QiwgY29sdW1uSWQpID0+IHtcbiAgcmV0dXJuIGNvbXBhcmVCYXNpYyhyb3dBLmdldFZhbHVlKGNvbHVtbklkKSwgcm93Qi5nZXRWYWx1ZShjb2x1bW5JZCkpO1xufTtcblxuLy8gVXRpbHNcblxuZnVuY3Rpb24gY29tcGFyZUJhc2ljKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGIgPyAwIDogYSA+IGIgPyAxIDogLTE7XG59XG5mdW5jdGlvbiB0b1N0cmluZyhhKSB7XG4gIGlmICh0eXBlb2YgYSA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoaXNOYU4oYSkgfHwgYSA9PT0gSW5maW5pdHkgfHwgYSA9PT0gLUluZmluaXR5KSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcoYSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLy8gTWl4ZWQgc29ydGluZyBpcyBzbG93LCBidXQgdmVyeSBpbmNsdXNpdmUgb2YgbWFueSBlZGdlIGNhc2VzLlxuLy8gSXQgaGFuZGxlcyBudW1iZXJzLCBtaXhlZCBhbHBoYW51bWVyaWMgY29tYmluYXRpb25zLCBhbmQgZXZlblxuLy8gbnVsbCwgdW5kZWZpbmVkLCBhbmQgSW5maW5pdHlcbmZ1bmN0aW9uIGNvbXBhcmVBbHBoYW51bWVyaWMoYVN0ciwgYlN0cikge1xuICAvLyBTcGxpdCBvbiBudW1iZXIgZ3JvdXBzLCBidXQga2VlcCB0aGUgZGVsaW1pdGVyXG4gIC8vIFRoZW4gcmVtb3ZlIGZhbHNleSBzcGxpdCB2YWx1ZXNcbiAgY29uc3QgYSA9IGFTdHIuc3BsaXQocmVTcGxpdEFscGhhTnVtZXJpYykuZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBiID0gYlN0ci5zcGxpdChyZVNwbGl0QWxwaGFOdW1lcmljKS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgLy8gV2hpbGVcbiAgd2hpbGUgKGEubGVuZ3RoICYmIGIubGVuZ3RoKSB7XG4gICAgY29uc3QgYWEgPSBhLnNoaWZ0KCk7XG4gICAgY29uc3QgYmIgPSBiLnNoaWZ0KCk7XG4gICAgY29uc3QgYW4gPSBwYXJzZUludChhYSwgMTApO1xuICAgIGNvbnN0IGJuID0gcGFyc2VJbnQoYmIsIDEwKTtcbiAgICBjb25zdCBjb21ibyA9IFthbiwgYm5dLnNvcnQoKTtcblxuICAgIC8vIEJvdGggYXJlIHN0cmluZ1xuICAgIGlmIChpc05hTihjb21ib1swXSkpIHtcbiAgICAgIGlmIChhYSA+IGJiKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgaWYgKGJiID4gYWEpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gT25lIGlzIGEgc3RyaW5nLCBvbmUgaXMgYSBudW1iZXJcbiAgICBpZiAoaXNOYU4oY29tYm9bMV0pKSB7XG4gICAgICByZXR1cm4gaXNOYU4oYW4pID8gLTEgOiAxO1xuICAgIH1cblxuICAgIC8vIEJvdGggYXJlIG51bWJlcnNcbiAgICBpZiAoYW4gPiBibikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmIChibiA+IGFuKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiBhLmxlbmd0aCAtIGIubGVuZ3RoO1xufVxuXG4vLyBFeHBvcnRzXG5cbmNvbnN0IHNvcnRpbmdGbnMgPSB7XG4gIGFscGhhbnVtZXJpYyxcbiAgYWxwaGFudW1lcmljQ2FzZVNlbnNpdGl2ZSxcbiAgdGV4dCxcbiAgdGV4dENhc2VTZW5zaXRpdmUsXG4gIGRhdGV0aW1lLFxuICBiYXNpY1xufTtcblxuLy9cblxuY29uc3QgU29ydGluZyA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNvcnRpbmc6IFtdLFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0Q29sdW1uRGVmOiAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNvcnRpbmdGbjogJ2F1dG8nLFxuICAgICAgc29ydFVuZGVmaW5lZDogMVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uU29ydGluZ0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignc29ydGluZycsIHRhYmxlKSxcbiAgICAgIGlzTXVsdGlTb3J0RXZlbnQ6IGUgPT4ge1xuICAgICAgICByZXR1cm4gZS5zaGlmdEtleTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XG4gICAgY29sdW1uLmdldEF1dG9Tb3J0aW5nRm4gPSAoKSA9PiB7XG4gICAgICBjb25zdCBmaXJzdFJvd3MgPSB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCkuZmxhdFJvd3Muc2xpY2UoMTApO1xuICAgICAgbGV0IGlzU3RyaW5nID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IHJvdyBvZiBmaXJzdFJvd3MpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSByb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHJvdy5nZXRWYWx1ZShjb2x1bW4uaWQpO1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0ZV0nKSB7XG4gICAgICAgICAgcmV0dXJuIHNvcnRpbmdGbnMuZGF0ZXRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpc1N0cmluZyA9IHRydWU7XG4gICAgICAgICAgaWYgKHZhbHVlLnNwbGl0KHJlU3BsaXRBbHBoYU51bWVyaWMpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3J0aW5nRm5zLmFscGhhbnVtZXJpYztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc1N0cmluZykge1xuICAgICAgICByZXR1cm4gc29ydGluZ0Zucy50ZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNvcnRpbmdGbnMuYmFzaWM7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0QXV0b1NvcnREaXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBmaXJzdFJvdyA9IHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwoKS5mbGF0Um93c1swXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gZmlyc3RSb3cgPT0gbnVsbCA/IHZvaWQgMCA6IGZpcnN0Um93LmdldFZhbHVlKGNvbHVtbi5pZCk7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gJ2FzYyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ2Rlc2MnO1xuICAgIH07XG4gICAgY29sdW1uLmdldFNvcnRpbmdGbiA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRzb3J0aW4sIF90YWJsZSRvcHRpb25zJHNvcnRpbjI7XG4gICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGNvbHVtbi5jb2x1bW5EZWYuc29ydGluZ0ZuKSA/IGNvbHVtbi5jb2x1bW5EZWYuc29ydGluZ0ZuIDogY29sdW1uLmNvbHVtbkRlZi5zb3J0aW5nRm4gPT09ICdhdXRvJyA/IGNvbHVtbi5nZXRBdXRvU29ydGluZ0ZuKCkgOiAoX3RhYmxlJG9wdGlvbnMkc29ydGluID0gKF90YWJsZSRvcHRpb25zJHNvcnRpbjIgPSB0YWJsZS5vcHRpb25zLnNvcnRpbmdGbnMpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkb3B0aW9ucyRzb3J0aW4yW2NvbHVtbi5jb2x1bW5EZWYuc29ydGluZ0ZuXSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJHNvcnRpbiA6IHNvcnRpbmdGbnNbY29sdW1uLmNvbHVtbkRlZi5zb3J0aW5nRm5dO1xuICAgIH07XG4gICAgY29sdW1uLnRvZ2dsZVNvcnRpbmcgPSAoZGVzYywgbXVsdGkpID0+IHtcbiAgICAgIC8vIGlmIChjb2x1bW4uY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgIC8vICAgY29sdW1uLmNvbHVtbnMuZm9yRWFjaCgoYywgaSkgPT4ge1xuICAgICAgLy8gICAgIGlmIChjLmlkKSB7XG4gICAgICAvLyAgICAgICB0YWJsZS50b2dnbGVDb2x1bW5Tb3J0aW5nKGMuaWQsIHVuZGVmaW5lZCwgbXVsdGkgfHwgISFpKVxuICAgICAgLy8gICAgIH1cbiAgICAgIC8vICAgfSlcbiAgICAgIC8vICAgcmV0dXJuXG4gICAgICAvLyB9XG5cbiAgICAgIC8vIHRoaXMgbmVlZHMgdG8gYmUgb3V0c2lkZSBvZiB0YWJsZS5zZXRTb3J0aW5nIHRvIGJlIGluIHN5bmMgd2l0aCByZXJlbmRlclxuICAgICAgY29uc3QgbmV4dFNvcnRpbmdPcmRlciA9IGNvbHVtbi5nZXROZXh0U29ydGluZ09yZGVyKCk7XG4gICAgICBjb25zdCBoYXNNYW51YWxWYWx1ZSA9IHR5cGVvZiBkZXNjICE9PSAndW5kZWZpbmVkJyAmJiBkZXNjICE9PSBudWxsO1xuICAgICAgdGFibGUuc2V0U29ydGluZyhvbGQgPT4ge1xuICAgICAgICAvLyBGaW5kIGFueSBleGlzdGluZyBzb3J0aW5nIGZvciB0aGlzIGNvbHVtblxuICAgICAgICBjb25zdCBleGlzdGluZ1NvcnRpbmcgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdJbmRleCA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmZpbmRJbmRleChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCk7XG4gICAgICAgIGxldCBuZXdTb3J0aW5nID0gW107XG5cbiAgICAgICAgLy8gV2hhdCBzaG91bGQgd2UgZG8gd2l0aCB0aGlzIHNvcnQgYWN0aW9uP1xuICAgICAgICBsZXQgc29ydEFjdGlvbjtcbiAgICAgICAgbGV0IG5leHREZXNjID0gaGFzTWFudWFsVmFsdWUgPyBkZXNjIDogbmV4dFNvcnRpbmdPcmRlciA9PT0gJ2Rlc2MnO1xuXG4gICAgICAgIC8vIE11bHRpLW1vZGVcbiAgICAgICAgaWYgKG9sZCAhPSBudWxsICYmIG9sZC5sZW5ndGggJiYgY29sdW1uLmdldENhbk11bHRpU29ydCgpICYmIG11bHRpKSB7XG4gICAgICAgICAgaWYgKGV4aXN0aW5nU29ydGluZykge1xuICAgICAgICAgICAgc29ydEFjdGlvbiA9ICd0b2dnbGUnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3J0QWN0aW9uID0gJ2FkZCc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vcm1hbCBtb2RlXG4gICAgICAgICAgaWYgKG9sZCAhPSBudWxsICYmIG9sZC5sZW5ndGggJiYgZXhpc3RpbmdJbmRleCAhPT0gb2xkLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHNvcnRBY3Rpb24gPSAncmVwbGFjZSc7XG4gICAgICAgICAgfSBlbHNlIGlmIChleGlzdGluZ1NvcnRpbmcpIHtcbiAgICAgICAgICAgIHNvcnRBY3Rpb24gPSAndG9nZ2xlJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc29ydEFjdGlvbiA9ICdyZXBsYWNlJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgdG9nZ2xlIHN0YXRlcyB0aGF0IHdpbGwgcmVtb3ZlIHRoZSBzb3J0aW5nXG4gICAgICAgIGlmIChzb3J0QWN0aW9uID09PSAndG9nZ2xlJykge1xuICAgICAgICAgIC8vIElmIHdlIGFyZSBcImFjdHVhbGx5XCIgdG9nZ2xpbmcgKG5vdCBhIG1hbnVhbCBzZXQgdmFsdWUpLCBzaG91bGQgd2UgcmVtb3ZlIHRoZSBzb3J0aW5nP1xuICAgICAgICAgIGlmICghaGFzTWFudWFsVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIElzIG91ciBpbnRlbnRpb24gdG8gcmVtb3ZlP1xuICAgICAgICAgICAgaWYgKCFuZXh0U29ydGluZ09yZGVyKSB7XG4gICAgICAgICAgICAgIHNvcnRBY3Rpb24gPSAncmVtb3ZlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvcnRBY3Rpb24gPT09ICdhZGQnKSB7XG4gICAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJG1heE11bDtcbiAgICAgICAgICBuZXdTb3J0aW5nID0gWy4uLm9sZCwge1xuICAgICAgICAgICAgaWQ6IGNvbHVtbi5pZCxcbiAgICAgICAgICAgIGRlc2M6IG5leHREZXNjXG4gICAgICAgICAgfV07XG4gICAgICAgICAgLy8gVGFrZSBsYXRlc3QgbiBjb2x1bW5zXG4gICAgICAgICAgbmV3U29ydGluZy5zcGxpY2UoMCwgbmV3U29ydGluZy5sZW5ndGggLSAoKF90YWJsZSRvcHRpb25zJG1heE11bCA9IHRhYmxlLm9wdGlvbnMubWF4TXVsdGlTb3J0Q29sQ291bnQpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRtYXhNdWwgOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpO1xuICAgICAgICB9IGVsc2UgaWYgKHNvcnRBY3Rpb24gPT09ICd0b2dnbGUnKSB7XG4gICAgICAgICAgLy8gVGhpcyBmbGlwcyAob3Igc2V0cykgdGhlXG4gICAgICAgICAgbmV3U29ydGluZyA9IG9sZC5tYXAoZCA9PiB7XG4gICAgICAgICAgICBpZiAoZC5pZCA9PT0gY29sdW1uLmlkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uZCxcbiAgICAgICAgICAgICAgICBkZXNjOiBuZXh0RGVzY1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc29ydEFjdGlvbiA9PT0gJ3JlbW92ZScpIHtcbiAgICAgICAgICBuZXdTb3J0aW5nID0gb2xkLmZpbHRlcihkID0+IGQuaWQgIT09IGNvbHVtbi5pZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3U29ydGluZyA9IFt7XG4gICAgICAgICAgICBpZDogY29sdW1uLmlkLFxuICAgICAgICAgICAgZGVzYzogbmV4dERlc2NcbiAgICAgICAgICB9XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U29ydGluZztcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29sdW1uLmdldEZpcnN0U29ydERpciA9ICgpID0+IHtcbiAgICAgIHZhciBfcmVmLCBfY29sdW1uJGNvbHVtbkRlZiRzb3I7XG4gICAgICBjb25zdCBzb3J0RGVzY0ZpcnN0ID0gKF9yZWYgPSAoX2NvbHVtbiRjb2x1bW5EZWYkc29yID0gY29sdW1uLmNvbHVtbkRlZi5zb3J0RGVzY0ZpcnN0KSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkc29yIDogdGFibGUub3B0aW9ucy5zb3J0RGVzY0ZpcnN0KSAhPSBudWxsID8gX3JlZiA6IGNvbHVtbi5nZXRBdXRvU29ydERpcigpID09PSAnZGVzYyc7XG4gICAgICByZXR1cm4gc29ydERlc2NGaXJzdCA/ICdkZXNjJyA6ICdhc2MnO1xuICAgIH07XG4gICAgY29sdW1uLmdldE5leHRTb3J0aW5nT3JkZXIgPSBtdWx0aSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZW5hYmxlLCBfdGFibGUkb3B0aW9ucyRlbmFibGUyO1xuICAgICAgY29uc3QgZmlyc3RTb3J0RGlyZWN0aW9uID0gY29sdW1uLmdldEZpcnN0U29ydERpcigpO1xuICAgICAgY29uc3QgaXNTb3J0ZWQgPSBjb2x1bW4uZ2V0SXNTb3J0ZWQoKTtcbiAgICAgIGlmICghaXNTb3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0U29ydERpcmVjdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NvcnRlZCAhPT0gZmlyc3RTb3J0RGlyZWN0aW9uICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlID0gdGFibGUub3B0aW9ucy5lbmFibGVTb3J0aW5nUmVtb3ZhbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWUpICYmIChcbiAgICAgIC8vIElmIGVuYWJsZVNvcnRSZW1vdmUsIGVuYWJsZSBpbiBnZW5lcmFsXG4gICAgICBtdWx0aSA/IChfdGFibGUkb3B0aW9ucyRlbmFibGUyID0gdGFibGUub3B0aW9ucy5lbmFibGVNdWx0aVJlbW92ZSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZTIgOiB0cnVlIDogdHJ1ZSkgLy8gSWYgbXVsdGksIGRvbid0IGFsbG93IGlmIGVuYWJsZU11bHRpUmVtb3ZlKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNTb3J0ZWQgPT09ICdkZXNjJyA/ICdhc2MnIDogJ2Rlc2MnO1xuICAgIH07XG4gICAgY29sdW1uLmdldENhblNvcnQgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5EZWYkZW5hLCBfdGFibGUkb3B0aW9ucyRlbmFibGUzO1xuICAgICAgcmV0dXJuICgoX2NvbHVtbiRjb2x1bW5EZWYkZW5hID0gY29sdW1uLmNvbHVtbkRlZi5lbmFibGVTb3J0aW5nKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUzID0gdGFibGUub3B0aW9ucy5lbmFibGVTb3J0aW5nKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlMyA6IHRydWUpICYmICEhY29sdW1uLmFjY2Vzc29yRm47XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Q2FuTXVsdGlTb3J0ID0gKCkgPT4ge1xuICAgICAgdmFyIF9yZWYyLCBfY29sdW1uJGNvbHVtbkRlZiRlbmEyO1xuICAgICAgcmV0dXJuIChfcmVmMiA9IChfY29sdW1uJGNvbHVtbkRlZiRlbmEyID0gY29sdW1uLmNvbHVtbkRlZi5lbmFibGVNdWx0aVNvcnQpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEyIDogdGFibGUub3B0aW9ucy5lbmFibGVNdWx0aVNvcnQpICE9IG51bGwgPyBfcmVmMiA6ICEhY29sdW1uLmFjY2Vzc29yRm47XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNTb3J0ZWQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJHNvcnRpO1xuICAgICAgY29uc3QgY29sdW1uU29ydCA9IChfdGFibGUkZ2V0U3RhdGUkc29ydGkgPSB0YWJsZS5nZXRTdGF0ZSgpLnNvcnRpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkc29ydGkuZmluZChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCk7XG4gICAgICByZXR1cm4gIWNvbHVtblNvcnQgPyBmYWxzZSA6IGNvbHVtblNvcnQuZGVzYyA/ICdkZXNjJyA6ICdhc2MnO1xuICAgIH07XG4gICAgY29sdW1uLmdldFNvcnRJbmRleCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkc29ydGkyLCBfdGFibGUkZ2V0U3RhdGUkc29ydGkzO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0U3RhdGUkc29ydGkyID0gKF90YWJsZSRnZXRTdGF0ZSRzb3J0aTMgPSB0YWJsZS5nZXRTdGF0ZSgpLnNvcnRpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkc29ydGkzLmZpbmRJbmRleChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCkpICE9IG51bGwgPyBfdGFibGUkZ2V0U3RhdGUkc29ydGkyIDogLTE7XG4gICAgfTtcbiAgICBjb2x1bW4uY2xlYXJTb3J0aW5nID0gKCkgPT4ge1xuICAgICAgLy9jbGVhciBzb3J0aW5nIGZvciBqdXN0IDEgY29sdW1uXG4gICAgICB0YWJsZS5zZXRTb3J0aW5nKG9sZCA9PiBvbGQgIT0gbnVsbCAmJiBvbGQubGVuZ3RoID8gb2xkLmZpbHRlcihkID0+IGQuaWQgIT09IGNvbHVtbi5pZCkgOiBbXSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0VG9nZ2xlU29ydGluZ0hhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYW5Tb3J0ID0gY29sdW1uLmdldENhblNvcnQoKTtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgaWYgKCFjYW5Tb3J0KSByZXR1cm47XG4gICAgICAgIGUucGVyc2lzdCA9PSBudWxsIHx8IGUucGVyc2lzdCgpO1xuICAgICAgICBjb2x1bW4udG9nZ2xlU29ydGluZyA9PSBudWxsIHx8IGNvbHVtbi50b2dnbGVTb3J0aW5nKHVuZGVmaW5lZCwgY29sdW1uLmdldENhbk11bHRpU29ydCgpID8gdGFibGUub3B0aW9ucy5pc011bHRpU29ydEV2ZW50ID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLmlzTXVsdGlTb3J0RXZlbnQoZSkgOiBmYWxzZSk7XG4gICAgICB9O1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgdGFibGUuc2V0U29ydGluZyA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vblNvcnRpbmdDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Tb3J0aW5nQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnJlc2V0U29ydGluZyA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRzLCBfdGFibGUkaW5pdGlhbFN0YXRlO1xuICAgICAgdGFibGUuc2V0U29ydGluZyhkZWZhdWx0U3RhdGUgPyBbXSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJHMgPSAoX3RhYmxlJGluaXRpYWxTdGF0ZSA9IHRhYmxlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUuc29ydGluZykgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkcyA6IFtdKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFByZVNvcnRlZFJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0R3JvdXBlZFJvd01vZGVsKCk7XG4gICAgdGFibGUuZ2V0U29ydGVkUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRTb3J0ZWRSb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldFNvcnRlZFJvd01vZGVsKSB7XG4gICAgICAgIHRhYmxlLl9nZXRTb3J0ZWRSb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0U29ydGVkUm93TW9kZWwodGFibGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRhYmxlLm9wdGlvbnMubWFudWFsU29ydGluZyB8fCAhdGFibGUuX2dldFNvcnRlZFJvd01vZGVsKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVTb3J0ZWRSb3dNb2RlbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRTb3J0ZWRSb3dNb2RlbCgpO1xuICAgIH07XG4gIH1cbn07XG5cbi8vXG5cbmNvbnN0IFZpc2liaWxpdHkgPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjb2x1bW5WaXNpYmlsaXR5OiB7fSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Db2x1bW5WaXNpYmlsaXR5Q2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdjb2x1bW5WaXNpYmlsaXR5JywgdGFibGUpXG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlQ29sdW1uOiAoY29sdW1uLCB0YWJsZSkgPT4ge1xuICAgIGNvbHVtbi50b2dnbGVWaXNpYmlsaXR5ID0gdmFsdWUgPT4ge1xuICAgICAgaWYgKGNvbHVtbi5nZXRDYW5IaWRlKCkpIHtcbiAgICAgICAgdGFibGUuc2V0Q29sdW1uVmlzaWJpbGl0eShvbGQgPT4gKHtcbiAgICAgICAgICAuLi5vbGQsXG4gICAgICAgICAgW2NvbHVtbi5pZF06IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6ICFjb2x1bW4uZ2V0SXNWaXNpYmxlKClcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29sdW1uLmdldElzVmlzaWJsZSA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkY29sdW0sIF90YWJsZSRnZXRTdGF0ZSRjb2x1bTI7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRTdGF0ZSRjb2x1bSA9IChfdGFibGUkZ2V0U3RhdGUkY29sdW0yID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5WaXNpYmlsaXR5KSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldFN0YXRlJGNvbHVtMltjb2x1bW4uaWRdKSAhPSBudWxsID8gX3RhYmxlJGdldFN0YXRlJGNvbHVtIDogdHJ1ZTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5IaWRlID0gKCkgPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1uRGVmJGVuYSwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlO1xuICAgICAgcmV0dXJuICgoX2NvbHVtbiRjb2x1bW5EZWYkZW5hID0gY29sdW1uLmNvbHVtbkRlZi5lbmFibGVIaWRpbmcpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlSGlkaW5nKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0VG9nZ2xlVmlzaWJpbGl0eUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIGNvbHVtbi50b2dnbGVWaXNpYmlsaXR5ID09IG51bGwgfHwgY29sdW1uLnRvZ2dsZVZpc2liaWxpdHkoZS50YXJnZXQuY2hlY2tlZCk7XG4gICAgICB9O1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVJvdzogKHJvdywgdGFibGUpID0+IHtcbiAgICByb3cuX2dldEFsbFZpc2libGVDZWxscyA9IG1lbW8oKCkgPT4gW3Jvdy5nZXRBbGxDZWxscygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblZpc2liaWxpdHldLCBjZWxscyA9PiB7XG4gICAgICByZXR1cm4gY2VsbHMuZmlsdGVyKGNlbGwgPT4gY2VsbC5jb2x1bW4uZ2V0SXNWaXNpYmxlKCkpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJiAncm93Ll9nZXRBbGxWaXNpYmxlQ2VsbHMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBIDogdGFibGUub3B0aW9ucy5kZWJ1Z1Jvd3M7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcm93LmdldFZpc2libGVDZWxscyA9IG1lbW8oKCkgPT4gW3Jvdy5nZXRMZWZ0VmlzaWJsZUNlbGxzKCksIHJvdy5nZXRDZW50ZXJWaXNpYmxlQ2VsbHMoKSwgcm93LmdldFJpZ2h0VmlzaWJsZUNlbGxzKCldLCAobGVmdCwgY2VudGVyLCByaWdodCkgPT4gWy4uLmxlZnQsIC4uLmNlbnRlciwgLi4ucmlnaHRdLCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdyb3cuZ2V0VmlzaWJsZUNlbGxzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTIgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBMiA6IHRhYmxlLm9wdGlvbnMuZGVidWdSb3dzO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIGNvbnN0IG1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZCA9IChrZXksIGdldENvbHVtbnMpID0+IHtcbiAgICAgIHJldHVybiBtZW1vKCgpID0+IFtnZXRDb2x1bW5zKCksIGdldENvbHVtbnMoKS5maWx0ZXIoZCA9PiBkLmdldElzVmlzaWJsZSgpKS5tYXAoZCA9PiBkLmlkKS5qb2luKCdfJyldLCBjb2x1bW5zID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbHVtbnMuZmlsdGVyKGQgPT4gZC5nZXRJc1Zpc2libGUgPT0gbnVsbCA/IHZvaWQgMCA6IGQuZ2V0SXNWaXNpYmxlKCkpO1xuICAgICAgfSwge1xuICAgICAgICBrZXksXG4gICAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTM7XG4gICAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EzID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTMgOiB0YWJsZS5vcHRpb25zLmRlYnVnQ29sdW1ucztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRWaXNpYmxlRmxhdENvbHVtbnMgPSBtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QoJ2dldFZpc2libGVGbGF0Q29sdW1ucycsICgpID0+IHRhYmxlLmdldEFsbEZsYXRDb2x1bW5zKCkpO1xuICAgIHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucyA9IG1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZCgnZ2V0VmlzaWJsZUxlYWZDb2x1bW5zJywgKCkgPT4gdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKSk7XG4gICAgdGFibGUuZ2V0TGVmdFZpc2libGVMZWFmQ29sdW1ucyA9IG1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZCgnZ2V0TGVmdFZpc2libGVMZWFmQ29sdW1ucycsICgpID0+IHRhYmxlLmdldExlZnRMZWFmQ29sdW1ucygpKTtcbiAgICB0YWJsZS5nZXRSaWdodFZpc2libGVMZWFmQ29sdW1ucyA9IG1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZCgnZ2V0UmlnaHRWaXNpYmxlTGVhZkNvbHVtbnMnLCAoKSA9PiB0YWJsZS5nZXRSaWdodExlYWZDb2x1bW5zKCkpO1xuICAgIHRhYmxlLmdldENlbnRlclZpc2libGVMZWFmQ29sdW1ucyA9IG1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZCgnZ2V0Q2VudGVyVmlzaWJsZUxlYWZDb2x1bW5zJywgKCkgPT4gdGFibGUuZ2V0Q2VudGVyTGVhZkNvbHVtbnMoKSk7XG4gICAgdGFibGUuc2V0Q29sdW1uVmlzaWJpbGl0eSA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkNvbHVtblZpc2liaWxpdHlDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Db2x1bW5WaXNpYmlsaXR5Q2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnJlc2V0Q29sdW1uVmlzaWJpbGl0eSA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRjO1xuICAgICAgdGFibGUuc2V0Q29sdW1uVmlzaWJpbGl0eShkZWZhdWx0U3RhdGUgPyB7fSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGMgPSB0YWJsZS5pbml0aWFsU3RhdGUuY29sdW1uVmlzaWJpbGl0eSkgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkYyA6IHt9KTtcbiAgICB9O1xuICAgIHRhYmxlLnRvZ2dsZUFsbENvbHVtbnNWaXNpYmxlID0gdmFsdWUgPT4ge1xuICAgICAgdmFyIF92YWx1ZTtcbiAgICAgIHZhbHVlID0gKF92YWx1ZSA9IHZhbHVlKSAhPSBudWxsID8gX3ZhbHVlIDogIXRhYmxlLmdldElzQWxsQ29sdW1uc1Zpc2libGUoKTtcbiAgICAgIHRhYmxlLnNldENvbHVtblZpc2liaWxpdHkodGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKS5yZWR1Y2UoKG9iaiwgY29sdW1uKSA9PiAoe1xuICAgICAgICAuLi5vYmosXG4gICAgICAgIFtjb2x1bW4uaWRdOiAhdmFsdWUgPyAhKGNvbHVtbi5nZXRDYW5IaWRlICE9IG51bGwgJiYgY29sdW1uLmdldENhbkhpZGUoKSkgOiB2YWx1ZVxuICAgICAgfSksIHt9KSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc0FsbENvbHVtbnNWaXNpYmxlID0gKCkgPT4gIXRhYmxlLmdldEFsbExlYWZDb2x1bW5zKCkuc29tZShjb2x1bW4gPT4gIShjb2x1bW4uZ2V0SXNWaXNpYmxlICE9IG51bGwgJiYgY29sdW1uLmdldElzVmlzaWJsZSgpKSk7XG4gICAgdGFibGUuZ2V0SXNTb21lQ29sdW1uc1Zpc2libGUgPSAoKSA9PiB0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLnNvbWUoY29sdW1uID0+IGNvbHVtbi5nZXRJc1Zpc2libGUgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbHVtbi5nZXRJc1Zpc2libGUoKSk7XG4gICAgdGFibGUuZ2V0VG9nZ2xlQWxsQ29sdW1uc1Zpc2liaWxpdHlIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICB2YXIgX3RhcmdldDtcbiAgICAgICAgdGFibGUudG9nZ2xlQWxsQ29sdW1uc1Zpc2libGUoKF90YXJnZXQgPSBlLnRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YXJnZXQuY2hlY2tlZCk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbn07XG5cbmNvbnN0IGZlYXR1cmVzID0gW0hlYWRlcnMsIFZpc2liaWxpdHksIE9yZGVyaW5nLCBQaW5uaW5nLCBGaWx0ZXJzLCBTb3J0aW5nLCBHcm91cGluZywgRXhwYW5kaW5nLCBQYWdpbmF0aW9uLCBSb3dTZWxlY3Rpb24sIENvbHVtblNpemluZ107XG5cbi8vXG5cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlKG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJGluaXRpYWxTdGF0ZTtcbiAgaWYgKG9wdGlvbnMuZGVidWdBbGwgfHwgb3B0aW9ucy5kZWJ1Z1RhYmxlKSB7XG4gICAgY29uc29sZS5pbmZvKCdDcmVhdGluZyBUYWJsZSBJbnN0YW5jZS4uLicpO1xuICB9XG4gIGxldCB0YWJsZSA9IHtcbiAgICBfZmVhdHVyZXM6IGZlYXR1cmVzXG4gIH07XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0gdGFibGUuX2ZlYXR1cmVzLnJlZHVjZSgob2JqLCBmZWF0dXJlKSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2JqLCBmZWF0dXJlLmdldERlZmF1bHRPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBmZWF0dXJlLmdldERlZmF1bHRPcHRpb25zKHRhYmxlKSk7XG4gIH0sIHt9KTtcbiAgY29uc3QgbWVyZ2VPcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gICAgaWYgKHRhYmxlLm9wdGlvbnMubWVyZ2VPcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5tZXJnZU9wdGlvbnMoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgfTtcbiAgY29uc3QgY29yZUluaXRpYWxTdGF0ZSA9IHt9O1xuICBsZXQgaW5pdGlhbFN0YXRlID0ge1xuICAgIC4uLmNvcmVJbml0aWFsU3RhdGUsXG4gICAgLi4uKChfb3B0aW9ucyRpbml0aWFsU3RhdGUgPSBvcHRpb25zLmluaXRpYWxTdGF0ZSkgIT0gbnVsbCA/IF9vcHRpb25zJGluaXRpYWxTdGF0ZSA6IHt9KVxuICB9O1xuICB0YWJsZS5fZmVhdHVyZXMuZm9yRWFjaChmZWF0dXJlID0+IHtcbiAgICB2YXIgX2ZlYXR1cmUkZ2V0SW5pdGlhbFN0O1xuICAgIGluaXRpYWxTdGF0ZSA9IChfZmVhdHVyZSRnZXRJbml0aWFsU3QgPSBmZWF0dXJlLmdldEluaXRpYWxTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogZmVhdHVyZS5nZXRJbml0aWFsU3RhdGUoaW5pdGlhbFN0YXRlKSkgIT0gbnVsbCA/IF9mZWF0dXJlJGdldEluaXRpYWxTdCA6IGluaXRpYWxTdGF0ZTtcbiAgfSk7XG4gIGNvbnN0IHF1ZXVlZCA9IFtdO1xuICBsZXQgcXVldWVkVGltZW91dCA9IGZhbHNlO1xuICBjb25zdCBjb3JlSW5zdGFuY2UgPSB7XG4gICAgX2ZlYXR1cmVzOiBmZWF0dXJlcyxcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9LFxuICAgIGluaXRpYWxTdGF0ZSxcbiAgICBfcXVldWU6IGNiID0+IHtcbiAgICAgIHF1ZXVlZC5wdXNoKGNiKTtcbiAgICAgIGlmICghcXVldWVkVGltZW91dCkge1xuICAgICAgICBxdWV1ZWRUaW1lb3V0ID0gdHJ1ZTtcblxuICAgICAgICAvLyBTY2hlZHVsZSBhIG1pY3JvdGFzayB0byBydW4gdGhlIHF1ZXVlZCBjYWxsYmFja3MgYWZ0ZXJcbiAgICAgICAgLy8gdGhlIGN1cnJlbnQgY2FsbCBzdGFjayAocmVuZGVyLCBldGMpIGhhcyBmaW5pc2hlZC5cbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgd2hpbGUgKHF1ZXVlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHF1ZXVlZC5zaGlmdCgpKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHF1ZXVlZFRpbWVvdXQgPSBmYWxzZTtcbiAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlc2V0OiAoKSA9PiB7XG4gICAgICB0YWJsZS5zZXRTdGF0ZSh0YWJsZS5pbml0aWFsU3RhdGUpO1xuICAgIH0sXG4gICAgc2V0T3B0aW9uczogdXBkYXRlciA9PiB7XG4gICAgICBjb25zdCBuZXdPcHRpb25zID0gZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCB0YWJsZS5vcHRpb25zKTtcbiAgICAgIHRhYmxlLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMobmV3T3B0aW9ucyk7XG4gICAgfSxcbiAgICBnZXRTdGF0ZTogKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMuc3RhdGU7XG4gICAgfSxcbiAgICBzZXRTdGF0ZTogdXBkYXRlciA9PiB7XG4gICAgICB0YWJsZS5vcHRpb25zLm9uU3RhdGVDaGFuZ2UgPT0gbnVsbCB8fCB0YWJsZS5vcHRpb25zLm9uU3RhdGVDaGFuZ2UodXBkYXRlcik7XG4gICAgfSxcbiAgICBfZ2V0Um93SWQ6IChyb3csIGluZGV4LCBwYXJlbnQpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRnZXRSb3c7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGdldFJvdyA9IHRhYmxlLm9wdGlvbnMuZ2V0Um93SWQgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMuZ2V0Um93SWQocm93LCBpbmRleCwgcGFyZW50KSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGdldFJvdyA6IGAke3BhcmVudCA/IFtwYXJlbnQuaWQsIGluZGV4XS5qb2luKCcuJykgOiBpbmRleH1gO1xuICAgIH0sXG4gICAgZ2V0Q29yZVJvd01vZGVsOiAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRDb3JlUm93TW9kZWwpIHtcbiAgICAgICAgdGFibGUuX2dldENvcmVSb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0Q29yZVJvd01vZGVsKHRhYmxlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0Q29yZVJvd01vZGVsKCk7XG4gICAgfSxcbiAgICAvLyBUaGUgZmluYWwgY2FsbHMgc3RhcnQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgbW9kZWwsXG4gICAgLy8gZXhwYW5kZWQgcm93cywgd2hpY2ggdGhlbiB3b3JrIHRoZWlyIHdheSB1cFxuXG4gICAgZ2V0Um93TW9kZWw6ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZS5nZXRQYWdpbmF0aW9uUm93TW9kZWwoKTtcbiAgICB9LFxuICAgIC8vaW4gbmV4dCB2ZXJzaW9uLCB3ZSBzaG91bGQganVzdCBwYXNzIGluIHRoZSByb3cgbW9kZWwgYXMgdGhlIG9wdGlvbmFsIDJuZCBhcmdcbiAgICBnZXRSb3c6IChpZCwgc2VhcmNoQWxsKSA9PiB7XG4gICAgICBsZXQgcm93ID0gKHNlYXJjaEFsbCA/IHRhYmxlLmdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCgpIDogdGFibGUuZ2V0Um93TW9kZWwoKSkucm93c0J5SWRbaWRdO1xuICAgICAgaWYgKCFyb3cpIHtcbiAgICAgICAgcm93ID0gdGFibGUuZ2V0Q29yZVJvd01vZGVsKCkucm93c0J5SWRbaWRdO1xuICAgICAgICBpZiAoIXJvdykge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGdldFJvdyBjb3VsZCBub3QgZmluZCByb3cgd2l0aCBJRDogJHtpZH1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByb3c7XG4gICAgfSxcbiAgICBfZ2V0RGVmYXVsdENvbHVtbkRlZjogbWVtbygoKSA9PiBbdGFibGUub3B0aW9ucy5kZWZhdWx0Q29sdW1uXSwgZGVmYXVsdENvbHVtbiA9PiB7XG4gICAgICB2YXIgX2RlZmF1bHRDb2x1bW47XG4gICAgICBkZWZhdWx0Q29sdW1uID0gKF9kZWZhdWx0Q29sdW1uID0gZGVmYXVsdENvbHVtbikgIT0gbnVsbCA/IF9kZWZhdWx0Q29sdW1uIDoge307XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoZWFkZXI6IHByb3BzID0+IHtcbiAgICAgICAgICBjb25zdCByZXNvbHZlZENvbHVtbkRlZiA9IHByb3BzLmhlYWRlci5jb2x1bW4uY29sdW1uRGVmO1xuICAgICAgICAgIGlmIChyZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvcktleSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yS2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JGbikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkQ29sdW1uRGVmLmlkO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gZm9vdGVyOiBwcm9wcyA9PiBwcm9wcy5oZWFkZXIuY29sdW1uLmlkLFxuICAgICAgICBjZWxsOiBwcm9wcyA9PiB7XG4gICAgICAgICAgdmFyIF9wcm9wcyRyZW5kZXJWYWx1ZSR0bywgX3Byb3BzJHJlbmRlclZhbHVlO1xuICAgICAgICAgIHJldHVybiAoX3Byb3BzJHJlbmRlclZhbHVlJHRvID0gKF9wcm9wcyRyZW5kZXJWYWx1ZSA9IHByb3BzLnJlbmRlclZhbHVlKCkpID09IG51bGwgfHwgX3Byb3BzJHJlbmRlclZhbHVlLnRvU3RyaW5nID09IG51bGwgPyB2b2lkIDAgOiBfcHJvcHMkcmVuZGVyVmFsdWUudG9TdHJpbmcoKSkgIT0gbnVsbCA/IF9wcm9wcyRyZW5kZXJWYWx1ZSR0byA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIC4uLnRhYmxlLl9mZWF0dXJlcy5yZWR1Y2UoKG9iaiwgZmVhdHVyZSkgPT4ge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9iaiwgZmVhdHVyZS5nZXREZWZhdWx0Q29sdW1uRGVmID09IG51bGwgPyB2b2lkIDAgOiBmZWF0dXJlLmdldERlZmF1bHRDb2x1bW5EZWYoKSk7XG4gICAgICAgIH0sIHt9KSxcbiAgICAgICAgLi4uZGVmYXVsdENvbHVtblxuICAgICAgfTtcbiAgICB9LCB7XG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBO1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnQ29sdW1ucztcbiAgICAgIH0sXG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXREZWZhdWx0Q29sdW1uRGVmJ1xuICAgIH0pLFxuICAgIF9nZXRDb2x1bW5EZWZzOiAoKSA9PiB0YWJsZS5vcHRpb25zLmNvbHVtbnMsXG4gICAgZ2V0QWxsQ29sdW1uczogbWVtbygoKSA9PiBbdGFibGUuX2dldENvbHVtbkRlZnMoKV0sIGNvbHVtbkRlZnMgPT4ge1xuICAgICAgY29uc3QgcmVjdXJzZUNvbHVtbnMgPSBmdW5jdGlvbiAoY29sdW1uRGVmcywgcGFyZW50LCBkZXB0aCkge1xuICAgICAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgICAgIGRlcHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sdW1uRGVmcy5tYXAoY29sdW1uRGVmID0+IHtcbiAgICAgICAgICBjb25zdCBjb2x1bW4gPSBjcmVhdGVDb2x1bW4odGFibGUsIGNvbHVtbkRlZiwgZGVwdGgsIHBhcmVudCk7XG4gICAgICAgICAgY29uc3QgZ3JvdXBpbmdDb2x1bW5EZWYgPSBjb2x1bW5EZWY7XG4gICAgICAgICAgY29sdW1uLmNvbHVtbnMgPSBncm91cGluZ0NvbHVtbkRlZi5jb2x1bW5zID8gcmVjdXJzZUNvbHVtbnMoZ3JvdXBpbmdDb2x1bW5EZWYuY29sdW1ucywgY29sdW1uLCBkZXB0aCArIDEpIDogW107XG4gICAgICAgICAgcmV0dXJuIGNvbHVtbjtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlY3Vyc2VDb2x1bW5zKGNvbHVtbkRlZnMpO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldEFsbENvbHVtbnMnLFxuICAgICAgZGVidWc6ICgpID0+IHtcbiAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTI7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBMiA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyIDogdGFibGUub3B0aW9ucy5kZWJ1Z0NvbHVtbnM7XG4gICAgICB9XG4gICAgfSksXG4gICAgZ2V0QWxsRmxhdENvbHVtbnM6IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbENvbHVtbnMoKV0sIGFsbENvbHVtbnMgPT4ge1xuICAgICAgcmV0dXJuIGFsbENvbHVtbnMuZmxhdE1hcChjb2x1bW4gPT4ge1xuICAgICAgICByZXR1cm4gY29sdW1uLmdldEZsYXRDb2x1bW5zKCk7XG4gICAgICB9KTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRBbGxGbGF0Q29sdW1ucycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMztcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EzID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTMgOiB0YWJsZS5vcHRpb25zLmRlYnVnQ29sdW1ucztcbiAgICAgIH1cbiAgICB9KSxcbiAgICBfZ2V0QWxsRmxhdENvbHVtbnNCeUlkOiBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxGbGF0Q29sdW1ucygpXSwgZmxhdENvbHVtbnMgPT4ge1xuICAgICAgcmV0dXJuIGZsYXRDb2x1bW5zLnJlZHVjZSgoYWNjLCBjb2x1bW4pID0+IHtcbiAgICAgICAgYWNjW2NvbHVtbi5pZF0gPSBjb2x1bW47XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0QWxsRmxhdENvbHVtbnNCeUlkJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E0O1xuICAgICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQTQgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBNCA6IHRhYmxlLm9wdGlvbnMuZGVidWdDb2x1bW5zO1xuICAgICAgfVxuICAgIH0pLFxuICAgIGdldEFsbExlYWZDb2x1bW5zOiBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxDb2x1bW5zKCksIHRhYmxlLl9nZXRPcmRlckNvbHVtbnNGbigpXSwgKGFsbENvbHVtbnMsIG9yZGVyQ29sdW1ucykgPT4ge1xuICAgICAgbGV0IGxlYWZDb2x1bW5zID0gYWxsQ29sdW1ucy5mbGF0TWFwKGNvbHVtbiA9PiBjb2x1bW4uZ2V0TGVhZkNvbHVtbnMoKSk7XG4gICAgICByZXR1cm4gb3JkZXJDb2x1bW5zKGxlYWZDb2x1bW5zKTtcbiAgICB9LCB7XG4gICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRBbGxMZWFmQ29sdW1ucycsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBNTtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0E1ID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTUgOiB0YWJsZS5vcHRpb25zLmRlYnVnQ29sdW1ucztcbiAgICAgIH1cbiAgICB9KSxcbiAgICBnZXRDb2x1bW46IGNvbHVtbklkID0+IHtcbiAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLl9nZXRBbGxGbGF0Q29sdW1uc0J5SWQoKVtjb2x1bW5JZF07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29sdW1uKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFtUYWJsZV0gQ29sdW1uIHdpdGggaWQgJyR7Y29sdW1uSWR9JyBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2x1bW47XG4gICAgfVxuICB9O1xuICBPYmplY3QuYXNzaWduKHRhYmxlLCBjb3JlSW5zdGFuY2UpO1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGFibGUuX2ZlYXR1cmVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IGZlYXR1cmUgPSB0YWJsZS5fZmVhdHVyZXNbaW5kZXhdO1xuICAgIGZlYXR1cmUgPT0gbnVsbCB8fCBmZWF0dXJlLmNyZWF0ZVRhYmxlID09IG51bGwgfHwgZmVhdHVyZS5jcmVhdGVUYWJsZSh0YWJsZSk7XG4gIH1cbiAgcmV0dXJuIHRhYmxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDZWxsKHRhYmxlLCByb3csIGNvbHVtbiwgY29sdW1uSWQpIHtcbiAgY29uc3QgZ2V0UmVuZGVyVmFsdWUgPSAoKSA9PiB7XG4gICAgdmFyIF9jZWxsJGdldFZhbHVlO1xuICAgIHJldHVybiAoX2NlbGwkZ2V0VmFsdWUgPSBjZWxsLmdldFZhbHVlKCkpICE9IG51bGwgPyBfY2VsbCRnZXRWYWx1ZSA6IHRhYmxlLm9wdGlvbnMucmVuZGVyRmFsbGJhY2tWYWx1ZTtcbiAgfTtcbiAgY29uc3QgY2VsbCA9IHtcbiAgICBpZDogYCR7cm93LmlkfV8ke2NvbHVtbi5pZH1gLFxuICAgIHJvdyxcbiAgICBjb2x1bW4sXG4gICAgZ2V0VmFsdWU6ICgpID0+IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCksXG4gICAgcmVuZGVyVmFsdWU6IGdldFJlbmRlclZhbHVlLFxuICAgIGdldENvbnRleHQ6IG1lbW8oKCkgPT4gW3RhYmxlLCBjb2x1bW4sIHJvdywgY2VsbF0sICh0YWJsZSwgY29sdW1uLCByb3csIGNlbGwpID0+ICh7XG4gICAgICB0YWJsZSxcbiAgICAgIGNvbHVtbixcbiAgICAgIHJvdyxcbiAgICAgIGNlbGw6IGNlbGwsXG4gICAgICBnZXRWYWx1ZTogY2VsbC5nZXRWYWx1ZSxcbiAgICAgIHJlbmRlclZhbHVlOiBjZWxsLnJlbmRlclZhbHVlXG4gICAgfSksIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2NlbGwuZ2V0Q29udGV4dCcsXG4gICAgICBkZWJ1ZzogKCkgPT4gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbFxuICAgIH0pXG4gIH07XG4gIHRhYmxlLl9mZWF0dXJlcy5mb3JFYWNoKGZlYXR1cmUgPT4ge1xuICAgIGZlYXR1cmUuY3JlYXRlQ2VsbCA9PSBudWxsIHx8IGZlYXR1cmUuY3JlYXRlQ2VsbChjZWxsLCBjb2x1bW4sIHJvdywgdGFibGUpO1xuICB9LCB7fSk7XG4gIHJldHVybiBjZWxsO1xufVxuXG5jb25zdCBjcmVhdGVSb3cgPSAodGFibGUsIGlkLCBvcmlnaW5hbCwgcm93SW5kZXgsIGRlcHRoLCBzdWJSb3dzLCBwYXJlbnRJZCkgPT4ge1xuICBsZXQgcm93ID0ge1xuICAgIGlkLFxuICAgIGluZGV4OiByb3dJbmRleCxcbiAgICBvcmlnaW5hbCxcbiAgICBkZXB0aCxcbiAgICBwYXJlbnRJZCxcbiAgICBfdmFsdWVzQ2FjaGU6IHt9LFxuICAgIF91bmlxdWVWYWx1ZXNDYWNoZToge30sXG4gICAgZ2V0VmFsdWU6IGNvbHVtbklkID0+IHtcbiAgICAgIGlmIChyb3cuX3ZhbHVlc0NhY2hlLmhhc093blByb3BlcnR5KGNvbHVtbklkKSkge1xuICAgICAgICByZXR1cm4gcm93Ll92YWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgICB9XG4gICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oY29sdW1uSWQpO1xuICAgICAgaWYgKCEoY29sdW1uICE9IG51bGwgJiYgY29sdW1uLmFjY2Vzc29yRm4pKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByb3cuX3ZhbHVlc0NhY2hlW2NvbHVtbklkXSA9IGNvbHVtbi5hY2Nlc3NvckZuKHJvdy5vcmlnaW5hbCwgcm93SW5kZXgpO1xuICAgICAgcmV0dXJuIHJvdy5fdmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgIH0sXG4gICAgZ2V0VW5pcXVlVmFsdWVzOiBjb2x1bW5JZCA9PiB7XG4gICAgICBpZiAocm93Ll91bmlxdWVWYWx1ZXNDYWNoZS5oYXNPd25Qcm9wZXJ0eShjb2x1bW5JZCkpIHtcbiAgICAgICAgcmV0dXJuIHJvdy5fdW5pcXVlVmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgfVxuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKTtcbiAgICAgIGlmICghKGNvbHVtbiAhPSBudWxsICYmIGNvbHVtbi5hY2Nlc3NvckZuKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKCFjb2x1bW4uY29sdW1uRGVmLmdldFVuaXF1ZVZhbHVlcykge1xuICAgICAgICByb3cuX3VuaXF1ZVZhbHVlc0NhY2hlW2NvbHVtbklkXSA9IFtyb3cuZ2V0VmFsdWUoY29sdW1uSWQpXTtcbiAgICAgICAgcmV0dXJuIHJvdy5fdW5pcXVlVmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgfVxuICAgICAgcm93Ll91bmlxdWVWYWx1ZXNDYWNoZVtjb2x1bW5JZF0gPSBjb2x1bW4uY29sdW1uRGVmLmdldFVuaXF1ZVZhbHVlcyhyb3cub3JpZ2luYWwsIHJvd0luZGV4KTtcbiAgICAgIHJldHVybiByb3cuX3VuaXF1ZVZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICB9LFxuICAgIHJlbmRlclZhbHVlOiBjb2x1bW5JZCA9PiB7XG4gICAgICB2YXIgX3JvdyRnZXRWYWx1ZTtcbiAgICAgIHJldHVybiAoX3JvdyRnZXRWYWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpICE9IG51bGwgPyBfcm93JGdldFZhbHVlIDogdGFibGUub3B0aW9ucy5yZW5kZXJGYWxsYmFja1ZhbHVlO1xuICAgIH0sXG4gICAgc3ViUm93czogc3ViUm93cyAhPSBudWxsID8gc3ViUm93cyA6IFtdLFxuICAgIGdldExlYWZSb3dzOiAoKSA9PiBmbGF0dGVuQnkocm93LnN1YlJvd3MsIGQgPT4gZC5zdWJSb3dzKSxcbiAgICBnZXRQYXJlbnRSb3c6ICgpID0+IHJvdy5wYXJlbnRJZCA/IHRhYmxlLmdldFJvdyhyb3cucGFyZW50SWQsIHRydWUpIDogdW5kZWZpbmVkLFxuICAgIGdldFBhcmVudFJvd3M6ICgpID0+IHtcbiAgICAgIGxldCBwYXJlbnRSb3dzID0gW107XG4gICAgICBsZXQgY3VycmVudFJvdyA9IHJvdztcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFJvdyA9IGN1cnJlbnRSb3cuZ2V0UGFyZW50Um93KCk7XG4gICAgICAgIGlmICghcGFyZW50Um93KSBicmVhaztcbiAgICAgICAgcGFyZW50Um93cy5wdXNoKHBhcmVudFJvdyk7XG4gICAgICAgIGN1cnJlbnRSb3cgPSBwYXJlbnRSb3c7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50Um93cy5yZXZlcnNlKCk7XG4gICAgfSxcbiAgICBnZXRBbGxDZWxsczogbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKV0sIGxlYWZDb2x1bW5zID0+IHtcbiAgICAgIHJldHVybiBsZWFmQ29sdW1ucy5tYXAoY29sdW1uID0+IHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNlbGwodGFibGUsIHJvdywgY29sdW1uLCBjb2x1bW4uaWQpO1xuICAgICAgfSk7XG4gICAgfSwge1xuICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAncm93LmdldEFsbENlbGxzJyxcbiAgICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQSA6IHRhYmxlLm9wdGlvbnMuZGVidWdSb3dzO1xuICAgICAgfVxuICAgIH0pLFxuICAgIF9nZXRBbGxDZWxsc0J5Q29sdW1uSWQ6IG1lbW8oKCkgPT4gW3Jvdy5nZXRBbGxDZWxscygpXSwgYWxsQ2VsbHMgPT4ge1xuICAgICAgcmV0dXJuIGFsbENlbGxzLnJlZHVjZSgoYWNjLCBjZWxsKSA9PiB7XG4gICAgICAgIGFjY1tjZWxsLmNvbHVtbi5pZF0gPSBjZWxsO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pO1xuICAgIH0sIHtcbiAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJiAncm93LmdldEFsbENlbGxzQnlDb2x1bW5JZCcsXG4gICAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBMjtcbiAgICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQTIgOiB0YWJsZS5vcHRpb25zLmRlYnVnUm93cztcbiAgICAgIH1cbiAgICB9KVxuICB9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYmxlLl9mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGZlYXR1cmUgPSB0YWJsZS5fZmVhdHVyZXNbaV07XG4gICAgZmVhdHVyZSA9PSBudWxsIHx8IGZlYXR1cmUuY3JlYXRlUm93ID09IG51bGwgfHwgZmVhdHVyZS5jcmVhdGVSb3cocm93LCB0YWJsZSk7XG4gIH1cbiAgcmV0dXJuIHJvdztcbn07XG5cbi8vIHR5cGUgUGVyc29uID0ge1xuLy8gICBmaXJzdE5hbWU6IHN0cmluZ1xuLy8gICBsYXN0TmFtZTogc3RyaW5nXG4vLyAgIGFnZTogbnVtYmVyXG4vLyAgIHZpc2l0czogbnVtYmVyXG4vLyAgIHN0YXR1czogc3RyaW5nXG4vLyAgIHByb2dyZXNzOiBudW1iZXJcbi8vICAgY3JlYXRlZEF0OiBEYXRlXG4vLyAgIG5lc3RlZDoge1xuLy8gICAgIGZvbzogW1xuLy8gICAgICAge1xuLy8gICAgICAgICBiYXI6ICdiYXInXG4vLyAgICAgICB9XG4vLyAgICAgXVxuLy8gICAgIGJhcjogeyBzdWJCYXI6IGJvb2xlYW4gfVtdXG4vLyAgICAgYmF6OiB7XG4vLyAgICAgICBmb286ICdmb28nXG4vLyAgICAgICBiYXI6IHtcbi8vICAgICAgICAgYmF6OiAnYmF6J1xuLy8gICAgICAgfVxuLy8gICAgIH1cbi8vICAgfVxuLy8gfVxuXG4vLyBjb25zdCB0ZXN0OiBEZWVwS2V5czxQZXJzb24+ID0gJ25lc3RlZC5mb28uMC5iYXInXG4vLyBjb25zdCB0ZXN0MjogRGVlcEtleXM8UGVyc29uPiA9ICduZXN0ZWQuYmFyJ1xuXG4vLyBjb25zdCBoZWxwZXIgPSBjcmVhdGVDb2x1bW5IZWxwZXI8UGVyc29uPigpXG5cbi8vIGhlbHBlci5hY2Nlc3NvcignbmVzdGVkLmZvbycsIHtcbi8vICAgY2VsbDogaW5mbyA9PiBpbmZvLmdldFZhbHVlKCksXG4vLyB9KVxuXG4vLyBoZWxwZXIuYWNjZXNzb3IoJ25lc3RlZC5mb28uMC5iYXInLCB7XG4vLyAgIGNlbGw6IGluZm8gPT4gaW5mby5nZXRWYWx1ZSgpLFxuLy8gfSlcblxuLy8gaGVscGVyLmFjY2Vzc29yKCduZXN0ZWQuYmFyJywge1xuLy8gICBjZWxsOiBpbmZvID0+IGluZm8uZ2V0VmFsdWUoKSxcbi8vIH0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbHVtbkhlbHBlcigpIHtcbiAgcmV0dXJuIHtcbiAgICBhY2Nlc3NvcjogKGFjY2Vzc29yLCBjb2x1bW4pID0+IHtcbiAgICAgIHJldHVybiB0eXBlb2YgYWNjZXNzb3IgPT09ICdmdW5jdGlvbicgPyB7XG4gICAgICAgIC4uLmNvbHVtbixcbiAgICAgICAgYWNjZXNzb3JGbjogYWNjZXNzb3JcbiAgICAgIH0gOiB7XG4gICAgICAgIC4uLmNvbHVtbixcbiAgICAgICAgYWNjZXNzb3JLZXk6IGFjY2Vzc29yXG4gICAgICB9O1xuICAgIH0sXG4gICAgZGlzcGxheTogY29sdW1uID0+IGNvbHVtbixcbiAgICBncm91cDogY29sdW1uID0+IGNvbHVtblxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDb3JlUm93TW9kZWwoKSB7XG4gIHJldHVybiB0YWJsZSA9PiBtZW1vKCgpID0+IFt0YWJsZS5vcHRpb25zLmRhdGFdLCBkYXRhID0+IHtcbiAgICBjb25zdCByb3dNb2RlbCA9IHtcbiAgICAgIHJvd3M6IFtdLFxuICAgICAgZmxhdFJvd3M6IFtdLFxuICAgICAgcm93c0J5SWQ6IHt9XG4gICAgfTtcbiAgICBjb25zdCBhY2Nlc3NSb3dzID0gZnVuY3Rpb24gKG9yaWdpbmFsUm93cywgZGVwdGgsIHBhcmVudFJvdykge1xuICAgICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICAgICAgZGVwdGggPSAwO1xuICAgICAgfVxuICAgICAgY29uc3Qgcm93cyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmlnaW5hbFJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSBhbiBleHBlbnNpdmUgY2hlY2sgYXQgc2NhbGUsIHNvIHdlIHNob3VsZCBtb3ZlIGl0IHNvbWV3aGVyZSBlbHNlLCBidXQgd2hlcmU/XG4gICAgICAgIC8vIGlmICghaWQpIHtcbiAgICAgICAgLy8gICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAvLyAgICAgdGhyb3cgbmV3IEVycm9yKGBnZXRSb3dJZCBleHBlY3RlZCBhbiBJRCwgYnV0IGdvdCAke2lkfWApXG4gICAgICAgIC8vICAgfVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gTWFrZSB0aGUgcm93XG4gICAgICAgIGNvbnN0IHJvdyA9IGNyZWF0ZVJvdyh0YWJsZSwgdGFibGUuX2dldFJvd0lkKG9yaWdpbmFsUm93c1tpXSwgaSwgcGFyZW50Um93KSwgb3JpZ2luYWxSb3dzW2ldLCBpLCBkZXB0aCwgdW5kZWZpbmVkLCBwYXJlbnRSb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmVudFJvdy5pZCk7XG5cbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiBldmVyeSByb3cgaW4gYSBmbGF0IGFycmF5XG4gICAgICAgIHJvd01vZGVsLmZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgLy8gQWxzbyBrZWVwIHRyYWNrIG9mIGV2ZXJ5IHJvdyBieSBpdHMgSURcbiAgICAgICAgcm93TW9kZWwucm93c0J5SWRbcm93LmlkXSA9IHJvdztcbiAgICAgICAgLy8gUHVzaCB0YWJsZSByb3cgaW50byBwYXJlbnRcbiAgICAgICAgcm93cy5wdXNoKHJvdyk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBvcmlnaW5hbCBzdWJyb3dzXG4gICAgICAgIGlmICh0YWJsZS5vcHRpb25zLmdldFN1YlJvd3MpIHtcbiAgICAgICAgICB2YXIgX3JvdyRvcmlnaW5hbFN1YlJvd3M7XG4gICAgICAgICAgcm93Lm9yaWdpbmFsU3ViUm93cyA9IHRhYmxlLm9wdGlvbnMuZ2V0U3ViUm93cyhvcmlnaW5hbFJvd3NbaV0sIGkpO1xuXG4gICAgICAgICAgLy8gVGhlbiByZWN1cnNpdmVseSBhY2Nlc3MgdGhlbVxuICAgICAgICAgIGlmICgoX3JvdyRvcmlnaW5hbFN1YlJvd3MgPSByb3cub3JpZ2luYWxTdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckb3JpZ2luYWxTdWJSb3dzLmxlbmd0aCkge1xuICAgICAgICAgICAgcm93LnN1YlJvd3MgPSBhY2Nlc3NSb3dzKHJvdy5vcmlnaW5hbFN1YlJvd3MsIGRlcHRoICsgMSwgcm93KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByb3dzO1xuICAgIH07XG4gICAgcm93TW9kZWwucm93cyA9IGFjY2Vzc1Jvd3MoZGF0YSk7XG4gICAgcmV0dXJuIHJvd01vZGVsO1xuICB9LCB7XG4gICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0Um93TW9kZWwnLFxuICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBO1xuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBIDogdGFibGUub3B0aW9ucy5kZWJ1Z1RhYmxlO1xuICAgIH0sXG4gICAgb25DaGFuZ2U6ICgpID0+IHtcbiAgICAgIHRhYmxlLl9hdXRvUmVzZXRQYWdlSW5kZXgoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJSb3dzKHJvd3MsIGZpbHRlclJvd0ltcGwsIHRhYmxlKSB7XG4gIGlmICh0YWJsZS5vcHRpb25zLmZpbHRlckZyb21MZWFmUm93cykge1xuICAgIHJldHVybiBmaWx0ZXJSb3dNb2RlbEZyb21MZWFmcyhyb3dzLCBmaWx0ZXJSb3dJbXBsLCB0YWJsZSk7XG4gIH1cbiAgcmV0dXJuIGZpbHRlclJvd01vZGVsRnJvbVJvb3Qocm93cywgZmlsdGVyUm93SW1wbCwgdGFibGUpO1xufVxuZnVuY3Rpb24gZmlsdGVyUm93TW9kZWxGcm9tTGVhZnMocm93c1RvRmlsdGVyLCBmaWx0ZXJSb3csIHRhYmxlKSB7XG4gIHZhciBfdGFibGUkb3B0aW9ucyRtYXhMZWE7XG4gIGNvbnN0IG5ld0ZpbHRlcmVkRmxhdFJvd3MgPSBbXTtcbiAgY29uc3QgbmV3RmlsdGVyZWRSb3dzQnlJZCA9IHt9O1xuICBjb25zdCBtYXhEZXB0aCA9IChfdGFibGUkb3B0aW9ucyRtYXhMZWEgPSB0YWJsZS5vcHRpb25zLm1heExlYWZSb3dGaWx0ZXJEZXB0aCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJG1heExlYSA6IDEwMDtcbiAgY29uc3QgcmVjdXJzZUZpbHRlclJvd3MgPSBmdW5jdGlvbiAocm93c1RvRmlsdGVyLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICBkZXB0aCA9IDA7XG4gICAgfVxuICAgIGNvbnN0IHJvd3MgPSBbXTtcblxuICAgIC8vIEZpbHRlciBmcm9tIGNoaWxkcmVuIHVwIGZpcnN0XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzVG9GaWx0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfcm93JHN1YlJvd3M7XG4gICAgICBsZXQgcm93ID0gcm93c1RvRmlsdGVyW2ldO1xuICAgICAgY29uc3QgbmV3Um93ID0gY3JlYXRlUm93KHRhYmxlLCByb3cuaWQsIHJvdy5vcmlnaW5hbCwgcm93LmluZGV4LCByb3cuZGVwdGgsIHVuZGVmaW5lZCwgcm93LnBhcmVudElkKTtcbiAgICAgIG5ld1Jvdy5jb2x1bW5GaWx0ZXJzID0gcm93LmNvbHVtbkZpbHRlcnM7XG4gICAgICBpZiAoKF9yb3ckc3ViUm93cyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93cy5sZW5ndGggJiYgZGVwdGggPCBtYXhEZXB0aCkge1xuICAgICAgICBuZXdSb3cuc3ViUm93cyA9IHJlY3Vyc2VGaWx0ZXJSb3dzKHJvdy5zdWJSb3dzLCBkZXB0aCArIDEpO1xuICAgICAgICByb3cgPSBuZXdSb3c7XG4gICAgICAgIGlmIChmaWx0ZXJSb3cocm93KSAmJiAhbmV3Um93LnN1YlJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgbmV3RmlsdGVyZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgICAgIG5ld0ZpbHRlcmVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWx0ZXJSb3cocm93KSB8fCBuZXdSb3cuc3ViUm93cy5sZW5ndGgpIHtcbiAgICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgICBuZXdGaWx0ZXJlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XG4gICAgICAgICAgbmV3RmlsdGVyZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdyA9IG5ld1JvdztcbiAgICAgICAgaWYgKGZpbHRlclJvdyhyb3cpKSB7XG4gICAgICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgbmV3RmlsdGVyZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgICAgIG5ld0ZpbHRlcmVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByb3dzO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHJvd3M6IHJlY3Vyc2VGaWx0ZXJSb3dzKHJvd3NUb0ZpbHRlciksXG4gICAgZmxhdFJvd3M6IG5ld0ZpbHRlcmVkRmxhdFJvd3MsXG4gICAgcm93c0J5SWQ6IG5ld0ZpbHRlcmVkUm93c0J5SWRcbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbHRlclJvd01vZGVsRnJvbVJvb3Qocm93c1RvRmlsdGVyLCBmaWx0ZXJSb3csIHRhYmxlKSB7XG4gIHZhciBfdGFibGUkb3B0aW9ucyRtYXhMZWEyO1xuICBjb25zdCBuZXdGaWx0ZXJlZEZsYXRSb3dzID0gW107XG4gIGNvbnN0IG5ld0ZpbHRlcmVkUm93c0J5SWQgPSB7fTtcbiAgY29uc3QgbWF4RGVwdGggPSAoX3RhYmxlJG9wdGlvbnMkbWF4TGVhMiA9IHRhYmxlLm9wdGlvbnMubWF4TGVhZlJvd0ZpbHRlckRlcHRoKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkbWF4TGVhMiA6IDEwMDtcblxuICAvLyBGaWx0ZXJzIHRvcCBsZXZlbCBhbmQgbmVzdGVkIHJvd3NcbiAgY29uc3QgcmVjdXJzZUZpbHRlclJvd3MgPSBmdW5jdGlvbiAocm93c1RvRmlsdGVyLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICBkZXB0aCA9IDA7XG4gICAgfVxuICAgIC8vIEZpbHRlciBmcm9tIHBhcmVudHMgZG93bndhcmQgZmlyc3RcblxuICAgIGNvbnN0IHJvd3MgPSBbXTtcblxuICAgIC8vIEFwcGx5IHRoZSBmaWx0ZXIgdG8gYW55IHN1YlJvd3NcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3NUb0ZpbHRlci5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHJvdyA9IHJvd3NUb0ZpbHRlcltpXTtcbiAgICAgIGNvbnN0IHBhc3MgPSBmaWx0ZXJSb3cocm93KTtcbiAgICAgIGlmIChwYXNzKSB7XG4gICAgICAgIHZhciBfcm93JHN1YlJvd3MyO1xuICAgICAgICBpZiAoKF9yb3ckc3ViUm93czIgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MyLmxlbmd0aCAmJiBkZXB0aCA8IG1heERlcHRoKSB7XG4gICAgICAgICAgY29uc3QgbmV3Um93ID0gY3JlYXRlUm93KHRhYmxlLCByb3cuaWQsIHJvdy5vcmlnaW5hbCwgcm93LmluZGV4LCByb3cuZGVwdGgsIHVuZGVmaW5lZCwgcm93LnBhcmVudElkKTtcbiAgICAgICAgICBuZXdSb3cuc3ViUm93cyA9IHJlY3Vyc2VGaWx0ZXJSb3dzKHJvdy5zdWJSb3dzLCBkZXB0aCArIDEpO1xuICAgICAgICAgIHJvdyA9IG5ld1JvdztcbiAgICAgICAgfVxuICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgbmV3RmlsdGVyZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgIG5ld0ZpbHRlcmVkUm93c0J5SWRbcm93LmlkXSA9IHJvdztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJvd3M7XG4gIH07XG4gIHJldHVybiB7XG4gICAgcm93czogcmVjdXJzZUZpbHRlclJvd3Mocm93c1RvRmlsdGVyKSxcbiAgICBmbGF0Um93czogbmV3RmlsdGVyZWRGbGF0Um93cyxcbiAgICByb3dzQnlJZDogbmV3RmlsdGVyZWRSb3dzQnlJZFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRGaWx0ZXJlZFJvd01vZGVsKCkge1xuICByZXR1cm4gdGFibGUgPT4gbWVtbygoKSA9PiBbdGFibGUuZ2V0UHJlRmlsdGVyZWRSb3dNb2RlbCgpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtbkZpbHRlcnMsIHRhYmxlLmdldFN0YXRlKCkuZ2xvYmFsRmlsdGVyXSwgKHJvd01vZGVsLCBjb2x1bW5GaWx0ZXJzLCBnbG9iYWxGaWx0ZXIpID0+IHtcbiAgICBpZiAoIXJvd01vZGVsLnJvd3MubGVuZ3RoIHx8ICEoY29sdW1uRmlsdGVycyAhPSBudWxsICYmIGNvbHVtbkZpbHRlcnMubGVuZ3RoKSAmJiAhZ2xvYmFsRmlsdGVyKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd01vZGVsLmZsYXRSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJvd01vZGVsLmZsYXRSb3dzW2ldLmNvbHVtbkZpbHRlcnMgPSB7fTtcbiAgICAgICAgcm93TW9kZWwuZmxhdFJvd3NbaV0uY29sdW1uRmlsdGVyc01ldGEgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByb3dNb2RlbDtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWRDb2x1bW5GaWx0ZXJzID0gW107XG4gICAgY29uc3QgcmVzb2x2ZWRHbG9iYWxGaWx0ZXJzID0gW107XG4gICAgKGNvbHVtbkZpbHRlcnMgIT0gbnVsbCA/IGNvbHVtbkZpbHRlcnMgOiBbXSkuZm9yRWFjaChkID0+IHtcbiAgICAgIHZhciBfZmlsdGVyRm4kcmVzb2x2ZUZpbHQ7XG4gICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oZC5pZCk7XG4gICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBmaWx0ZXJGbiA9IGNvbHVtbi5nZXRGaWx0ZXJGbigpO1xuICAgICAgaWYgKCFmaWx0ZXJGbikge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGZpbmQgYSB2YWxpZCAnY29sdW1uLmZpbHRlckZuJyBmb3IgY29sdW1uIHdpdGggdGhlIElEOiAke2NvbHVtbi5pZH0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZWRDb2x1bW5GaWx0ZXJzLnB1c2goe1xuICAgICAgICBpZDogZC5pZCxcbiAgICAgICAgZmlsdGVyRm4sXG4gICAgICAgIHJlc29sdmVkVmFsdWU6IChfZmlsdGVyRm4kcmVzb2x2ZUZpbHQgPSBmaWx0ZXJGbi5yZXNvbHZlRmlsdGVyVmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IGZpbHRlckZuLnJlc29sdmVGaWx0ZXJWYWx1ZShkLnZhbHVlKSkgIT0gbnVsbCA/IF9maWx0ZXJGbiRyZXNvbHZlRmlsdCA6IGQudmFsdWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IGZpbHRlcmFibGVJZHMgPSBjb2x1bW5GaWx0ZXJzLm1hcChkID0+IGQuaWQpO1xuICAgIGNvbnN0IGdsb2JhbEZpbHRlckZuID0gdGFibGUuZ2V0R2xvYmFsRmlsdGVyRm4oKTtcbiAgICBjb25zdCBnbG9iYWxseUZpbHRlcmFibGVDb2x1bW5zID0gdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKS5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi5nZXRDYW5HbG9iYWxGaWx0ZXIoKSk7XG4gICAgaWYgKGdsb2JhbEZpbHRlciAmJiBnbG9iYWxGaWx0ZXJGbiAmJiBnbG9iYWxseUZpbHRlcmFibGVDb2x1bW5zLmxlbmd0aCkge1xuICAgICAgZmlsdGVyYWJsZUlkcy5wdXNoKCdfX2dsb2JhbF9fJyk7XG4gICAgICBnbG9iYWxseUZpbHRlcmFibGVDb2x1bW5zLmZvckVhY2goY29sdW1uID0+IHtcbiAgICAgICAgdmFyIF9nbG9iYWxGaWx0ZXJGbiRyZXNvbDtcbiAgICAgICAgcmVzb2x2ZWRHbG9iYWxGaWx0ZXJzLnB1c2goe1xuICAgICAgICAgIGlkOiBjb2x1bW4uaWQsXG4gICAgICAgICAgZmlsdGVyRm46IGdsb2JhbEZpbHRlckZuLFxuICAgICAgICAgIHJlc29sdmVkVmFsdWU6IChfZ2xvYmFsRmlsdGVyRm4kcmVzb2wgPSBnbG9iYWxGaWx0ZXJGbi5yZXNvbHZlRmlsdGVyVmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IGdsb2JhbEZpbHRlckZuLnJlc29sdmVGaWx0ZXJWYWx1ZShnbG9iYWxGaWx0ZXIpKSAhPSBudWxsID8gX2dsb2JhbEZpbHRlckZuJHJlc29sIDogZ2xvYmFsRmlsdGVyXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBjdXJyZW50Q29sdW1uRmlsdGVyO1xuICAgIGxldCBjdXJyZW50R2xvYmFsRmlsdGVyO1xuXG4gICAgLy8gRmxhZyB0aGUgcHJlZmlsdGVyZWQgcm93IG1vZGVsIHdpdGggZWFjaCBmaWx0ZXIgc3RhdGVcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvd01vZGVsLmZsYXRSb3dzLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCByb3cgPSByb3dNb2RlbC5mbGF0Um93c1tqXTtcbiAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzID0ge307XG4gICAgICBpZiAocmVzb2x2ZWRDb2x1bW5GaWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc29sdmVkQ29sdW1uRmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGN1cnJlbnRDb2x1bW5GaWx0ZXIgPSByZXNvbHZlZENvbHVtbkZpbHRlcnNbaV07XG4gICAgICAgICAgY29uc3QgaWQgPSBjdXJyZW50Q29sdW1uRmlsdGVyLmlkO1xuXG4gICAgICAgICAgLy8gVGFnIHRoZSByb3cgd2l0aCB0aGUgY29sdW1uIGZpbHRlciBzdGF0ZVxuICAgICAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzW2lkXSA9IGN1cnJlbnRDb2x1bW5GaWx0ZXIuZmlsdGVyRm4ocm93LCBpZCwgY3VycmVudENvbHVtbkZpbHRlci5yZXNvbHZlZFZhbHVlLCBmaWx0ZXJNZXRhID0+IHtcbiAgICAgICAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzTWV0YVtpZF0gPSBmaWx0ZXJNZXRhO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzb2x2ZWRHbG9iYWxGaWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc29sdmVkR2xvYmFsRmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGN1cnJlbnRHbG9iYWxGaWx0ZXIgPSByZXNvbHZlZEdsb2JhbEZpbHRlcnNbaV07XG4gICAgICAgICAgY29uc3QgaWQgPSBjdXJyZW50R2xvYmFsRmlsdGVyLmlkO1xuICAgICAgICAgIC8vIFRhZyB0aGUgcm93IHdpdGggdGhlIGZpcnN0IHRydXRoeSBnbG9iYWwgZmlsdGVyIHN0YXRlXG4gICAgICAgICAgaWYgKGN1cnJlbnRHbG9iYWxGaWx0ZXIuZmlsdGVyRm4ocm93LCBpZCwgY3VycmVudEdsb2JhbEZpbHRlci5yZXNvbHZlZFZhbHVlLCBmaWx0ZXJNZXRhID0+IHtcbiAgICAgICAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzTWV0YVtpZF0gPSBmaWx0ZXJNZXRhO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByb3cuY29sdW1uRmlsdGVycy5fX2dsb2JhbF9fID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocm93LmNvbHVtbkZpbHRlcnMuX19nbG9iYWxfXyAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzLl9fZ2xvYmFsX18gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmaWx0ZXJSb3dzSW1wbCA9IHJvdyA9PiB7XG4gICAgICAvLyBIb3Jpem9udGFsbHkgZmlsdGVyIHJvd3MgdGhyb3VnaCBlYWNoIGNvbHVtblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJhYmxlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyb3cuY29sdW1uRmlsdGVyc1tmaWx0ZXJhYmxlSWRzW2ldXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvLyBGaWx0ZXIgZmluYWwgcm93cyB1c2luZyBhbGwgb2YgdGhlIGFjdGl2ZSBmaWx0ZXJzXG4gICAgcmV0dXJuIGZpbHRlclJvd3Mocm93TW9kZWwucm93cywgZmlsdGVyUm93c0ltcGwsIHRhYmxlKTtcbiAgfSwge1xuICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldEZpbHRlcmVkUm93TW9kZWwnLFxuICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBO1xuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBIDogdGFibGUub3B0aW9ucy5kZWJ1Z1RhYmxlO1xuICAgIH0sXG4gICAgb25DaGFuZ2U6ICgpID0+IHtcbiAgICAgIHRhYmxlLl9hdXRvUmVzZXRQYWdlSW5kZXgoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRGYWNldGVkUm93TW9kZWwoKSB7XG4gIHJldHVybiAodGFibGUsIGNvbHVtbklkKSA9PiBtZW1vKCgpID0+IFt0YWJsZS5nZXRQcmVGaWx0ZXJlZFJvd01vZGVsKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uRmlsdGVycywgdGFibGUuZ2V0U3RhdGUoKS5nbG9iYWxGaWx0ZXIsIHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwoKV0sIChwcmVSb3dNb2RlbCwgY29sdW1uRmlsdGVycywgZ2xvYmFsRmlsdGVyKSA9PiB7XG4gICAgaWYgKCFwcmVSb3dNb2RlbC5yb3dzLmxlbmd0aCB8fCAhKGNvbHVtbkZpbHRlcnMgIT0gbnVsbCAmJiBjb2x1bW5GaWx0ZXJzLmxlbmd0aCkgJiYgIWdsb2JhbEZpbHRlcikge1xuICAgICAgcmV0dXJuIHByZVJvd01vZGVsO1xuICAgIH1cbiAgICBjb25zdCBmaWx0ZXJhYmxlSWRzID0gWy4uLmNvbHVtbkZpbHRlcnMubWFwKGQgPT4gZC5pZCkuZmlsdGVyKGQgPT4gZCAhPT0gY29sdW1uSWQpLCBnbG9iYWxGaWx0ZXIgPyAnX19nbG9iYWxfXycgOiB1bmRlZmluZWRdLmZpbHRlcihCb29sZWFuKTtcbiAgICBjb25zdCBmaWx0ZXJSb3dzSW1wbCA9IHJvdyA9PiB7XG4gICAgICAvLyBIb3Jpem9udGFsbHkgZmlsdGVyIHJvd3MgdGhyb3VnaCBlYWNoIGNvbHVtblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJhYmxlSWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyb3cuY29sdW1uRmlsdGVyc1tmaWx0ZXJhYmxlSWRzW2ldXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIGZpbHRlclJvd3MocHJlUm93TW9kZWwucm93cywgZmlsdGVyUm93c0ltcGwsIHRhYmxlKTtcbiAgfSwge1xuICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldEZhY2V0ZWRSb3dNb2RlbF8nICsgY29sdW1uSWQsXG4gICAgZGVidWc6ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnVGFibGU7XG4gICAgfSxcbiAgICBvbkNoYW5nZTogKCkgPT4ge31cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEZhY2V0ZWRVbmlxdWVWYWx1ZXMoKSB7XG4gIHJldHVybiAodGFibGUsIGNvbHVtbklkKSA9PiBtZW1vKCgpID0+IHtcbiAgICB2YXIgX3RhYmxlJGdldENvbHVtbjtcbiAgICByZXR1cm4gWyhfdGFibGUkZ2V0Q29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRDb2x1bW4uZ2V0RmFjZXRlZFJvd01vZGVsKCldO1xuICB9LCBmYWNldGVkUm93TW9kZWwgPT4ge1xuICAgIGlmICghZmFjZXRlZFJvd01vZGVsKSByZXR1cm4gbmV3IE1hcCgpO1xuICAgIGxldCBmYWNldGVkVW5pcXVlVmFsdWVzID0gbmV3IE1hcCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmFjZXRlZFJvd01vZGVsLmZsYXRSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBmYWNldGVkUm93TW9kZWwuZmxhdFJvd3NbaV0uZ2V0VW5pcXVlVmFsdWVzKGNvbHVtbklkKTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2pdO1xuICAgICAgICBpZiAoZmFjZXRlZFVuaXF1ZVZhbHVlcy5oYXModmFsdWUpKSB7XG4gICAgICAgICAgdmFyIF9mYWNldGVkVW5pcXVlVmFsdWVzJDtcbiAgICAgICAgICBmYWNldGVkVW5pcXVlVmFsdWVzLnNldCh2YWx1ZSwgKChfZmFjZXRlZFVuaXF1ZVZhbHVlcyQgPSBmYWNldGVkVW5pcXVlVmFsdWVzLmdldCh2YWx1ZSkpICE9IG51bGwgPyBfZmFjZXRlZFVuaXF1ZVZhbHVlcyQgOiAwKSArIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZhY2V0ZWRVbmlxdWVWYWx1ZXMuc2V0KHZhbHVlLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFjZXRlZFVuaXF1ZVZhbHVlcztcbiAgfSwge1xuICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgJ2dldEZhY2V0ZWRVbmlxdWVWYWx1ZXNfJyArIGNvbHVtbklkLFxuICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBO1xuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBIDogdGFibGUub3B0aW9ucy5kZWJ1Z1RhYmxlO1xuICAgIH0sXG4gICAgb25DaGFuZ2U6ICgpID0+IHt9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRGYWNldGVkTWluTWF4VmFsdWVzKCkge1xuICByZXR1cm4gKHRhYmxlLCBjb2x1bW5JZCkgPT4gbWVtbygoKSA9PiB7XG4gICAgdmFyIF90YWJsZSRnZXRDb2x1bW47XG4gICAgcmV0dXJuIFsoX3RhYmxlJGdldENvbHVtbiA9IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCkpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0Q29sdW1uLmdldEZhY2V0ZWRSb3dNb2RlbCgpXTtcbiAgfSwgZmFjZXRlZFJvd01vZGVsID0+IHtcbiAgICB2YXIgX2ZhY2V0ZWRSb3dNb2RlbCRmbGF0O1xuICAgIGlmICghZmFjZXRlZFJvd01vZGVsKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGZpcnN0VmFsdWUgPSAoX2ZhY2V0ZWRSb3dNb2RlbCRmbGF0ID0gZmFjZXRlZFJvd01vZGVsLmZsYXRSb3dzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2ZhY2V0ZWRSb3dNb2RlbCRmbGF0LmdldFVuaXF1ZVZhbHVlcyhjb2x1bW5JZCk7XG4gICAgaWYgKHR5cGVvZiBmaXJzdFZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IGZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSBbZmlyc3RWYWx1ZSwgZmlyc3RWYWx1ZV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYWNldGVkUm93TW9kZWwuZmxhdFJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IGZhY2V0ZWRSb3dNb2RlbC5mbGF0Um93c1tpXS5nZXRVbmlxdWVWYWx1ZXMoY29sdW1uSWQpO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbal07XG4gICAgICAgIGlmICh2YWx1ZSA8IGZhY2V0ZWRNaW5NYXhWYWx1ZXNbMF0pIHtcbiAgICAgICAgICBmYWNldGVkTWluTWF4VmFsdWVzWzBdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPiBmYWNldGVkTWluTWF4VmFsdWVzWzFdKSB7XG4gICAgICAgICAgZmFjZXRlZE1pbk1heFZhbHVlc1sxXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWNldGVkTWluTWF4VmFsdWVzO1xuICB9LCB7XG4gICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0RmFjZXRlZE1pbk1heFZhbHVlc18nICsgY29sdW1uSWQsXG4gICAgZGVidWc6ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnVGFibGU7XG4gICAgfSxcbiAgICBvbkNoYW5nZTogKCkgPT4ge31cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFNvcnRlZFJvd01vZGVsKCkge1xuICByZXR1cm4gdGFibGUgPT4gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5zb3J0aW5nLCB0YWJsZS5nZXRQcmVTb3J0ZWRSb3dNb2RlbCgpXSwgKHNvcnRpbmcsIHJvd01vZGVsKSA9PiB7XG4gICAgaWYgKCFyb3dNb2RlbC5yb3dzLmxlbmd0aCB8fCAhKHNvcnRpbmcgIT0gbnVsbCAmJiBzb3J0aW5nLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiByb3dNb2RlbDtcbiAgICB9XG4gICAgY29uc3Qgc29ydGluZ1N0YXRlID0gdGFibGUuZ2V0U3RhdGUoKS5zb3J0aW5nO1xuICAgIGNvbnN0IHNvcnRlZEZsYXRSb3dzID0gW107XG5cbiAgICAvLyBGaWx0ZXIgb3V0IHNvcnRpbmdzIHRoYXQgY29ycmVzcG9uZCB0byBub24gZXhpc3RpbmcgY29sdW1uc1xuICAgIGNvbnN0IGF2YWlsYWJsZVNvcnRpbmcgPSBzb3J0aW5nU3RhdGUuZmlsdGVyKHNvcnQgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRDb2x1bW47XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRDb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oc29ydC5pZCkpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0Q29sdW1uLmdldENhblNvcnQoKTtcbiAgICB9KTtcbiAgICBjb25zdCBjb2x1bW5JbmZvQnlJZCA9IHt9O1xuICAgIGF2YWlsYWJsZVNvcnRpbmcuZm9yRWFjaChzb3J0RW50cnkgPT4ge1xuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKHNvcnRFbnRyeS5pZCk7XG4gICAgICBpZiAoIWNvbHVtbikgcmV0dXJuO1xuICAgICAgY29sdW1uSW5mb0J5SWRbc29ydEVudHJ5LmlkXSA9IHtcbiAgICAgICAgc29ydFVuZGVmaW5lZDogY29sdW1uLmNvbHVtbkRlZi5zb3J0VW5kZWZpbmVkLFxuICAgICAgICBpbnZlcnRTb3J0aW5nOiBjb2x1bW4uY29sdW1uRGVmLmludmVydFNvcnRpbmcsXG4gICAgICAgIHNvcnRpbmdGbjogY29sdW1uLmdldFNvcnRpbmdGbigpXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHNvcnREYXRhID0gcm93cyA9PiB7XG4gICAgICAvLyBUaGlzIHdpbGwgYWxzbyBwZXJmb3JtIGEgc3RhYmxlIHNvcnRpbmcgdXNpbmcgdGhlIHJvdyBpbmRleFxuICAgICAgLy8gaWYgbmVlZGVkLlxuICAgICAgY29uc3Qgc29ydGVkRGF0YSA9IHJvd3MubWFwKHJvdyA9PiAoe1xuICAgICAgICAuLi5yb3dcbiAgICAgIH0pKTtcbiAgICAgIHNvcnRlZERhdGEuc29ydCgocm93QSwgcm93QikgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF2YWlsYWJsZVNvcnRpbmcubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICB2YXIgX3NvcnRFbnRyeSRkZXNjO1xuICAgICAgICAgIGNvbnN0IHNvcnRFbnRyeSA9IGF2YWlsYWJsZVNvcnRpbmdbaV07XG4gICAgICAgICAgY29uc3QgY29sdW1uSW5mbyA9IGNvbHVtbkluZm9CeUlkW3NvcnRFbnRyeS5pZF07XG4gICAgICAgICAgY29uc3QgaXNEZXNjID0gKF9zb3J0RW50cnkkZGVzYyA9IHNvcnRFbnRyeSA9PSBudWxsID8gdm9pZCAwIDogc29ydEVudHJ5LmRlc2MpICE9IG51bGwgPyBfc29ydEVudHJ5JGRlc2MgOiBmYWxzZTtcbiAgICAgICAgICBsZXQgc29ydEludCA9IDA7XG5cbiAgICAgICAgICAvLyBBbGwgc29ydGluZyBpbnRzIHNob3VsZCBhbHdheXMgcmV0dXJuIGluIGFzY2VuZGluZyBvcmRlclxuICAgICAgICAgIGlmIChjb2x1bW5JbmZvLnNvcnRVbmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGFWYWx1ZSA9IHJvd0EuZ2V0VmFsdWUoc29ydEVudHJ5LmlkKTtcbiAgICAgICAgICAgIGNvbnN0IGJWYWx1ZSA9IHJvd0IuZ2V0VmFsdWUoc29ydEVudHJ5LmlkKTtcbiAgICAgICAgICAgIGNvbnN0IGFVbmRlZmluZWQgPSBhVmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGJVbmRlZmluZWQgPSBiVmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChhVW5kZWZpbmVkIHx8IGJVbmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc29ydEludCA9IGFVbmRlZmluZWQgJiYgYlVuZGVmaW5lZCA/IDAgOiBhVW5kZWZpbmVkID8gY29sdW1uSW5mby5zb3J0VW5kZWZpbmVkIDogLWNvbHVtbkluZm8uc29ydFVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNvcnRJbnQgPT09IDApIHtcbiAgICAgICAgICAgIHNvcnRJbnQgPSBjb2x1bW5JbmZvLnNvcnRpbmdGbihyb3dBLCByb3dCLCBzb3J0RW50cnkuaWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHNvcnRpbmcgaXMgbm9uLXplcm8sIHRha2UgY2FyZSBvZiBkZXNjIGFuZCBpbnZlcnNpb25cbiAgICAgICAgICBpZiAoc29ydEludCAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKGlzRGVzYykge1xuICAgICAgICAgICAgICBzb3J0SW50ICo9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbHVtbkluZm8uaW52ZXJ0U29ydGluZykge1xuICAgICAgICAgICAgICBzb3J0SW50ICo9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvcnRJbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dBLmluZGV4IC0gcm93Qi5pbmRleDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBJZiB0aGVyZSBhcmUgc3ViLXJvd3MsIHNvcnQgdGhlbVxuICAgICAgc29ydGVkRGF0YS5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgIHZhciBfcm93JHN1YlJvd3M7XG4gICAgICAgIHNvcnRlZEZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgaWYgKChfcm93JHN1YlJvd3MgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgcm93LnN1YlJvd3MgPSBzb3J0RGF0YShyb3cuc3ViUm93cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvcnRlZERhdGE7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgcm93czogc29ydERhdGEocm93TW9kZWwucm93cyksXG4gICAgICBmbGF0Um93czogc29ydGVkRmxhdFJvd3MsXG4gICAgICByb3dzQnlJZDogcm93TW9kZWwucm93c0J5SWRcbiAgICB9O1xuICB9LCB7XG4gICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0U29ydGVkUm93TW9kZWwnLFxuICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBO1xuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBIDogdGFibGUub3B0aW9ucy5kZWJ1Z1RhYmxlO1xuICAgIH0sXG4gICAgb25DaGFuZ2U6ICgpID0+IHtcbiAgICAgIHRhYmxlLl9hdXRvUmVzZXRQYWdlSW5kZXgoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRHcm91cGVkUm93TW9kZWwoKSB7XG4gIHJldHVybiB0YWJsZSA9PiBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLmdyb3VwaW5nLCB0YWJsZS5nZXRQcmVHcm91cGVkUm93TW9kZWwoKV0sIChncm91cGluZywgcm93TW9kZWwpID0+IHtcbiAgICBpZiAoIXJvd01vZGVsLnJvd3MubGVuZ3RoIHx8ICFncm91cGluZy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiByb3dNb2RlbDtcbiAgICB9XG5cbiAgICAvLyBGaWx0ZXIgdGhlIGdyb3VwaW5nIGxpc3QgZG93biB0byBjb2x1bW5zIHRoYXQgZXhpc3RcbiAgICBjb25zdCBleGlzdGluZ0dyb3VwaW5nID0gZ3JvdXBpbmcuZmlsdGVyKGNvbHVtbklkID0+IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCkpO1xuICAgIGNvbnN0IGdyb3VwZWRGbGF0Um93cyA9IFtdO1xuICAgIGNvbnN0IGdyb3VwZWRSb3dzQnlJZCA9IHt9O1xuICAgIC8vIGNvbnN0IG9ubHlHcm91cGVkRmxhdFJvd3M6IFJvd1tdID0gW107XG4gICAgLy8gY29uc3Qgb25seUdyb3VwZWRSb3dzQnlJZDogUmVjb3JkPFJvd0lkLCBSb3c+ID0ge307XG4gICAgLy8gY29uc3Qgbm9uR3JvdXBlZEZsYXRSb3dzOiBSb3dbXSA9IFtdO1xuICAgIC8vIGNvbnN0IG5vbkdyb3VwZWRSb3dzQnlJZDogUmVjb3JkPFJvd0lkLCBSb3c+ID0ge307XG5cbiAgICAvLyBSZWN1cnNpdmVseSBncm91cCB0aGUgZGF0YVxuICAgIGNvbnN0IGdyb3VwVXBSZWN1cnNpdmVseSA9IGZ1bmN0aW9uIChyb3dzLCBkZXB0aCwgcGFyZW50SWQpIHtcbiAgICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRlcHRoID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIEdyb3VwaW5nIGRlcHRoIGhhcyBiZWVuIGJlZW4gbWV0XG4gICAgICAvLyBTdG9wIGdyb3VwaW5nIGFuZCBzaW1wbHkgcmV3cml0ZSB0aGQgZGVwdGggYW5kIHJvdyByZWxhdGlvbnNoaXBzXG4gICAgICBpZiAoZGVwdGggPj0gZXhpc3RpbmdHcm91cGluZy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJvd3MubWFwKHJvdyA9PiB7XG4gICAgICAgICAgcm93LmRlcHRoID0gZGVwdGg7XG4gICAgICAgICAgZ3JvdXBlZEZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgICBncm91cGVkUm93c0J5SWRbcm93LmlkXSA9IHJvdztcbiAgICAgICAgICBpZiAocm93LnN1YlJvd3MpIHtcbiAgICAgICAgICAgIHJvdy5zdWJSb3dzID0gZ3JvdXBVcFJlY3Vyc2l2ZWx5KHJvdy5zdWJSb3dzLCBkZXB0aCArIDEsIHJvdy5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgY29sdW1uSWQgPSBleGlzdGluZ0dyb3VwaW5nW2RlcHRoXTtcblxuICAgICAgLy8gR3JvdXAgdGhlIHJvd3MgdG9nZXRoZXIgZm9yIHRoaXMgbGV2ZWxcbiAgICAgIGNvbnN0IHJvd0dyb3Vwc01hcCA9IGdyb3VwQnkocm93cywgY29sdW1uSWQpO1xuXG4gICAgICAvLyBQZWZvcm0gYWdncmVnYXRpb25zIGZvciBlYWNoIGdyb3VwXG4gICAgICBjb25zdCBhZ2dyZWdhdGVkR3JvdXBlZFJvd3MgPSBBcnJheS5mcm9tKHJvd0dyb3Vwc01hcC5lbnRyaWVzKCkpLm1hcCgoX3JlZiwgaW5kZXgpID0+IHtcbiAgICAgICAgbGV0IFtncm91cGluZ1ZhbHVlLCBncm91cGVkUm93c10gPSBfcmVmO1xuICAgICAgICBsZXQgaWQgPSBgJHtjb2x1bW5JZH06JHtncm91cGluZ1ZhbHVlfWA7XG4gICAgICAgIGlkID0gcGFyZW50SWQgPyBgJHtwYXJlbnRJZH0+JHtpZH1gIDogaWQ7XG5cbiAgICAgICAgLy8gRmlyc3QsIFJlY3Vyc2UgdG8gZ3JvdXAgc3ViIHJvd3MgYmVmb3JlIGFnZ3JlZ2F0aW9uXG4gICAgICAgIGNvbnN0IHN1YlJvd3MgPSBncm91cFVwUmVjdXJzaXZlbHkoZ3JvdXBlZFJvd3MsIGRlcHRoICsgMSwgaWQpO1xuXG4gICAgICAgIC8vIEZsYXR0ZW4gdGhlIGxlYWYgcm93cyBvZiB0aGUgcm93cyBpbiB0aGlzIGdyb3VwXG4gICAgICAgIGNvbnN0IGxlYWZSb3dzID0gZGVwdGggPyBmbGF0dGVuQnkoZ3JvdXBlZFJvd3MsIHJvdyA9PiByb3cuc3ViUm93cykgOiBncm91cGVkUm93cztcbiAgICAgICAgY29uc3Qgcm93ID0gY3JlYXRlUm93KHRhYmxlLCBpZCwgbGVhZlJvd3NbMF0ub3JpZ2luYWwsIGluZGV4LCBkZXB0aCwgdW5kZWZpbmVkLCBwYXJlbnRJZCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocm93LCB7XG4gICAgICAgICAgZ3JvdXBpbmdDb2x1bW5JZDogY29sdW1uSWQsXG4gICAgICAgICAgZ3JvdXBpbmdWYWx1ZSxcbiAgICAgICAgICBzdWJSb3dzLFxuICAgICAgICAgIGxlYWZSb3dzLFxuICAgICAgICAgIGdldFZhbHVlOiBjb2x1bW5JZCA9PiB7XG4gICAgICAgICAgICAvLyBEb24ndCBhZ2dyZWdhdGUgY29sdW1ucyB0aGF0IGFyZSBpbiB0aGUgZ3JvdXBpbmdcbiAgICAgICAgICAgIGlmIChleGlzdGluZ0dyb3VwaW5nLmluY2x1ZGVzKGNvbHVtbklkKSkge1xuICAgICAgICAgICAgICBpZiAocm93Ll92YWx1ZXNDYWNoZS5oYXNPd25Qcm9wZXJ0eShjb2x1bW5JZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm93Ll92YWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGdyb3VwZWRSb3dzWzBdKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9ncm91cGVkUm93cyQwJGdldFZhbDtcbiAgICAgICAgICAgICAgICByb3cuX3ZhbHVlc0NhY2hlW2NvbHVtbklkXSA9IChfZ3JvdXBlZFJvd3MkMCRnZXRWYWwgPSBncm91cGVkUm93c1swXS5nZXRWYWx1ZShjb2x1bW5JZCkpICE9IG51bGwgPyBfZ3JvdXBlZFJvd3MkMCRnZXRWYWwgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJvdy5fdmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZS5oYXNPd25Qcm9wZXJ0eShjb2x1bW5JZCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFnZ3JlZ2F0ZSB0aGUgdmFsdWVzXG4gICAgICAgICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oY29sdW1uSWQpO1xuICAgICAgICAgICAgY29uc3QgYWdncmVnYXRlRm4gPSBjb2x1bW4gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbHVtbi5nZXRBZ2dyZWdhdGlvbkZuKCk7XG4gICAgICAgICAgICBpZiAoYWdncmVnYXRlRm4pIHtcbiAgICAgICAgICAgICAgcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXSA9IGFnZ3JlZ2F0ZUZuKGNvbHVtbklkLCBsZWFmUm93cywgZ3JvdXBlZFJvd3MpO1xuICAgICAgICAgICAgICByZXR1cm4gcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzdWJSb3dzLmZvckVhY2goc3ViUm93ID0+IHtcbiAgICAgICAgICBncm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgICAgIGdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgICAgIC8vIGlmIChzdWJSb3cuZ2V0SXNHcm91cGVkPy4oKSkge1xuICAgICAgICAgIC8vICAgb25seUdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAgICAgLy8gICBvbmx5R3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XG4gICAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgICAvLyAgIG5vbkdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAgICAgLy8gICBub25Hcm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgICAgICAvLyB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcm93O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWdncmVnYXRlZEdyb3VwZWRSb3dzO1xuICAgIH07XG4gICAgY29uc3QgZ3JvdXBlZFJvd3MgPSBncm91cFVwUmVjdXJzaXZlbHkocm93TW9kZWwucm93cywgMCk7XG4gICAgZ3JvdXBlZFJvd3MuZm9yRWFjaChzdWJSb3cgPT4ge1xuICAgICAgZ3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KTtcbiAgICAgIGdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgLy8gaWYgKHN1YlJvdy5nZXRJc0dyb3VwZWQ/LigpKSB7XG4gICAgICAvLyAgIG9ubHlHcm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgLy8gICBvbmx5R3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gICBub25Hcm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgLy8gICBub25Hcm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgIC8vIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgcm93czogZ3JvdXBlZFJvd3MsXG4gICAgICBmbGF0Um93czogZ3JvdXBlZEZsYXRSb3dzLFxuICAgICAgcm93c0J5SWQ6IGdyb3VwZWRSb3dzQnlJZFxuICAgIH07XG4gIH0sIHtcbiAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmICdnZXRHcm91cGVkUm93TW9kZWwnLFxuICAgIGRlYnVnOiAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZGVidWdBO1xuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgPSB0YWJsZS5vcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZGVidWdBIDogdGFibGUub3B0aW9ucy5kZWJ1Z1RhYmxlO1xuICAgIH0sXG4gICAgb25DaGFuZ2U6ICgpID0+IHtcbiAgICAgIHRhYmxlLl9xdWV1ZSgoKSA9PiB7XG4gICAgICAgIHRhYmxlLl9hdXRvUmVzZXRFeHBhbmRlZCgpO1xuICAgICAgICB0YWJsZS5fYXV0b1Jlc2V0UGFnZUluZGV4KCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ3JvdXBCeShyb3dzLCBjb2x1bW5JZCkge1xuICBjb25zdCBncm91cE1hcCA9IG5ldyBNYXAoKTtcbiAgcmV0dXJuIHJvd3MucmVkdWNlKChtYXAsIHJvdykgPT4ge1xuICAgIGNvbnN0IHJlc0tleSA9IGAke3Jvdy5nZXRHcm91cGluZ1ZhbHVlKGNvbHVtbklkKX1gO1xuICAgIGNvbnN0IHByZXZpb3VzID0gbWFwLmdldChyZXNLZXkpO1xuICAgIGlmICghcHJldmlvdXMpIHtcbiAgICAgIG1hcC5zZXQocmVzS2V5LCBbcm93XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXZpb3VzLnB1c2gocm93KTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbiAgfSwgZ3JvdXBNYXApO1xufVxuXG5mdW5jdGlvbiBnZXRFeHBhbmRlZFJvd01vZGVsKCkge1xuICByZXR1cm4gdGFibGUgPT4gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5leHBhbmRlZCwgdGFibGUuZ2V0UHJlRXhwYW5kZWRSb3dNb2RlbCgpLCB0YWJsZS5vcHRpb25zLnBhZ2luYXRlRXhwYW5kZWRSb3dzXSwgKGV4cGFuZGVkLCByb3dNb2RlbCwgcGFnaW5hdGVFeHBhbmRlZFJvd3MpID0+IHtcbiAgICBpZiAoIXJvd01vZGVsLnJvd3MubGVuZ3RoIHx8IGV4cGFuZGVkICE9PSB0cnVlICYmICFPYmplY3Qua2V5cyhleHBhbmRlZCAhPSBudWxsID8gZXhwYW5kZWQgOiB7fSkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcm93TW9kZWw7XG4gICAgfVxuICAgIGlmICghcGFnaW5hdGVFeHBhbmRlZFJvd3MpIHtcbiAgICAgIC8vIE9ubHkgZXhwYW5kIHJvd3MgYXQgdGhpcyBwb2ludCBpZiB0aGV5IGFyZSBiZWluZyBwYWdpbmF0ZWRcbiAgICAgIHJldHVybiByb3dNb2RlbDtcbiAgICB9XG4gICAgcmV0dXJuIGV4cGFuZFJvd3Mocm93TW9kZWwpO1xuICB9LCB7XG4gICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0RXhwYW5kZWRSb3dNb2RlbCcsXG4gICAgZGVidWc6ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRkZWJ1Z0E7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGRlYnVnQSA9IHRhYmxlLm9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRkZWJ1Z0EgOiB0YWJsZS5vcHRpb25zLmRlYnVnVGFibGU7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGV4cGFuZFJvd3Mocm93TW9kZWwpIHtcbiAgY29uc3QgZXhwYW5kZWRSb3dzID0gW107XG4gIGNvbnN0IGhhbmRsZVJvdyA9IHJvdyA9PiB7XG4gICAgdmFyIF9yb3ckc3ViUm93cztcbiAgICBleHBhbmRlZFJvd3MucHVzaChyb3cpO1xuICAgIGlmICgoX3JvdyRzdWJSb3dzID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzLmxlbmd0aCAmJiByb3cuZ2V0SXNFeHBhbmRlZCgpKSB7XG4gICAgICByb3cuc3ViUm93cy5mb3JFYWNoKGhhbmRsZVJvdyk7XG4gICAgfVxuICB9O1xuICByb3dNb2RlbC5yb3dzLmZvckVhY2goaGFuZGxlUm93KTtcbiAgcmV0dXJuIHtcbiAgICByb3dzOiBleHBhbmRlZFJvd3MsXG4gICAgZmxhdFJvd3M6IHJvd01vZGVsLmZsYXRSb3dzLFxuICAgIHJvd3NCeUlkOiByb3dNb2RlbC5yb3dzQnlJZFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRQYWdpbmF0aW9uUm93TW9kZWwob3B0cykge1xuICByZXR1cm4gdGFibGUgPT4gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5wYWdpbmF0aW9uLCB0YWJsZS5nZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwoKSwgdGFibGUub3B0aW9ucy5wYWdpbmF0ZUV4cGFuZGVkUm93cyA/IHVuZGVmaW5lZCA6IHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWRdLCAocGFnaW5hdGlvbiwgcm93TW9kZWwpID0+IHtcbiAgICBpZiAoIXJvd01vZGVsLnJvd3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcm93TW9kZWw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VTaXplLFxuICAgICAgcGFnZUluZGV4XG4gICAgfSA9IHBhZ2luYXRpb247XG4gICAgbGV0IHtcbiAgICAgIHJvd3MsXG4gICAgICBmbGF0Um93cyxcbiAgICAgIHJvd3NCeUlkXG4gICAgfSA9IHJvd01vZGVsO1xuICAgIGNvbnN0IHBhZ2VTdGFydCA9IHBhZ2VTaXplICogcGFnZUluZGV4O1xuICAgIGNvbnN0IHBhZ2VFbmQgPSBwYWdlU3RhcnQgKyBwYWdlU2l6ZTtcbiAgICByb3dzID0gcm93cy5zbGljZShwYWdlU3RhcnQsIHBhZ2VFbmQpO1xuICAgIGxldCBwYWdpbmF0ZWRSb3dNb2RlbDtcbiAgICBpZiAoIXRhYmxlLm9wdGlvbnMucGFnaW5hdGVFeHBhbmRlZFJvd3MpIHtcbiAgICAgIHBhZ2luYXRlZFJvd01vZGVsID0gZXhwYW5kUm93cyh7XG4gICAgICAgIHJvd3MsXG4gICAgICAgIGZsYXRSb3dzLFxuICAgICAgICByb3dzQnlJZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhZ2luYXRlZFJvd01vZGVsID0ge1xuICAgICAgICByb3dzLFxuICAgICAgICBmbGF0Um93cyxcbiAgICAgICAgcm93c0J5SWRcbiAgICAgIH07XG4gICAgfVxuICAgIHBhZ2luYXRlZFJvd01vZGVsLmZsYXRSb3dzID0gW107XG4gICAgY29uc3QgaGFuZGxlUm93ID0gcm93ID0+IHtcbiAgICAgIHBhZ2luYXRlZFJvd01vZGVsLmZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgIGlmIChyb3cuc3ViUm93cy5sZW5ndGgpIHtcbiAgICAgICAgcm93LnN1YlJvd3MuZm9yRWFjaChoYW5kbGVSb3cpO1xuICAgICAgfVxuICAgIH07XG4gICAgcGFnaW5hdGVkUm93TW9kZWwucm93cy5mb3JFYWNoKGhhbmRsZVJvdyk7XG4gICAgcmV0dXJuIHBhZ2luYXRlZFJvd01vZGVsO1xuICB9LCB7XG4gICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAnZ2V0UGFnaW5hdGlvblJvd01vZGVsJyxcbiAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGRlYnVnQTtcbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZGVidWdBID0gdGFibGUub3B0aW9ucy5kZWJ1Z0FsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGRlYnVnQSA6IHRhYmxlLm9wdGlvbnMuZGVidWdUYWJsZTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgeyBDb2x1bW5TaXppbmcsIEV4cGFuZGluZywgRmlsdGVycywgR3JvdXBpbmcsIEhlYWRlcnMsIE9yZGVyaW5nLCBQYWdpbmF0aW9uLCBQaW5uaW5nLCBSb3dTZWxlY3Rpb24sIFNvcnRpbmcsIFZpc2liaWxpdHksIGFnZ3JlZ2F0aW9uRm5zLCBidWlsZEhlYWRlckdyb3VwcywgY3JlYXRlQ2VsbCwgY3JlYXRlQ29sdW1uLCBjcmVhdGVDb2x1bW5IZWxwZXIsIGNyZWF0ZVJvdywgY3JlYXRlVGFibGUsIGRlZmF1bHRDb2x1bW5TaXppbmcsIGV4cGFuZFJvd3MsIGZpbHRlckZucywgZmxhdHRlbkJ5LCBmdW5jdGlvbmFsVXBkYXRlLCBnZXRDb3JlUm93TW9kZWwsIGdldEV4cGFuZGVkUm93TW9kZWwsIGdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMsIGdldEZhY2V0ZWRSb3dNb2RlbCwgZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcywgZ2V0RmlsdGVyZWRSb3dNb2RlbCwgZ2V0R3JvdXBlZFJvd01vZGVsLCBnZXRQYWdpbmF0aW9uUm93TW9kZWwsIGdldFNvcnRlZFJvd01vZGVsLCBpc0Z1bmN0aW9uLCBpc051bWJlckFycmF5LCBpc1Jvd1NlbGVjdGVkLCBpc1N1YlJvd1NlbGVjdGVkLCBtYWtlU3RhdGVVcGRhdGVyLCBtZW1vLCBub29wLCBvcmRlckNvbHVtbnMsIHBhc3NpdmVFdmVudFN1cHBvcnRlZCwgcmVTcGxpdEFscGhhTnVtZXJpYywgc2VsZWN0Um93c0ZuLCBzaG91bGRBdXRvUmVtb3ZlRmlsdGVyLCBzb3J0aW5nRm5zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOlsiZnVuY3Rpb25hbFVwZGF0ZSIsInVwZGF0ZXIiLCJpbnB1dCIsIm5vb3AiLCJtYWtlU3RhdGVVcGRhdGVyIiwia2V5IiwiaW5zdGFuY2UiLCJzZXRTdGF0ZSIsIm9sZCIsImlzRnVuY3Rpb24iLCJkIiwiRnVuY3Rpb24iLCJpc051bWJlckFycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwiZXZlcnkiLCJ2YWwiLCJmbGF0dGVuQnkiLCJhcnIiLCJnZXRDaGlsZHJlbiIsImZsYXQiLCJyZWN1cnNlIiwic3ViQXJyIiwiZm9yRWFjaCIsIml0ZW0iLCJwdXNoIiwiY2hpbGRyZW4iLCJsZW5ndGgiLCJtZW1vIiwiZ2V0RGVwcyIsImZuIiwib3B0cyIsImRlcHMiLCJyZXN1bHQiLCJkZXBUaW1lIiwiZGVidWciLCJEYXRlIiwibm93IiwibmV3RGVwcyIsImRlcHNDaGFuZ2VkIiwic29tZSIsImRlcCIsImluZGV4IiwicmVzdWx0VGltZSIsIm9uQ2hhbmdlIiwiZGVwRW5kVGltZSIsIk1hdGgiLCJyb3VuZCIsInJlc3VsdEVuZFRpbWUiLCJyZXN1bHRGcHNQZXJjZW50YWdlIiwicGFkIiwic3RyIiwibnVtIiwiU3RyaW5nIiwiY29uc29sZSIsImluZm8iLCJtYXgiLCJtaW4iLCJjcmVhdGVDb2x1bW4iLCJ0YWJsZSIsImNvbHVtbkRlZiIsImRlcHRoIiwicGFyZW50IiwiX3JlZiIsIl9yZXNvbHZlZENvbHVtbkRlZiRpZCIsImRlZmF1bHRDb2x1bW4iLCJfZ2V0RGVmYXVsdENvbHVtbkRlZiIsInJlc29sdmVkQ29sdW1uRGVmIiwiYWNjZXNzb3JLZXkiLCJpZCIsInJlcGxhY2UiLCJ1bmRlZmluZWQiLCJoZWFkZXIiLCJhY2Nlc3NvckZuIiwiaW5jbHVkZXMiLCJvcmlnaW5hbFJvdyIsInNwbGl0IiwiX3Jlc3VsdCIsInByb2Nlc3MiLCJ3YXJuIiwiRXJyb3IiLCJjb2x1bW4iLCJjb2x1bW5zIiwiZ2V0RmxhdENvbHVtbnMiLCJfY29sdW1uJGNvbHVtbnMiLCJmbGF0TWFwIiwiX3RhYmxlJG9wdGlvbnMkZGVidWdBIiwib3B0aW9ucyIsImRlYnVnQWxsIiwiZGVidWdDb2x1bW5zIiwiZ2V0TGVhZkNvbHVtbnMiLCJfZ2V0T3JkZXJDb2x1bW5zRm4iLCJvcmRlckNvbHVtbnMiLCJfY29sdW1uJGNvbHVtbnMyIiwibGVhZkNvbHVtbnMiLCJfdGFibGUkb3B0aW9ucyRkZWJ1Z0EyIiwiZmVhdHVyZSIsIl9mZWF0dXJlcyIsImNyZWF0ZUhlYWRlciIsIl9vcHRpb25zJGlkIiwiaXNQbGFjZWhvbGRlciIsInBsYWNlaG9sZGVySWQiLCJzdWJIZWFkZXJzIiwiY29sU3BhbiIsInJvd1NwYW4iLCJoZWFkZXJHcm91cCIsImdldExlYWZIZWFkZXJzIiwibGVhZkhlYWRlcnMiLCJyZWN1cnNlSGVhZGVyIiwiaCIsIm1hcCIsImdldENvbnRleHQiLCJIZWFkZXJzIiwiY3JlYXRlVGFibGUiLCJnZXRIZWFkZXJHcm91cHMiLCJnZXRBbGxDb2x1bW5zIiwiZ2V0VmlzaWJsZUxlYWZDb2x1bW5zIiwiZ2V0U3RhdGUiLCJjb2x1bW5QaW5uaW5nIiwibGVmdCIsInJpZ2h0IiwiYWxsQ29sdW1ucyIsIl9sZWZ0JG1hcCRmaWx0ZXIiLCJfcmlnaHQkbWFwJGZpbHRlciIsImxlZnRDb2x1bW5zIiwiY29sdW1uSWQiLCJmaW5kIiwiZmlsdGVyIiwiQm9vbGVhbiIsInJpZ2h0Q29sdW1ucyIsImNlbnRlckNvbHVtbnMiLCJoZWFkZXJHcm91cHMiLCJidWlsZEhlYWRlckdyb3VwcyIsImRlYnVnSGVhZGVycyIsImdldENlbnRlckhlYWRlckdyb3VwcyIsImdldExlZnRIZWFkZXJHcm91cHMiLCJfbGVmdCRtYXAkZmlsdGVyMiIsIm9yZGVyZWRMZWFmQ29sdW1ucyIsIl90YWJsZSRvcHRpb25zJGRlYnVnQTMiLCJnZXRSaWdodEhlYWRlckdyb3VwcyIsIl9yaWdodCRtYXAkZmlsdGVyMiIsIl90YWJsZSRvcHRpb25zJGRlYnVnQTQiLCJnZXRGb290ZXJHcm91cHMiLCJyZXZlcnNlIiwiX3RhYmxlJG9wdGlvbnMkZGVidWdBNSIsImdldExlZnRGb290ZXJHcm91cHMiLCJfdGFibGUkb3B0aW9ucyRkZWJ1Z0E2IiwiZ2V0Q2VudGVyRm9vdGVyR3JvdXBzIiwiX3RhYmxlJG9wdGlvbnMkZGVidWdBNyIsImdldFJpZ2h0Rm9vdGVyR3JvdXBzIiwiX3RhYmxlJG9wdGlvbnMkZGVidWdBOCIsImdldEZsYXRIZWFkZXJzIiwiaGVhZGVycyIsIl90YWJsZSRvcHRpb25zJGRlYnVnQTkiLCJnZXRMZWZ0RmxhdEhlYWRlcnMiLCJfdGFibGUkb3B0aW9ucyRkZWJ1Z0ExMCIsImdldENlbnRlckZsYXRIZWFkZXJzIiwiX3RhYmxlJG9wdGlvbnMkZGVidWdBMTEiLCJnZXRSaWdodEZsYXRIZWFkZXJzIiwiX3RhYmxlJG9wdGlvbnMkZGVidWdBMTIiLCJnZXRDZW50ZXJMZWFmSGVhZGVycyIsImZsYXRIZWFkZXJzIiwiX2hlYWRlciRzdWJIZWFkZXJzIiwiX3RhYmxlJG9wdGlvbnMkZGVidWdBMTMiLCJnZXRMZWZ0TGVhZkhlYWRlcnMiLCJfaGVhZGVyJHN1YkhlYWRlcnMyIiwiX3RhYmxlJG9wdGlvbnMkZGVidWdBMTQiLCJnZXRSaWdodExlYWZIZWFkZXJzIiwiX2hlYWRlciRzdWJIZWFkZXJzMyIsIl90YWJsZSRvcHRpb25zJGRlYnVnQTE1IiwiY2VudGVyIiwiX2xlZnQkMCRoZWFkZXJzIiwiX2xlZnQkIiwiX2NlbnRlciQwJGhlYWRlcnMiLCJfY2VudGVyJCIsIl9yaWdodCQwJGhlYWRlcnMiLCJfcmlnaHQkIiwiX3RhYmxlJG9wdGlvbnMkZGVidWdBMTYiLCJjb2x1bW5zVG9Hcm91cCIsImhlYWRlckZhbWlseSIsIl9oZWFkZXJHcm91cHMkMCRoZWFkZSIsIl9oZWFkZXJHcm91cHMkIiwibWF4RGVwdGgiLCJmaW5kTWF4RGVwdGgiLCJnZXRJc1Zpc2libGUiLCJjcmVhdGVIZWFkZXJHcm91cCIsImhlYWRlcnNUb0dyb3VwIiwiam9pbiIsInBlbmRpbmdQYXJlbnRIZWFkZXJzIiwiaGVhZGVyVG9Hcm91cCIsImxhdGVzdFBlbmRpbmdQYXJlbnRIZWFkZXIiLCJpc0xlYWZIZWFkZXIiLCJib3R0b21IZWFkZXJzIiwicmVjdXJzZUhlYWRlcnNGb3JTcGFucyIsImZpbHRlcmVkSGVhZGVycyIsImNoaWxkUm93U3BhbnMiLCJjaGlsZENvbFNwYW4iLCJjaGlsZFJvd1NwYW4iLCJtaW5DaGlsZFJvd1NwYW4iLCJkZWZhdWx0Q29sdW1uU2l6aW5nIiwic2l6ZSIsIm1pblNpemUiLCJtYXhTaXplIiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsImdldERlZmF1bHRDb2x1bW5TaXppbmdJbmZvU3RhdGUiLCJzdGFydE9mZnNldCIsInN0YXJ0U2l6ZSIsImRlbHRhT2Zmc2V0IiwiZGVsdGFQZXJjZW50YWdlIiwiaXNSZXNpemluZ0NvbHVtbiIsImNvbHVtblNpemluZ1N0YXJ0IiwiQ29sdW1uU2l6aW5nIiwiZ2V0RGVmYXVsdENvbHVtbkRlZiIsImdldEluaXRpYWxTdGF0ZSIsInN0YXRlIiwiY29sdW1uU2l6aW5nIiwiY29sdW1uU2l6aW5nSW5mbyIsImdldERlZmF1bHRPcHRpb25zIiwiY29sdW1uUmVzaXplTW9kZSIsImNvbHVtblJlc2l6ZURpcmVjdGlvbiIsIm9uQ29sdW1uU2l6aW5nQ2hhbmdlIiwib25Db2x1bW5TaXppbmdJbmZvQ2hhbmdlIiwiZ2V0U2l6ZSIsIl9jb2x1bW4kY29sdW1uRGVmJG1pbiIsIl9jb2x1bW4kY29sdW1uRGVmJG1heCIsImNvbHVtblNpemUiLCJnZXRTdGFydCIsInBvc2l0aW9uIiwiZ2V0TGVmdFZpc2libGVMZWFmQ29sdW1ucyIsImdldFJpZ2h0VmlzaWJsZUxlYWZDb2x1bW5zIiwiZmluZEluZGV4IiwicHJldlNpYmxpbmdDb2x1bW4iLCJyZXNldFNpemUiLCJzZXRDb2x1bW5TaXppbmciLCJfcmVmMiIsIl8iLCJyZXN0IiwiZ2V0Q2FuUmVzaXplIiwiX2NvbHVtbiRjb2x1bW5EZWYkZW5hIiwiX3RhYmxlJG9wdGlvbnMkZW5hYmxlIiwiZW5hYmxlUmVzaXppbmciLCJlbmFibGVDb2x1bW5SZXNpemluZyIsImdldElzUmVzaXppbmciLCJzdW0iLCJfaGVhZGVyJGNvbHVtbiRnZXRTaXoiLCJwcmV2U2libGluZ0hlYWRlciIsImdldFJlc2l6ZUhhbmRsZXIiLCJfY29udGV4dERvY3VtZW50IiwiZ2V0Q29sdW1uIiwiY2FuUmVzaXplIiwiZSIsInBlcnNpc3QiLCJpc1RvdWNoU3RhcnRFdmVudCIsInRvdWNoZXMiLCJjbGllbnRYIiwibmV3Q29sdW1uU2l6aW5nIiwidXBkYXRlT2Zmc2V0IiwiZXZlbnRUeXBlIiwiY2xpZW50WFBvcyIsInNldENvbHVtblNpemluZ0luZm8iLCJfb2xkJHN0YXJ0T2Zmc2V0IiwiX29sZCRzdGFydFNpemUiLCJkZWx0YURpcmVjdGlvbiIsIl9yZWYzIiwiaGVhZGVyU2l6ZSIsIm9uTW92ZSIsIm9uRW5kIiwiY29udGV4dERvY3VtZW50IiwiZG9jdW1lbnQiLCJtb3VzZUV2ZW50cyIsIm1vdmVIYW5kbGVyIiwidXBIYW5kbGVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInRvdWNoRXZlbnRzIiwiY2FuY2VsYWJsZSIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiX2UkdG91Y2hlcyQiLCJwYXNzaXZlSWZTdXBwb3J0ZWQiLCJwYXNzaXZlRXZlbnRTdXBwb3J0ZWQiLCJwYXNzaXZlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlc2V0Q29sdW1uU2l6aW5nIiwiZGVmYXVsdFN0YXRlIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRjIiwiaW5pdGlhbFN0YXRlIiwicmVzZXRIZWFkZXJTaXplSW5mbyIsIl90YWJsZSRpbml0aWFsU3RhdGUkYzIiLCJnZXRUb3RhbFNpemUiLCJfdGFibGUkZ2V0SGVhZGVyR3JvdXAiLCJfdGFibGUkZ2V0SGVhZGVyR3JvdXAyIiwicmVkdWNlIiwiZ2V0TGVmdFRvdGFsU2l6ZSIsIl90YWJsZSRnZXRMZWZ0SGVhZGVyRyIsIl90YWJsZSRnZXRMZWZ0SGVhZGVyRzIiLCJnZXRDZW50ZXJUb3RhbFNpemUiLCJfdGFibGUkZ2V0Q2VudGVySGVhZGUiLCJfdGFibGUkZ2V0Q2VudGVySGVhZGUyIiwiZ2V0UmlnaHRUb3RhbFNpemUiLCJfdGFibGUkZ2V0UmlnaHRIZWFkZXIiLCJfdGFibGUkZ2V0UmlnaHRIZWFkZXIyIiwicGFzc2l2ZVN1cHBvcnRlZCIsInN1cHBvcnRlZCIsIndpbmRvdyIsImVyciIsInR5cGUiLCJFeHBhbmRpbmciLCJleHBhbmRlZCIsIm9uRXhwYW5kZWRDaGFuZ2UiLCJwYWdpbmF0ZUV4cGFuZGVkUm93cyIsInJlZ2lzdGVyZWQiLCJxdWV1ZWQiLCJfYXV0b1Jlc2V0RXhwYW5kZWQiLCJfdGFibGUkb3B0aW9ucyRhdXRvUmUiLCJfcXVldWUiLCJhdXRvUmVzZXRBbGwiLCJhdXRvUmVzZXRFeHBhbmRlZCIsIm1hbnVhbEV4cGFuZGluZyIsInJlc2V0RXhwYW5kZWQiLCJzZXRFeHBhbmRlZCIsInRvZ2dsZUFsbFJvd3NFeHBhbmRlZCIsImdldElzQWxsUm93c0V4cGFuZGVkIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRlIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSIsImdldENhblNvbWVSb3dzRXhwYW5kIiwiZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsIiwiZmxhdFJvd3MiLCJyb3ciLCJnZXRDYW5FeHBhbmQiLCJnZXRUb2dnbGVBbGxSb3dzRXhwYW5kZWRIYW5kbGVyIiwiZ2V0SXNTb21lUm93c0V4cGFuZGVkIiwiT2JqZWN0IiwidmFsdWVzIiwia2V5cyIsImdldFJvd01vZGVsIiwiZ2V0SXNFeHBhbmRlZCIsImdldEV4cGFuZGVkRGVwdGgiLCJyb3dJZHMiLCJyb3dzQnlJZCIsInNwbGl0SWQiLCJnZXRQcmVFeHBhbmRlZFJvd01vZGVsIiwiZ2V0U29ydGVkUm93TW9kZWwiLCJnZXRFeHBhbmRlZFJvd01vZGVsIiwiX2dldEV4cGFuZGVkUm93TW9kZWwiLCJjcmVhdGVSb3ciLCJ0b2dnbGVFeHBhbmRlZCIsIl9leHBhbmRlZCIsImV4aXN0cyIsIm9sZEV4cGFuZGVkIiwicm93SWQiLCJfdGFibGUkb3B0aW9ucyRnZXRJc1IiLCJnZXRJc1Jvd0V4cGFuZGVkIiwiX3RhYmxlJG9wdGlvbnMkZ2V0Um93IiwiX3JvdyRzdWJSb3dzIiwiZ2V0Um93Q2FuRXhwYW5kIiwiZW5hYmxlRXhwYW5kaW5nIiwic3ViUm93cyIsImdldElzQWxsUGFyZW50c0V4cGFuZGVkIiwiaXNGdWxseUV4cGFuZGVkIiwiY3VycmVudFJvdyIsInBhcmVudElkIiwiZ2V0Um93IiwiZ2V0VG9nZ2xlRXhwYW5kZWRIYW5kbGVyIiwiY2FuRXhwYW5kIiwiaW5jbHVkZXNTdHJpbmciLCJmaWx0ZXJWYWx1ZSIsIl9yb3ckZ2V0VmFsdWUiLCJzZWFyY2giLCJ0b0xvd2VyQ2FzZSIsImdldFZhbHVlIiwidG9TdHJpbmciLCJhdXRvUmVtb3ZlIiwidGVzdEZhbHNleSIsImluY2x1ZGVzU3RyaW5nU2Vuc2l0aXZlIiwiX3JvdyRnZXRWYWx1ZTIiLCJlcXVhbHNTdHJpbmciLCJfcm93JGdldFZhbHVlMyIsImFyckluY2x1ZGVzIiwiX3JvdyRnZXRWYWx1ZTQiLCJhcnJJbmNsdWRlc0FsbCIsIl9yb3ckZ2V0VmFsdWU1IiwiYXJySW5jbHVkZXNTb21lIiwiX3JvdyRnZXRWYWx1ZTYiLCJlcXVhbHMiLCJ3ZWFrRXF1YWxzIiwiaW5OdW1iZXJSYW5nZSIsInJvd1ZhbHVlIiwicmVzb2x2ZUZpbHRlclZhbHVlIiwidW5zYWZlTWluIiwidW5zYWZlTWF4IiwicGFyc2VkTWluIiwicGFyc2VGbG9hdCIsInBhcnNlZE1heCIsImlzTmFOIiwiSW5maW5pdHkiLCJ0ZW1wIiwiZmlsdGVyRm5zIiwiRmlsdGVycyIsImZpbHRlckZuIiwiY29sdW1uRmlsdGVycyIsImdsb2JhbEZpbHRlciIsIm9uQ29sdW1uRmlsdGVyc0NoYW5nZSIsIm9uR2xvYmFsRmlsdGVyQ2hhbmdlIiwiZmlsdGVyRnJvbUxlYWZSb3dzIiwibWF4TGVhZlJvd0ZpbHRlckRlcHRoIiwiZ2xvYmFsRmlsdGVyRm4iLCJnZXRDb2x1bW5DYW5HbG9iYWxGaWx0ZXIiLCJfdGFibGUkZ2V0Q29yZVJvd01vZGUiLCJ2YWx1ZSIsImdldENvcmVSb3dNb2RlbCIsIl9nZXRBbGxDZWxsc0J5Q29sdW1uSWQiLCJnZXRBdXRvRmlsdGVyRm4iLCJmaXJzdFJvdyIsImdldEZpbHRlckZuIiwiX3RhYmxlJG9wdGlvbnMkZmlsdGVyIiwiX3RhYmxlJG9wdGlvbnMkZmlsdGVyMiIsImdldENhbkZpbHRlciIsIl90YWJsZSRvcHRpb25zJGVuYWJsZTIiLCJlbmFibGVDb2x1bW5GaWx0ZXIiLCJlbmFibGVDb2x1bW5GaWx0ZXJzIiwiZW5hYmxlRmlsdGVycyIsImdldENhbkdsb2JhbEZpbHRlciIsIl9jb2x1bW4kY29sdW1uRGVmJGVuYTIiLCJfdGFibGUkb3B0aW9ucyRlbmFibGUzIiwiX3RhYmxlJG9wdGlvbnMkZW5hYmxlNCIsIl90YWJsZSRvcHRpb25zJGdldENvbCIsImVuYWJsZUdsb2JhbEZpbHRlciIsImdldElzRmlsdGVyZWQiLCJnZXRGaWx0ZXJJbmRleCIsImdldEZpbHRlclZhbHVlIiwiX3RhYmxlJGdldFN0YXRlJGNvbHVtIiwiX3RhYmxlJGdldFN0YXRlJGNvbHVtMiIsIl90YWJsZSRnZXRTdGF0ZSRjb2x1bTMiLCJzZXRGaWx0ZXJWYWx1ZSIsInNldENvbHVtbkZpbHRlcnMiLCJwcmV2aW91c2ZpbHRlciIsIm5ld0ZpbHRlciIsInNob3VsZEF1dG9SZW1vdmVGaWx0ZXIiLCJfb2xkJGZpbHRlciIsIm5ld0ZpbHRlck9iaiIsIl9vbGQkbWFwIiwiX2dldEZhY2V0ZWRSb3dNb2RlbCIsImdldEZhY2V0ZWRSb3dNb2RlbCIsImdldFByZUZpbHRlcmVkUm93TW9kZWwiLCJfZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyIsImdldEZhY2V0ZWRVbmlxdWVWYWx1ZXMiLCJNYXAiLCJfZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyIsImdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMiLCJjb2x1bW5GaWx0ZXJzTWV0YSIsImdldEdsb2JhbEF1dG9GaWx0ZXJGbiIsImdldEdsb2JhbEZpbHRlckZuIiwiX3RhYmxlJG9wdGlvbnMkZmlsdGVyMyIsIl90YWJsZSRvcHRpb25zJGZpbHRlcjQiLCJnZXRBbGxMZWFmQ29sdW1ucyIsInVwZGF0ZUZuIiwiX2Z1bmN0aW9uYWxVcGRhdGUiLCJzZXRHbG9iYWxGaWx0ZXIiLCJyZXNldEdsb2JhbEZpbHRlciIsInJlc2V0Q29sdW1uRmlsdGVycyIsImdldEZpbHRlcmVkUm93TW9kZWwiLCJfZ2V0RmlsdGVyZWRSb3dNb2RlbCIsIm1hbnVhbEZpbHRlcmluZyIsIl9nZXRHbG9iYWxGYWNldGVkUm93TW9kZWwiLCJnZXRHbG9iYWxGYWNldGVkUm93TW9kZWwiLCJfZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcyIsImdldEdsb2JhbEZhY2V0ZWRVbmlxdWVWYWx1ZXMiLCJfZ2V0R2xvYmFsRmFjZXRlZE1pbk1heFZhbHVlcyIsImdldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMiLCJfbGVhZlJvd3MiLCJjaGlsZFJvd3MiLCJuZXh0IiwibmV4dFZhbHVlIiwiZXh0ZW50IiwibWVhbiIsImxlYWZSb3dzIiwiY291bnQiLCJtZWRpYW4iLCJtaWQiLCJmbG9vciIsIm51bXMiLCJzb3J0IiwiYSIsImIiLCJ1bmlxdWUiLCJmcm9tIiwiU2V0IiwidW5pcXVlQ291bnQiLCJfY29sdW1uSWQiLCJhZ2dyZWdhdGlvbkZucyIsIkdyb3VwaW5nIiwiYWdncmVnYXRlZENlbGwiLCJwcm9wcyIsIl90b1N0cmluZyIsIl9wcm9wcyRnZXRWYWx1ZSIsImFnZ3JlZ2F0aW9uRm4iLCJncm91cGluZyIsIm9uR3JvdXBpbmdDaGFuZ2UiLCJncm91cGVkQ29sdW1uTW9kZSIsInRvZ2dsZUdyb3VwaW5nIiwic2V0R3JvdXBpbmciLCJnZXRDYW5Hcm91cCIsImVuYWJsZUdyb3VwaW5nIiwiZ2V0SXNHcm91cGVkIiwiX3RhYmxlJGdldFN0YXRlJGdyb3VwIiwiZ2V0R3JvdXBlZEluZGV4IiwiX3RhYmxlJGdldFN0YXRlJGdyb3VwMiIsImluZGV4T2YiLCJnZXRUb2dnbGVHcm91cGluZ0hhbmRsZXIiLCJjYW5Hcm91cCIsImdldEF1dG9BZ2dyZWdhdGlvbkZuIiwicHJvdG90eXBlIiwiY2FsbCIsImdldEFnZ3JlZ2F0aW9uRm4iLCJfdGFibGUkb3B0aW9ucyRhZ2dyZWciLCJfdGFibGUkb3B0aW9ucyRhZ2dyZWcyIiwicmVzZXRHcm91cGluZyIsIl90YWJsZSRpbml0aWFsU3RhdGUkZyIsImdldFByZUdyb3VwZWRSb3dNb2RlbCIsImdldEdyb3VwZWRSb3dNb2RlbCIsIl9nZXRHcm91cGVkUm93TW9kZWwiLCJtYW51YWxHcm91cGluZyIsImdyb3VwaW5nQ29sdW1uSWQiLCJnZXRHcm91cGluZ1ZhbHVlIiwiX2dyb3VwaW5nVmFsdWVzQ2FjaGUiLCJoYXNPd25Qcm9wZXJ0eSIsIm9yaWdpbmFsIiwiY3JlYXRlQ2VsbCIsImNlbGwiLCJnZXRJc1BsYWNlaG9sZGVyIiwiZ2V0SXNBZ2dyZWdhdGVkIiwibm9uR3JvdXBpbmdDb2x1bW5zIiwiY29sIiwiZ3JvdXBpbmdDb2x1bW5zIiwiZyIsIk9yZGVyaW5nIiwiY29sdW1uT3JkZXIiLCJvbkNvbHVtbk9yZGVyQ2hhbmdlIiwic2V0Q29sdW1uT3JkZXIiLCJyZXNldENvbHVtbk9yZGVyIiwib3JkZXJlZENvbHVtbnMiLCJjb2x1bW5PcmRlckNvcHkiLCJjb2x1bW5zQ29weSIsInRhcmdldENvbHVtbklkIiwic2hpZnQiLCJmb3VuZEluZGV4Iiwic3BsaWNlIiwiZGVmYXVsdFBhZ2VJbmRleCIsImRlZmF1bHRQYWdlU2l6ZSIsImdldERlZmF1bHRQYWdpbmF0aW9uU3RhdGUiLCJwYWdlSW5kZXgiLCJwYWdlU2l6ZSIsIlBhZ2luYXRpb24iLCJwYWdpbmF0aW9uIiwib25QYWdpbmF0aW9uQ2hhbmdlIiwiX2F1dG9SZXNldFBhZ2VJbmRleCIsImF1dG9SZXNldFBhZ2VJbmRleCIsIm1hbnVhbFBhZ2luYXRpb24iLCJyZXNldFBhZ2VJbmRleCIsInNldFBhZ2luYXRpb24iLCJzYWZlVXBkYXRlciIsIm5ld1N0YXRlIiwicmVzZXRQYWdpbmF0aW9uIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRwIiwic2V0UGFnZUluZGV4IiwibWF4UGFnZUluZGV4IiwicGFnZUNvdW50IiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRwMiIsInJlc2V0UGFnZVNpemUiLCJfdGFibGUkaW5pdGlhbFN0YXRlJHAzIiwiX3RhYmxlJGluaXRpYWxTdGF0ZTIiLCJzZXRQYWdlU2l6ZSIsInRvcFJvd0luZGV4Iiwic2V0UGFnZUNvdW50IiwiX3RhYmxlJG9wdGlvbnMkcGFnZUNvIiwibmV3UGFnZUNvdW50IiwiZ2V0UGFnZU9wdGlvbnMiLCJnZXRQYWdlQ291bnQiLCJwYWdlT3B0aW9ucyIsImZpbGwiLCJpIiwiZGVidWdUYWJsZSIsImdldENhblByZXZpb3VzUGFnZSIsImdldENhbk5leHRQYWdlIiwicHJldmlvdXNQYWdlIiwibmV4dFBhZ2UiLCJnZXRQYWdpbmF0aW9uUm93TW9kZWwiLCJfZ2V0UGFnaW5hdGlvblJvd01vZGVsIiwiX3RhYmxlJG9wdGlvbnMkcGFnZUNvMiIsImNlaWwiLCJyb3dzIiwiZ2V0RGVmYXVsdENvbHVtblBpbm5pbmdTdGF0ZSIsImdldERlZmF1bHRSb3dQaW5uaW5nU3RhdGUiLCJ0b3AiLCJib3R0b20iLCJQaW5uaW5nIiwicm93UGlubmluZyIsIm9uQ29sdW1uUGlubmluZ0NoYW5nZSIsIm9uUm93UGlubmluZ0NoYW5nZSIsInBpbiIsImNvbHVtbklkcyIsInNldENvbHVtblBpbm5pbmciLCJfb2xkJGxlZnQzIiwiX29sZCRyaWdodDMiLCJfb2xkJGxlZnQiLCJfb2xkJHJpZ2h0IiwiX29sZCRsZWZ0MiIsIl9vbGQkcmlnaHQyIiwiZ2V0Q2FuUGluIiwiX2QkY29sdW1uRGVmJGVuYWJsZVBpIiwiZW5hYmxlUGlubmluZyIsImVuYWJsZUNvbHVtblBpbm5pbmciLCJnZXRJc1Bpbm5lZCIsImxlYWZDb2x1bW5JZHMiLCJpc0xlZnQiLCJpc1JpZ2h0IiwiZ2V0UGlubmVkSW5kZXgiLCJpbmNsdWRlTGVhZlJvd3MiLCJpbmNsdWRlUGFyZW50Um93cyIsImxlYWZSb3dJZHMiLCJnZXRMZWFmUm93cyIsInBhcmVudFJvd0lkcyIsImdldFBhcmVudFJvd3MiLCJzZXRSb3dQaW5uaW5nIiwiX29sZCR0b3AzIiwiX29sZCRib3R0b20zIiwiX29sZCR0b3AiLCJfb2xkJGJvdHRvbSIsImhhcyIsIl9vbGQkdG9wMiIsIl9vbGQkYm90dG9tMiIsIl9yZWY0IiwiZW5hYmxlUm93UGlubmluZyIsImlzVG9wIiwiaXNCb3R0b20iLCJfdGFibGUkX2dldFBpbm5lZFJvd3MiLCJfdmlzaWJsZVBpbm5lZFJvd0lkcyQiLCJ2aXNpYmxlUGlubmVkUm93SWRzIiwiX2dldFBpbm5lZFJvd3MiLCJfcmVmNSIsImdldENlbnRlclZpc2libGVDZWxscyIsIl9nZXRBbGxWaXNpYmxlQ2VsbHMiLCJhbGxDZWxscyIsImxlZnRBbmRSaWdodCIsImRlYnVnUm93cyIsImdldExlZnRWaXNpYmxlQ2VsbHMiLCJjZWxscyIsImdldFJpZ2h0VmlzaWJsZUNlbGxzIiwicmVzZXRDb2x1bW5QaW5uaW5nIiwiZ2V0SXNTb21lQ29sdW1uc1Bpbm5lZCIsIl9waW5uaW5nU3RhdGUkcG9zaXRpbyIsInBpbm5pbmdTdGF0ZSIsIl9waW5uaW5nU3RhdGUkbGVmdCIsIl9waW5uaW5nU3RhdGUkcmlnaHQiLCJnZXRMZWZ0TGVhZkNvbHVtbnMiLCJnZXRSaWdodExlYWZDb2x1bW5zIiwiZ2V0Q2VudGVyTGVhZkNvbHVtbnMiLCJyZXNldFJvd1Bpbm5pbmciLCJfdGFibGUkaW5pdGlhbFN0YXRlJHIiLCJnZXRJc1NvbWVSb3dzUGlubmVkIiwiX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvMiIsIl9waW5uaW5nU3RhdGUkdG9wIiwiX3Bpbm5pbmdTdGF0ZSRib3R0b20iLCJ2aXNpYmxlUm93cyIsInBpbm5lZFJvd0lkcyIsIl90YWJsZSRvcHRpb25zJGtlZXBQaSIsImtlZXBQaW5uZWRSb3dzIiwiZ2V0VG9wUm93cyIsImdldEJvdHRvbVJvd3MiLCJnZXRDZW50ZXJSb3dzIiwiYWxsUm93cyIsInRvcEFuZEJvdHRvbSIsIlJvd1NlbGVjdGlvbiIsInJvd1NlbGVjdGlvbiIsIm9uUm93U2VsZWN0aW9uQ2hhbmdlIiwiZW5hYmxlUm93U2VsZWN0aW9uIiwiZW5hYmxlTXVsdGlSb3dTZWxlY3Rpb24iLCJlbmFibGVTdWJSb3dTZWxlY3Rpb24iLCJzZXRSb3dTZWxlY3Rpb24iLCJyZXNldFJvd1NlbGVjdGlvbiIsInRvZ2dsZUFsbFJvd3NTZWxlY3RlZCIsImdldElzQWxsUm93c1NlbGVjdGVkIiwicHJlR3JvdXBlZEZsYXRSb3dzIiwiZ2V0Q2FuU2VsZWN0IiwidG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZCIsInJlc29sdmVkVmFsdWUiLCJnZXRJc0FsbFBhZ2VSb3dzU2VsZWN0ZWQiLCJtdXRhdGVSb3dJc1NlbGVjdGVkIiwiZ2V0UHJlU2VsZWN0ZWRSb3dNb2RlbCIsImdldFNlbGVjdGVkUm93TW9kZWwiLCJyb3dNb2RlbCIsInNlbGVjdFJvd3NGbiIsImdldEZpbHRlcmVkU2VsZWN0ZWRSb3dNb2RlbCIsImdldEdyb3VwZWRTZWxlY3RlZFJvd01vZGVsIiwiaXNBbGxSb3dzU2VsZWN0ZWQiLCJwYWdpbmF0aW9uRmxhdFJvd3MiLCJpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQiLCJnZXRJc1NvbWVSb3dzU2VsZWN0ZWQiLCJfdGFibGUkZ2V0U3RhdGUkcm93U2UiLCJ0b3RhbFNlbGVjdGVkIiwiZ2V0SXNTb21lUGFnZVJvd3NTZWxlY3RlZCIsImdldElzU2VsZWN0ZWQiLCJnZXRJc1NvbWVTZWxlY3RlZCIsImdldFRvZ2dsZUFsbFJvd3NTZWxlY3RlZEhhbmRsZXIiLCJ0YXJnZXQiLCJjaGVja2VkIiwiZ2V0VG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZEhhbmRsZXIiLCJ0b2dnbGVTZWxlY3RlZCIsImlzU2VsZWN0ZWQiLCJfb3B0cyRzZWxlY3RDaGlsZHJlbiIsInNlbGVjdGVkUm93SWRzIiwic2VsZWN0Q2hpbGRyZW4iLCJpc1Jvd1NlbGVjdGVkIiwiaXNTdWJSb3dTZWxlY3RlZCIsImdldElzQWxsU3ViUm93c1NlbGVjdGVkIiwiZ2V0Q2FuU2VsZWN0U3ViUm93cyIsImdldENhbk11bHRpU2VsZWN0IiwiZ2V0VG9nZ2xlU2VsZWN0ZWRIYW5kbGVyIiwiY2FuU2VsZWN0IiwiX3RhcmdldCIsImluY2x1ZGVDaGlsZHJlbiIsIm5ld1NlbGVjdGVkRmxhdFJvd3MiLCJuZXdTZWxlY3RlZFJvd3NCeUlkIiwicmVjdXJzZVJvd3MiLCJfcm93JHN1YlJvd3MyIiwic2VsZWN0aW9uIiwiX3NlbGVjdGlvbiRyb3ckaWQiLCJfcm93JHN1YlJvd3MzIiwiYWxsQ2hpbGRyZW5TZWxlY3RlZCIsInNvbWVTZWxlY3RlZCIsInN1YlJvdyIsInN1YlJvd0NoaWxkcmVuU2VsZWN0ZWQiLCJyZVNwbGl0QWxwaGFOdW1lcmljIiwiYWxwaGFudW1lcmljIiwicm93QSIsInJvd0IiLCJjb21wYXJlQWxwaGFudW1lcmljIiwiYWxwaGFudW1lcmljQ2FzZVNlbnNpdGl2ZSIsInRleHQiLCJjb21wYXJlQmFzaWMiLCJ0ZXh0Q2FzZVNlbnNpdGl2ZSIsImRhdGV0aW1lIiwiYmFzaWMiLCJhU3RyIiwiYlN0ciIsImFhIiwiYmIiLCJhbiIsInBhcnNlSW50IiwiYm4iLCJjb21ibyIsInNvcnRpbmdGbnMiLCJTb3J0aW5nIiwic29ydGluZyIsInNvcnRpbmdGbiIsInNvcnRVbmRlZmluZWQiLCJvblNvcnRpbmdDaGFuZ2UiLCJpc011bHRpU29ydEV2ZW50Iiwic2hpZnRLZXkiLCJnZXRBdXRvU29ydGluZ0ZuIiwiZmlyc3RSb3dzIiwic2xpY2UiLCJpc1N0cmluZyIsImdldEF1dG9Tb3J0RGlyIiwiZ2V0U29ydGluZ0ZuIiwiX3RhYmxlJG9wdGlvbnMkc29ydGluIiwiX3RhYmxlJG9wdGlvbnMkc29ydGluMiIsInRvZ2dsZVNvcnRpbmciLCJkZXNjIiwibXVsdGkiLCJuZXh0U29ydGluZ09yZGVyIiwiZ2V0TmV4dFNvcnRpbmdPcmRlciIsImhhc01hbnVhbFZhbHVlIiwic2V0U29ydGluZyIsImV4aXN0aW5nU29ydGluZyIsImV4aXN0aW5nSW5kZXgiLCJuZXdTb3J0aW5nIiwic29ydEFjdGlvbiIsIm5leHREZXNjIiwiZ2V0Q2FuTXVsdGlTb3J0IiwiX3RhYmxlJG9wdGlvbnMkbWF4TXVsIiwibWF4TXVsdGlTb3J0Q29sQ291bnQiLCJnZXRGaXJzdFNvcnREaXIiLCJfY29sdW1uJGNvbHVtbkRlZiRzb3IiLCJzb3J0RGVzY0ZpcnN0IiwiZmlyc3RTb3J0RGlyZWN0aW9uIiwiaXNTb3J0ZWQiLCJnZXRJc1NvcnRlZCIsImVuYWJsZVNvcnRpbmdSZW1vdmFsIiwiZW5hYmxlTXVsdGlSZW1vdmUiLCJnZXRDYW5Tb3J0IiwiZW5hYmxlU29ydGluZyIsImVuYWJsZU11bHRpU29ydCIsIl90YWJsZSRnZXRTdGF0ZSRzb3J0aSIsImNvbHVtblNvcnQiLCJnZXRTb3J0SW5kZXgiLCJfdGFibGUkZ2V0U3RhdGUkc29ydGkyIiwiX3RhYmxlJGdldFN0YXRlJHNvcnRpMyIsImNsZWFyU29ydGluZyIsImdldFRvZ2dsZVNvcnRpbmdIYW5kbGVyIiwiY2FuU29ydCIsInJlc2V0U29ydGluZyIsIl90YWJsZSRpbml0aWFsU3RhdGUkcyIsImdldFByZVNvcnRlZFJvd01vZGVsIiwiX2dldFNvcnRlZFJvd01vZGVsIiwibWFudWFsU29ydGluZyIsIlZpc2liaWxpdHkiLCJjb2x1bW5WaXNpYmlsaXR5Iiwib25Db2x1bW5WaXNpYmlsaXR5Q2hhbmdlIiwidG9nZ2xlVmlzaWJpbGl0eSIsImdldENhbkhpZGUiLCJzZXRDb2x1bW5WaXNpYmlsaXR5IiwiZW5hYmxlSGlkaW5nIiwiZ2V0VG9nZ2xlVmlzaWJpbGl0eUhhbmRsZXIiLCJnZXRBbGxDZWxscyIsImdldFZpc2libGVDZWxscyIsIm1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZCIsImdldENvbHVtbnMiLCJnZXRWaXNpYmxlRmxhdENvbHVtbnMiLCJnZXRBbGxGbGF0Q29sdW1ucyIsImdldENlbnRlclZpc2libGVMZWFmQ29sdW1ucyIsInJlc2V0Q29sdW1uVmlzaWJpbGl0eSIsInRvZ2dsZUFsbENvbHVtbnNWaXNpYmxlIiwiX3ZhbHVlIiwiZ2V0SXNBbGxDb2x1bW5zVmlzaWJsZSIsIm9iaiIsImdldElzU29tZUNvbHVtbnNWaXNpYmxlIiwiZ2V0VG9nZ2xlQWxsQ29sdW1uc1Zpc2liaWxpdHlIYW5kbGVyIiwiZmVhdHVyZXMiLCJfb3B0aW9ucyRpbml0aWFsU3RhdGUiLCJkZWZhdWx0T3B0aW9ucyIsImFzc2lnbiIsIm1lcmdlT3B0aW9ucyIsImNvcmVJbml0aWFsU3RhdGUiLCJfZmVhdHVyZSRnZXRJbml0aWFsU3QiLCJxdWV1ZWRUaW1lb3V0IiwiY29yZUluc3RhbmNlIiwiY2IiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJjYXRjaCIsImVycm9yIiwic2V0VGltZW91dCIsInJlc2V0Iiwic2V0T3B0aW9ucyIsIm5ld09wdGlvbnMiLCJvblN0YXRlQ2hhbmdlIiwiX2dldFJvd0lkIiwiZ2V0Um93SWQiLCJfZ2V0Q29yZVJvd01vZGVsIiwic2VhcmNoQWxsIiwiX2RlZmF1bHRDb2x1bW4iLCJfcHJvcHMkcmVuZGVyVmFsdWUkdG8iLCJfcHJvcHMkcmVuZGVyVmFsdWUiLCJyZW5kZXJWYWx1ZSIsIl9nZXRDb2x1bW5EZWZzIiwiY29sdW1uRGVmcyIsInJlY3Vyc2VDb2x1bW5zIiwiZ3JvdXBpbmdDb2x1bW5EZWYiLCJfZ2V0QWxsRmxhdENvbHVtbnNCeUlkIiwiZmxhdENvbHVtbnMiLCJhY2MiLCJnZXRSZW5kZXJWYWx1ZSIsIl9jZWxsJGdldFZhbHVlIiwicmVuZGVyRmFsbGJhY2tWYWx1ZSIsInJvd0luZGV4IiwiX3ZhbHVlc0NhY2hlIiwiX3VuaXF1ZVZhbHVlc0NhY2hlIiwiZ2V0VW5pcXVlVmFsdWVzIiwiZ2V0UGFyZW50Um93IiwicGFyZW50Um93cyIsInBhcmVudFJvdyIsImNyZWF0ZUNvbHVtbkhlbHBlciIsImFjY2Vzc29yIiwiZGlzcGxheSIsImdyb3VwIiwiZGF0YSIsImFjY2Vzc1Jvd3MiLCJvcmlnaW5hbFJvd3MiLCJnZXRTdWJSb3dzIiwiX3JvdyRvcmlnaW5hbFN1YlJvd3MiLCJvcmlnaW5hbFN1YlJvd3MiLCJmaWx0ZXJSb3dzIiwiZmlsdGVyUm93SW1wbCIsImZpbHRlclJvd01vZGVsRnJvbUxlYWZzIiwiZmlsdGVyUm93TW9kZWxGcm9tUm9vdCIsInJvd3NUb0ZpbHRlciIsImZpbHRlclJvdyIsIl90YWJsZSRvcHRpb25zJG1heExlYSIsIm5ld0ZpbHRlcmVkRmxhdFJvd3MiLCJuZXdGaWx0ZXJlZFJvd3NCeUlkIiwicmVjdXJzZUZpbHRlclJvd3MiLCJuZXdSb3ciLCJfdGFibGUkb3B0aW9ucyRtYXhMZWEyIiwicGFzcyIsInJlc29sdmVkQ29sdW1uRmlsdGVycyIsInJlc29sdmVkR2xvYmFsRmlsdGVycyIsIl9maWx0ZXJGbiRyZXNvbHZlRmlsdCIsImZpbHRlcmFibGVJZHMiLCJnbG9iYWxseUZpbHRlcmFibGVDb2x1bW5zIiwiX2dsb2JhbEZpbHRlckZuJHJlc29sIiwiY3VycmVudENvbHVtbkZpbHRlciIsImN1cnJlbnRHbG9iYWxGaWx0ZXIiLCJqIiwiZmlsdGVyTWV0YSIsIl9fZ2xvYmFsX18iLCJmaWx0ZXJSb3dzSW1wbCIsInByZVJvd01vZGVsIiwiX3RhYmxlJGdldENvbHVtbiIsImZhY2V0ZWRSb3dNb2RlbCIsImZhY2V0ZWRVbmlxdWVWYWx1ZXMiLCJfZmFjZXRlZFVuaXF1ZVZhbHVlcyQiLCJzZXQiLCJnZXQiLCJfZmFjZXRlZFJvd01vZGVsJGZsYXQiLCJmaXJzdFZhbHVlIiwiZmFjZXRlZE1pbk1heFZhbHVlcyIsInNvcnRpbmdTdGF0ZSIsInNvcnRlZEZsYXRSb3dzIiwiYXZhaWxhYmxlU29ydGluZyIsImNvbHVtbkluZm9CeUlkIiwic29ydEVudHJ5IiwiaW52ZXJ0U29ydGluZyIsInNvcnREYXRhIiwic29ydGVkRGF0YSIsIl9zb3J0RW50cnkkZGVzYyIsImNvbHVtbkluZm8iLCJpc0Rlc2MiLCJzb3J0SW50IiwiYVZhbHVlIiwiYlZhbHVlIiwiYVVuZGVmaW5lZCIsImJVbmRlZmluZWQiLCJleGlzdGluZ0dyb3VwaW5nIiwiZ3JvdXBlZEZsYXRSb3dzIiwiZ3JvdXBlZFJvd3NCeUlkIiwiZ3JvdXBVcFJlY3Vyc2l2ZWx5Iiwicm93R3JvdXBzTWFwIiwiZ3JvdXBCeSIsImFnZ3JlZ2F0ZWRHcm91cGVkUm93cyIsImVudHJpZXMiLCJncm91cGluZ1ZhbHVlIiwiZ3JvdXBlZFJvd3MiLCJfZ3JvdXBlZFJvd3MkMCRnZXRWYWwiLCJhZ2dyZWdhdGVGbiIsImdyb3VwTWFwIiwicmVzS2V5IiwicHJldmlvdXMiLCJleHBhbmRSb3dzIiwiZXhwYW5kZWRSb3dzIiwiaGFuZGxlUm93IiwicGFnZVN0YXJ0IiwicGFnZUVuZCIsInBhZ2luYXRlZFJvd01vZGVsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@tanstack+table-core@8.11.6/node_modules/@tanstack/table-core/build/lib/index.mjs\n");

/***/ })

};
;