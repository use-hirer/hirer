"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-dom@18.2.0_react@18.2.0";
exports.ids = ["vendor-chunks/react-dom@18.2.0_react@18.2.0"];
exports.modules = {

/***/ "(rsc)/../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js":
/*!*************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * @license React\n * react-dom-server-legacy.node.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! react */ \"(rsc)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\n        var stream = __webpack_require__(/*! stream */ \"stream\");\n        var ReactVersion = \"18.2.0\";\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        // by calls to these methods by a Babel plugin.\n        //\n        // In PROD (or in packages without access to React internals),\n        // they are left as they are instead.\n        function warn(format) {\n            {\n                {\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    printWarning(\"warn\", format, args);\n                }\n            }\n        }\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        function scheduleWork(callback) {\n            callback();\n        }\n        function beginWriting(destination) {}\n        function writeChunk(destination, chunk) {\n            writeChunkAndReturn(destination, chunk);\n        }\n        function writeChunkAndReturn(destination, chunk) {\n            return destination.push(chunk);\n        }\n        function completeWriting(destination) {}\n        function close(destination) {\n            destination.push(null);\n        }\n        function stringToChunk(content) {\n            return content;\n        }\n        function stringToPrecomputedChunk(content) {\n            return content;\n        }\n        function closeWithError(destination, error) {\n            // $FlowFixMe: This is an Error object or the destination accepts other types.\n            destination.destroy(error);\n        }\n        /*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\";\n                return type;\n            }\n        } // $FlowFixMe only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkAttributeStringCoercion(value, attributeName) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided `%s` attribute is an unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", attributeName, typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function checkCSSPropertyStringCoercion(value, propName) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided `%s` CSS property is an unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", propName, typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function checkHtmlStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided HTML markup uses a value of unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        // A reserved attribute.\n        // It is handled by React separately and shouldn't be written to the DOM.\n        var RESERVED = 0; // A simple string attribute.\n        // Attributes that aren't in the filter are presumed to have this type.\n        var STRING = 1; // A string attribute that accepts booleans in React. In HTML, these are called\n        // \"enumerated\" attributes with \"true\" and \"false\" as possible values.\n        // When true, it should be set to a \"true\" string.\n        // When false, it should be set to a \"false\" string.\n        var BOOLEANISH_STRING = 2; // A real boolean attribute.\n        // When true, it should be present (set either to an empty string or its name).\n        // When false, it should be omitted.\n        var BOOLEAN = 3; // An attribute that can be used as a flag as well as with a value.\n        // When true, it should be present (set either to an empty string or its name).\n        // When false, it should be omitted.\n        // For any other value, should be present with that value.\n        var OVERLOADED_BOOLEAN = 4; // An attribute that must be numeric or parse as a numeric.\n        // When falsy, it should be removed.\n        var NUMERIC = 5; // An attribute that must be positive numeric or parse as a positive numeric.\n        // When falsy, it should be removed.\n        var POSITIVE_NUMERIC = 6;\n        /* eslint-disable max-len */ var ATTRIBUTE_NAME_START_CHAR = \":A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n        /* eslint-enable max-len */ var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + \"\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\n        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp(\"^[\" + ATTRIBUTE_NAME_START_CHAR + \"][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var illegalAttributeNameCache = {};\n        var validatedAttributeNameCache = {};\n        function isAttributeNameSafe(attributeName) {\n            if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {\n                return true;\n            }\n            if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {\n                return false;\n            }\n            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\n                validatedAttributeNameCache[attributeName] = true;\n                return true;\n            }\n            illegalAttributeNameCache[attributeName] = true;\n            {\n                error(\"Invalid attribute name: `%s`\", attributeName);\n            }\n            return false;\n        }\n        function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {\n            if (propertyInfo !== null && propertyInfo.type === RESERVED) {\n                return false;\n            }\n            switch(typeof value){\n                case \"function\":\n                case \"symbol\":\n                    // eslint-disable-line\n                    return true;\n                case \"boolean\":\n                    {\n                        if (isCustomComponentTag) {\n                            return false;\n                        }\n                        if (propertyInfo !== null) {\n                            return !propertyInfo.acceptsBooleans;\n                        } else {\n                            var prefix = name.toLowerCase().slice(0, 5);\n                            return prefix !== \"data-\" && prefix !== \"aria-\";\n                        }\n                    }\n                default:\n                    return false;\n            }\n        }\n        function getPropertyInfo(name) {\n            return properties.hasOwnProperty(name) ? properties[name] : null;\n        }\n        function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL, removeEmptyString) {\n            this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;\n            this.attributeName = attributeName;\n            this.attributeNamespace = attributeNamespace;\n            this.mustUseProperty = mustUseProperty;\n            this.propertyName = name;\n            this.type = type;\n            this.sanitizeURL = sanitizeURL;\n            this.removeEmptyString = removeEmptyString;\n        } // When adding attributes to this list, be sure to also add them to\n        // the `possibleStandardNames` module to ensure casing and incorrect\n        // name warnings.\n        var properties = {}; // These props are reserved by React. They shouldn't be written to the DOM.\n        var reservedProps = [\n            \"children\",\n            \"dangerouslySetInnerHTML\",\n            // elements (not just inputs). Now that ReactDOMInput assigns to the\n            // defaultValue property -- do we need this?\n            \"defaultValue\",\n            \"defaultChecked\",\n            \"innerHTML\",\n            \"suppressContentEditableWarning\",\n            \"suppressHydrationWarning\",\n            \"style\"\n        ];\n        reservedProps.forEach(function(name) {\n            properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);\n        }); // A few React string attributes have a different name.\n        // This is a mapping from React prop names to the attribute names.\n        [\n            [\n                \"acceptCharset\",\n                \"accept-charset\"\n            ],\n            [\n                \"className\",\n                \"class\"\n            ],\n            [\n                \"htmlFor\",\n                \"for\"\n            ],\n            [\n                \"httpEquiv\",\n                \"http-equiv\"\n            ]\n        ].forEach(function(_ref) {\n            var name = _ref[0], attributeName = _ref[1];\n            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);\n        }); // These are \"enumerated\" HTML attributes that accept \"true\" and \"false\".\n        // In React, we let users pass `true` and `false` even though technically\n        // these aren't boolean attributes (they are coerced to strings).\n        [\n            \"contentEditable\",\n            \"draggable\",\n            \"spellCheck\",\n            \"value\"\n        ].forEach(function(name) {\n            properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);\n        }); // These are \"enumerated\" SVG attributes that accept \"true\" and \"false\".\n        // In React, we let users pass `true` and `false` even though technically\n        // these aren't boolean attributes (they are coerced to strings).\n        // Since these are SVG attributes, their attribute names are case-sensitive.\n        [\n            \"autoReverse\",\n            \"externalResourcesRequired\",\n            \"focusable\",\n            \"preserveAlpha\"\n        ].forEach(function(name) {\n            properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);\n        }); // These are HTML boolean attributes.\n        [\n            \"allowFullScreen\",\n            \"async\",\n            // on the client side because the browsers are inconsistent. Instead we call focus().\n            \"autoFocus\",\n            \"autoPlay\",\n            \"controls\",\n            \"default\",\n            \"defer\",\n            \"disabled\",\n            \"disablePictureInPicture\",\n            \"disableRemotePlayback\",\n            \"formNoValidate\",\n            \"hidden\",\n            \"loop\",\n            \"noModule\",\n            \"noValidate\",\n            \"open\",\n            \"playsInline\",\n            \"readOnly\",\n            \"required\",\n            \"reversed\",\n            \"scoped\",\n            \"seamless\",\n            \"itemScope\"\n        ].forEach(function(name) {\n            properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);\n        }); // These are the few React props that we set as DOM properties\n        // rather than attributes. These are all booleans.\n        [\n            \"checked\",\n            // disabled with `removeAttribute`. We have special logic for handling this.\n            \"multiple\",\n            \"muted\",\n            \"selected\" // NOTE: if you add a camelCased prop to this list,\n        ].forEach(function(name) {\n            properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);\n        }); // These are HTML attributes that are \"overloaded booleans\": they behave like\n        // booleans, but can also accept a string value.\n        [\n            \"capture\",\n            \"download\" // NOTE: if you add a camelCased prop to this list,\n        ].forEach(function(name) {\n            properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);\n        }); // These are HTML attributes that must be positive numbers.\n        [\n            \"cols\",\n            \"rows\",\n            \"size\",\n            \"span\" // NOTE: if you add a camelCased prop to this list,\n        ].forEach(function(name) {\n            properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);\n        }); // These are HTML attributes that must be numbers.\n        [\n            \"rowSpan\",\n            \"start\"\n        ].forEach(function(name) {\n            properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);\n        });\n        var CAMELIZE = /[\\-\\:]([a-z])/g;\n        var capitalize = function(token) {\n            return token[1].toUpperCase();\n        }; // This is a list of all SVG attributes that need special casing, namespacing,\n        // or boolean value assignment. Regular attributes that just accept strings\n        // and have the same names are omitted, just like in the HTML attribute filter.\n        // Some of these attributes can be hard to find. This list was created by\n        // scraping the MDN documentation.\n        [\n            \"accent-height\",\n            \"alignment-baseline\",\n            \"arabic-form\",\n            \"baseline-shift\",\n            \"cap-height\",\n            \"clip-path\",\n            \"clip-rule\",\n            \"color-interpolation\",\n            \"color-interpolation-filters\",\n            \"color-profile\",\n            \"color-rendering\",\n            \"dominant-baseline\",\n            \"enable-background\",\n            \"fill-opacity\",\n            \"fill-rule\",\n            \"flood-color\",\n            \"flood-opacity\",\n            \"font-family\",\n            \"font-size\",\n            \"font-size-adjust\",\n            \"font-stretch\",\n            \"font-style\",\n            \"font-variant\",\n            \"font-weight\",\n            \"glyph-name\",\n            \"glyph-orientation-horizontal\",\n            \"glyph-orientation-vertical\",\n            \"horiz-adv-x\",\n            \"horiz-origin-x\",\n            \"image-rendering\",\n            \"letter-spacing\",\n            \"lighting-color\",\n            \"marker-end\",\n            \"marker-mid\",\n            \"marker-start\",\n            \"overline-position\",\n            \"overline-thickness\",\n            \"paint-order\",\n            \"panose-1\",\n            \"pointer-events\",\n            \"rendering-intent\",\n            \"shape-rendering\",\n            \"stop-color\",\n            \"stop-opacity\",\n            \"strikethrough-position\",\n            \"strikethrough-thickness\",\n            \"stroke-dasharray\",\n            \"stroke-dashoffset\",\n            \"stroke-linecap\",\n            \"stroke-linejoin\",\n            \"stroke-miterlimit\",\n            \"stroke-opacity\",\n            \"stroke-width\",\n            \"text-anchor\",\n            \"text-decoration\",\n            \"text-rendering\",\n            \"underline-position\",\n            \"underline-thickness\",\n            \"unicode-bidi\",\n            \"unicode-range\",\n            \"units-per-em\",\n            \"v-alphabetic\",\n            \"v-hanging\",\n            \"v-ideographic\",\n            \"v-mathematical\",\n            \"vector-effect\",\n            \"vert-adv-y\",\n            \"vert-origin-x\",\n            \"vert-origin-y\",\n            \"word-spacing\",\n            \"writing-mode\",\n            \"xmlns:xlink\",\n            \"x-height\" // NOTE: if you add a camelCased prop to this list,\n        ].forEach(function(attributeName) {\n            var name = attributeName.replace(CAMELIZE, capitalize);\n            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);\n        }); // String SVG attributes with the xlink namespace.\n        [\n            \"xlink:actuate\",\n            \"xlink:arcrole\",\n            \"xlink:role\",\n            \"xlink:show\",\n            \"xlink:title\",\n            \"xlink:type\" // NOTE: if you add a camelCased prop to this list,\n        ].forEach(function(attributeName) {\n            var name = attributeName.replace(CAMELIZE, capitalize);\n            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, \"http://www.w3.org/1999/xlink\", false, false);\n        }); // String SVG attributes with the xml namespace.\n        [\n            \"xml:base\",\n            \"xml:lang\",\n            \"xml:space\" // NOTE: if you add a camelCased prop to this list,\n        ].forEach(function(attributeName) {\n            var name = attributeName.replace(CAMELIZE, capitalize);\n            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, \"http://www.w3.org/XML/1998/namespace\", false, false);\n        }); // These attribute exists both in HTML and SVG.\n        // The attribute name is case-sensitive in SVG so we can't just use\n        // the React name like we do for attributes that exist only in HTML.\n        [\n            \"tabIndex\",\n            \"crossOrigin\"\n        ].forEach(function(attributeName) {\n            properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);\n        }); // These attributes accept URLs. These must not allow javascript: URLS.\n        // These will also need to accept Trusted Types object in the future.\n        var xlinkHref = \"xlinkHref\";\n        properties[xlinkHref] = new PropertyInfoRecord(\"xlinkHref\", STRING, false, \"xlink:href\", \"http://www.w3.org/1999/xlink\", true, false);\n        [\n            \"src\",\n            \"href\",\n            \"action\",\n            \"formAction\"\n        ].forEach(function(attributeName) {\n            properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);\n        });\n        /**\n * CSS properties which accept numbers but are not in units of \"px\".\n */ var isUnitlessNumber = {\n            animationIterationCount: true,\n            aspectRatio: true,\n            borderImageOutset: true,\n            borderImageSlice: true,\n            borderImageWidth: true,\n            boxFlex: true,\n            boxFlexGroup: true,\n            boxOrdinalGroup: true,\n            columnCount: true,\n            columns: true,\n            flex: true,\n            flexGrow: true,\n            flexPositive: true,\n            flexShrink: true,\n            flexNegative: true,\n            flexOrder: true,\n            gridArea: true,\n            gridRow: true,\n            gridRowEnd: true,\n            gridRowSpan: true,\n            gridRowStart: true,\n            gridColumn: true,\n            gridColumnEnd: true,\n            gridColumnSpan: true,\n            gridColumnStart: true,\n            fontWeight: true,\n            lineClamp: true,\n            lineHeight: true,\n            opacity: true,\n            order: true,\n            orphans: true,\n            tabSize: true,\n            widows: true,\n            zIndex: true,\n            zoom: true,\n            // SVG-related properties\n            fillOpacity: true,\n            floodOpacity: true,\n            stopOpacity: true,\n            strokeDasharray: true,\n            strokeDashoffset: true,\n            strokeMiterlimit: true,\n            strokeOpacity: true,\n            strokeWidth: true\n        };\n        /**\n * @param {string} prefix vendor-specific prefix, eg: Webkit\n * @param {string} key style name, eg: transitionDuration\n * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n * WebkitTransitionDuration\n */ function prefixKey(prefix, key) {\n            return prefix + key.charAt(0).toUpperCase() + key.substring(1);\n        }\n        /**\n * Support style names that may come passed in prefixed by adding permutations\n * of vendor prefixes.\n */ var prefixes = [\n            \"Webkit\",\n            \"ms\",\n            \"Moz\",\n            \"O\"\n        ]; // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n        // infinite loop, because it iterates over the newly added props too.\n        Object.keys(isUnitlessNumber).forEach(function(prop) {\n            prefixes.forEach(function(prefix) {\n                isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];\n            });\n        });\n        var hasReadOnlyValue = {\n            button: true,\n            checkbox: true,\n            image: true,\n            hidden: true,\n            radio: true,\n            reset: true,\n            submit: true\n        };\n        function checkControlledValueProps(tagName, props) {\n            {\n                if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {\n                    error(\"You provided a `value` prop to a form field without an \" + \"`onChange` handler. This will render a read-only field. If \" + \"the field should be mutable use `defaultValue`. Otherwise, \" + \"set either `onChange` or `readOnly`.\");\n                }\n                if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {\n                    error(\"You provided a `checked` prop to a form field without an \" + \"`onChange` handler. This will render a read-only field. If \" + \"the field should be mutable use `defaultChecked`. Otherwise, \" + \"set either `onChange` or `readOnly`.\");\n                }\n            }\n        }\n        function isCustomComponent(tagName, props) {\n            if (tagName.indexOf(\"-\") === -1) {\n                return typeof props.is === \"string\";\n            }\n            switch(tagName){\n                // These are reserved SVG and MathML elements.\n                // We don't mind this list too much because we expect it to never grow.\n                // The alternative is to track the namespace in a few places which is convoluted.\n                // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n                case \"annotation-xml\":\n                case \"color-profile\":\n                case \"font-face\":\n                case \"font-face-src\":\n                case \"font-face-uri\":\n                case \"font-face-format\":\n                case \"font-face-name\":\n                case \"missing-glyph\":\n                    return false;\n                default:\n                    return true;\n            }\n        }\n        var ariaProperties = {\n            \"aria-current\": 0,\n            // state\n            \"aria-description\": 0,\n            \"aria-details\": 0,\n            \"aria-disabled\": 0,\n            // state\n            \"aria-hidden\": 0,\n            // state\n            \"aria-invalid\": 0,\n            // state\n            \"aria-keyshortcuts\": 0,\n            \"aria-label\": 0,\n            \"aria-roledescription\": 0,\n            // Widget Attributes\n            \"aria-autocomplete\": 0,\n            \"aria-checked\": 0,\n            \"aria-expanded\": 0,\n            \"aria-haspopup\": 0,\n            \"aria-level\": 0,\n            \"aria-modal\": 0,\n            \"aria-multiline\": 0,\n            \"aria-multiselectable\": 0,\n            \"aria-orientation\": 0,\n            \"aria-placeholder\": 0,\n            \"aria-pressed\": 0,\n            \"aria-readonly\": 0,\n            \"aria-required\": 0,\n            \"aria-selected\": 0,\n            \"aria-sort\": 0,\n            \"aria-valuemax\": 0,\n            \"aria-valuemin\": 0,\n            \"aria-valuenow\": 0,\n            \"aria-valuetext\": 0,\n            // Live Region Attributes\n            \"aria-atomic\": 0,\n            \"aria-busy\": 0,\n            \"aria-live\": 0,\n            \"aria-relevant\": 0,\n            // Drag-and-Drop Attributes\n            \"aria-dropeffect\": 0,\n            \"aria-grabbed\": 0,\n            // Relationship Attributes\n            \"aria-activedescendant\": 0,\n            \"aria-colcount\": 0,\n            \"aria-colindex\": 0,\n            \"aria-colspan\": 0,\n            \"aria-controls\": 0,\n            \"aria-describedby\": 0,\n            \"aria-errormessage\": 0,\n            \"aria-flowto\": 0,\n            \"aria-labelledby\": 0,\n            \"aria-owns\": 0,\n            \"aria-posinset\": 0,\n            \"aria-rowcount\": 0,\n            \"aria-rowindex\": 0,\n            \"aria-rowspan\": 0,\n            \"aria-setsize\": 0\n        };\n        var warnedProperties = {};\n        var rARIA = new RegExp(\"^(aria)-[\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var rARIACamel = new RegExp(\"^(aria)[A-Z][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        function validateProperty(tagName, name) {\n            {\n                if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {\n                    return true;\n                }\n                if (rARIACamel.test(name)) {\n                    var ariaName = \"aria-\" + name.slice(4).toLowerCase();\n                    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null; // If this is an aria-* attribute, but is not listed in the known DOM\n                    // DOM properties, then it is an invalid aria-* attribute.\n                    if (correctName == null) {\n                        error(\"Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.\", name);\n                        warnedProperties[name] = true;\n                        return true;\n                    } // aria-* attributes should be lowercase; suggest the lowercase version.\n                    if (name !== correctName) {\n                        error(\"Invalid ARIA attribute `%s`. Did you mean `%s`?\", name, correctName);\n                        warnedProperties[name] = true;\n                        return true;\n                    }\n                }\n                if (rARIA.test(name)) {\n                    var lowerCasedName = name.toLowerCase();\n                    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null; // If this is an aria-* attribute, but is not listed in the known DOM\n                    // DOM properties, then it is an invalid aria-* attribute.\n                    if (standardName == null) {\n                        warnedProperties[name] = true;\n                        return false;\n                    } // aria-* attributes should be lowercase; suggest the lowercase version.\n                    if (name !== standardName) {\n                        error(\"Unknown ARIA attribute `%s`. Did you mean `%s`?\", name, standardName);\n                        warnedProperties[name] = true;\n                        return true;\n                    }\n                }\n            }\n            return true;\n        }\n        function warnInvalidARIAProps(type, props) {\n            {\n                var invalidProps = [];\n                for(var key in props){\n                    var isValid = validateProperty(type, key);\n                    if (!isValid) {\n                        invalidProps.push(key);\n                    }\n                }\n                var unknownPropString = invalidProps.map(function(prop) {\n                    return \"`\" + prop + \"`\";\n                }).join(\", \");\n                if (invalidProps.length === 1) {\n                    error(\"Invalid aria prop %s on <%s> tag. \" + \"For details, see https://reactjs.org/link/invalid-aria-props\", unknownPropString, type);\n                } else if (invalidProps.length > 1) {\n                    error(\"Invalid aria props %s on <%s> tag. \" + \"For details, see https://reactjs.org/link/invalid-aria-props\", unknownPropString, type);\n                }\n            }\n        }\n        function validateProperties(type, props) {\n            if (isCustomComponent(type, props)) {\n                return;\n            }\n            warnInvalidARIAProps(type, props);\n        }\n        var didWarnValueNull = false;\n        function validateProperties$1(type, props) {\n            {\n                if (type !== \"input\" && type !== \"textarea\" && type !== \"select\") {\n                    return;\n                }\n                if (props != null && props.value === null && !didWarnValueNull) {\n                    didWarnValueNull = true;\n                    if (type === \"select\" && props.multiple) {\n                        error(\"`value` prop on `%s` should not be null. \" + \"Consider using an empty array when `multiple` is set to `true` \" + \"to clear the component or `undefined` for uncontrolled components.\", type);\n                    } else {\n                        error(\"`value` prop on `%s` should not be null. \" + \"Consider using an empty string to clear the component or `undefined` \" + \"for uncontrolled components.\", type);\n                    }\n                }\n            }\n        }\n        // When adding attributes to the HTML or SVG allowed attribute list, be sure to\n        // also add them to this module to ensure casing and incorrect name\n        // warnings.\n        var possibleStandardNames = {\n            // HTML\n            accept: \"accept\",\n            acceptcharset: \"acceptCharset\",\n            \"accept-charset\": \"acceptCharset\",\n            accesskey: \"accessKey\",\n            action: \"action\",\n            allowfullscreen: \"allowFullScreen\",\n            alt: \"alt\",\n            as: \"as\",\n            async: \"async\",\n            autocapitalize: \"autoCapitalize\",\n            autocomplete: \"autoComplete\",\n            autocorrect: \"autoCorrect\",\n            autofocus: \"autoFocus\",\n            autoplay: \"autoPlay\",\n            autosave: \"autoSave\",\n            capture: \"capture\",\n            cellpadding: \"cellPadding\",\n            cellspacing: \"cellSpacing\",\n            challenge: \"challenge\",\n            charset: \"charSet\",\n            checked: \"checked\",\n            children: \"children\",\n            cite: \"cite\",\n            class: \"className\",\n            classid: \"classID\",\n            classname: \"className\",\n            cols: \"cols\",\n            colspan: \"colSpan\",\n            content: \"content\",\n            contenteditable: \"contentEditable\",\n            contextmenu: \"contextMenu\",\n            controls: \"controls\",\n            controlslist: \"controlsList\",\n            coords: \"coords\",\n            crossorigin: \"crossOrigin\",\n            dangerouslysetinnerhtml: \"dangerouslySetInnerHTML\",\n            data: \"data\",\n            datetime: \"dateTime\",\n            default: \"default\",\n            defaultchecked: \"defaultChecked\",\n            defaultvalue: \"defaultValue\",\n            defer: \"defer\",\n            dir: \"dir\",\n            disabled: \"disabled\",\n            disablepictureinpicture: \"disablePictureInPicture\",\n            disableremoteplayback: \"disableRemotePlayback\",\n            download: \"download\",\n            draggable: \"draggable\",\n            enctype: \"encType\",\n            enterkeyhint: \"enterKeyHint\",\n            for: \"htmlFor\",\n            form: \"form\",\n            formmethod: \"formMethod\",\n            formaction: \"formAction\",\n            formenctype: \"formEncType\",\n            formnovalidate: \"formNoValidate\",\n            formtarget: \"formTarget\",\n            frameborder: \"frameBorder\",\n            headers: \"headers\",\n            height: \"height\",\n            hidden: \"hidden\",\n            high: \"high\",\n            href: \"href\",\n            hreflang: \"hrefLang\",\n            htmlfor: \"htmlFor\",\n            httpequiv: \"httpEquiv\",\n            \"http-equiv\": \"httpEquiv\",\n            icon: \"icon\",\n            id: \"id\",\n            imagesizes: \"imageSizes\",\n            imagesrcset: \"imageSrcSet\",\n            innerhtml: \"innerHTML\",\n            inputmode: \"inputMode\",\n            integrity: \"integrity\",\n            is: \"is\",\n            itemid: \"itemID\",\n            itemprop: \"itemProp\",\n            itemref: \"itemRef\",\n            itemscope: \"itemScope\",\n            itemtype: \"itemType\",\n            keyparams: \"keyParams\",\n            keytype: \"keyType\",\n            kind: \"kind\",\n            label: \"label\",\n            lang: \"lang\",\n            list: \"list\",\n            loop: \"loop\",\n            low: \"low\",\n            manifest: \"manifest\",\n            marginwidth: \"marginWidth\",\n            marginheight: \"marginHeight\",\n            max: \"max\",\n            maxlength: \"maxLength\",\n            media: \"media\",\n            mediagroup: \"mediaGroup\",\n            method: \"method\",\n            min: \"min\",\n            minlength: \"minLength\",\n            multiple: \"multiple\",\n            muted: \"muted\",\n            name: \"name\",\n            nomodule: \"noModule\",\n            nonce: \"nonce\",\n            novalidate: \"noValidate\",\n            open: \"open\",\n            optimum: \"optimum\",\n            pattern: \"pattern\",\n            placeholder: \"placeholder\",\n            playsinline: \"playsInline\",\n            poster: \"poster\",\n            preload: \"preload\",\n            profile: \"profile\",\n            radiogroup: \"radioGroup\",\n            readonly: \"readOnly\",\n            referrerpolicy: \"referrerPolicy\",\n            rel: \"rel\",\n            required: \"required\",\n            reversed: \"reversed\",\n            role: \"role\",\n            rows: \"rows\",\n            rowspan: \"rowSpan\",\n            sandbox: \"sandbox\",\n            scope: \"scope\",\n            scoped: \"scoped\",\n            scrolling: \"scrolling\",\n            seamless: \"seamless\",\n            selected: \"selected\",\n            shape: \"shape\",\n            size: \"size\",\n            sizes: \"sizes\",\n            span: \"span\",\n            spellcheck: \"spellCheck\",\n            src: \"src\",\n            srcdoc: \"srcDoc\",\n            srclang: \"srcLang\",\n            srcset: \"srcSet\",\n            start: \"start\",\n            step: \"step\",\n            style: \"style\",\n            summary: \"summary\",\n            tabindex: \"tabIndex\",\n            target: \"target\",\n            title: \"title\",\n            type: \"type\",\n            usemap: \"useMap\",\n            value: \"value\",\n            width: \"width\",\n            wmode: \"wmode\",\n            wrap: \"wrap\",\n            // SVG\n            about: \"about\",\n            accentheight: \"accentHeight\",\n            \"accent-height\": \"accentHeight\",\n            accumulate: \"accumulate\",\n            additive: \"additive\",\n            alignmentbaseline: \"alignmentBaseline\",\n            \"alignment-baseline\": \"alignmentBaseline\",\n            allowreorder: \"allowReorder\",\n            alphabetic: \"alphabetic\",\n            amplitude: \"amplitude\",\n            arabicform: \"arabicForm\",\n            \"arabic-form\": \"arabicForm\",\n            ascent: \"ascent\",\n            attributename: \"attributeName\",\n            attributetype: \"attributeType\",\n            autoreverse: \"autoReverse\",\n            azimuth: \"azimuth\",\n            basefrequency: \"baseFrequency\",\n            baselineshift: \"baselineShift\",\n            \"baseline-shift\": \"baselineShift\",\n            baseprofile: \"baseProfile\",\n            bbox: \"bbox\",\n            begin: \"begin\",\n            bias: \"bias\",\n            by: \"by\",\n            calcmode: \"calcMode\",\n            capheight: \"capHeight\",\n            \"cap-height\": \"capHeight\",\n            clip: \"clip\",\n            clippath: \"clipPath\",\n            \"clip-path\": \"clipPath\",\n            clippathunits: \"clipPathUnits\",\n            cliprule: \"clipRule\",\n            \"clip-rule\": \"clipRule\",\n            color: \"color\",\n            colorinterpolation: \"colorInterpolation\",\n            \"color-interpolation\": \"colorInterpolation\",\n            colorinterpolationfilters: \"colorInterpolationFilters\",\n            \"color-interpolation-filters\": \"colorInterpolationFilters\",\n            colorprofile: \"colorProfile\",\n            \"color-profile\": \"colorProfile\",\n            colorrendering: \"colorRendering\",\n            \"color-rendering\": \"colorRendering\",\n            contentscripttype: \"contentScriptType\",\n            contentstyletype: \"contentStyleType\",\n            cursor: \"cursor\",\n            cx: \"cx\",\n            cy: \"cy\",\n            d: \"d\",\n            datatype: \"datatype\",\n            decelerate: \"decelerate\",\n            descent: \"descent\",\n            diffuseconstant: \"diffuseConstant\",\n            direction: \"direction\",\n            display: \"display\",\n            divisor: \"divisor\",\n            dominantbaseline: \"dominantBaseline\",\n            \"dominant-baseline\": \"dominantBaseline\",\n            dur: \"dur\",\n            dx: \"dx\",\n            dy: \"dy\",\n            edgemode: \"edgeMode\",\n            elevation: \"elevation\",\n            enablebackground: \"enableBackground\",\n            \"enable-background\": \"enableBackground\",\n            end: \"end\",\n            exponent: \"exponent\",\n            externalresourcesrequired: \"externalResourcesRequired\",\n            fill: \"fill\",\n            fillopacity: \"fillOpacity\",\n            \"fill-opacity\": \"fillOpacity\",\n            fillrule: \"fillRule\",\n            \"fill-rule\": \"fillRule\",\n            filter: \"filter\",\n            filterres: \"filterRes\",\n            filterunits: \"filterUnits\",\n            floodopacity: \"floodOpacity\",\n            \"flood-opacity\": \"floodOpacity\",\n            floodcolor: \"floodColor\",\n            \"flood-color\": \"floodColor\",\n            focusable: \"focusable\",\n            fontfamily: \"fontFamily\",\n            \"font-family\": \"fontFamily\",\n            fontsize: \"fontSize\",\n            \"font-size\": \"fontSize\",\n            fontsizeadjust: \"fontSizeAdjust\",\n            \"font-size-adjust\": \"fontSizeAdjust\",\n            fontstretch: \"fontStretch\",\n            \"font-stretch\": \"fontStretch\",\n            fontstyle: \"fontStyle\",\n            \"font-style\": \"fontStyle\",\n            fontvariant: \"fontVariant\",\n            \"font-variant\": \"fontVariant\",\n            fontweight: \"fontWeight\",\n            \"font-weight\": \"fontWeight\",\n            format: \"format\",\n            from: \"from\",\n            fx: \"fx\",\n            fy: \"fy\",\n            g1: \"g1\",\n            g2: \"g2\",\n            glyphname: \"glyphName\",\n            \"glyph-name\": \"glyphName\",\n            glyphorientationhorizontal: \"glyphOrientationHorizontal\",\n            \"glyph-orientation-horizontal\": \"glyphOrientationHorizontal\",\n            glyphorientationvertical: \"glyphOrientationVertical\",\n            \"glyph-orientation-vertical\": \"glyphOrientationVertical\",\n            glyphref: \"glyphRef\",\n            gradienttransform: \"gradientTransform\",\n            gradientunits: \"gradientUnits\",\n            hanging: \"hanging\",\n            horizadvx: \"horizAdvX\",\n            \"horiz-adv-x\": \"horizAdvX\",\n            horizoriginx: \"horizOriginX\",\n            \"horiz-origin-x\": \"horizOriginX\",\n            ideographic: \"ideographic\",\n            imagerendering: \"imageRendering\",\n            \"image-rendering\": \"imageRendering\",\n            in2: \"in2\",\n            in: \"in\",\n            inlist: \"inlist\",\n            intercept: \"intercept\",\n            k1: \"k1\",\n            k2: \"k2\",\n            k3: \"k3\",\n            k4: \"k4\",\n            k: \"k\",\n            kernelmatrix: \"kernelMatrix\",\n            kernelunitlength: \"kernelUnitLength\",\n            kerning: \"kerning\",\n            keypoints: \"keyPoints\",\n            keysplines: \"keySplines\",\n            keytimes: \"keyTimes\",\n            lengthadjust: \"lengthAdjust\",\n            letterspacing: \"letterSpacing\",\n            \"letter-spacing\": \"letterSpacing\",\n            lightingcolor: \"lightingColor\",\n            \"lighting-color\": \"lightingColor\",\n            limitingconeangle: \"limitingConeAngle\",\n            local: \"local\",\n            markerend: \"markerEnd\",\n            \"marker-end\": \"markerEnd\",\n            markerheight: \"markerHeight\",\n            markermid: \"markerMid\",\n            \"marker-mid\": \"markerMid\",\n            markerstart: \"markerStart\",\n            \"marker-start\": \"markerStart\",\n            markerunits: \"markerUnits\",\n            markerwidth: \"markerWidth\",\n            mask: \"mask\",\n            maskcontentunits: \"maskContentUnits\",\n            maskunits: \"maskUnits\",\n            mathematical: \"mathematical\",\n            mode: \"mode\",\n            numoctaves: \"numOctaves\",\n            offset: \"offset\",\n            opacity: \"opacity\",\n            operator: \"operator\",\n            order: \"order\",\n            orient: \"orient\",\n            orientation: \"orientation\",\n            origin: \"origin\",\n            overflow: \"overflow\",\n            overlineposition: \"overlinePosition\",\n            \"overline-position\": \"overlinePosition\",\n            overlinethickness: \"overlineThickness\",\n            \"overline-thickness\": \"overlineThickness\",\n            paintorder: \"paintOrder\",\n            \"paint-order\": \"paintOrder\",\n            panose1: \"panose1\",\n            \"panose-1\": \"panose1\",\n            pathlength: \"pathLength\",\n            patterncontentunits: \"patternContentUnits\",\n            patterntransform: \"patternTransform\",\n            patternunits: \"patternUnits\",\n            pointerevents: \"pointerEvents\",\n            \"pointer-events\": \"pointerEvents\",\n            points: \"points\",\n            pointsatx: \"pointsAtX\",\n            pointsaty: \"pointsAtY\",\n            pointsatz: \"pointsAtZ\",\n            prefix: \"prefix\",\n            preservealpha: \"preserveAlpha\",\n            preserveaspectratio: \"preserveAspectRatio\",\n            primitiveunits: \"primitiveUnits\",\n            property: \"property\",\n            r: \"r\",\n            radius: \"radius\",\n            refx: \"refX\",\n            refy: \"refY\",\n            renderingintent: \"renderingIntent\",\n            \"rendering-intent\": \"renderingIntent\",\n            repeatcount: \"repeatCount\",\n            repeatdur: \"repeatDur\",\n            requiredextensions: \"requiredExtensions\",\n            requiredfeatures: \"requiredFeatures\",\n            resource: \"resource\",\n            restart: \"restart\",\n            result: \"result\",\n            results: \"results\",\n            rotate: \"rotate\",\n            rx: \"rx\",\n            ry: \"ry\",\n            scale: \"scale\",\n            security: \"security\",\n            seed: \"seed\",\n            shaperendering: \"shapeRendering\",\n            \"shape-rendering\": \"shapeRendering\",\n            slope: \"slope\",\n            spacing: \"spacing\",\n            specularconstant: \"specularConstant\",\n            specularexponent: \"specularExponent\",\n            speed: \"speed\",\n            spreadmethod: \"spreadMethod\",\n            startoffset: \"startOffset\",\n            stddeviation: \"stdDeviation\",\n            stemh: \"stemh\",\n            stemv: \"stemv\",\n            stitchtiles: \"stitchTiles\",\n            stopcolor: \"stopColor\",\n            \"stop-color\": \"stopColor\",\n            stopopacity: \"stopOpacity\",\n            \"stop-opacity\": \"stopOpacity\",\n            strikethroughposition: \"strikethroughPosition\",\n            \"strikethrough-position\": \"strikethroughPosition\",\n            strikethroughthickness: \"strikethroughThickness\",\n            \"strikethrough-thickness\": \"strikethroughThickness\",\n            string: \"string\",\n            stroke: \"stroke\",\n            strokedasharray: \"strokeDasharray\",\n            \"stroke-dasharray\": \"strokeDasharray\",\n            strokedashoffset: \"strokeDashoffset\",\n            \"stroke-dashoffset\": \"strokeDashoffset\",\n            strokelinecap: \"strokeLinecap\",\n            \"stroke-linecap\": \"strokeLinecap\",\n            strokelinejoin: \"strokeLinejoin\",\n            \"stroke-linejoin\": \"strokeLinejoin\",\n            strokemiterlimit: \"strokeMiterlimit\",\n            \"stroke-miterlimit\": \"strokeMiterlimit\",\n            strokewidth: \"strokeWidth\",\n            \"stroke-width\": \"strokeWidth\",\n            strokeopacity: \"strokeOpacity\",\n            \"stroke-opacity\": \"strokeOpacity\",\n            suppresscontenteditablewarning: \"suppressContentEditableWarning\",\n            suppresshydrationwarning: \"suppressHydrationWarning\",\n            surfacescale: \"surfaceScale\",\n            systemlanguage: \"systemLanguage\",\n            tablevalues: \"tableValues\",\n            targetx: \"targetX\",\n            targety: \"targetY\",\n            textanchor: \"textAnchor\",\n            \"text-anchor\": \"textAnchor\",\n            textdecoration: \"textDecoration\",\n            \"text-decoration\": \"textDecoration\",\n            textlength: \"textLength\",\n            textrendering: \"textRendering\",\n            \"text-rendering\": \"textRendering\",\n            to: \"to\",\n            transform: \"transform\",\n            typeof: \"typeof\",\n            u1: \"u1\",\n            u2: \"u2\",\n            underlineposition: \"underlinePosition\",\n            \"underline-position\": \"underlinePosition\",\n            underlinethickness: \"underlineThickness\",\n            \"underline-thickness\": \"underlineThickness\",\n            unicode: \"unicode\",\n            unicodebidi: \"unicodeBidi\",\n            \"unicode-bidi\": \"unicodeBidi\",\n            unicoderange: \"unicodeRange\",\n            \"unicode-range\": \"unicodeRange\",\n            unitsperem: \"unitsPerEm\",\n            \"units-per-em\": \"unitsPerEm\",\n            unselectable: \"unselectable\",\n            valphabetic: \"vAlphabetic\",\n            \"v-alphabetic\": \"vAlphabetic\",\n            values: \"values\",\n            vectoreffect: \"vectorEffect\",\n            \"vector-effect\": \"vectorEffect\",\n            version: \"version\",\n            vertadvy: \"vertAdvY\",\n            \"vert-adv-y\": \"vertAdvY\",\n            vertoriginx: \"vertOriginX\",\n            \"vert-origin-x\": \"vertOriginX\",\n            vertoriginy: \"vertOriginY\",\n            \"vert-origin-y\": \"vertOriginY\",\n            vhanging: \"vHanging\",\n            \"v-hanging\": \"vHanging\",\n            videographic: \"vIdeographic\",\n            \"v-ideographic\": \"vIdeographic\",\n            viewbox: \"viewBox\",\n            viewtarget: \"viewTarget\",\n            visibility: \"visibility\",\n            vmathematical: \"vMathematical\",\n            \"v-mathematical\": \"vMathematical\",\n            vocab: \"vocab\",\n            widths: \"widths\",\n            wordspacing: \"wordSpacing\",\n            \"word-spacing\": \"wordSpacing\",\n            writingmode: \"writingMode\",\n            \"writing-mode\": \"writingMode\",\n            x1: \"x1\",\n            x2: \"x2\",\n            x: \"x\",\n            xchannelselector: \"xChannelSelector\",\n            xheight: \"xHeight\",\n            \"x-height\": \"xHeight\",\n            xlinkactuate: \"xlinkActuate\",\n            \"xlink:actuate\": \"xlinkActuate\",\n            xlinkarcrole: \"xlinkArcrole\",\n            \"xlink:arcrole\": \"xlinkArcrole\",\n            xlinkhref: \"xlinkHref\",\n            \"xlink:href\": \"xlinkHref\",\n            xlinkrole: \"xlinkRole\",\n            \"xlink:role\": \"xlinkRole\",\n            xlinkshow: \"xlinkShow\",\n            \"xlink:show\": \"xlinkShow\",\n            xlinktitle: \"xlinkTitle\",\n            \"xlink:title\": \"xlinkTitle\",\n            xlinktype: \"xlinkType\",\n            \"xlink:type\": \"xlinkType\",\n            xmlbase: \"xmlBase\",\n            \"xml:base\": \"xmlBase\",\n            xmllang: \"xmlLang\",\n            \"xml:lang\": \"xmlLang\",\n            xmlns: \"xmlns\",\n            \"xml:space\": \"xmlSpace\",\n            xmlnsxlink: \"xmlnsXlink\",\n            \"xmlns:xlink\": \"xmlnsXlink\",\n            xmlspace: \"xmlSpace\",\n            y1: \"y1\",\n            y2: \"y2\",\n            y: \"y\",\n            ychannelselector: \"yChannelSelector\",\n            z: \"z\",\n            zoomandpan: \"zoomAndPan\"\n        };\n        var validateProperty$1 = function() {};\n        {\n            var warnedProperties$1 = {};\n            var EVENT_NAME_REGEX = /^on./;\n            var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;\n            var rARIA$1 = new RegExp(\"^(aria)-[\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n            var rARIACamel$1 = new RegExp(\"^(aria)[A-Z][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n            validateProperty$1 = function(tagName, name, value, eventRegistry) {\n                if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {\n                    return true;\n                }\n                var lowerCasedName = name.toLowerCase();\n                if (lowerCasedName === \"onfocusin\" || lowerCasedName === \"onfocusout\") {\n                    error(\"React uses onFocus and onBlur instead of onFocusIn and onFocusOut. \" + \"All React events are normalized to bubble, so onFocusIn and onFocusOut \" + \"are not needed/supported by React.\");\n                    warnedProperties$1[name] = true;\n                    return true;\n                } // We can't rely on the event system being injected on the server.\n                if (eventRegistry != null) {\n                    var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;\n                    if (registrationNameDependencies.hasOwnProperty(name)) {\n                        return true;\n                    }\n                    var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;\n                    if (registrationName != null) {\n                        error(\"Invalid event handler property `%s`. Did you mean `%s`?\", name, registrationName);\n                        warnedProperties$1[name] = true;\n                        return true;\n                    }\n                    if (EVENT_NAME_REGEX.test(name)) {\n                        error(\"Unknown event handler property `%s`. It will be ignored.\", name);\n                        warnedProperties$1[name] = true;\n                        return true;\n                    }\n                } else if (EVENT_NAME_REGEX.test(name)) {\n                    // If no event plugins have been injected, we are in a server environment.\n                    // So we can't tell if the event name is correct for sure, but we can filter\n                    // out known bad ones like `onclick`. We can't suggest a specific replacement though.\n                    if (INVALID_EVENT_NAME_REGEX.test(name)) {\n                        error(\"Invalid event handler property `%s`. \" + \"React events use the camelCase naming convention, for example `onClick`.\", name);\n                    }\n                    warnedProperties$1[name] = true;\n                    return true;\n                } // Let the ARIA attribute hook validate ARIA attributes\n                if (rARIA$1.test(name) || rARIACamel$1.test(name)) {\n                    return true;\n                }\n                if (lowerCasedName === \"innerhtml\") {\n                    error(\"Directly setting property `innerHTML` is not permitted. \" + \"For more information, lookup documentation on `dangerouslySetInnerHTML`.\");\n                    warnedProperties$1[name] = true;\n                    return true;\n                }\n                if (lowerCasedName === \"aria\") {\n                    error(\"The `aria` attribute is reserved for future use in React. \" + \"Pass individual `aria-` attributes instead.\");\n                    warnedProperties$1[name] = true;\n                    return true;\n                }\n                if (lowerCasedName === \"is\" && value !== null && value !== undefined && typeof value !== \"string\") {\n                    error(\"Received a `%s` for a string attribute `is`. If this is expected, cast \" + \"the value to a string.\", typeof value);\n                    warnedProperties$1[name] = true;\n                    return true;\n                }\n                if (typeof value === \"number\" && isNaN(value)) {\n                    error(\"Received NaN for the `%s` attribute. If this is expected, cast \" + \"the value to a string.\", name);\n                    warnedProperties$1[name] = true;\n                    return true;\n                }\n                var propertyInfo = getPropertyInfo(name);\n                var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED; // Known attributes should match the casing specified in the property config.\n                if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n                    var standardName = possibleStandardNames[lowerCasedName];\n                    if (standardName !== name) {\n                        error(\"Invalid DOM property `%s`. Did you mean `%s`?\", name, standardName);\n                        warnedProperties$1[name] = true;\n                        return true;\n                    }\n                } else if (!isReserved && name !== lowerCasedName) {\n                    // Unknown attributes should have lowercase casing since that's how they\n                    // will be cased anyway with server rendering.\n                    error(\"React does not recognize the `%s` prop on a DOM element. If you \" + \"intentionally want it to appear in the DOM as a custom \" + \"attribute, spell it as lowercase `%s` instead. \" + \"If you accidentally passed it from a parent component, remove \" + \"it from the DOM element.\", name, lowerCasedName);\n                    warnedProperties$1[name] = true;\n                    return true;\n                }\n                if (typeof value === \"boolean\" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {\n                    if (value) {\n                        error(\"Received `%s` for a non-boolean attribute `%s`.\\n\\n\" + \"If you want to write it to the DOM, pass a string instead: \" + '%s=\"%s\" or %s={value.toString()}.', value, name, name, value, name);\n                    } else {\n                        error(\"Received `%s` for a non-boolean attribute `%s`.\\n\\n\" + \"If you want to write it to the DOM, pass a string instead: \" + '%s=\"%s\" or %s={value.toString()}.\\n\\n' + \"If you used to conditionally omit it with %s={condition && value}, \" + \"pass %s={condition ? value : undefined} instead.\", value, name, name, value, name, name, name);\n                    }\n                    warnedProperties$1[name] = true;\n                    return true;\n                } // Now that we've validated casing, do not validate\n                // data types for reserved props\n                if (isReserved) {\n                    return true;\n                } // Warn when a known attribute is a bad type\n                if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {\n                    warnedProperties$1[name] = true;\n                    return false;\n                } // Warn when passing the strings 'false' or 'true' into a boolean prop\n                if ((value === \"false\" || value === \"true\") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {\n                    error(\"Received the string `%s` for the boolean attribute `%s`. \" + \"%s \" + \"Did you mean %s={%s}?\", value, name, value === \"false\" ? \"The browser will interpret it as a truthy value.\" : 'Although this works, it will not work as expected if you pass the string \"false\".', name, value);\n                    warnedProperties$1[name] = true;\n                    return true;\n                }\n                return true;\n            };\n        }\n        var warnUnknownProperties = function(type, props, eventRegistry) {\n            {\n                var unknownProps = [];\n                for(var key in props){\n                    var isValid = validateProperty$1(type, key, props[key], eventRegistry);\n                    if (!isValid) {\n                        unknownProps.push(key);\n                    }\n                }\n                var unknownPropString = unknownProps.map(function(prop) {\n                    return \"`\" + prop + \"`\";\n                }).join(\", \");\n                if (unknownProps.length === 1) {\n                    error(\"Invalid value for prop %s on <%s> tag. Either remove it from the element, \" + \"or pass a string or number value to keep it in the DOM. \" + \"For details, see https://reactjs.org/link/attribute-behavior \", unknownPropString, type);\n                } else if (unknownProps.length > 1) {\n                    error(\"Invalid values for props %s on <%s> tag. Either remove them from the element, \" + \"or pass a string or number value to keep them in the DOM. \" + \"For details, see https://reactjs.org/link/attribute-behavior \", unknownPropString, type);\n                }\n            }\n        };\n        function validateProperties$2(type, props, eventRegistry) {\n            if (isCustomComponent(type, props)) {\n                return;\n            }\n            warnUnknownProperties(type, props, eventRegistry);\n        }\n        var warnValidStyle = function() {};\n        {\n            // 'msTransform' is correct, but the other prefixes should be capitalized\n            var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;\n            var msPattern = /^-ms-/;\n            var hyphenPattern = /-(.)/g; // style values shouldn't contain a semicolon\n            var badStyleValueWithSemicolonPattern = /;\\s*$/;\n            var warnedStyleNames = {};\n            var warnedStyleValues = {};\n            var warnedForNaNValue = false;\n            var warnedForInfinityValue = false;\n            var camelize = function(string) {\n                return string.replace(hyphenPattern, function(_, character) {\n                    return character.toUpperCase();\n                });\n            };\n            var warnHyphenatedStyleName = function(name) {\n                if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n                    return;\n                }\n                warnedStyleNames[name] = true;\n                error(\"Unsupported style property %s. Did you mean %s?\", name, // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n                // is converted to lowercase `ms`.\n                camelize(name.replace(msPattern, \"ms-\")));\n            };\n            var warnBadVendoredStyleName = function(name) {\n                if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n                    return;\n                }\n                warnedStyleNames[name] = true;\n                error(\"Unsupported vendor-prefixed style property %s. Did you mean %s?\", name, name.charAt(0).toUpperCase() + name.slice(1));\n            };\n            var warnStyleValueWithSemicolon = function(name, value) {\n                if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\n                    return;\n                }\n                warnedStyleValues[value] = true;\n                error(\"Style property values shouldn't contain a semicolon. \" + 'Try \"%s: %s\" instead.', name, value.replace(badStyleValueWithSemicolonPattern, \"\"));\n            };\n            var warnStyleValueIsNaN = function(name, value) {\n                if (warnedForNaNValue) {\n                    return;\n                }\n                warnedForNaNValue = true;\n                error(\"`NaN` is an invalid value for the `%s` css style property.\", name);\n            };\n            var warnStyleValueIsInfinity = function(name, value) {\n                if (warnedForInfinityValue) {\n                    return;\n                }\n                warnedForInfinityValue = true;\n                error(\"`Infinity` is an invalid value for the `%s` css style property.\", name);\n            };\n            warnValidStyle = function(name, value) {\n                if (name.indexOf(\"-\") > -1) {\n                    warnHyphenatedStyleName(name);\n                } else if (badVendoredStyleNamePattern.test(name)) {\n                    warnBadVendoredStyleName(name);\n                } else if (badStyleValueWithSemicolonPattern.test(value)) {\n                    warnStyleValueWithSemicolon(name, value);\n                }\n                if (typeof value === \"number\") {\n                    if (isNaN(value)) {\n                        warnStyleValueIsNaN(name, value);\n                    } else if (!isFinite(value)) {\n                        warnStyleValueIsInfinity(name, value);\n                    }\n                }\n            };\n        }\n        var warnValidStyle$1 = warnValidStyle;\n        // code copied and modified from escape-html\n        var matchHtmlRegExp = /[\"'&<>]/;\n        /**\n * Escapes special characters and HTML entities in a given html string.\n *\n * @param  {string} string HTML string to escape for later insertion\n * @return {string}\n * @public\n */ function escapeHtml(string) {\n            {\n                checkHtmlStringCoercion(string);\n            }\n            var str = \"\" + string;\n            var match = matchHtmlRegExp.exec(str);\n            if (!match) {\n                return str;\n            }\n            var escape;\n            var html = \"\";\n            var index;\n            var lastIndex = 0;\n            for(index = match.index; index < str.length; index++){\n                switch(str.charCodeAt(index)){\n                    case 34:\n                        // \"\n                        escape = \"&quot;\";\n                        break;\n                    case 38:\n                        // &\n                        escape = \"&amp;\";\n                        break;\n                    case 39:\n                        // '\n                        escape = \"&#x27;\"; // modified from escape-html; used to be '&#39'\n                        break;\n                    case 60:\n                        // <\n                        escape = \"&lt;\";\n                        break;\n                    case 62:\n                        // >\n                        escape = \"&gt;\";\n                        break;\n                    default:\n                        continue;\n                }\n                if (lastIndex !== index) {\n                    html += str.substring(lastIndex, index);\n                }\n                lastIndex = index + 1;\n                html += escape;\n            }\n            return lastIndex !== index ? html + str.substring(lastIndex, index) : html;\n        } // end code copied and modified from escape-html\n        /**\n * Escapes text to prevent scripting attacks.\n *\n * @param {*} text Text value to escape.\n * @return {string} An escaped string.\n */ function escapeTextForBrowser(text) {\n            if (typeof text === \"boolean\" || typeof text === \"number\") {\n                // this shortcircuit helps perf for types that we know will never have\n                // special characters, especially given that this function is used often\n                // for numeric dom ids.\n                return \"\" + text;\n            }\n            return escapeHtml(text);\n        }\n        var uppercasePattern = /([A-Z])/g;\n        var msPattern$1 = /^ms-/;\n        /**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n */ function hyphenateStyleName(name) {\n            return name.replace(uppercasePattern, \"-$1\").toLowerCase().replace(msPattern$1, \"-ms-\");\n        }\n        // and any newline or tab are filtered out as if they're not part of the URL.\n        // https://url.spec.whatwg.org/#url-parsing\n        // Tab or newline are defined as \\r\\n\\t:\n        // https://infra.spec.whatwg.org/#ascii-tab-or-newline\n        // A C0 control is a code point in the range \\u0000 NULL to \\u001F\n        // INFORMATION SEPARATOR ONE, inclusive:\n        // https://infra.spec.whatwg.org/#c0-control-or-space\n        /* eslint-disable max-len */ var isJavaScriptProtocol = /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*\\:/i;\n        var didWarn = false;\n        function sanitizeURL(url) {\n            {\n                if (!didWarn && isJavaScriptProtocol.test(url)) {\n                    didWarn = true;\n                    error(\"A future version of React will block javascript: URLs as a security precaution. \" + \"Use event handlers instead if you can. If you need to generate unsafe HTML try \" + \"using dangerouslySetInnerHTML instead. React was passed %s.\", JSON.stringify(url));\n                }\n            }\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        var startInlineScript = stringToPrecomputedChunk(\"<script>\");\n        var endInlineScript = stringToPrecomputedChunk(\"</script>\");\n        var startScriptSrc = stringToPrecomputedChunk('<script src=\"');\n        var startModuleSrc = stringToPrecomputedChunk('<script type=\"module\" src=\"');\n        var endAsyncScript = stringToPrecomputedChunk('\" async=\"\"></script>');\n        /**\n * This escaping function is designed to work with bootstrapScriptContent only.\n * because we know we are escaping the entire script. We can avoid for instance\n * escaping html comment string sequences that are valid javascript as well because\n * if there are no sebsequent <script sequences the html parser will never enter\n * script data double escaped state (see: https://www.w3.org/TR/html53/syntax.html#script-data-double-escaped-state)\n *\n * While untrusted script content should be made safe before using this api it will\n * ensure that the script cannot be early terminated or never terminated state\n */ function escapeBootstrapScriptContent(scriptText) {\n            {\n                checkHtmlStringCoercion(scriptText);\n            }\n            return (\"\" + scriptText).replace(scriptRegex, scriptReplacer);\n        }\n        var scriptRegex = /(<\\/|<)(s)(cript)/gi;\n        var scriptReplacer = function(match, prefix, s, suffix) {\n            return \"\" + prefix + (s === \"s\" ? \"\\\\u0073\" : \"\\\\u0053\") + suffix;\n        }; // Allows us to keep track of what we've already written so we can refer back to it.\n        function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {\n            var idPrefix = identifierPrefix === undefined ? \"\" : identifierPrefix;\n            var inlineScriptWithNonce = nonce === undefined ? startInlineScript : stringToPrecomputedChunk('<script nonce=\"' + escapeTextForBrowser(nonce) + '\">');\n            var bootstrapChunks = [];\n            if (bootstrapScriptContent !== undefined) {\n                bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);\n            }\n            if (bootstrapScripts !== undefined) {\n                for(var i = 0; i < bootstrapScripts.length; i++){\n                    bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(bootstrapScripts[i])), endAsyncScript);\n                }\n            }\n            if (bootstrapModules !== undefined) {\n                for(var _i = 0; _i < bootstrapModules.length; _i++){\n                    bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(bootstrapModules[_i])), endAsyncScript);\n                }\n            }\n            return {\n                bootstrapChunks: bootstrapChunks,\n                startInlineScript: inlineScriptWithNonce,\n                placeholderPrefix: stringToPrecomputedChunk(idPrefix + \"P:\"),\n                segmentPrefix: stringToPrecomputedChunk(idPrefix + \"S:\"),\n                boundaryPrefix: idPrefix + \"B:\",\n                idPrefix: idPrefix,\n                nextSuspenseID: 0,\n                sentCompleteSegmentFunction: false,\n                sentCompleteBoundaryFunction: false,\n                sentClientRenderFunction: false\n            };\n        } // Constants for the insertion mode we're currently writing in. We don't encode all HTML5 insertion\n        // modes. We only include the variants as they matter for the sake of our purposes.\n        // We don't actually provide the namespace therefore we use constants instead of the string.\n        var ROOT_HTML_MODE = 0; // Used for the root most element tag.\n        var HTML_MODE = 1;\n        var SVG_MODE = 2;\n        var MATHML_MODE = 3;\n        var HTML_TABLE_MODE = 4;\n        var HTML_TABLE_BODY_MODE = 5;\n        var HTML_TABLE_ROW_MODE = 6;\n        var HTML_COLGROUP_MODE = 7; // We have a greater than HTML_TABLE_MODE check elsewhere. If you add more cases here, make sure it\n        // still makes sense\n        function createFormatContext(insertionMode, selectedValue) {\n            return {\n                insertionMode: insertionMode,\n                selectedValue: selectedValue\n            };\n        }\n        function getChildFormatContext(parentContext, type, props) {\n            switch(type){\n                case \"select\":\n                    return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);\n                case \"svg\":\n                    return createFormatContext(SVG_MODE, null);\n                case \"math\":\n                    return createFormatContext(MATHML_MODE, null);\n                case \"foreignObject\":\n                    return createFormatContext(HTML_MODE, null);\n                // Table parents are special in that their children can only be created at all if they're\n                // wrapped in a table parent. So we need to encode that we're entering this mode.\n                case \"table\":\n                    return createFormatContext(HTML_TABLE_MODE, null);\n                case \"thead\":\n                case \"tbody\":\n                case \"tfoot\":\n                    return createFormatContext(HTML_TABLE_BODY_MODE, null);\n                case \"colgroup\":\n                    return createFormatContext(HTML_COLGROUP_MODE, null);\n                case \"tr\":\n                    return createFormatContext(HTML_TABLE_ROW_MODE, null);\n            }\n            if (parentContext.insertionMode >= HTML_TABLE_MODE) {\n                // Whatever tag this was, it wasn't a table parent or other special parent, so we must have\n                // entered plain HTML again.\n                return createFormatContext(HTML_MODE, null);\n            }\n            if (parentContext.insertionMode === ROOT_HTML_MODE) {\n                // We've emitted the root and is now in plain HTML mode.\n                return createFormatContext(HTML_MODE, null);\n            }\n            return parentContext;\n        }\n        var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;\n        function assignSuspenseBoundaryID(responseState) {\n            var generatedID = responseState.nextSuspenseID++;\n            return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));\n        }\n        function makeId(responseState, treeId, localId) {\n            var idPrefix = responseState.idPrefix;\n            var id = \":\" + idPrefix + \"R\" + treeId; // Unless this is the first id at this level, append a number at the end\n            // that represents the position of this useId hook among all the useId\n            // hooks for this fiber.\n            if (localId > 0) {\n                id += \"H\" + localId.toString(32);\n            }\n            return id + \":\";\n        }\n        function encodeHTMLTextNode(text) {\n            return escapeTextForBrowser(text);\n        }\n        var textSeparator = stringToPrecomputedChunk(\"<!-- -->\");\n        function pushTextInstance(target, text, responseState, textEmbedded) {\n            if (text === \"\") {\n                // Empty text doesn't have a DOM node representation and the hydration is aware of this.\n                return textEmbedded;\n            }\n            if (textEmbedded) {\n                target.push(textSeparator);\n            }\n            target.push(stringToChunk(encodeHTMLTextNode(text)));\n            return true;\n        } // Called when Fizz is done with a Segment. Currently the only purpose is to conditionally\n        // emit a text separator when we don't know for sure it is safe to omit\n        function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {\n            if (lastPushedText && textEmbedded) {\n                target.push(textSeparator);\n            }\n        }\n        var styleNameCache = new Map();\n        function processStyleName(styleName) {\n            var chunk = styleNameCache.get(styleName);\n            if (chunk !== undefined) {\n                return chunk;\n            }\n            var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));\n            styleNameCache.set(styleName, result);\n            return result;\n        }\n        var styleAttributeStart = stringToPrecomputedChunk(' style=\"');\n        var styleAssign = stringToPrecomputedChunk(\":\");\n        var styleSeparator = stringToPrecomputedChunk(\";\");\n        function pushStyle(target, responseState, style) {\n            if (typeof style !== \"object\") {\n                throw new Error(\"The `style` prop expects a mapping from style properties to values, \" + \"not a string. For example, style={{marginRight: spacing + 'em'}} when \" + \"using JSX.\");\n            }\n            var isFirst = true;\n            for(var styleName in style){\n                if (!hasOwnProperty.call(style, styleName)) {\n                    continue;\n                } // If you provide unsafe user data here they can inject arbitrary CSS\n                // which may be problematic (I couldn't repro this):\n                // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n                // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n                // This is not an XSS hole but instead a potential CSS injection issue\n                // which has lead to a greater discussion about how we're going to\n                // trust URLs moving forward. See #2115901\n                var styleValue = style[styleName];\n                if (styleValue == null || typeof styleValue === \"boolean\" || styleValue === \"\") {\n                    continue;\n                }\n                var nameChunk = void 0;\n                var valueChunk = void 0;\n                var isCustomProperty = styleName.indexOf(\"--\") === 0;\n                if (isCustomProperty) {\n                    nameChunk = stringToChunk(escapeTextForBrowser(styleName));\n                    {\n                        checkCSSPropertyStringCoercion(styleValue, styleName);\n                    }\n                    valueChunk = stringToChunk(escapeTextForBrowser((\"\" + styleValue).trim()));\n                } else {\n                    {\n                        warnValidStyle$1(styleName, styleValue);\n                    }\n                    nameChunk = processStyleName(styleName);\n                    if (typeof styleValue === \"number\") {\n                        if (styleValue !== 0 && !hasOwnProperty.call(isUnitlessNumber, styleName)) {\n                            valueChunk = stringToChunk(styleValue + \"px\"); // Presumes implicit 'px' suffix for unitless numbers\n                        } else {\n                            valueChunk = stringToChunk(\"\" + styleValue);\n                        }\n                    } else {\n                        {\n                            checkCSSPropertyStringCoercion(styleValue, styleName);\n                        }\n                        valueChunk = stringToChunk(escapeTextForBrowser((\"\" + styleValue).trim()));\n                    }\n                }\n                if (isFirst) {\n                    isFirst = false; // If it's first, we don't need any separators prefixed.\n                    target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);\n                } else {\n                    target.push(styleSeparator, nameChunk, styleAssign, valueChunk);\n                }\n            }\n            if (!isFirst) {\n                target.push(attributeEnd);\n            }\n        }\n        var attributeSeparator = stringToPrecomputedChunk(\" \");\n        var attributeAssign = stringToPrecomputedChunk('=\"');\n        var attributeEnd = stringToPrecomputedChunk('\"');\n        var attributeEmptyString = stringToPrecomputedChunk('=\"\"');\n        function pushAttribute(target, responseState, name, value) {\n            switch(name){\n                case \"style\":\n                    {\n                        pushStyle(target, responseState, value);\n                        return;\n                    }\n                case \"defaultValue\":\n                case \"defaultChecked\":\n                case \"innerHTML\":\n                case \"suppressContentEditableWarning\":\n                case \"suppressHydrationWarning\":\n                    // Ignored. These are built-in to React on the client.\n                    return;\n            }\n            if (// We have already filtered out null/undefined and reserved words.\n            name.length > 2 && (name[0] === \"o\" || name[0] === \"O\") && (name[1] === \"n\" || name[1] === \"N\")) {\n                return;\n            }\n            var propertyInfo = getPropertyInfo(name);\n            if (propertyInfo !== null) {\n                // shouldRemoveAttribute\n                switch(typeof value){\n                    case \"function\":\n                    case \"symbol\":\n                        // eslint-disable-line\n                        return;\n                    case \"boolean\":\n                        {\n                            if (!propertyInfo.acceptsBooleans) {\n                                return;\n                            }\n                        }\n                }\n                var attributeName = propertyInfo.attributeName;\n                var attributeNameChunk = stringToChunk(attributeName); // TODO: If it's known we can cache the chunk.\n                switch(propertyInfo.type){\n                    case BOOLEAN:\n                        if (value) {\n                            target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);\n                        }\n                        return;\n                    case OVERLOADED_BOOLEAN:\n                        if (value === true) {\n                            target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);\n                        } else if (value === false) ;\n                        else {\n                            target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        return;\n                    case NUMERIC:\n                        if (!isNaN(value)) {\n                            target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        break;\n                    case POSITIVE_NUMERIC:\n                        if (!isNaN(value) && value >= 1) {\n                            target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        break;\n                    default:\n                        if (propertyInfo.sanitizeURL) {\n                            {\n                                checkAttributeStringCoercion(value, attributeName);\n                            }\n                            value = \"\" + value;\n                            sanitizeURL(value);\n                        }\n                        target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                }\n            } else if (isAttributeNameSafe(name)) {\n                // shouldRemoveAttribute\n                switch(typeof value){\n                    case \"function\":\n                    case \"symbol\":\n                        // eslint-disable-line\n                        return;\n                    case \"boolean\":\n                        {\n                            var prefix = name.toLowerCase().slice(0, 5);\n                            if (prefix !== \"data-\" && prefix !== \"aria-\") {\n                                return;\n                            }\n                        }\n                }\n                target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n            }\n        }\n        var endOfStartTag = stringToPrecomputedChunk(\">\");\n        var endOfStartTagSelfClosing = stringToPrecomputedChunk(\"/>\");\n        function pushInnerHTML(target, innerHTML, children) {\n            if (innerHTML != null) {\n                if (children != null) {\n                    throw new Error(\"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\");\n                }\n                if (typeof innerHTML !== \"object\" || !(\"__html\" in innerHTML)) {\n                    throw new Error(\"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. \" + \"Please visit https://reactjs.org/link/dangerously-set-inner-html \" + \"for more information.\");\n                }\n                var html = innerHTML.__html;\n                if (html !== null && html !== undefined) {\n                    {\n                        checkHtmlStringCoercion(html);\n                    }\n                    target.push(stringToChunk(\"\" + html));\n                }\n            }\n        } // TODO: Move these to ResponseState so that we warn for every request.\n        // It would help debugging in stateful servers (e.g. service worker).\n        var didWarnDefaultInputValue = false;\n        var didWarnDefaultChecked = false;\n        var didWarnDefaultSelectValue = false;\n        var didWarnDefaultTextareaValue = false;\n        var didWarnInvalidOptionChildren = false;\n        var didWarnInvalidOptionInnerHTML = false;\n        var didWarnSelectedSetOnOption = false;\n        function checkSelectProp(props, propName) {\n            {\n                var value = props[propName];\n                if (value != null) {\n                    var array = isArray(value);\n                    if (props.multiple && !array) {\n                        error(\"The `%s` prop supplied to <select> must be an array if \" + \"`multiple` is true.\", propName);\n                    } else if (!props.multiple && array) {\n                        error(\"The `%s` prop supplied to <select> must be a scalar \" + \"value if `multiple` is false.\", propName);\n                    }\n                }\n            }\n        }\n        function pushStartSelect(target, props, responseState) {\n            {\n                checkControlledValueProps(\"select\", props);\n                checkSelectProp(props, \"value\");\n                checkSelectProp(props, \"defaultValue\");\n                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultSelectValue) {\n                    error(\"Select elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled select \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\");\n                    didWarnDefaultSelectValue = true;\n                }\n            }\n            target.push(startChunkForTag(\"select\"));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            // TODO: This doesn't really make sense for select since it can't use the controlled\n                            // value in the innerHTML.\n                            innerHTML = propValue;\n                            break;\n                        case \"defaultValue\":\n                        case \"value\":\n                            break;\n                        default:\n                            pushAttribute(target, responseState, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            return children;\n        }\n        function flattenOptionChildren(children) {\n            var content = \"\"; // Flatten children and warn if they aren't strings or numbers;\n            // invalid types are ignored.\n            React.Children.forEach(children, function(child) {\n                if (child == null) {\n                    return;\n                }\n                content += child;\n                {\n                    if (!didWarnInvalidOptionChildren && typeof child !== \"string\" && typeof child !== \"number\") {\n                        didWarnInvalidOptionChildren = true;\n                        error(\"Cannot infer the option value of complex children. \" + \"Pass a `value` prop or use a plain string as children to <option>.\");\n                    }\n                }\n            });\n            return content;\n        }\n        var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=\"\"');\n        function pushStartOption(target, props, responseState, formatContext) {\n            var selectedValue = formatContext.selectedValue;\n            target.push(startChunkForTag(\"option\"));\n            var children = null;\n            var value = null;\n            var selected = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"selected\":\n                            // ignore\n                            selected = propValue;\n                            {\n                                // TODO: Remove support for `selected` in <option>.\n                                if (!didWarnSelectedSetOnOption) {\n                                    error(\"Use the `defaultValue` or `value` props on <select> instead of \" + \"setting `selected` on <option>.\");\n                                    didWarnSelectedSetOnOption = true;\n                                }\n                            }\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        // eslint-disable-next-line-no-fallthrough\n                        case \"value\":\n                            value = propValue;\n                        // We intentionally fallthrough to also set the attribute on the node.\n                        // eslint-disable-next-line-no-fallthrough\n                        default:\n                            pushAttribute(target, responseState, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            if (selectedValue != null) {\n                var stringValue;\n                if (value !== null) {\n                    {\n                        checkAttributeStringCoercion(value, \"value\");\n                    }\n                    stringValue = \"\" + value;\n                } else {\n                    {\n                        if (innerHTML !== null) {\n                            if (!didWarnInvalidOptionInnerHTML) {\n                                didWarnInvalidOptionInnerHTML = true;\n                                error(\"Pass a `value` prop if you set dangerouslyInnerHTML so React knows \" + \"which value should be selected.\");\n                            }\n                        }\n                    }\n                    stringValue = flattenOptionChildren(children);\n                }\n                if (isArray(selectedValue)) {\n                    // multiple\n                    for(var i = 0; i < selectedValue.length; i++){\n                        {\n                            checkAttributeStringCoercion(selectedValue[i], \"value\");\n                        }\n                        var v = \"\" + selectedValue[i];\n                        if (v === stringValue) {\n                            target.push(selectedMarkerAttribute);\n                            break;\n                        }\n                    }\n                } else {\n                    {\n                        checkAttributeStringCoercion(selectedValue, \"select.value\");\n                    }\n                    if (\"\" + selectedValue === stringValue) {\n                        target.push(selectedMarkerAttribute);\n                    }\n                }\n            } else if (selected) {\n                target.push(selectedMarkerAttribute);\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            return children;\n        }\n        function pushInput(target, props, responseState) {\n            {\n                checkControlledValueProps(\"input\", props);\n                if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnDefaultChecked) {\n                    error(\"%s contains an input of type %s with both checked and defaultChecked props. \" + \"Input elements must be either controlled or uncontrolled \" + \"(specify either the checked prop, or the defaultChecked prop, but not \" + \"both). Decide between using a controlled or uncontrolled input \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\", \"A component\", props.type);\n                    didWarnDefaultChecked = true;\n                }\n                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultInputValue) {\n                    error(\"%s contains an input of type %s with both value and defaultValue props. \" + \"Input elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled input \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\", \"A component\", props.type);\n                    didWarnDefaultInputValue = true;\n                }\n            }\n            target.push(startChunkForTag(\"input\"));\n            var value = null;\n            var defaultValue = null;\n            var checked = null;\n            var defaultChecked = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"input\" + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        // eslint-disable-next-line-no-fallthrough\n                        case \"defaultChecked\":\n                            defaultChecked = propValue;\n                            break;\n                        case \"defaultValue\":\n                            defaultValue = propValue;\n                            break;\n                        case \"checked\":\n                            checked = propValue;\n                            break;\n                        case \"value\":\n                            value = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, responseState, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            if (checked !== null) {\n                pushAttribute(target, responseState, \"checked\", checked);\n            } else if (defaultChecked !== null) {\n                pushAttribute(target, responseState, \"checked\", defaultChecked);\n            }\n            if (value !== null) {\n                pushAttribute(target, responseState, \"value\", value);\n            } else if (defaultValue !== null) {\n                pushAttribute(target, responseState, \"value\", defaultValue);\n            }\n            target.push(endOfStartTagSelfClosing);\n            return null;\n        }\n        function pushStartTextArea(target, props, responseState) {\n            {\n                checkControlledValueProps(\"textarea\", props);\n                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultTextareaValue) {\n                    error(\"Textarea elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled textarea \" + \"and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\");\n                    didWarnDefaultTextareaValue = true;\n                }\n            }\n            target.push(startChunkForTag(\"textarea\"));\n            var value = null;\n            var defaultValue = null;\n            var children = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"value\":\n                            value = propValue;\n                            break;\n                        case \"defaultValue\":\n                            defaultValue = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"`dangerouslySetInnerHTML` does not make sense on <textarea>.\");\n                        // eslint-disable-next-line-no-fallthrough\n                        default:\n                            pushAttribute(target, responseState, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            if (value === null && defaultValue !== null) {\n                value = defaultValue;\n            }\n            target.push(endOfStartTag); // TODO (yungsters): Remove support for children content in <textarea>.\n            if (children != null) {\n                {\n                    error(\"Use the `defaultValue` or `value` props instead of setting \" + \"children on <textarea>.\");\n                }\n                if (value != null) {\n                    throw new Error(\"If you supply `defaultValue` on a <textarea>, do not pass children.\");\n                }\n                if (isArray(children)) {\n                    if (children.length > 1) {\n                        throw new Error(\"<textarea> can only have at most one child.\");\n                    } // TODO: remove the coercion and the DEV check below because it will\n                    // always be overwritten by the coercion several lines below it. #22309\n                    {\n                        checkHtmlStringCoercion(children[0]);\n                    }\n                    value = \"\" + children[0];\n                }\n                {\n                    checkHtmlStringCoercion(children);\n                }\n                value = \"\" + children;\n            }\n            if (typeof value === \"string\" && value[0] === \"\\n\") {\n                // text/html ignores the first character in these tags if it's a newline\n                // Prefer to break application/xml over text/html (for now) by adding\n                // a newline specifically to get eaten by the parser. (Alternately for\n                // textareas, replacing \"^\\n\" with \"\\r\\n\" doesn't get eaten, and the first\n                // \\r is normalized out by HTMLTextAreaElement#value.)\n                // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>\n                // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>\n                // See: <http://www.w3.org/TR/html5/syntax.html#newlines>\n                // See: Parsing of \"textarea\" \"listing\" and \"pre\" elements\n                //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>\n                target.push(leadingNewline);\n            } // ToString and push directly instead of recurse over children.\n            // We don't really support complex children in the value anyway.\n            // This also currently avoids a trailing comment node which breaks textarea.\n            if (value !== null) {\n                {\n                    checkAttributeStringCoercion(value, \"value\");\n                }\n                target.push(stringToChunk(encodeHTMLTextNode(\"\" + value)));\n            }\n            return null;\n        }\n        function pushSelfClosing(target, props, tag, responseState) {\n            target.push(startChunkForTag(tag));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(tag + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        // eslint-disable-next-line-no-fallthrough\n                        default:\n                            pushAttribute(target, responseState, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTagSelfClosing);\n            return null;\n        }\n        function pushStartMenuItem(target, props, responseState) {\n            target.push(startChunkForTag(\"menuitem\"));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"menuitems cannot have `children` nor `dangerouslySetInnerHTML`.\");\n                        // eslint-disable-next-line-no-fallthrough\n                        default:\n                            pushAttribute(target, responseState, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            return null;\n        }\n        function pushStartTitle(target, props, responseState) {\n            target.push(startChunkForTag(\"title\"));\n            var children = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"`dangerouslySetInnerHTML` does not make sense on <title>.\");\n                        // eslint-disable-next-line-no-fallthrough\n                        default:\n                            pushAttribute(target, responseState, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            {\n                var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;\n                if (Array.isArray(children) && children.length > 1) {\n                    error(\"A title element received an array with more than 1 element as children. \" + \"In browsers title Elements can only have Text Nodes as children. If \" + \"the children being rendered output more than a single text node in aggregate the browser \" + \"will display markup and comments as text in the title and hydration will likely fail and \" + \"fall back to client rendering\");\n                } else if (child != null && child.$$typeof != null) {\n                    error(\"A title element received a React element for children. \" + \"In the browser title Elements can only have Text Nodes as children. If \" + \"the children being rendered output more than a single text node in aggregate the browser \" + \"will display markup and comments as text in the title and hydration will likely fail and \" + \"fall back to client rendering\");\n                } else if (child != null && typeof child !== \"string\" && typeof child !== \"number\") {\n                    error(\"A title element received a value that was not a string or number for children. \" + \"In the browser title Elements can only have Text Nodes as children. If \" + \"the children being rendered output more than a single text node in aggregate the browser \" + \"will display markup and comments as text in the title and hydration will likely fail and \" + \"fall back to client rendering\");\n                }\n            }\n            return children;\n        }\n        function pushStartGenericElement(target, props, tag, responseState) {\n            target.push(startChunkForTag(tag));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, responseState, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            if (typeof children === \"string\") {\n                // Special case children as a string to avoid the unnecessary comment.\n                // TODO: Remove this special case after the general optimization is in place.\n                target.push(stringToChunk(encodeHTMLTextNode(children)));\n                return null;\n            }\n            return children;\n        }\n        function pushStartCustomElement(target, props, tag, responseState) {\n            target.push(startChunkForTag(tag));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        case \"style\":\n                            pushStyle(target, responseState, propValue);\n                            break;\n                        case \"suppressContentEditableWarning\":\n                        case \"suppressHydrationWarning\":\n                            break;\n                        default:\n                            if (isAttributeNameSafe(propKey) && typeof propValue !== \"function\" && typeof propValue !== \"symbol\") {\n                                target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);\n                            }\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            return children;\n        }\n        var leadingNewline = stringToPrecomputedChunk(\"\\n\");\n        function pushStartPreformattedElement(target, props, tag, responseState) {\n            target.push(startChunkForTag(tag));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, responseState, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag); // text/html ignores the first character in these tags if it's a newline\n            // Prefer to break application/xml over text/html (for now) by adding\n            // a newline specifically to get eaten by the parser. (Alternately for\n            // textareas, replacing \"^\\n\" with \"\\r\\n\" doesn't get eaten, and the first\n            // \\r is normalized out by HTMLTextAreaElement#value.)\n            // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>\n            // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>\n            // See: <http://www.w3.org/TR/html5/syntax.html#newlines>\n            // See: Parsing of \"textarea\" \"listing\" and \"pre\" elements\n            //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>\n            // TODO: This doesn't deal with the case where the child is an array\n            // or component that returns a string.\n            if (innerHTML != null) {\n                if (children != null) {\n                    throw new Error(\"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\");\n                }\n                if (typeof innerHTML !== \"object\" || !(\"__html\" in innerHTML)) {\n                    throw new Error(\"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. \" + \"Please visit https://reactjs.org/link/dangerously-set-inner-html \" + \"for more information.\");\n                }\n                var html = innerHTML.__html;\n                if (html !== null && html !== undefined) {\n                    if (typeof html === \"string\" && html.length > 0 && html[0] === \"\\n\") {\n                        target.push(leadingNewline, stringToChunk(html));\n                    } else {\n                        {\n                            checkHtmlStringCoercion(html);\n                        }\n                        target.push(stringToChunk(\"\" + html));\n                    }\n                }\n            }\n            if (typeof children === \"string\" && children[0] === \"\\n\") {\n                target.push(leadingNewline);\n            }\n            return children;\n        } // We accept any tag to be rendered but since this gets injected into arbitrary\n        // HTML, we want to make sure that it's a safe tag.\n        // http://www.w3.org/TR/REC-xml/#NT-Name\n        var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\\.\\-\\d]*$/; // Simplified subset\n        var validatedTagCache = new Map();\n        function startChunkForTag(tag) {\n            var tagStartChunk = validatedTagCache.get(tag);\n            if (tagStartChunk === undefined) {\n                if (!VALID_TAG_REGEX.test(tag)) {\n                    throw new Error(\"Invalid tag: \" + tag);\n                }\n                tagStartChunk = stringToPrecomputedChunk(\"<\" + tag);\n                validatedTagCache.set(tag, tagStartChunk);\n            }\n            return tagStartChunk;\n        }\n        var DOCTYPE = stringToPrecomputedChunk(\"<!DOCTYPE html>\");\n        function pushStartInstance(target, type, props, responseState, formatContext) {\n            {\n                validateProperties(type, props);\n                validateProperties$1(type, props);\n                validateProperties$2(type, props, null);\n                if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {\n                    error(\"A component is `contentEditable` and contains `children` managed by \" + \"React. It is now your responsibility to guarantee that none of \" + \"those nodes are unexpectedly modified or duplicated. This is \" + \"probably not intentional.\");\n                }\n                if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {\n                    if (type.indexOf(\"-\") === -1 && typeof props.is !== \"string\" && type.toLowerCase() !== type) {\n                        error(\"<%s /> is using incorrect casing. \" + \"Use PascalCase for React components, \" + \"or lowercase for HTML elements.\", type);\n                    }\n                }\n            }\n            switch(type){\n                // Special tags\n                case \"select\":\n                    return pushStartSelect(target, props, responseState);\n                case \"option\":\n                    return pushStartOption(target, props, responseState, formatContext);\n                case \"textarea\":\n                    return pushStartTextArea(target, props, responseState);\n                case \"input\":\n                    return pushInput(target, props, responseState);\n                case \"menuitem\":\n                    return pushStartMenuItem(target, props, responseState);\n                case \"title\":\n                    return pushStartTitle(target, props, responseState);\n                // Newline eating tags\n                case \"listing\":\n                case \"pre\":\n                    {\n                        return pushStartPreformattedElement(target, props, type, responseState);\n                    }\n                // Omitted close tags\n                case \"area\":\n                case \"base\":\n                case \"br\":\n                case \"col\":\n                case \"embed\":\n                case \"hr\":\n                case \"img\":\n                case \"keygen\":\n                case \"link\":\n                case \"meta\":\n                case \"param\":\n                case \"source\":\n                case \"track\":\n                case \"wbr\":\n                    {\n                        return pushSelfClosing(target, props, type, responseState);\n                    }\n                // These are reserved SVG and MathML elements, that are never custom elements.\n                // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n                case \"annotation-xml\":\n                case \"color-profile\":\n                case \"font-face\":\n                case \"font-face-src\":\n                case \"font-face-uri\":\n                case \"font-face-format\":\n                case \"font-face-name\":\n                case \"missing-glyph\":\n                    {\n                        return pushStartGenericElement(target, props, type, responseState);\n                    }\n                case \"html\":\n                    {\n                        if (formatContext.insertionMode === ROOT_HTML_MODE) {\n                            // If we're rendering the html tag and we're at the root (i.e. not in foreignObject)\n                            // then we also emit the DOCTYPE as part of the root content as a convenience for\n                            // rendering the whole document.\n                            target.push(DOCTYPE);\n                        }\n                        return pushStartGenericElement(target, props, type, responseState);\n                    }\n                default:\n                    {\n                        if (type.indexOf(\"-\") === -1 && typeof props.is !== \"string\") {\n                            // Generic element\n                            return pushStartGenericElement(target, props, type, responseState);\n                        } else {\n                            // Custom element\n                            return pushStartCustomElement(target, props, type, responseState);\n                        }\n                    }\n            }\n        }\n        var endTag1 = stringToPrecomputedChunk(\"</\");\n        var endTag2 = stringToPrecomputedChunk(\">\");\n        function pushEndInstance(target, type, props) {\n            switch(type){\n                // Omitted close tags\n                // TODO: Instead of repeating this switch we could try to pass a flag from above.\n                // That would require returning a tuple. Which might be ok if it gets inlined.\n                case \"area\":\n                case \"base\":\n                case \"br\":\n                case \"col\":\n                case \"embed\":\n                case \"hr\":\n                case \"img\":\n                case \"input\":\n                case \"keygen\":\n                case \"link\":\n                case \"meta\":\n                case \"param\":\n                case \"source\":\n                case \"track\":\n                case \"wbr\":\n                    {\n                        break;\n                    }\n                default:\n                    {\n                        target.push(endTag1, stringToChunk(type), endTag2);\n                    }\n            }\n        }\n        function writeCompletedRoot(destination, responseState) {\n            var bootstrapChunks = responseState.bootstrapChunks;\n            var i = 0;\n            for(; i < bootstrapChunks.length - 1; i++){\n                writeChunk(destination, bootstrapChunks[i]);\n            }\n            if (i < bootstrapChunks.length) {\n                return writeChunkAndReturn(destination, bootstrapChunks[i]);\n            }\n            return true;\n        } // Structural Nodes\n        // A placeholder is a node inside a hidden partial tree that can be filled in later, but before\n        // display. It's never visible to users. We use the template tag because it can be used in every\n        // type of parent. <script> tags also work in every other tag except <colgroup>.\n        var placeholder1 = stringToPrecomputedChunk('<template id=\"');\n        var placeholder2 = stringToPrecomputedChunk('\"></template>');\n        function writePlaceholder(destination, responseState, id) {\n            writeChunk(destination, placeholder1);\n            writeChunk(destination, responseState.placeholderPrefix);\n            var formattedID = stringToChunk(id.toString(16));\n            writeChunk(destination, formattedID);\n            return writeChunkAndReturn(destination, placeholder2);\n        } // Suspense boundaries are encoded as comments.\n        var startCompletedSuspenseBoundary = stringToPrecomputedChunk(\"<!--$-->\");\n        var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id=\"');\n        var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('\"></template>');\n        var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk(\"<!--$!-->\");\n        var endSuspenseBoundary = stringToPrecomputedChunk(\"<!--/$-->\");\n        var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk(\"<template\");\n        var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('\"');\n        var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst=\"');\n        var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg=\"');\n        var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck=\"');\n        var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk(\"></template>\");\n        function writeStartCompletedSuspenseBoundary(destination, responseState) {\n            return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);\n        }\n        function writeStartPendingSuspenseBoundary(destination, responseState, id) {\n            writeChunk(destination, startPendingSuspenseBoundary1);\n            if (id === null) {\n                throw new Error(\"An ID must have been assigned before we can complete the boundary.\");\n            }\n            writeChunk(destination, id);\n            return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);\n        }\n        function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {\n            var result;\n            result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);\n            writeChunk(destination, clientRenderedSuspenseBoundaryError1);\n            if (errorDigest) {\n                writeChunk(destination, clientRenderedSuspenseBoundaryError1A);\n                writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));\n                writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);\n            }\n            {\n                if (errorMesssage) {\n                    writeChunk(destination, clientRenderedSuspenseBoundaryError1B);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));\n                    writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);\n                }\n                if (errorComponentStack) {\n                    writeChunk(destination, clientRenderedSuspenseBoundaryError1C);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));\n                    writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);\n                }\n            }\n            result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);\n            return result;\n        }\n        function writeEndCompletedSuspenseBoundary(destination, responseState) {\n            return writeChunkAndReturn(destination, endSuspenseBoundary);\n        }\n        function writeEndPendingSuspenseBoundary(destination, responseState) {\n            return writeChunkAndReturn(destination, endSuspenseBoundary);\n        }\n        function writeEndClientRenderedSuspenseBoundary(destination, responseState) {\n            return writeChunkAndReturn(destination, endSuspenseBoundary);\n        }\n        var startSegmentHTML = stringToPrecomputedChunk('<div hidden id=\"');\n        var startSegmentHTML2 = stringToPrecomputedChunk('\">');\n        var endSegmentHTML = stringToPrecomputedChunk(\"</div>\");\n        var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden=\"true\" style=\"display:none\" id=\"');\n        var startSegmentSVG2 = stringToPrecomputedChunk('\">');\n        var endSegmentSVG = stringToPrecomputedChunk(\"</svg>\");\n        var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden=\"true\" style=\"display:none\" id=\"');\n        var startSegmentMathML2 = stringToPrecomputedChunk('\">');\n        var endSegmentMathML = stringToPrecomputedChunk(\"</math>\");\n        var startSegmentTable = stringToPrecomputedChunk('<table hidden id=\"');\n        var startSegmentTable2 = stringToPrecomputedChunk('\">');\n        var endSegmentTable = stringToPrecomputedChunk(\"</table>\");\n        var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id=\"');\n        var startSegmentTableBody2 = stringToPrecomputedChunk('\">');\n        var endSegmentTableBody = stringToPrecomputedChunk(\"</tbody></table>\");\n        var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id=\"');\n        var startSegmentTableRow2 = stringToPrecomputedChunk('\">');\n        var endSegmentTableRow = stringToPrecomputedChunk(\"</tr></table>\");\n        var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id=\"');\n        var startSegmentColGroup2 = stringToPrecomputedChunk('\">');\n        var endSegmentColGroup = stringToPrecomputedChunk(\"</colgroup></table>\");\n        function writeStartSegment(destination, responseState, formatContext, id) {\n            switch(formatContext.insertionMode){\n                case ROOT_HTML_MODE:\n                case HTML_MODE:\n                    {\n                        writeChunk(destination, startSegmentHTML);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentHTML2);\n                    }\n                case SVG_MODE:\n                    {\n                        writeChunk(destination, startSegmentSVG);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentSVG2);\n                    }\n                case MATHML_MODE:\n                    {\n                        writeChunk(destination, startSegmentMathML);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentMathML2);\n                    }\n                case HTML_TABLE_MODE:\n                    {\n                        writeChunk(destination, startSegmentTable);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentTable2);\n                    }\n                // TODO: For the rest of these, there will be extra wrapper nodes that never\n                // get deleted from the document. We need to delete the table too as part\n                // of the injected scripts. They are invisible though so it's not too terrible\n                // and it's kind of an edge case to suspend in a table. Totally supported though.\n                case HTML_TABLE_BODY_MODE:\n                    {\n                        writeChunk(destination, startSegmentTableBody);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentTableBody2);\n                    }\n                case HTML_TABLE_ROW_MODE:\n                    {\n                        writeChunk(destination, startSegmentTableRow);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentTableRow2);\n                    }\n                case HTML_COLGROUP_MODE:\n                    {\n                        writeChunk(destination, startSegmentColGroup);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentColGroup2);\n                    }\n                default:\n                    {\n                        throw new Error(\"Unknown insertion mode. This is a bug in React.\");\n                    }\n            }\n        }\n        function writeEndSegment(destination, formatContext) {\n            switch(formatContext.insertionMode){\n                case ROOT_HTML_MODE:\n                case HTML_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentHTML);\n                    }\n                case SVG_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentSVG);\n                    }\n                case MATHML_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentMathML);\n                    }\n                case HTML_TABLE_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentTable);\n                    }\n                case HTML_TABLE_BODY_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentTableBody);\n                    }\n                case HTML_TABLE_ROW_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentTableRow);\n                    }\n                case HTML_COLGROUP_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentColGroup);\n                    }\n                default:\n                    {\n                        throw new Error(\"Unknown insertion mode. This is a bug in React.\");\n                    }\n            }\n        } // Instruction Set\n        // The following code is the source scripts that we then minify and inline below,\n        // with renamed function names that we hope don't collide:\n        // const COMMENT_NODE = 8;\n        // const SUSPENSE_START_DATA = '$';\n        // const SUSPENSE_END_DATA = '/$';\n        // const SUSPENSE_PENDING_START_DATA = '$?';\n        // const SUSPENSE_FALLBACK_START_DATA = '$!';\n        //\n        // function clientRenderBoundary(suspenseBoundaryID, errorDigest, errorMsg, errorComponentStack) {\n        //   // Find the fallback's first element.\n        //   const suspenseIdNode = document.getElementById(suspenseBoundaryID);\n        //   if (!suspenseIdNode) {\n        //     // The user must have already navigated away from this tree.\n        //     // E.g. because the parent was hydrated.\n        //     return;\n        //   }\n        //   // Find the boundary around the fallback. This is always the previous node.\n        //   const suspenseNode = suspenseIdNode.previousSibling;\n        //   // Tag it to be client rendered.\n        //   suspenseNode.data = SUSPENSE_FALLBACK_START_DATA;\n        //   // assign error metadata to first sibling\n        //   let dataset = suspenseIdNode.dataset;\n        //   if (errorDigest) dataset.dgst = errorDigest;\n        //   if (errorMsg) dataset.msg = errorMsg;\n        //   if (errorComponentStack) dataset.stck = errorComponentStack;\n        //   // Tell React to retry it if the parent already hydrated.\n        //   if (suspenseNode._reactRetry) {\n        //     suspenseNode._reactRetry();\n        //   }\n        // }\n        //\n        // function completeBoundary(suspenseBoundaryID, contentID) {\n        //   // Find the fallback's first element.\n        //   const suspenseIdNode = document.getElementById(suspenseBoundaryID);\n        //   const contentNode = document.getElementById(contentID);\n        //   // We'll detach the content node so that regardless of what happens next we don't leave in the tree.\n        //   // This might also help by not causing recalcing each time we move a child from here to the target.\n        //   contentNode.parentNode.removeChild(contentNode);\n        //   if (!suspenseIdNode) {\n        //     // The user must have already navigated away from this tree.\n        //     // E.g. because the parent was hydrated. That's fine there's nothing to do\n        //     // but we have to make sure that we already deleted the container node.\n        //     return;\n        //   }\n        //   // Find the boundary around the fallback. This is always the previous node.\n        //   const suspenseNode = suspenseIdNode.previousSibling;\n        //\n        //   // Clear all the existing children. This is complicated because\n        //   // there can be embedded Suspense boundaries in the fallback.\n        //   // This is similar to clearSuspenseBoundary in ReactDOMHostConfig.\n        //   // TODO: We could avoid this if we never emitted suspense boundaries in fallback trees.\n        //   // They never hydrate anyway. However, currently we support incrementally loading the fallback.\n        //   const parentInstance = suspenseNode.parentNode;\n        //   let node = suspenseNode.nextSibling;\n        //   let depth = 0;\n        //   do {\n        //     if (node && node.nodeType === COMMENT_NODE) {\n        //       const data = node.data;\n        //       if (data === SUSPENSE_END_DATA) {\n        //         if (depth === 0) {\n        //           break;\n        //         } else {\n        //           depth--;\n        //         }\n        //       } else if (\n        //         data === SUSPENSE_START_DATA ||\n        //         data === SUSPENSE_PENDING_START_DATA ||\n        //         data === SUSPENSE_FALLBACK_START_DATA\n        //       ) {\n        //         depth++;\n        //       }\n        //     }\n        //\n        //     const nextNode = node.nextSibling;\n        //     parentInstance.removeChild(node);\n        //     node = nextNode;\n        //   } while (node);\n        //\n        //   const endOfBoundary = node;\n        //\n        //   // Insert all the children from the contentNode between the start and end of suspense boundary.\n        //   while (contentNode.firstChild) {\n        //     parentInstance.insertBefore(contentNode.firstChild, endOfBoundary);\n        //   }\n        //   suspenseNode.data = SUSPENSE_START_DATA;\n        //   if (suspenseNode._reactRetry) {\n        //     suspenseNode._reactRetry();\n        //   }\n        // }\n        //\n        // function completeSegment(containerID, placeholderID) {\n        //   const segmentContainer = document.getElementById(containerID);\n        //   const placeholderNode = document.getElementById(placeholderID);\n        //   // We always expect both nodes to exist here because, while we might\n        //   // have navigated away from the main tree, we still expect the detached\n        //   // tree to exist.\n        //   segmentContainer.parentNode.removeChild(segmentContainer);\n        //   while (segmentContainer.firstChild) {\n        //     placeholderNode.parentNode.insertBefore(\n        //       segmentContainer.firstChild,\n        //       placeholderNode,\n        //     );\n        //   }\n        //   placeholderNode.parentNode.removeChild(placeholderNode);\n        // }\n        var completeSegmentFunction = \"function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}\";\n        var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if(\"/$\"===d)if(0===e)break;else e--;else\"$\"!==d&&\"$?\"!==d&&\"$!\"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data=\"$\";a._reactRetry&&a._reactRetry()}}';\n        var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';\n        var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS(\"');\n        var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS(\"');\n        var completeSegmentScript2 = stringToPrecomputedChunk('\",\"');\n        var completeSegmentScript3 = stringToPrecomputedChunk('\")</script>');\n        function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {\n            writeChunk(destination, responseState.startInlineScript);\n            if (!responseState.sentCompleteSegmentFunction) {\n                // The first time we write this, we'll need to include the full implementation.\n                responseState.sentCompleteSegmentFunction = true;\n                writeChunk(destination, completeSegmentScript1Full);\n            } else {\n                // Future calls can just reuse the same function.\n                writeChunk(destination, completeSegmentScript1Partial);\n            }\n            writeChunk(destination, responseState.segmentPrefix);\n            var formattedID = stringToChunk(contentSegmentID.toString(16));\n            writeChunk(destination, formattedID);\n            writeChunk(destination, completeSegmentScript2);\n            writeChunk(destination, responseState.placeholderPrefix);\n            writeChunk(destination, formattedID);\n            return writeChunkAndReturn(destination, completeSegmentScript3);\n        }\n        var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC(\"');\n        var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC(\"');\n        var completeBoundaryScript2 = stringToPrecomputedChunk('\",\"');\n        var completeBoundaryScript3 = stringToPrecomputedChunk('\")</script>');\n        function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {\n            writeChunk(destination, responseState.startInlineScript);\n            if (!responseState.sentCompleteBoundaryFunction) {\n                // The first time we write this, we'll need to include the full implementation.\n                responseState.sentCompleteBoundaryFunction = true;\n                writeChunk(destination, completeBoundaryScript1Full);\n            } else {\n                // Future calls can just reuse the same function.\n                writeChunk(destination, completeBoundaryScript1Partial);\n            }\n            if (boundaryID === null) {\n                throw new Error(\"An ID must have been assigned before we can complete the boundary.\");\n            }\n            var formattedContentID = stringToChunk(contentSegmentID.toString(16));\n            writeChunk(destination, boundaryID);\n            writeChunk(destination, completeBoundaryScript2);\n            writeChunk(destination, responseState.segmentPrefix);\n            writeChunk(destination, formattedContentID);\n            return writeChunkAndReturn(destination, completeBoundaryScript3);\n        }\n        var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX(\"');\n        var clientRenderScript1Partial = stringToPrecomputedChunk('$RX(\"');\n        var clientRenderScript1A = stringToPrecomputedChunk('\"');\n        var clientRenderScript2 = stringToPrecomputedChunk(\")</script>\");\n        var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(\",\");\n        function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {\n            writeChunk(destination, responseState.startInlineScript);\n            if (!responseState.sentClientRenderFunction) {\n                // The first time we write this, we'll need to include the full implementation.\n                responseState.sentClientRenderFunction = true;\n                writeChunk(destination, clientRenderScript1Full);\n            } else {\n                // Future calls can just reuse the same function.\n                writeChunk(destination, clientRenderScript1Partial);\n            }\n            if (boundaryID === null) {\n                throw new Error(\"An ID must have been assigned before we can complete the boundary.\");\n            }\n            writeChunk(destination, boundaryID);\n            writeChunk(destination, clientRenderScript1A);\n            if (errorDigest || errorMessage || errorComponentStack) {\n                writeChunk(destination, clientRenderErrorScriptArgInterstitial);\n                writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || \"\")));\n            }\n            if (errorMessage || errorComponentStack) {\n                writeChunk(destination, clientRenderErrorScriptArgInterstitial);\n                writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || \"\")));\n            }\n            if (errorComponentStack) {\n                writeChunk(destination, clientRenderErrorScriptArgInterstitial);\n                writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));\n            }\n            return writeChunkAndReturn(destination, clientRenderScript2);\n        }\n        var regexForJSStringsInScripts = /[<\\u2028\\u2029]/g;\n        function escapeJSStringsForInstructionScripts(input) {\n            var escaped = JSON.stringify(input);\n            return escaped.replace(regexForJSStringsInScripts, function(match) {\n                switch(match){\n                    // santizing breaking out of strings and script tags\n                    case \"<\":\n                        return \"\\\\u003c\";\n                    case \"\\u2028\":\n                        return \"\\\\u2028\";\n                    case \"\\u2029\":\n                        return \"\\\\u2029\";\n                    default:\n                        {\n                            // eslint-disable-next-line react-internal/prod-error-codes\n                            throw new Error(\"escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\");\n                        }\n                }\n            });\n        }\n        function createResponseState$1(generateStaticMarkup, identifierPrefix) {\n            var responseState = createResponseState(identifierPrefix, undefined);\n            return {\n                // Keep this in sync with ReactDOMServerFormatConfig\n                bootstrapChunks: responseState.bootstrapChunks,\n                startInlineScript: responseState.startInlineScript,\n                placeholderPrefix: responseState.placeholderPrefix,\n                segmentPrefix: responseState.segmentPrefix,\n                boundaryPrefix: responseState.boundaryPrefix,\n                idPrefix: responseState.idPrefix,\n                nextSuspenseID: responseState.nextSuspenseID,\n                sentCompleteSegmentFunction: responseState.sentCompleteSegmentFunction,\n                sentCompleteBoundaryFunction: responseState.sentCompleteBoundaryFunction,\n                sentClientRenderFunction: responseState.sentClientRenderFunction,\n                // This is an extra field for the legacy renderer\n                generateStaticMarkup: generateStaticMarkup\n            };\n        }\n        function createRootFormatContext() {\n            return {\n                insertionMode: HTML_MODE,\n                // We skip the root mode because we don't want to emit the DOCTYPE in legacy mode.\n                selectedValue: null\n            };\n        }\n        function pushTextInstance$1(target, text, responseState, textEmbedded) {\n            if (responseState.generateStaticMarkup) {\n                target.push(stringToChunk(escapeTextForBrowser(text)));\n                return false;\n            } else {\n                return pushTextInstance(target, text, responseState, textEmbedded);\n            }\n        }\n        function pushSegmentFinale$1(target, responseState, lastPushedText, textEmbedded) {\n            if (responseState.generateStaticMarkup) {\n                return;\n            } else {\n                return pushSegmentFinale(target, responseState, lastPushedText, textEmbedded);\n            }\n        }\n        function writeStartCompletedSuspenseBoundary$1(destination, responseState) {\n            if (responseState.generateStaticMarkup) {\n                // A completed boundary is done and doesn't need a representation in the HTML\n                // if we're not going to be hydrating it.\n                return true;\n            }\n            return writeStartCompletedSuspenseBoundary(destination);\n        }\n        function writeStartClientRenderedSuspenseBoundary$1(destination, responseState, errorDigest, errorMessage, errorComponentStack) {\n            if (responseState.generateStaticMarkup) {\n                // A client rendered boundary is done and doesn't need a representation in the HTML\n                // since we'll never hydrate it. This is arguably an error in static generation.\n                return true;\n            }\n            return writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMessage, errorComponentStack);\n        }\n        function writeEndCompletedSuspenseBoundary$1(destination, responseState) {\n            if (responseState.generateStaticMarkup) {\n                return true;\n            }\n            return writeEndCompletedSuspenseBoundary(destination);\n        }\n        function writeEndClientRenderedSuspenseBoundary$1(destination, responseState) {\n            if (responseState.generateStaticMarkup) {\n                return true;\n            }\n            return writeEndClientRenderedSuspenseBoundary(destination);\n        }\n        var assign = Object.assign;\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_SCOPE_TYPE = Symbol.for(\"react.scope\");\n        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for(\"react.debug_trace_mode\");\n        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for(\"react.legacy_hidden\");\n        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for(\"react.default_value\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            {\n                if (typeof type.tag === \"number\") {\n                    error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                }\n            }\n            if (typeof type === \"function\") {\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            var control;\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            try {\n                // This should throw.\n                if (construct) {\n                    // Something should be setting the props in the constructor.\n                    var Fake = function() {\n                        throw Error();\n                    }; // $FlowFixMe\n                    Object.defineProperty(Fake.prototype, \"props\", {\n                        set: function() {\n                            // We use a throwing setter instead of frozen or non-writable props\n                            // because that won't throw in a non-strict mode function.\n                            throw Error();\n                        }\n                    });\n                    if (typeof Reflect === \"object\" && Reflect.construct) {\n                        // We construct a different control for this case to include any extra\n                        // frames added by the construct call.\n                        try {\n                            Reflect.construct(Fake, []);\n                        } catch (x) {\n                            control = x;\n                        }\n                        Reflect.construct(fn, [], Fake);\n                    } else {\n                        try {\n                            Fake.call();\n                        } catch (x) {\n                            control = x;\n                        }\n                        fn.call(Fake.prototype);\n                    }\n                } else {\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        control = x;\n                    }\n                    fn();\n                }\n            } catch (sample) {\n                // This is inlined manually because closure doesn't do it for us.\n                if (sample && control && typeof sample.stack === \"string\") {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sample.stack.split(\"\\n\");\n                    var controlLines = control.stack.split(\"\\n\");\n                    var s = sampleLines.length - 1;\n                    var c = controlLines.length - 1;\n                    while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                        // We expect at least one stack frame to be shared.\n                        // Typically this will be the root most one. However, stack frames may be\n                        // cut off due to maximum stack limits. In this case, one maybe cut off\n                        // earlier than the other. We assume that the sample is longer or the same\n                        // and there for cut off earlier. So we should find the root most frame in\n                        // the sample somewhere in the control.\n                        c--;\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        }\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeClassComponentFrame(ctor, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(ctor, true);\n            }\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement(null);\n                        }\n                    }\n                }\n            }\n        }\n        var warnedAboutMissingGetChildContext;\n        {\n            warnedAboutMissingGetChildContext = {};\n        }\n        var emptyContextObject = {};\n        {\n            Object.freeze(emptyContextObject);\n        }\n        function getMaskedContext(type, unmaskedContext) {\n            {\n                var contextTypes = type.contextTypes;\n                if (!contextTypes) {\n                    return emptyContextObject;\n                }\n                var context = {};\n                for(var key in contextTypes){\n                    context[key] = unmaskedContext[key];\n                }\n                {\n                    var name = getComponentNameFromType(type) || \"Unknown\";\n                    checkPropTypes(contextTypes, context, \"context\", name);\n                }\n                return context;\n            }\n        }\n        function processChildContext(instance, type, parentContext, childContextTypes) {\n            {\n                // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n                // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n                if (typeof instance.getChildContext !== \"function\") {\n                    {\n                        var componentName = getComponentNameFromType(type) || \"Unknown\";\n                        if (!warnedAboutMissingGetChildContext[componentName]) {\n                            warnedAboutMissingGetChildContext[componentName] = true;\n                            error(\"%s.childContextTypes is specified but there is no getChildContext() method \" + \"on the instance. You can either define getChildContext() on %s or remove \" + \"childContextTypes from it.\", componentName, componentName);\n                        }\n                    }\n                    return parentContext;\n                }\n                var childContext = instance.getChildContext();\n                for(var contextKey in childContext){\n                    if (!(contextKey in childContextTypes)) {\n                        throw new Error((getComponentNameFromType(type) || \"Unknown\") + '.getChildContext(): key \"' + contextKey + '\" is not defined in childContextTypes.');\n                    }\n                }\n                {\n                    var name = getComponentNameFromType(type) || \"Unknown\";\n                    checkPropTypes(childContextTypes, childContext, \"child context\", name);\n                }\n                return assign({}, parentContext, childContext);\n            }\n        }\n        var rendererSigil;\n        {\n            // Use this to detect multiple renderers using the same context\n            rendererSigil = {};\n        }\n        // Forming a reverse tree.\n        var rootContextSnapshot = null; // We assume that this runtime owns the \"current\" field on all ReactContext instances.\n        // This global (actually thread local) state represents what state all those \"current\",\n        // fields are currently in.\n        var currentActiveSnapshot = null;\n        function popNode(prev) {\n            {\n                prev.context._currentValue2 = prev.parentValue;\n            }\n        }\n        function pushNode(next) {\n            {\n                next.context._currentValue2 = next.value;\n            }\n        }\n        function popToNearestCommonAncestor(prev, next) {\n            if (prev === next) ;\n            else {\n                popNode(prev);\n                var parentPrev = prev.parent;\n                var parentNext = next.parent;\n                if (parentPrev === null) {\n                    if (parentNext !== null) {\n                        throw new Error(\"The stacks must reach the root at the same time. This is a bug in React.\");\n                    }\n                } else {\n                    if (parentNext === null) {\n                        throw new Error(\"The stacks must reach the root at the same time. This is a bug in React.\");\n                    }\n                    popToNearestCommonAncestor(parentPrev, parentNext);\n                } // On the way back, we push the new ones that weren't common.\n                pushNode(next);\n            }\n        }\n        function popAllPrevious(prev) {\n            popNode(prev);\n            var parentPrev = prev.parent;\n            if (parentPrev !== null) {\n                popAllPrevious(parentPrev);\n            }\n        }\n        function pushAllNext(next) {\n            var parentNext = next.parent;\n            if (parentNext !== null) {\n                pushAllNext(parentNext);\n            }\n            pushNode(next);\n        }\n        function popPreviousToCommonLevel(prev, next) {\n            popNode(prev);\n            var parentPrev = prev.parent;\n            if (parentPrev === null) {\n                throw new Error(\"The depth must equal at least at zero before reaching the root. This is a bug in React.\");\n            }\n            if (parentPrev.depth === next.depth) {\n                // We found the same level. Now we just need to find a shared ancestor.\n                popToNearestCommonAncestor(parentPrev, next);\n            } else {\n                // We must still be deeper.\n                popPreviousToCommonLevel(parentPrev, next);\n            }\n        }\n        function popNextToCommonLevel(prev, next) {\n            var parentNext = next.parent;\n            if (parentNext === null) {\n                throw new Error(\"The depth must equal at least at zero before reaching the root. This is a bug in React.\");\n            }\n            if (prev.depth === parentNext.depth) {\n                // We found the same level. Now we just need to find a shared ancestor.\n                popToNearestCommonAncestor(prev, parentNext);\n            } else {\n                // We must still be deeper.\n                popNextToCommonLevel(prev, parentNext);\n            }\n            pushNode(next);\n        } // Perform context switching to the new snapshot.\n        // To make it cheap to read many contexts, while not suspending, we make the switch eagerly by\n        // updating all the context's current values. That way reads, always just read the current value.\n        // At the cost of updating contexts even if they're never read by this subtree.\n        function switchContext(newSnapshot) {\n            // The basic algorithm we need to do is to pop back any contexts that are no longer on the stack.\n            // We also need to update any new contexts that are now on the stack with the deepest value.\n            // The easiest way to update new contexts is to just reapply them in reverse order from the\n            // perspective of the backpointers. To avoid allocating a lot when switching, we use the stack\n            // for that. Therefore this algorithm is recursive.\n            // 1) First we pop which ever snapshot tree was deepest. Popping old contexts as we go.\n            // 2) Then we find the nearest common ancestor from there. Popping old contexts as we go.\n            // 3) Then we reapply new contexts on the way back up the stack.\n            var prev = currentActiveSnapshot;\n            var next = newSnapshot;\n            if (prev !== next) {\n                if (prev === null) {\n                    // $FlowFixMe: This has to be non-null since it's not equal to prev.\n                    pushAllNext(next);\n                } else if (next === null) {\n                    popAllPrevious(prev);\n                } else if (prev.depth === next.depth) {\n                    popToNearestCommonAncestor(prev, next);\n                } else if (prev.depth > next.depth) {\n                    popPreviousToCommonLevel(prev, next);\n                } else {\n                    popNextToCommonLevel(prev, next);\n                }\n                currentActiveSnapshot = next;\n            }\n        }\n        function pushProvider(context, nextValue) {\n            var prevValue;\n            {\n                prevValue = context._currentValue2;\n                context._currentValue2 = nextValue;\n                {\n                    if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {\n                        error(\"Detected multiple renderers concurrently rendering the \" + \"same context provider. This is currently unsupported.\");\n                    }\n                    context._currentRenderer2 = rendererSigil;\n                }\n            }\n            var prevNode = currentActiveSnapshot;\n            var newNode = {\n                parent: prevNode,\n                depth: prevNode === null ? 0 : prevNode.depth + 1,\n                context: context,\n                parentValue: prevValue,\n                value: nextValue\n            };\n            currentActiveSnapshot = newNode;\n            return newNode;\n        }\n        function popProvider(context) {\n            var prevSnapshot = currentActiveSnapshot;\n            if (prevSnapshot === null) {\n                throw new Error(\"Tried to pop a Context at the root of the app. This is a bug in React.\");\n            }\n            {\n                if (prevSnapshot.context !== context) {\n                    error(\"The parent context is not the expected context. This is probably a bug in React.\");\n                }\n            }\n            {\n                var _value = prevSnapshot.parentValue;\n                if (_value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {\n                    prevSnapshot.context._currentValue2 = prevSnapshot.context._defaultValue;\n                } else {\n                    prevSnapshot.context._currentValue2 = _value;\n                }\n                {\n                    if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {\n                        error(\"Detected multiple renderers concurrently rendering the \" + \"same context provider. This is currently unsupported.\");\n                    }\n                    context._currentRenderer2 = rendererSigil;\n                }\n            }\n            return currentActiveSnapshot = prevSnapshot.parent;\n        }\n        function getActiveContext() {\n            return currentActiveSnapshot;\n        }\n        function readContext(context) {\n            var value = context._currentValue2;\n            return value;\n        }\n        /**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */ function get(key) {\n            return key._reactInternals;\n        }\n        function set(key, value) {\n            key._reactInternals = value;\n        }\n        var didWarnAboutNoopUpdateForComponent = {};\n        var didWarnAboutDeprecatedWillMount = {};\n        var didWarnAboutUninitializedState;\n        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\n        var didWarnAboutLegacyLifecyclesAndDerivedState;\n        var didWarnAboutUndefinedDerivedState;\n        var warnOnUndefinedDerivedState;\n        var warnOnInvalidCallback;\n        var didWarnAboutDirectlyAssigningPropsToState;\n        var didWarnAboutContextTypeAndContextTypes;\n        var didWarnAboutInvalidateContextType;\n        {\n            didWarnAboutUninitializedState = new Set();\n            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n            didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n            didWarnAboutDirectlyAssigningPropsToState = new Set();\n            didWarnAboutUndefinedDerivedState = new Set();\n            didWarnAboutContextTypeAndContextTypes = new Set();\n            didWarnAboutInvalidateContextType = new Set();\n            var didWarnOnInvalidCallback = new Set();\n            warnOnInvalidCallback = function(callback, callerName) {\n                if (callback === null || typeof callback === \"function\") {\n                    return;\n                }\n                var key = callerName + \"_\" + callback;\n                if (!didWarnOnInvalidCallback.has(key)) {\n                    didWarnOnInvalidCallback.add(key);\n                    error(\"%s(...): Expected the last optional `callback` argument to be a \" + \"function. Instead received: %s.\", callerName, callback);\n                }\n            };\n            warnOnUndefinedDerivedState = function(type, partialState) {\n                if (partialState === undefined) {\n                    var componentName = getComponentNameFromType(type) || \"Component\";\n                    if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n                        didWarnAboutUndefinedDerivedState.add(componentName);\n                        error(\"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. \" + \"You have returned undefined.\", componentName);\n                    }\n                }\n            };\n        }\n        function warnNoop(publicInstance, callerName) {\n            {\n                var _constructor = publicInstance.constructor;\n                var componentName = _constructor && getComponentNameFromType(_constructor) || \"ReactClass\";\n                var warningKey = componentName + \".\" + callerName;\n                if (didWarnAboutNoopUpdateForComponent[warningKey]) {\n                    return;\n                }\n                error(\"%s(...): Can only update a mounting component. \" + \"This usually means you called %s() outside componentWillMount() on the server. \" + \"This is a no-op.\\n\\nPlease check the code for the %s component.\", callerName, callerName, componentName);\n                didWarnAboutNoopUpdateForComponent[warningKey] = true;\n            }\n        }\n        var classComponentUpdater = {\n            isMounted: function(inst) {\n                return false;\n            },\n            enqueueSetState: function(inst, payload, callback) {\n                var internals = get(inst);\n                if (internals.queue === null) {\n                    warnNoop(inst, \"setState\");\n                } else {\n                    internals.queue.push(payload);\n                    {\n                        if (callback !== undefined && callback !== null) {\n                            warnOnInvalidCallback(callback, \"setState\");\n                        }\n                    }\n                }\n            },\n            enqueueReplaceState: function(inst, payload, callback) {\n                var internals = get(inst);\n                internals.replace = true;\n                internals.queue = [\n                    payload\n                ];\n                {\n                    if (callback !== undefined && callback !== null) {\n                        warnOnInvalidCallback(callback, \"setState\");\n                    }\n                }\n            },\n            enqueueForceUpdate: function(inst, callback) {\n                var internals = get(inst);\n                if (internals.queue === null) {\n                    warnNoop(inst, \"forceUpdate\");\n                } else {\n                    {\n                        if (callback !== undefined && callback !== null) {\n                            warnOnInvalidCallback(callback, \"setState\");\n                        }\n                    }\n                }\n            }\n        };\n        function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {\n            var partialState = getDerivedStateFromProps(nextProps, prevState);\n            {\n                warnOnUndefinedDerivedState(ctor, partialState);\n            }\n            var newState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);\n            return newState;\n        }\n        function constructClassInstance(ctor, props, maskedLegacyContext) {\n            var context = emptyContextObject;\n            var contextType = ctor.contextType;\n            {\n                if (\"contextType\" in ctor) {\n                    var isValid = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>\n                    if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n                        didWarnAboutInvalidateContextType.add(ctor);\n                        var addendum = \"\";\n                        if (contextType === undefined) {\n                            addendum = \" However, it is set to undefined. \" + \"This can be caused by a typo or by mixing up named and default imports. \" + \"This can also happen due to a circular dependency, so \" + \"try moving the createContext() call to a separate file.\";\n                        } else if (typeof contextType !== \"object\") {\n                            addendum = \" However, it is set to a \" + typeof contextType + \".\";\n                        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n                            addendum = \" Did you accidentally pass the Context.Provider instead?\";\n                        } else if (contextType._context !== undefined) {\n                            // <Context.Consumer>\n                            addendum = \" Did you accidentally pass the Context.Consumer instead?\";\n                        } else {\n                            addendum = \" However, it is set to an object with keys {\" + Object.keys(contextType).join(\", \") + \"}.\";\n                        }\n                        error(\"%s defines an invalid contextType. \" + \"contextType should point to the Context object returned by React.createContext().%s\", getComponentNameFromType(ctor) || \"Component\", addendum);\n                    }\n                }\n            }\n            if (typeof contextType === \"object\" && contextType !== null) {\n                context = readContext(contextType);\n            } else {\n                context = maskedLegacyContext;\n            }\n            var instance = new ctor(props, context);\n            {\n                if (typeof ctor.getDerivedStateFromProps === \"function\" && (instance.state === null || instance.state === undefined)) {\n                    var componentName = getComponentNameFromType(ctor) || \"Component\";\n                    if (!didWarnAboutUninitializedState.has(componentName)) {\n                        didWarnAboutUninitializedState.add(componentName);\n                        error(\"`%s` uses `getDerivedStateFromProps` but its initial state is \" + \"%s. This is not recommended. Instead, define the initial state by \" + \"assigning an object to `this.state` in the constructor of `%s`. \" + \"This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\", componentName, instance.state === null ? \"null\" : \"undefined\", componentName);\n                    }\n                } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n                // Warn about these lifecycles if they are present.\n                // Don't warn about react-lifecycles-compat polyfilled methods though.\n                if (typeof ctor.getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\") {\n                    var foundWillMountName = null;\n                    var foundWillReceivePropsName = null;\n                    var foundWillUpdateName = null;\n                    if (typeof instance.componentWillMount === \"function\" && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                        foundWillMountName = \"componentWillMount\";\n                    } else if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                        foundWillMountName = \"UNSAFE_componentWillMount\";\n                    }\n                    if (typeof instance.componentWillReceiveProps === \"function\" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n                        foundWillReceivePropsName = \"componentWillReceiveProps\";\n                    } else if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n                        foundWillReceivePropsName = \"UNSAFE_componentWillReceiveProps\";\n                    }\n                    if (typeof instance.componentWillUpdate === \"function\" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n                        foundWillUpdateName = \"componentWillUpdate\";\n                    } else if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n                        foundWillUpdateName = \"UNSAFE_componentWillUpdate\";\n                    }\n                    if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n                        var _componentName = getComponentNameFromType(ctor) || \"Component\";\n                        var newApiName = typeof ctor.getDerivedStateFromProps === \"function\" ? \"getDerivedStateFromProps()\" : \"getSnapshotBeforeUpdate()\";\n                        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n                            didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n                            error(\"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n\" + \"%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n\" + \"The above lifecycles should be removed. Learn more about this warning here:\\n\" + \"https://reactjs.org/link/unsafe-component-lifecycles\", _componentName, newApiName, foundWillMountName !== null ? \"\\n  \" + foundWillMountName : \"\", foundWillReceivePropsName !== null ? \"\\n  \" + foundWillReceivePropsName : \"\", foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : \"\");\n                        }\n                    }\n                }\n            }\n            return instance;\n        }\n        function checkClassInstance(instance, ctor, newProps) {\n            {\n                var name = getComponentNameFromType(ctor) || \"Component\";\n                var renderPresent = instance.render;\n                if (!renderPresent) {\n                    if (ctor.prototype && typeof ctor.prototype.render === \"function\") {\n                        error(\"%s(...): No `render` method found on the returned component \" + \"instance: did you accidentally return an object from the constructor?\", name);\n                    } else {\n                        error(\"%s(...): No `render` method found on the returned component \" + \"instance: you may have forgotten to define `render`.\", name);\n                    }\n                }\n                if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {\n                    error(\"getInitialState was defined on %s, a plain JavaScript class. \" + \"This is only supported for classes created using React.createClass. \" + \"Did you mean to define a state property instead?\", name);\n                }\n                if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps was defined on %s, a plain JavaScript class. \" + \"This is only supported for classes created using React.createClass. \" + \"Use a static property to define defaultProps instead.\", name);\n                }\n                if (instance.propTypes) {\n                    error(\"propTypes was defined as an instance property on %s. Use a static \" + \"property to define propTypes instead.\", name);\n                }\n                if (instance.contextType) {\n                    error(\"contextType was defined as an instance property on %s. Use a static \" + \"property to define contextType instead.\", name);\n                }\n                {\n                    if (instance.contextTypes) {\n                        error(\"contextTypes was defined as an instance property on %s. Use a static \" + \"property to define contextTypes instead.\", name);\n                    }\n                    if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {\n                        didWarnAboutContextTypeAndContextTypes.add(ctor);\n                        error(\"%s declares both contextTypes and contextType static properties. \" + \"The legacy contextTypes property will be ignored.\", name);\n                    }\n                }\n                if (typeof instance.componentShouldUpdate === \"function\") {\n                    error(\"%s has a method called \" + \"componentShouldUpdate(). Did you mean shouldComponentUpdate()? \" + \"The name is phrased as a question because the function is \" + \"expected to return a value.\", name);\n                }\n                if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== \"undefined\") {\n                    error(\"%s has a method called shouldComponentUpdate(). \" + \"shouldComponentUpdate should not be used when extending React.PureComponent. \" + \"Please extend React.Component if shouldComponentUpdate is used.\", getComponentNameFromType(ctor) || \"A pure component\");\n                }\n                if (typeof instance.componentDidUnmount === \"function\") {\n                    error(\"%s has a method called \" + \"componentDidUnmount(). But there is no such lifecycle method. \" + \"Did you mean componentWillUnmount()?\", name);\n                }\n                if (typeof instance.componentDidReceiveProps === \"function\") {\n                    error(\"%s has a method called \" + \"componentDidReceiveProps(). But there is no such lifecycle method. \" + \"If you meant to update the state in response to changing props, \" + \"use componentWillReceiveProps(). If you meant to fetch data or \" + \"run side-effects or mutations after React has updated the UI, use componentDidUpdate().\", name);\n                }\n                if (typeof instance.componentWillRecieveProps === \"function\") {\n                    error(\"%s has a method called \" + \"componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\", name);\n                }\n                if (typeof instance.UNSAFE_componentWillRecieveProps === \"function\") {\n                    error(\"%s has a method called \" + \"UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\", name);\n                }\n                var hasMutatedProps = instance.props !== newProps;\n                if (instance.props !== undefined && hasMutatedProps) {\n                    error(\"%s(...): When calling super() in `%s`, make sure to pass \" + \"up the same props that your component's constructor was passed.\", name, name);\n                }\n                if (instance.defaultProps) {\n                    error(\"Setting defaultProps as an instance property on %s is not supported and will be ignored.\" + \" Instead, define defaultProps as a static property on %s.\", name, name);\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === \"function\" && typeof instance.componentDidUpdate !== \"function\" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n                    didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n                    error(\"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). \" + \"This component defines getSnapshotBeforeUpdate() only.\", getComponentNameFromType(ctor));\n                }\n                if (typeof instance.getDerivedStateFromProps === \"function\") {\n                    error(\"%s: getDerivedStateFromProps() is defined as an instance method \" + \"and will be ignored. Instead, declare it as a static method.\", name);\n                }\n                if (typeof instance.getDerivedStateFromError === \"function\") {\n                    error(\"%s: getDerivedStateFromError() is defined as an instance method \" + \"and will be ignored. Instead, declare it as a static method.\", name);\n                }\n                if (typeof ctor.getSnapshotBeforeUpdate === \"function\") {\n                    error(\"%s: getSnapshotBeforeUpdate() is defined as a static method \" + \"and will be ignored. Instead, declare it as an instance method.\", name);\n                }\n                var _state = instance.state;\n                if (_state && (typeof _state !== \"object\" || isArray(_state))) {\n                    error(\"%s.state: must be set to an object or null\", name);\n                }\n                if (typeof instance.getChildContext === \"function\" && typeof ctor.childContextTypes !== \"object\") {\n                    error(\"%s.getChildContext(): childContextTypes must be defined in order to \" + \"use getChildContext().\", name);\n                }\n            }\n        }\n        function callComponentWillMount(type, instance) {\n            var oldState = instance.state;\n            if (typeof instance.componentWillMount === \"function\") {\n                {\n                    if (instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                        var componentName = getComponentNameFromType(type) || \"Unknown\";\n                        if (!didWarnAboutDeprecatedWillMount[componentName]) {\n                            warn(\"componentWillMount has been renamed, and is not recommended for use. \" + \"See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n\" + \"* Move code from componentWillMount to componentDidMount (preferred in most cases) \" + \"or the constructor.\\n\" + \"\\nPlease update the following components: %s\", componentName);\n                            didWarnAboutDeprecatedWillMount[componentName] = true;\n                        }\n                    }\n                }\n                instance.componentWillMount();\n            }\n            if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                instance.UNSAFE_componentWillMount();\n            }\n            if (oldState !== instance.state) {\n                {\n                    error(\"%s.componentWillMount(): Assigning directly to this.state is \" + \"deprecated (except inside a component's \" + \"constructor). Use setState instead.\", getComponentNameFromType(type) || \"Component\");\n                }\n                classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n            }\n        }\n        function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {\n            if (internalInstance.queue !== null && internalInstance.queue.length > 0) {\n                var oldQueue = internalInstance.queue;\n                var oldReplace = internalInstance.replace;\n                internalInstance.queue = null;\n                internalInstance.replace = false;\n                if (oldReplace && oldQueue.length === 1) {\n                    inst.state = oldQueue[0];\n                } else {\n                    var nextState = oldReplace ? oldQueue[0] : inst.state;\n                    var dontMutate = true;\n                    for(var i = oldReplace ? 1 : 0; i < oldQueue.length; i++){\n                        var partial = oldQueue[i];\n                        var partialState = typeof partial === \"function\" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;\n                        if (partialState != null) {\n                            if (dontMutate) {\n                                dontMutate = false;\n                                nextState = assign({}, nextState, partialState);\n                            } else {\n                                assign(nextState, partialState);\n                            }\n                        }\n                    }\n                    inst.state = nextState;\n                }\n            } else {\n                internalInstance.queue = null;\n            }\n        } // Invokes the mount life-cycles on a previously never rendered instance.\n        function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {\n            {\n                checkClassInstance(instance, ctor, newProps);\n            }\n            var initialState = instance.state !== undefined ? instance.state : null;\n            instance.updater = classComponentUpdater;\n            instance.props = newProps;\n            instance.state = initialState; // We don't bother initializing the refs object on the server, since we're not going to resolve them anyway.\n            // The internal instance will be used to manage updates that happen during this mount.\n            var internalInstance = {\n                queue: [],\n                replace: false\n            };\n            set(instance, internalInstance);\n            var contextType = ctor.contextType;\n            if (typeof contextType === \"object\" && contextType !== null) {\n                instance.context = readContext(contextType);\n            } else {\n                instance.context = maskedLegacyContext;\n            }\n            {\n                if (instance.state === newProps) {\n                    var componentName = getComponentNameFromType(ctor) || \"Component\";\n                    if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n                        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n                        error(\"%s: It is not recommended to assign props directly to state \" + \"because updates to props won't be reflected in state. \" + \"In most cases, it is better to use props directly.\", componentName);\n                    }\n                }\n            }\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            if (typeof getDerivedStateFromProps === \"function\") {\n                instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);\n            } // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (typeof ctor.getDerivedStateFromProps !== \"function\" && typeof instance.getSnapshotBeforeUpdate !== \"function\" && (typeof instance.UNSAFE_componentWillMount === \"function\" || typeof instance.componentWillMount === \"function\")) {\n                callComponentWillMount(ctor, instance); // If we had additional state updates during this life-cycle, let's\n                // process them now.\n                processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);\n            }\n        }\n        // Ids are base 32 strings whose binary representation corresponds to the\n        // position of a node in a tree.\n        // Every time the tree forks into multiple children, we add additional bits to\n        // the left of the sequence that represent the position of the child within the\n        // current level of children.\n        //\n        //      00101       00010001011010101\n        //             \n        //   Fork 5 of 20       Parent id\n        //\n        // The leading 0s are important. In the above example, you only need 3 bits to\n        // represent slot 5. However, you need 5 bits to represent all the forks at\n        // the current level, so we must account for the empty bits at the end.\n        //\n        // For this same reason, slots are 1-indexed instead of 0-indexed. Otherwise,\n        // the zeroth id at a level would be indistinguishable from its parent.\n        //\n        // If a node has only one child, and does not materialize an id (i.e. does not\n        // contain a useId hook), then we don't need to allocate any space in the\n        // sequence. It's treated as a transparent indirection. For example, these two\n        // trees produce the same ids:\n        //\n        // <>                          <>\n        //   <Indirection>               <A />\n        //     <A />                     <B />\n        //   </Indirection>            </>\n        //   <B />\n        // </>\n        //\n        // However, we cannot skip any node that materializes an id. Otherwise, a parent\n        // id that does not fork would be indistinguishable from its child id. For\n        // example, this tree does not fork, but the parent and child must have\n        // different ids.\n        //\n        // <Parent>\n        //   <Child />\n        // </Parent>\n        //\n        // To handle this scenario, every time we materialize an id, we allocate a\n        // new level with a single slot. You can think of this as a fork with only one\n        // prong, or an array of children with length 1.\n        //\n        // It's possible for the size of the sequence to exceed 32 bits, the max\n        // size for bitwise operations. When this happens, we make more room by\n        // converting the right part of the id to a string and storing it in an overflow\n        // variable. We use a base 32 string representation, because 32 is the largest\n        // power of 2 that is supported by toString(). We want the base to be large so\n        // that the resulting ids are compact, and we want the base to be a power of 2\n        // because every log2(base) bits corresponds to a single character, i.e. every\n        // log2(32) = 5 bits. That means we can lop bits off the end 5 at a time without\n        // affecting the final result.\n        var emptyTreeContext = {\n            id: 1,\n            overflow: \"\"\n        };\n        function getTreeId(context) {\n            var overflow = context.overflow;\n            var idWithLeadingBit = context.id;\n            var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\n            return id.toString(32) + overflow;\n        }\n        function pushTreeContext(baseContext, totalChildren, index) {\n            var baseIdWithLeadingBit = baseContext.id;\n            var baseOverflow = baseContext.overflow; // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n            // of the id; we use it to account for leading 0s.\n            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;\n            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);\n            var slot = index + 1;\n            var length = getBitLength(totalChildren) + baseLength; // 30 is the max length we can store without overflowing, taking into\n            // consideration the leading 1 we use to mark the end of the sequence.\n            if (length > 30) {\n                // We overflowed the bitwise-safe range. Fall back to slower algorithm.\n                // This branch assumes the length of the base id is greater than 5; it won't\n                // work for smaller ids, because you need 5 bits per character.\n                //\n                // We encode the id in multiple steps: first the base id, then the\n                // remaining digits.\n                //\n                // Each 5 bit sequence corresponds to a single base 32 character. So for\n                // example, if the current id is 23 bits long, we can convert 20 of those\n                // bits into a string of 4 characters, with 3 bits left over.\n                //\n                // First calculate how many bits in the base id represent a complete\n                // sequence of characters.\n                var numberOfOverflowBits = baseLength - baseLength % 5; // Then create a bitmask that selects only those bits.\n                var newOverflowBits = (1 << numberOfOverflowBits) - 1; // Select the bits, and convert them to a base 32 string.\n                var newOverflow = (baseId & newOverflowBits).toString(32); // Now we can remove those bits from the base id.\n                var restOfBaseId = baseId >> numberOfOverflowBits;\n                var restOfBaseLength = baseLength - numberOfOverflowBits; // Finally, encode the rest of the bits using the normal algorithm. Because\n                // we made more room, this time it won't overflow.\n                var restOfLength = getBitLength(totalChildren) + restOfBaseLength;\n                var restOfNewBits = slot << restOfBaseLength;\n                var id = restOfNewBits | restOfBaseId;\n                var overflow = newOverflow + baseOverflow;\n                return {\n                    id: 1 << restOfLength | id,\n                    overflow: overflow\n                };\n            } else {\n                // Normal path\n                var newBits = slot << baseLength;\n                var _id = newBits | baseId;\n                var _overflow = baseOverflow;\n                return {\n                    id: 1 << length | _id,\n                    overflow: _overflow\n                };\n            }\n        }\n        function getBitLength(number) {\n            return 32 - clz32(number);\n        }\n        function getLeadingBit(id) {\n            return 1 << getBitLength(id) - 1;\n        } // TODO: Math.clz32 is supported in Node 12+. Maybe we can drop the fallback.\n        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros.\n        // Based on:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n        var log = Math.log;\n        var LN2 = Math.LN2;\n        function clz32Fallback(x) {\n            var asUint = x >>> 0;\n            if (asUint === 0) {\n                return 32;\n            }\n            return 31 - (log(asUint) / LN2 | 0) | 0;\n        }\n        /**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */ function is(x, y) {\n            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n            ;\n        }\n        var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n        var currentlyRenderingComponent = null;\n        var currentlyRenderingTask = null;\n        var firstWorkInProgressHook = null;\n        var workInProgressHook = null; // Whether the work-in-progress hook is a re-rendered hook\n        var isReRender = false; // Whether an update was scheduled during the currently executing render pass.\n        var didScheduleRenderPhaseUpdate = false; // Counts the number of useId hooks in this component\n        var localIdCounter = 0; // Lazily created map of render-phase updates\n        var renderPhaseUpdates = null; // Counter to prevent infinite loops.\n        var numberOfReRenders = 0;\n        var RE_RENDER_LIMIT = 25;\n        var isInHookUserCodeInDev = false; // In DEV, this is the name of the currently executing primitive hook\n        var currentHookNameInDev;\n        function resolveCurrentlyRenderingComponent() {\n            if (currentlyRenderingComponent === null) {\n                throw new Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for\" + \" one of the following reasons:\\n\" + \"1. You might have mismatching versions of React and the renderer (such as React DOM)\\n\" + \"2. You might be breaking the Rules of Hooks\\n\" + \"3. You might have more than one copy of React in the same app\\n\" + \"See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n            }\n            {\n                if (isInHookUserCodeInDev) {\n                    error(\"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. \" + \"You can only call Hooks at the top level of your React function. \" + \"For more information, see \" + \"https://reactjs.org/link/rules-of-hooks\");\n                }\n            }\n            return currentlyRenderingComponent;\n        }\n        function areHookInputsEqual(nextDeps, prevDeps) {\n            if (prevDeps === null) {\n                {\n                    error(\"%s received a final argument during this render, but not during \" + \"the previous render. Even though the final argument is optional, \" + \"its type cannot change between renders.\", currentHookNameInDev);\n                }\n                return false;\n            }\n            {\n                // Don't bother comparing lengths in prod because these arrays should be\n                // passed inline.\n                if (nextDeps.length !== prevDeps.length) {\n                    error(\"The final argument passed to %s changed size between renders. The \" + \"order and size of this array must remain constant.\\n\\n\" + \"Previous: %s\\n\" + \"Incoming: %s\", currentHookNameInDev, \"[\" + nextDeps.join(\", \") + \"]\", \"[\" + prevDeps.join(\", \") + \"]\");\n                }\n            }\n            for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++){\n                if (objectIs(nextDeps[i], prevDeps[i])) {\n                    continue;\n                }\n                return false;\n            }\n            return true;\n        }\n        function createHook() {\n            if (numberOfReRenders > 0) {\n                throw new Error(\"Rendered more hooks than during the previous render\");\n            }\n            return {\n                memoizedState: null,\n                queue: null,\n                next: null\n            };\n        }\n        function createWorkInProgressHook() {\n            if (workInProgressHook === null) {\n                // This is the first hook in the list\n                if (firstWorkInProgressHook === null) {\n                    isReRender = false;\n                    firstWorkInProgressHook = workInProgressHook = createHook();\n                } else {\n                    // There's already a work-in-progress. Reuse it.\n                    isReRender = true;\n                    workInProgressHook = firstWorkInProgressHook;\n                }\n            } else {\n                if (workInProgressHook.next === null) {\n                    isReRender = false; // Append to the end of the list\n                    workInProgressHook = workInProgressHook.next = createHook();\n                } else {\n                    // There's already a work-in-progress. Reuse it.\n                    isReRender = true;\n                    workInProgressHook = workInProgressHook.next;\n                }\n            }\n            return workInProgressHook;\n        }\n        function prepareToUseHooks(task, componentIdentity) {\n            currentlyRenderingComponent = componentIdentity;\n            currentlyRenderingTask = task;\n            {\n                isInHookUserCodeInDev = false;\n            }\n            // didScheduleRenderPhaseUpdate = false;\n            // localIdCounter = 0;\n            // firstWorkInProgressHook = null;\n            // numberOfReRenders = 0;\n            // renderPhaseUpdates = null;\n            // workInProgressHook = null;\n            localIdCounter = 0;\n        }\n        function finishHooks(Component, props, children, refOrContext) {\n            // This must be called after every function component to prevent hooks from\n            // being used in classes.\n            while(didScheduleRenderPhaseUpdate){\n                // Updates were scheduled during the render phase. They are stored in\n                // the `renderPhaseUpdates` map. Call the component again, reusing the\n                // work-in-progress hooks and applying the additional updates on top. Keep\n                // restarting until no more updates are scheduled.\n                didScheduleRenderPhaseUpdate = false;\n                localIdCounter = 0;\n                numberOfReRenders += 1; // Start over from the beginning of the list\n                workInProgressHook = null;\n                children = Component(props, refOrContext);\n            }\n            resetHooksState();\n            return children;\n        }\n        function checkDidRenderIdHook() {\n            // This should be called immediately after every finishHooks call.\n            // Conceptually, it's part of the return value of finishHooks; it's only a\n            // separate function to avoid using an array tuple.\n            var didRenderIdHook = localIdCounter !== 0;\n            return didRenderIdHook;\n        } // Reset the internal hooks state if an error occurs while rendering a component\n        function resetHooksState() {\n            {\n                isInHookUserCodeInDev = false;\n            }\n            currentlyRenderingComponent = null;\n            currentlyRenderingTask = null;\n            didScheduleRenderPhaseUpdate = false;\n            firstWorkInProgressHook = null;\n            numberOfReRenders = 0;\n            renderPhaseUpdates = null;\n            workInProgressHook = null;\n        }\n        function readContext$1(context) {\n            {\n                if (isInHookUserCodeInDev) {\n                    error(\"Context can only be read while React is rendering. \" + \"In classes, you can read it in the render method or getDerivedStateFromProps. \" + \"In function components, you can read it directly in the function body, but not \" + \"inside Hooks like useReducer() or useMemo().\");\n                }\n            }\n            return readContext(context);\n        }\n        function useContext(context) {\n            {\n                currentHookNameInDev = \"useContext\";\n            }\n            resolveCurrentlyRenderingComponent();\n            return readContext(context);\n        }\n        function basicStateReducer(state, action) {\n            // $FlowFixMe: Flow doesn't like mixed types\n            return typeof action === \"function\" ? action(state) : action;\n        }\n        function useState(initialState) {\n            {\n                currentHookNameInDev = \"useState\";\n            }\n            return useReducer(basicStateReducer, initialState);\n        }\n        function useReducer(reducer, initialArg, init) {\n            {\n                if (reducer !== basicStateReducer) {\n                    currentHookNameInDev = \"useReducer\";\n                }\n            }\n            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n            workInProgressHook = createWorkInProgressHook();\n            if (isReRender) {\n                // This is a re-render. Apply the new render phase updates to the previous\n                // current hook.\n                var queue = workInProgressHook.queue;\n                var dispatch = queue.dispatch;\n                if (renderPhaseUpdates !== null) {\n                    // Render phase updates are stored in a map of queue -> linked list\n                    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n                    if (firstRenderPhaseUpdate !== undefined) {\n                        renderPhaseUpdates.delete(queue);\n                        var newState = workInProgressHook.memoizedState;\n                        var update = firstRenderPhaseUpdate;\n                        do {\n                            // Process this render phase update. We don't have to check the\n                            // priority because it will always be the same as the current\n                            // render's.\n                            var action = update.action;\n                            {\n                                isInHookUserCodeInDev = true;\n                            }\n                            newState = reducer(newState, action);\n                            {\n                                isInHookUserCodeInDev = false;\n                            }\n                            update = update.next;\n                        }while (update !== null);\n                        workInProgressHook.memoizedState = newState;\n                        return [\n                            newState,\n                            dispatch\n                        ];\n                    }\n                }\n                return [\n                    workInProgressHook.memoizedState,\n                    dispatch\n                ];\n            } else {\n                {\n                    isInHookUserCodeInDev = true;\n                }\n                var initialState;\n                if (reducer === basicStateReducer) {\n                    // Special case for `useState`.\n                    initialState = typeof initialArg === \"function\" ? initialArg() : initialArg;\n                } else {\n                    initialState = init !== undefined ? init(initialArg) : initialArg;\n                }\n                {\n                    isInHookUserCodeInDev = false;\n                }\n                workInProgressHook.memoizedState = initialState;\n                var _queue = workInProgressHook.queue = {\n                    last: null,\n                    dispatch: null\n                };\n                var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);\n                return [\n                    workInProgressHook.memoizedState,\n                    _dispatch\n                ];\n            }\n        }\n        function useMemo(nextCreate, deps) {\n            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n            workInProgressHook = createWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            if (workInProgressHook !== null) {\n                var prevState = workInProgressHook.memoizedState;\n                if (prevState !== null) {\n                    if (nextDeps !== null) {\n                        var prevDeps = prevState[1];\n                        if (areHookInputsEqual(nextDeps, prevDeps)) {\n                            return prevState[0];\n                        }\n                    }\n                }\n            }\n            {\n                isInHookUserCodeInDev = true;\n            }\n            var nextValue = nextCreate();\n            {\n                isInHookUserCodeInDev = false;\n            }\n            workInProgressHook.memoizedState = [\n                nextValue,\n                nextDeps\n            ];\n            return nextValue;\n        }\n        function useRef(initialValue) {\n            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n            workInProgressHook = createWorkInProgressHook();\n            var previousRef = workInProgressHook.memoizedState;\n            if (previousRef === null) {\n                var ref = {\n                    current: initialValue\n                };\n                {\n                    Object.seal(ref);\n                }\n                workInProgressHook.memoizedState = ref;\n                return ref;\n            } else {\n                return previousRef;\n            }\n        }\n        function useLayoutEffect(create, inputs) {\n            {\n                currentHookNameInDev = \"useLayoutEffect\";\n                error(\"useLayoutEffect does nothing on the server, because its effect cannot \" + \"be encoded into the server renderer's output format. This will lead \" + \"to a mismatch between the initial, non-hydrated UI and the intended \" + \"UI. To avoid this, useLayoutEffect should only be used in \" + \"components that render exclusively on the client. \" + \"See https://reactjs.org/link/uselayouteffect-ssr for common fixes.\");\n            }\n        }\n        function dispatchAction(componentIdentity, queue, action) {\n            if (numberOfReRenders >= RE_RENDER_LIMIT) {\n                throw new Error(\"Too many re-renders. React limits the number of renders to prevent \" + \"an infinite loop.\");\n            }\n            if (componentIdentity === currentlyRenderingComponent) {\n                // This is a render phase update. Stash it in a lazily-created map of\n                // queue -> linked list of updates. After this render pass, we'll restart\n                // and apply the stashed updates on top of the work-in-progress hook.\n                didScheduleRenderPhaseUpdate = true;\n                var update = {\n                    action: action,\n                    next: null\n                };\n                if (renderPhaseUpdates === null) {\n                    renderPhaseUpdates = new Map();\n                }\n                var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n                if (firstRenderPhaseUpdate === undefined) {\n                    renderPhaseUpdates.set(queue, update);\n                } else {\n                    // Append the update to the end of the list.\n                    var lastRenderPhaseUpdate = firstRenderPhaseUpdate;\n                    while(lastRenderPhaseUpdate.next !== null){\n                        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n                    }\n                    lastRenderPhaseUpdate.next = update;\n                }\n            }\n        }\n        function useCallback(callback, deps) {\n            return useMemo(function() {\n                return callback;\n            }, deps);\n        } // TODO Decide on how to implement this hook for server rendering.\n        // If a mutation occurs during render, consider triggering a Suspense boundary\n        // and falling back to client rendering.\n        function useMutableSource(source, getSnapshot, subscribe) {\n            resolveCurrentlyRenderingComponent();\n            return getSnapshot(source._source);\n        }\n        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n            if (getServerSnapshot === undefined) {\n                throw new Error(\"Missing getServerSnapshot, which is required for \" + \"server-rendered content. Will revert to client rendering.\");\n            }\n            return getServerSnapshot();\n        }\n        function useDeferredValue(value) {\n            resolveCurrentlyRenderingComponent();\n            return value;\n        }\n        function unsupportedStartTransition() {\n            throw new Error(\"startTransition cannot be called during server rendering.\");\n        }\n        function useTransition() {\n            resolveCurrentlyRenderingComponent();\n            return [\n                false,\n                unsupportedStartTransition\n            ];\n        }\n        function useId() {\n            var task = currentlyRenderingTask;\n            var treeId = getTreeId(task.treeContext);\n            var responseState = currentResponseState;\n            if (responseState === null) {\n                throw new Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component.\");\n            }\n            var localId = localIdCounter++;\n            return makeId(responseState, treeId, localId);\n        }\n        function noop() {}\n        var Dispatcher = {\n            readContext: readContext$1,\n            useContext: useContext,\n            useMemo: useMemo,\n            useReducer: useReducer,\n            useRef: useRef,\n            useState: useState,\n            useInsertionEffect: noop,\n            useLayoutEffect: useLayoutEffect,\n            useCallback: useCallback,\n            // useImperativeHandle is not run in the server environment\n            useImperativeHandle: noop,\n            // Effects are not run in the server environment.\n            useEffect: noop,\n            // Debugging effect\n            useDebugValue: noop,\n            useDeferredValue: useDeferredValue,\n            useTransition: useTransition,\n            useId: useId,\n            // Subscriptions are not setup in a server environment.\n            useMutableSource: useMutableSource,\n            useSyncExternalStore: useSyncExternalStore\n        };\n        var currentResponseState = null;\n        function setCurrentResponseState(responseState) {\n            currentResponseState = responseState;\n        }\n        function getStackByComponentStackNode(componentStack) {\n            try {\n                var info = \"\";\n                var node = componentStack;\n                do {\n                    switch(node.tag){\n                        case 0:\n                            info += describeBuiltInComponentFrame(node.type, null, null);\n                            break;\n                        case 1:\n                            info += describeFunctionComponentFrame(node.type, null, null);\n                            break;\n                        case 2:\n                            info += describeClassComponentFrame(node.type, null, null);\n                            break;\n                    }\n                    node = node.parent;\n                }while (node);\n                return info;\n            } catch (x) {\n                return \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n            }\n        }\n        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        var PENDING = 0;\n        var COMPLETED = 1;\n        var FLUSHED = 2;\n        var ABORTED = 3;\n        var ERRORED = 4;\n        var OPEN = 0;\n        var CLOSING = 1;\n        var CLOSED = 2;\n        // This is a default heuristic for how to split up the HTML content into progressive\n        // loading. Our goal is to be able to display additional new content about every 500ms.\n        // Faster than that is unnecessary and should be throttled on the client. It also\n        // adds unnecessary overhead to do more splits. We don't know if it's a higher or lower\n        // end device but higher end suffer less from the overhead than lower end does from\n        // not getting small enough pieces. We error on the side of low end.\n        // We base this on low end 3G speeds which is about 500kbits per second. We assume\n        // that there can be a reasonable drop off from max bandwidth which leaves you with\n        // as little as 80%. We can receive half of that each 500ms - at best. In practice,\n        // a little bandwidth is lost to processing and contention - e.g. CSS and images that\n        // are downloaded along with the main content. So we estimate about half of that to be\n        // the lower end throughput. In other words, we expect that you can at least show\n        // about 12.5kb of content per 500ms. Not counting starting latency for the first\n        // paint.\n        // 500 * 1024 / 8 * .8 * 0.5 / 2\n        var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;\n        function defaultErrorHandler(error) {\n            console[\"error\"](error); // Don't transform to our wrapper\n            return null;\n        }\n        function noop$1() {}\n        function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError) {\n            var pingedTasks = [];\n            var abortSet = new Set();\n            var request = {\n                destination: null,\n                responseState: responseState,\n                progressiveChunkSize: progressiveChunkSize === undefined ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,\n                status: OPEN,\n                fatalError: null,\n                nextSegmentId: 0,\n                allPendingTasks: 0,\n                pendingRootTasks: 0,\n                completedRootSegment: null,\n                abortableTasks: abortSet,\n                pingedTasks: pingedTasks,\n                clientRenderedBoundaries: [],\n                completedBoundaries: [],\n                partialBoundaries: [],\n                onError: onError === undefined ? defaultErrorHandler : onError,\n                onAllReady: onAllReady === undefined ? noop$1 : onAllReady,\n                onShellReady: onShellReady === undefined ? noop$1 : onShellReady,\n                onShellError: onShellError === undefined ? noop$1 : onShellError,\n                onFatalError: onFatalError === undefined ? noop$1 : onFatalError\n            }; // This segment represents the root fallback.\n            var rootSegment = createPendingSegment(request, 0, null, rootFormatContext, false, false); // There is no parent so conceptually, we're unblocked to flush this segment.\n            rootSegment.parentFlushed = true;\n            var rootTask = createTask(request, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);\n            pingedTasks.push(rootTask);\n            return request;\n        }\n        function pingTask(request, task) {\n            var pingedTasks = request.pingedTasks;\n            pingedTasks.push(task);\n            if (pingedTasks.length === 1) {\n                scheduleWork(function() {\n                    return performWork(request);\n                });\n            }\n        }\n        function createSuspenseBoundary(request, fallbackAbortableTasks) {\n            return {\n                id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,\n                rootSegmentID: -1,\n                parentFlushed: false,\n                pendingTasks: 0,\n                forceClientRender: false,\n                completedSegments: [],\n                byteSize: 0,\n                fallbackAbortableTasks: fallbackAbortableTasks,\n                errorDigest: null\n            };\n        }\n        function createTask(request, node, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {\n            request.allPendingTasks++;\n            if (blockedBoundary === null) {\n                request.pendingRootTasks++;\n            } else {\n                blockedBoundary.pendingTasks++;\n            }\n            var task = {\n                node: node,\n                ping: function() {\n                    return pingTask(request, task);\n                },\n                blockedBoundary: blockedBoundary,\n                blockedSegment: blockedSegment,\n                abortSet: abortSet,\n                legacyContext: legacyContext,\n                context: context,\n                treeContext: treeContext\n            };\n            {\n                task.componentStack = null;\n            }\n            abortSet.add(task);\n            return task;\n        }\n        function createPendingSegment(request, index, boundary, formatContext, lastPushedText, textEmbedded) {\n            return {\n                status: PENDING,\n                id: -1,\n                // lazily assigned later\n                index: index,\n                parentFlushed: false,\n                chunks: [],\n                children: [],\n                formatContext: formatContext,\n                boundary: boundary,\n                lastPushedText: lastPushedText,\n                textEmbedded: textEmbedded\n            };\n        } // DEV-only global reference to the currently executing task\n        var currentTaskInDEV = null;\n        function getCurrentStackInDEV() {\n            {\n                if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {\n                    return \"\";\n                }\n                return getStackByComponentStackNode(currentTaskInDEV.componentStack);\n            }\n        }\n        function pushBuiltInComponentStackInDEV(task, type) {\n            {\n                task.componentStack = {\n                    tag: 0,\n                    parent: task.componentStack,\n                    type: type\n                };\n            }\n        }\n        function pushFunctionComponentStackInDEV(task, type) {\n            {\n                task.componentStack = {\n                    tag: 1,\n                    parent: task.componentStack,\n                    type: type\n                };\n            }\n        }\n        function pushClassComponentStackInDEV(task, type) {\n            {\n                task.componentStack = {\n                    tag: 2,\n                    parent: task.componentStack,\n                    type: type\n                };\n            }\n        }\n        function popComponentStackInDEV(task) {\n            {\n                if (task.componentStack === null) {\n                    error(\"Unexpectedly popped too many stack frames. This is a bug in React.\");\n                } else {\n                    task.componentStack = task.componentStack.parent;\n                }\n            }\n        } // stash the component stack of an unwinding error until it is processed\n        var lastBoundaryErrorComponentStackDev = null;\n        function captureBoundaryErrorDetailsDev(boundary, error) {\n            {\n                var errorMessage;\n                if (typeof error === \"string\") {\n                    errorMessage = error;\n                } else if (error && typeof error.message === \"string\") {\n                    errorMessage = error.message;\n                } else {\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    errorMessage = String(error);\n                }\n                var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();\n                lastBoundaryErrorComponentStackDev = null;\n                boundary.errorMessage = errorMessage;\n                boundary.errorComponentStack = errorComponentStack;\n            }\n        }\n        function logRecoverableError(request, error) {\n            // If this callback errors, we intentionally let that error bubble up to become a fatal error\n            // so that someone fixes the error reporting instead of hiding it.\n            var errorDigest = request.onError(error);\n            if (errorDigest != null && typeof errorDigest !== \"string\") {\n                // eslint-disable-next-line react-internal/prod-error-codes\n                throw new Error('onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"' + typeof errorDigest + '\" instead');\n            }\n            return errorDigest;\n        }\n        function fatalError(request, error) {\n            // This is called outside error handling code such as if the root errors outside\n            // a suspense boundary or if the root suspense boundary's fallback errors.\n            // It's also called if React itself or its host configs errors.\n            var onShellError = request.onShellError;\n            onShellError(error);\n            var onFatalError = request.onFatalError;\n            onFatalError(error);\n            if (request.destination !== null) {\n                request.status = CLOSED;\n                closeWithError(request.destination, error);\n            } else {\n                request.status = CLOSING;\n                request.fatalError = error;\n            }\n        }\n        function renderSuspenseBoundary(request, task, props) {\n            pushBuiltInComponentStackInDEV(task, \"Suspense\");\n            var parentBoundary = task.blockedBoundary;\n            var parentSegment = task.blockedSegment; // Each time we enter a suspense boundary, we split out into a new segment for\n            // the fallback so that we can later replace that segment with the content.\n            // This also lets us split out the main content even if it doesn't suspend,\n            // in case it ends up generating a large subtree of content.\n            var fallback = props.fallback;\n            var content = props.children;\n            var fallbackAbortSet = new Set();\n            var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);\n            var insertionIndex = parentSegment.chunks.length; // The children of the boundary segment is actually the fallback.\n            var boundarySegment = createPendingSegment(request, insertionIndex, newBoundary, parentSegment.formatContext, false, false);\n            parentSegment.children.push(boundarySegment); // The parentSegment has a child Segment at this index so we reset the lastPushedText marker on the parent\n            parentSegment.lastPushedText = false; // This segment is the actual child content. We can start rendering that immediately.\n            var contentRootSegment = createPendingSegment(request, 0, null, parentSegment.formatContext, false, false); // We mark the root segment as having its parent flushed. It's not really flushed but there is\n            // no parent segment so there's nothing to wait on.\n            contentRootSegment.parentFlushed = true; // Currently this is running synchronously. We could instead schedule this to pingedTasks.\n            // I suspect that there might be some efficiency benefits from not creating the suspended task\n            // and instead just using the stack if possible.\n            // TODO: Call this directly instead of messing with saving and restoring contexts.\n            // We can reuse the current context and task to render the content immediately without\n            // context switching. We just need to temporarily switch which boundary and which segment\n            // we're writing to. If something suspends, it'll spawn new suspended task with that context.\n            task.blockedBoundary = newBoundary;\n            task.blockedSegment = contentRootSegment;\n            try {\n                // We use the safe form because we don't handle suspending here. Only error handling.\n                renderNode(request, task, content);\n                pushSegmentFinale$1(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);\n                contentRootSegment.status = COMPLETED;\n                queueCompletedSegment(newBoundary, contentRootSegment);\n                if (newBoundary.pendingTasks === 0) {\n                    // This must have been the last segment we were waiting on. This boundary is now complete.\n                    // Therefore we won't need the fallback. We early return so that we don't have to create\n                    // the fallback.\n                    popComponentStackInDEV(task);\n                    return;\n                }\n            } catch (error) {\n                contentRootSegment.status = ERRORED;\n                newBoundary.forceClientRender = true;\n                newBoundary.errorDigest = logRecoverableError(request, error);\n                {\n                    captureBoundaryErrorDetailsDev(newBoundary, error);\n                }\n            // We don't need to schedule any task because we know the parent has written yet.\n            // We do need to fallthrough to create the fallback though.\n            } finally{\n                task.blockedBoundary = parentBoundary;\n                task.blockedSegment = parentSegment;\n            } // We create suspended task for the fallback because we don't want to actually work\n            // on it yet in case we finish the main content, so we queue for later.\n            var suspendedFallbackTask = createTask(request, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);\n            {\n                suspendedFallbackTask.componentStack = task.componentStack;\n            }\n            // on preparing fallbacks if we don't have any more main content to task on.\n            request.pingedTasks.push(suspendedFallbackTask);\n            popComponentStackInDEV(task);\n        }\n        function renderHostElement(request, task, type, props) {\n            pushBuiltInComponentStackInDEV(task, type);\n            var segment = task.blockedSegment;\n            var children = pushStartInstance(segment.chunks, type, props, request.responseState, segment.formatContext);\n            segment.lastPushedText = false;\n            var prevContext = segment.formatContext;\n            segment.formatContext = getChildFormatContext(prevContext, type, props); // We use the non-destructive form because if something suspends, we still\n            // need to pop back up and finish this subtree of HTML.\n            renderNode(request, task, children); // We expect that errors will fatal the whole task and that we don't need\n            // the correct context. Therefore this is not in a finally.\n            segment.formatContext = prevContext;\n            pushEndInstance(segment.chunks, type);\n            segment.lastPushedText = false;\n            popComponentStackInDEV(task);\n        }\n        function shouldConstruct$1(Component) {\n            return Component.prototype && Component.prototype.isReactComponent;\n        }\n        function renderWithHooks(request, task, Component, props, secondArg) {\n            var componentIdentity = {};\n            prepareToUseHooks(task, componentIdentity);\n            var result = Component(props, secondArg);\n            return finishHooks(Component, props, result, secondArg);\n        }\n        function finishClassComponent(request, task, instance, Component, props) {\n            var nextChildren = instance.render();\n            {\n                if (instance.props !== props) {\n                    if (!didWarnAboutReassigningProps) {\n                        error(\"It looks like %s is reassigning its own `this.props` while rendering. \" + \"This is not supported and can lead to confusing bugs.\", getComponentNameFromType(Component) || \"a component\");\n                    }\n                    didWarnAboutReassigningProps = true;\n                }\n            }\n            {\n                var childContextTypes = Component.childContextTypes;\n                if (childContextTypes !== null && childContextTypes !== undefined) {\n                    var previousContext = task.legacyContext;\n                    var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);\n                    task.legacyContext = mergedContext;\n                    renderNodeDestructive(request, task, nextChildren);\n                    task.legacyContext = previousContext;\n                    return;\n                }\n            }\n            renderNodeDestructive(request, task, nextChildren);\n        }\n        function renderClassComponent(request, task, Component, props) {\n            pushClassComponentStackInDEV(task, Component);\n            var maskedContext = getMaskedContext(Component, task.legacyContext);\n            var instance = constructClassInstance(Component, props, maskedContext);\n            mountClassInstance(instance, Component, props, maskedContext);\n            finishClassComponent(request, task, instance, Component, props);\n            popComponentStackInDEV(task);\n        }\n        var didWarnAboutBadClass = {};\n        var didWarnAboutModulePatternComponent = {};\n        var didWarnAboutContextTypeOnFunctionComponent = {};\n        var didWarnAboutGetDerivedStateOnFunctionComponent = {};\n        var didWarnAboutReassigningProps = false;\n        var didWarnAboutGenerators = false;\n        var didWarnAboutMaps = false;\n        var hasWarnedAboutUsingContextAsConsumer = false; // This would typically be a function component but we still support module pattern\n        // components for some reason.\n        function renderIndeterminateComponent(request, task, Component, props) {\n            var legacyContext;\n            {\n                legacyContext = getMaskedContext(Component, task.legacyContext);\n            }\n            pushFunctionComponentStackInDEV(task, Component);\n            {\n                if (Component.prototype && typeof Component.prototype.render === \"function\") {\n                    var componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutBadClass[componentName]) {\n                        error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + \"This is likely to cause errors. Change %s to extend React.Component instead.\", componentName, componentName);\n                        didWarnAboutBadClass[componentName] = true;\n                    }\n                }\n            }\n            var value = renderWithHooks(request, task, Component, props, legacyContext);\n            var hasId = checkDidRenderIdHook();\n            {\n                // Support for module components is deprecated and is removed behind a flag.\n                // Whether or not it would crash later, we want to show a good message in DEV first.\n                if (typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === undefined) {\n                    var _componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutModulePatternComponent[_componentName]) {\n                        error(\"The <%s /> component appears to be a function component that returns a class instance. \" + \"Change %s to a class that extends React.Component instead. \" + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + \"cannot be called with `new` by React.\", _componentName, _componentName, _componentName);\n                        didWarnAboutModulePatternComponent[_componentName] = true;\n                    }\n                }\n            }\n            if (// Eventually we'll delete this branch altogether.\n            typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === undefined) {\n                {\n                    var _componentName2 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutModulePatternComponent[_componentName2]) {\n                        error(\"The <%s /> component appears to be a function component that returns a class instance. \" + \"Change %s to a class that extends React.Component instead. \" + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + \"cannot be called with `new` by React.\", _componentName2, _componentName2, _componentName2);\n                        didWarnAboutModulePatternComponent[_componentName2] = true;\n                    }\n                }\n                mountClassInstance(value, Component, props, legacyContext);\n                finishClassComponent(request, task, value, Component, props);\n            } else {\n                {\n                    validateFunctionComponentInDev(Component);\n                }\n                // the previous task every again, so we can use the destructive recursive form.\n                if (hasId) {\n                    // This component materialized an id. We treat this as its own level, with\n                    // a single \"child\" slot.\n                    var prevTreeContext = task.treeContext;\n                    var totalChildren = 1;\n                    var index = 0;\n                    task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);\n                    try {\n                        renderNodeDestructive(request, task, value);\n                    } finally{\n                        task.treeContext = prevTreeContext;\n                    }\n                } else {\n                    renderNodeDestructive(request, task, value);\n                }\n            }\n            popComponentStackInDEV(task);\n        }\n        function validateFunctionComponentInDev(Component) {\n            {\n                if (Component) {\n                    if (Component.childContextTypes) {\n                        error(\"%s(...): childContextTypes cannot be defined on a function component.\", Component.displayName || Component.name || \"Component\");\n                    }\n                }\n                if (typeof Component.getDerivedStateFromProps === \"function\") {\n                    var _componentName3 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {\n                        error(\"%s: Function components do not support getDerivedStateFromProps.\", _componentName3);\n                        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;\n                    }\n                }\n                if (typeof Component.contextType === \"object\" && Component.contextType !== null) {\n                    var _componentName4 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {\n                        error(\"%s: Function components do not support contextType.\", _componentName4);\n                        didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;\n                    }\n                }\n            }\n        }\n        function resolveDefaultProps(Component, baseProps) {\n            if (Component && Component.defaultProps) {\n                // Resolve default props. Taken from ReactElement\n                var props = assign({}, baseProps);\n                var defaultProps = Component.defaultProps;\n                for(var propName in defaultProps){\n                    if (props[propName] === undefined) {\n                        props[propName] = defaultProps[propName];\n                    }\n                }\n                return props;\n            }\n            return baseProps;\n        }\n        function renderForwardRef(request, task, type, props, ref) {\n            pushFunctionComponentStackInDEV(task, type.render);\n            var children = renderWithHooks(request, task, type.render, props, ref);\n            var hasId = checkDidRenderIdHook();\n            if (hasId) {\n                // This component materialized an id. We treat this as its own level, with\n                // a single \"child\" slot.\n                var prevTreeContext = task.treeContext;\n                var totalChildren = 1;\n                var index = 0;\n                task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);\n                try {\n                    renderNodeDestructive(request, task, children);\n                } finally{\n                    task.treeContext = prevTreeContext;\n                }\n            } else {\n                renderNodeDestructive(request, task, children);\n            }\n            popComponentStackInDEV(task);\n        }\n        function renderMemo(request, task, type, props, ref) {\n            var innerType = type.type;\n            var resolvedProps = resolveDefaultProps(innerType, props);\n            renderElement(request, task, innerType, resolvedProps, ref);\n        }\n        function renderContextConsumer(request, task, context, props) {\n            // The logic below for Context differs depending on PROD or DEV mode. In\n            // DEV mode, we create a separate object for Context.Consumer that acts\n            // like a proxy to Context. This proxy object adds unnecessary code in PROD\n            // so we use the old behaviour (Context.Consumer references Context) to\n            // reduce size and overhead. The separate object references context via\n            // a property called \"_context\", which also gives us the ability to check\n            // in DEV mode if this property exists or not and warn if it does not.\n            {\n                if (context._context === undefined) {\n                    // This may be because it's a Context (rather than a Consumer).\n                    // Or it may be because it's older React where they're the same thing.\n                    // We only want to warn if we're sure it's a new React.\n                    if (context !== context.Consumer) {\n                        if (!hasWarnedAboutUsingContextAsConsumer) {\n                            hasWarnedAboutUsingContextAsConsumer = true;\n                            error(\"Rendering <Context> directly is not supported and will be removed in \" + \"a future major release. Did you mean to render <Context.Consumer> instead?\");\n                        }\n                    }\n                } else {\n                    context = context._context;\n                }\n            }\n            var render = props.children;\n            {\n                if (typeof render !== \"function\") {\n                    error(\"A context consumer was rendered with multiple children, or a child \" + \"that isn't a function. A context consumer expects a single child \" + \"that is a function. If you did pass a function, make sure there \" + \"is no trailing or leading whitespace around it.\");\n                }\n            }\n            var newValue = readContext(context);\n            var newChildren = render(newValue);\n            renderNodeDestructive(request, task, newChildren);\n        }\n        function renderContextProvider(request, task, type, props) {\n            var context = type._context;\n            var value = props.value;\n            var children = props.children;\n            var prevSnapshot;\n            {\n                prevSnapshot = task.context;\n            }\n            task.context = pushProvider(context, value);\n            renderNodeDestructive(request, task, children);\n            task.context = popProvider(context);\n            {\n                if (prevSnapshot !== task.context) {\n                    error(\"Popping the context provider did not return back to the original snapshot. This is a bug in React.\");\n                }\n            }\n        }\n        function renderLazyComponent(request, task, lazyComponent, props, ref) {\n            pushBuiltInComponentStackInDEV(task, \"Lazy\");\n            var payload = lazyComponent._payload;\n            var init = lazyComponent._init;\n            var Component = init(payload);\n            var resolvedProps = resolveDefaultProps(Component, props);\n            renderElement(request, task, Component, resolvedProps, ref);\n            popComponentStackInDEV(task);\n        }\n        function renderElement(request, task, type, props, ref) {\n            if (typeof type === \"function\") {\n                if (shouldConstruct$1(type)) {\n                    renderClassComponent(request, task, type, props);\n                    return;\n                } else {\n                    renderIndeterminateComponent(request, task, type, props);\n                    return;\n                }\n            }\n            if (typeof type === \"string\") {\n                renderHostElement(request, task, type, props);\n                return;\n            }\n            switch(type){\n                // TODO: LegacyHidden acts the same as a fragment. This only works\n                // because we currently assume that every instance of LegacyHidden is\n                // accompanied by a host component wrapper. In the hidden mode, the host\n                // component is given a `hidden` attribute, which ensures that the\n                // initial HTML is not visible. To support the use of LegacyHidden as a\n                // true fragment, without an extra DOM node, we would have to hide the\n                // initial HTML in some other way.\n                // TODO: Add REACT_OFFSCREEN_TYPE here too with the same capability.\n                case REACT_LEGACY_HIDDEN_TYPE:\n                case REACT_DEBUG_TRACING_MODE_TYPE:\n                case REACT_STRICT_MODE_TYPE:\n                case REACT_PROFILER_TYPE:\n                case REACT_FRAGMENT_TYPE:\n                    {\n                        renderNodeDestructive(request, task, props.children);\n                        return;\n                    }\n                case REACT_SUSPENSE_LIST_TYPE:\n                    {\n                        pushBuiltInComponentStackInDEV(task, \"SuspenseList\"); // TODO: SuspenseList should control the boundaries.\n                        renderNodeDestructive(request, task, props.children);\n                        popComponentStackInDEV(task);\n                        return;\n                    }\n                case REACT_SCOPE_TYPE:\n                    {\n                        throw new Error(\"ReactDOMServer does not yet support scope components.\");\n                    }\n                // eslint-disable-next-line-no-fallthrough\n                case REACT_SUSPENSE_TYPE:\n                    {\n                        {\n                            renderSuspenseBoundary(request, task, props);\n                        }\n                        return;\n                    }\n            }\n            if (typeof type === \"object\" && type !== null) {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        {\n                            renderForwardRef(request, task, type, props, ref);\n                            return;\n                        }\n                    case REACT_MEMO_TYPE:\n                        {\n                            renderMemo(request, task, type, props, ref);\n                            return;\n                        }\n                    case REACT_PROVIDER_TYPE:\n                        {\n                            renderContextProvider(request, task, type, props);\n                            return;\n                        }\n                    case REACT_CONTEXT_TYPE:\n                        {\n                            renderContextConsumer(request, task, type, props);\n                            return;\n                        }\n                    case REACT_LAZY_TYPE:\n                        {\n                            renderLazyComponent(request, task, type, props);\n                            return;\n                        }\n                }\n            }\n            var info = \"\";\n            {\n                if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                    info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and \" + \"named imports.\";\n                }\n            }\n            throw new Error(\"Element type is invalid: expected a string (for built-in \" + \"components) or a class/function (for composite components) \" + (\"but got: \" + (type == null ? type : typeof type) + \".\" + info));\n        }\n        function validateIterable(iterable, iteratorFn) {\n            {\n                // We don't support rendering Generators because it's a mutation.\n                // See https://github.com/facebook/react/issues/12995\n                if (typeof Symbol === \"function\" && // $FlowFixMe Flow doesn't know about toStringTag\n                iterable[Symbol.toStringTag] === \"Generator\") {\n                    if (!didWarnAboutGenerators) {\n                        error(\"Using Generators as children is unsupported and will likely yield \" + \"unexpected results because enumerating a generator mutates it. \" + \"You may convert it to an array with `Array.from()` or the \" + \"`[...spread]` operator before rendering. Keep in mind \" + \"you might need to polyfill these features for older browsers.\");\n                    }\n                    didWarnAboutGenerators = true;\n                } // Warn about using Maps as children\n                if (iterable.entries === iteratorFn) {\n                    if (!didWarnAboutMaps) {\n                        error(\"Using Maps as children is not supported. \" + \"Use an array of keyed ReactElements instead.\");\n                    }\n                    didWarnAboutMaps = true;\n                }\n            }\n        }\n        function renderNodeDestructive(request, task, node) {\n            {\n                // In Dev we wrap renderNodeDestructiveImpl in a try / catch so we can capture\n                // a component stack at the right place in the tree. We don't do this in renderNode\n                // becuase it is not called at every layer of the tree and we may lose frames\n                try {\n                    return renderNodeDestructiveImpl(request, task, node);\n                } catch (x) {\n                    if (typeof x === \"object\" && x !== null && typeof x.then === \"function\") ;\n                    else {\n                        // This is an error, stash the component stack if it is null.\n                        lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();\n                    } // rethrow so normal suspense logic can handle thrown value accordingly\n                    throw x;\n                }\n            }\n        } // This function by it self renders a node and consumes the task by mutating it\n        // to update the current execution state.\n        function renderNodeDestructiveImpl(request, task, node) {\n            // Stash the node we're working on. We'll pick up from this task in case\n            // something suspends.\n            task.node = node; // Handle object types\n            if (typeof node === \"object\" && node !== null) {\n                switch(node.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        {\n                            var element = node;\n                            var type = element.type;\n                            var props = element.props;\n                            var ref = element.ref;\n                            renderElement(request, task, type, props, ref);\n                            return;\n                        }\n                    case REACT_PORTAL_TYPE:\n                        throw new Error(\"Portals are not currently supported by the server renderer. \" + \"Render them conditionally so that they only appear on the client render.\");\n                    // eslint-disable-next-line-no-fallthrough\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyNode = node;\n                            var payload = lazyNode._payload;\n                            var init = lazyNode._init;\n                            var resolvedNode;\n                            {\n                                try {\n                                    resolvedNode = init(payload);\n                                } catch (x) {\n                                    if (typeof x === \"object\" && x !== null && typeof x.then === \"function\") {\n                                        // this Lazy initializer is suspending. push a temporary frame onto the stack so it can be\n                                        // popped off in spawnNewSuspendedTask. This aligns stack behavior between Lazy in element position\n                                        // vs Component position. We do not want the frame for Errors so we exclusively do this in\n                                        // the wakeable branch\n                                        pushBuiltInComponentStackInDEV(task, \"Lazy\");\n                                    }\n                                    throw x;\n                                }\n                            }\n                            renderNodeDestructive(request, task, resolvedNode);\n                            return;\n                        }\n                }\n                if (isArray(node)) {\n                    renderChildrenArray(request, task, node);\n                    return;\n                }\n                var iteratorFn = getIteratorFn(node);\n                if (iteratorFn) {\n                    {\n                        validateIterable(node, iteratorFn);\n                    }\n                    var iterator = iteratorFn.call(node);\n                    if (iterator) {\n                        // We need to know how many total children are in this set, so that we\n                        // can allocate enough id slots to acommodate them. So we must exhaust\n                        // the iterator before we start recursively rendering the children.\n                        // TODO: This is not great but I think it's inherent to the id\n                        // generation algorithm.\n                        var step = iterator.next(); // If there are not entries, we need to push an empty so we start by checking that.\n                        if (!step.done) {\n                            var children = [];\n                            do {\n                                children.push(step.value);\n                                step = iterator.next();\n                            }while (!step.done);\n                            renderChildrenArray(request, task, children);\n                            return;\n                        }\n                        return;\n                    }\n                }\n                var childString = Object.prototype.toString.call(node);\n                throw new Error(\"Objects are not valid as a React child (found: \" + (childString === \"[object Object]\" ? \"object with keys {\" + Object.keys(node).join(\", \") + \"}\" : childString) + \"). \" + \"If you meant to render a collection of children, use an array \" + \"instead.\");\n            }\n            if (typeof node === \"string\") {\n                var segment = task.blockedSegment;\n                segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, node, request.responseState, segment.lastPushedText);\n                return;\n            }\n            if (typeof node === \"number\") {\n                var _segment = task.blockedSegment;\n                _segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, \"\" + node, request.responseState, _segment.lastPushedText);\n                return;\n            }\n            {\n                if (typeof node === \"function\") {\n                    error(\"Functions are not valid as a React child. This may happen if \" + \"you return a Component instead of <Component /> from render. \" + \"Or maybe you meant to call this function rather than return it.\");\n                }\n            }\n        }\n        function renderChildrenArray(request, task, children) {\n            var totalChildren = children.length;\n            for(var i = 0; i < totalChildren; i++){\n                var prevTreeContext = task.treeContext;\n                task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i);\n                try {\n                    // We need to use the non-destructive form so that we can safely pop back\n                    // up and render the sibling if something suspends.\n                    renderNode(request, task, children[i]);\n                } finally{\n                    task.treeContext = prevTreeContext;\n                }\n            }\n        }\n        function spawnNewSuspendedTask(request, task, x) {\n            // Something suspended, we'll need to create a new segment and resolve it later.\n            var segment = task.blockedSegment;\n            var insertionIndex = segment.chunks.length;\n            var newSegment = createPendingSegment(request, insertionIndex, null, segment.formatContext, segment.lastPushedText, true);\n            segment.children.push(newSegment); // Reset lastPushedText for current Segment since the new Segment \"consumed\" it\n            segment.lastPushedText = false;\n            var newTask = createTask(request, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);\n            {\n                if (task.componentStack !== null) {\n                    // We pop one task off the stack because the node that suspended will be tried again,\n                    // which will add it back onto the stack.\n                    newTask.componentStack = task.componentStack.parent;\n                }\n            }\n            var ping = newTask.ping;\n            x.then(ping, ping);\n        } // This is a non-destructive form of rendering a node. If it suspends it spawns\n        // a new task and restores the context of this task to what it was before.\n        function renderNode(request, task, node) {\n            // TODO: Store segment.children.length here and reset it in case something\n            // suspended partially through writing something.\n            // Snapshot the current context in case something throws to interrupt the\n            // process.\n            var previousFormatContext = task.blockedSegment.formatContext;\n            var previousLegacyContext = task.legacyContext;\n            var previousContext = task.context;\n            var previousComponentStack = null;\n            {\n                previousComponentStack = task.componentStack;\n            }\n            try {\n                return renderNodeDestructive(request, task, node);\n            } catch (x) {\n                resetHooksState();\n                if (typeof x === \"object\" && x !== null && typeof x.then === \"function\") {\n                    spawnNewSuspendedTask(request, task, x); // Restore the context. We assume that this will be restored by the inner\n                    // functions in case nothing throws so we don't use \"finally\" here.\n                    task.blockedSegment.formatContext = previousFormatContext;\n                    task.legacyContext = previousLegacyContext;\n                    task.context = previousContext; // Restore all active ReactContexts to what they were before.\n                    switchContext(previousContext);\n                    {\n                        task.componentStack = previousComponentStack;\n                    }\n                    return;\n                } else {\n                    // Restore the context. We assume that this will be restored by the inner\n                    // functions in case nothing throws so we don't use \"finally\" here.\n                    task.blockedSegment.formatContext = previousFormatContext;\n                    task.legacyContext = previousLegacyContext;\n                    task.context = previousContext; // Restore all active ReactContexts to what they were before.\n                    switchContext(previousContext);\n                    {\n                        task.componentStack = previousComponentStack;\n                    }\n                    // Let's terminate the rest of the tree and don't render any siblings.\n                    throw x;\n                }\n            }\n        }\n        function erroredTask(request, boundary, segment, error) {\n            // Report the error to a global handler.\n            var errorDigest = logRecoverableError(request, error);\n            if (boundary === null) {\n                fatalError(request, error);\n            } else {\n                boundary.pendingTasks--;\n                if (!boundary.forceClientRender) {\n                    boundary.forceClientRender = true;\n                    boundary.errorDigest = errorDigest;\n                    {\n                        captureBoundaryErrorDetailsDev(boundary, error);\n                    }\n                    // so we can flush it, if the parent already flushed.\n                    if (boundary.parentFlushed) {\n                        // We don't have a preference where in the queue this goes since it's likely\n                        // to error on the client anyway. However, intentionally client-rendered\n                        // boundaries should be flushed earlier so that they can start on the client.\n                        // We reuse the same queue for errors.\n                        request.clientRenderedBoundaries.push(boundary);\n                    }\n                }\n            }\n            request.allPendingTasks--;\n            if (request.allPendingTasks === 0) {\n                var onAllReady = request.onAllReady;\n                onAllReady();\n            }\n        }\n        function abortTaskSoft(task) {\n            // This aborts task without aborting the parent boundary that it blocks.\n            // It's used for when we didn't need this task to complete the tree.\n            // If task was needed, then it should use abortTask instead.\n            var request = this;\n            var boundary = task.blockedBoundary;\n            var segment = task.blockedSegment;\n            segment.status = ABORTED;\n            finishedTask(request, boundary, segment);\n        }\n        function abortTask(task, request, reason) {\n            // This aborts the task and aborts the parent that it blocks, putting it into\n            // client rendered mode.\n            var boundary = task.blockedBoundary;\n            var segment = task.blockedSegment;\n            segment.status = ABORTED;\n            if (boundary === null) {\n                request.allPendingTasks--; // We didn't complete the root so we have nothing to show. We can close\n                // the request;\n                if (request.status !== CLOSED) {\n                    request.status = CLOSED;\n                    if (request.destination !== null) {\n                        close(request.destination);\n                    }\n                }\n            } else {\n                boundary.pendingTasks--;\n                if (!boundary.forceClientRender) {\n                    boundary.forceClientRender = true;\n                    var _error = reason === undefined ? new Error(\"The render was aborted by the server without a reason.\") : reason;\n                    boundary.errorDigest = request.onError(_error);\n                    {\n                        var errorPrefix = \"The server did not finish this Suspense boundary: \";\n                        if (_error && typeof _error.message === \"string\") {\n                            _error = errorPrefix + _error.message;\n                        } else {\n                            // eslint-disable-next-line react-internal/safe-string-coercion\n                            _error = errorPrefix + String(_error);\n                        }\n                        var previousTaskInDev = currentTaskInDEV;\n                        currentTaskInDEV = task;\n                        try {\n                            captureBoundaryErrorDetailsDev(boundary, _error);\n                        } finally{\n                            currentTaskInDEV = previousTaskInDev;\n                        }\n                    }\n                    if (boundary.parentFlushed) {\n                        request.clientRenderedBoundaries.push(boundary);\n                    }\n                } // If this boundary was still pending then we haven't already cancelled its fallbacks.\n                // We'll need to abort the fallbacks, which will also error that parent boundary.\n                boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {\n                    return abortTask(fallbackTask, request, reason);\n                });\n                boundary.fallbackAbortableTasks.clear();\n                request.allPendingTasks--;\n                if (request.allPendingTasks === 0) {\n                    var onAllReady = request.onAllReady;\n                    onAllReady();\n                }\n            }\n        }\n        function queueCompletedSegment(boundary, segment) {\n            if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {\n                // This is an empty segment. There's nothing to write, so we can instead transfer the ID\n                // to the child. That way any existing references point to the child.\n                var childSegment = segment.children[0];\n                childSegment.id = segment.id;\n                childSegment.parentFlushed = true;\n                if (childSegment.status === COMPLETED) {\n                    queueCompletedSegment(boundary, childSegment);\n                }\n            } else {\n                var completedSegments = boundary.completedSegments;\n                completedSegments.push(segment);\n            }\n        }\n        function finishedTask(request, boundary, segment) {\n            if (boundary === null) {\n                if (segment.parentFlushed) {\n                    if (request.completedRootSegment !== null) {\n                        throw new Error(\"There can only be one root segment. This is a bug in React.\");\n                    }\n                    request.completedRootSegment = segment;\n                }\n                request.pendingRootTasks--;\n                if (request.pendingRootTasks === 0) {\n                    // We have completed the shell so the shell can't error anymore.\n                    request.onShellError = noop$1;\n                    var onShellReady = request.onShellReady;\n                    onShellReady();\n                }\n            } else {\n                boundary.pendingTasks--;\n                if (boundary.forceClientRender) ;\n                else if (boundary.pendingTasks === 0) {\n                    // This must have been the last segment we were waiting on. This boundary is now complete.\n                    if (segment.parentFlushed) {\n                        // Our parent segment already flushed, so we need to schedule this segment to be emitted.\n                        // If it is a segment that was aborted, we'll write other content instead so we don't need\n                        // to emit it.\n                        if (segment.status === COMPLETED) {\n                            queueCompletedSegment(boundary, segment);\n                        }\n                    }\n                    if (boundary.parentFlushed) {\n                        // The segment might be part of a segment that didn't flush yet, but if the boundary's\n                        // parent flushed, we need to schedule the boundary to be emitted.\n                        request.completedBoundaries.push(boundary);\n                    } // We can now cancel any pending task on the fallback since we won't need to show it anymore.\n                    // This needs to happen after we read the parentFlushed flags because aborting can finish\n                    // work which can trigger user code, which can start flushing, which can change those flags.\n                    boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);\n                    boundary.fallbackAbortableTasks.clear();\n                } else {\n                    if (segment.parentFlushed) {\n                        // Our parent already flushed, so we need to schedule this segment to be emitted.\n                        // If it is a segment that was aborted, we'll write other content instead so we don't need\n                        // to emit it.\n                        if (segment.status === COMPLETED) {\n                            queueCompletedSegment(boundary, segment);\n                            var completedSegments = boundary.completedSegments;\n                            if (completedSegments.length === 1) {\n                                // This is the first time since we last flushed that we completed anything.\n                                // We can schedule this boundary to emit its partially completed segments early\n                                // in case the parent has already been flushed.\n                                if (boundary.parentFlushed) {\n                                    request.partialBoundaries.push(boundary);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            request.allPendingTasks--;\n            if (request.allPendingTasks === 0) {\n                // This needs to be called at the very end so that we can synchronously write the result\n                // in the callback if needed.\n                var onAllReady = request.onAllReady;\n                onAllReady();\n            }\n        }\n        function retryTask(request, task) {\n            var segment = task.blockedSegment;\n            if (segment.status !== PENDING) {\n                // We completed this by other means before we had a chance to retry it.\n                return;\n            } // We restore the context to what it was when we suspended.\n            // We don't restore it after we leave because it's likely that we'll end up\n            // needing a very similar context soon again.\n            switchContext(task.context);\n            var prevTaskInDEV = null;\n            {\n                prevTaskInDEV = currentTaskInDEV;\n                currentTaskInDEV = task;\n            }\n            try {\n                // We call the destructive form that mutates this task. That way if something\n                // suspends again, we can reuse the same task instead of spawning a new one.\n                renderNodeDestructive(request, task, task.node);\n                pushSegmentFinale$1(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded);\n                task.abortSet.delete(task);\n                segment.status = COMPLETED;\n                finishedTask(request, task.blockedBoundary, segment);\n            } catch (x) {\n                resetHooksState();\n                if (typeof x === \"object\" && x !== null && typeof x.then === \"function\") {\n                    // Something suspended again, let's pick it back up later.\n                    var ping = task.ping;\n                    x.then(ping, ping);\n                } else {\n                    task.abortSet.delete(task);\n                    segment.status = ERRORED;\n                    erroredTask(request, task.blockedBoundary, segment, x);\n                }\n            } finally{\n                {\n                    currentTaskInDEV = prevTaskInDEV;\n                }\n            }\n        }\n        function performWork(request) {\n            if (request.status === CLOSED) {\n                return;\n            }\n            var prevContext = getActiveContext();\n            var prevDispatcher = ReactCurrentDispatcher$1.current;\n            ReactCurrentDispatcher$1.current = Dispatcher;\n            var prevGetCurrentStackImpl;\n            {\n                prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;\n                ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;\n            }\n            var prevResponseState = currentResponseState;\n            setCurrentResponseState(request.responseState);\n            try {\n                var pingedTasks = request.pingedTasks;\n                var i;\n                for(i = 0; i < pingedTasks.length; i++){\n                    var task = pingedTasks[i];\n                    retryTask(request, task);\n                }\n                pingedTasks.splice(0, i);\n                if (request.destination !== null) {\n                    flushCompletedQueues(request, request.destination);\n                }\n            } catch (error) {\n                logRecoverableError(request, error);\n                fatalError(request, error);\n            } finally{\n                setCurrentResponseState(prevResponseState);\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n                {\n                    ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;\n                }\n                if (prevDispatcher === Dispatcher) {\n                    // This means that we were in a reentrant work loop. This could happen\n                    // in a renderer that supports synchronous work like renderToString,\n                    // when it's called from within another renderer.\n                    // Normally we don't bother switching the contexts to their root/default\n                    // values when leaving because we'll likely need the same or similar\n                    // context again. However, when we're inside a synchronous loop like this\n                    // we'll to restore the context to what it was before returning.\n                    switchContext(prevContext);\n                }\n            }\n        }\n        function flushSubtree(request, destination, segment) {\n            segment.parentFlushed = true;\n            switch(segment.status){\n                case PENDING:\n                    {\n                        // We're emitting a placeholder for this segment to be filled in later.\n                        // Therefore we'll need to assign it an ID - to refer to it by.\n                        var segmentID = segment.id = request.nextSegmentId++; // When this segment finally completes it won't be embedded in text since it will flush separately\n                        segment.lastPushedText = false;\n                        segment.textEmbedded = false;\n                        return writePlaceholder(destination, request.responseState, segmentID);\n                    }\n                case COMPLETED:\n                    {\n                        segment.status = FLUSHED;\n                        var r = true;\n                        var chunks = segment.chunks;\n                        var chunkIdx = 0;\n                        var children = segment.children;\n                        for(var childIdx = 0; childIdx < children.length; childIdx++){\n                            var nextChild = children[childIdx]; // Write all the chunks up until the next child.\n                            for(; chunkIdx < nextChild.index; chunkIdx++){\n                                writeChunk(destination, chunks[chunkIdx]);\n                            }\n                            r = flushSegment(request, destination, nextChild);\n                        } // Finally just write all the remaining chunks\n                        for(; chunkIdx < chunks.length - 1; chunkIdx++){\n                            writeChunk(destination, chunks[chunkIdx]);\n                        }\n                        if (chunkIdx < chunks.length) {\n                            r = writeChunkAndReturn(destination, chunks[chunkIdx]);\n                        }\n                        return r;\n                    }\n                default:\n                    {\n                        throw new Error(\"Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.\");\n                    }\n            }\n        }\n        function flushSegment(request, destination, segment) {\n            var boundary = segment.boundary;\n            if (boundary === null) {\n                // Not a suspense boundary.\n                return flushSubtree(request, destination, segment);\n            }\n            boundary.parentFlushed = true; // This segment is a Suspense boundary. We need to decide whether to\n            // emit the content or the fallback now.\n            if (boundary.forceClientRender) {\n                // Emit a client rendered suspense boundary wrapper.\n                // We never queue the inner boundary so we'll never emit its content or partial segments.\n                writeStartClientRenderedSuspenseBoundary$1(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack); // Flush the fallback.\n                flushSubtree(request, destination, segment);\n                return writeEndClientRenderedSuspenseBoundary$1(destination, request.responseState);\n            } else if (boundary.pendingTasks > 0) {\n                // This boundary is still loading. Emit a pending suspense boundary wrapper.\n                // Assign an ID to refer to the future content by.\n                boundary.rootSegmentID = request.nextSegmentId++;\n                if (boundary.completedSegments.length > 0) {\n                    // If this is at least partially complete, we can queue it to be partially emitted early.\n                    request.partialBoundaries.push(boundary);\n                } /// This is the first time we should have referenced this ID.\n                var id = boundary.id = assignSuspenseBoundaryID(request.responseState);\n                writeStartPendingSuspenseBoundary(destination, request.responseState, id); // Flush the fallback.\n                flushSubtree(request, destination, segment);\n                return writeEndPendingSuspenseBoundary(destination, request.responseState);\n            } else if (boundary.byteSize > request.progressiveChunkSize) {\n                // This boundary is large and will be emitted separately so that we can progressively show\n                // other content. We add it to the queue during the flush because we have to ensure that\n                // the parent flushes first so that there's something to inject it into.\n                // We also have to make sure that it's emitted into the queue in a deterministic slot.\n                // I.e. we can't insert it here when it completes.\n                // Assign an ID to refer to the future content by.\n                boundary.rootSegmentID = request.nextSegmentId++;\n                request.completedBoundaries.push(boundary); // Emit a pending rendered suspense boundary wrapper.\n                writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id); // Flush the fallback.\n                flushSubtree(request, destination, segment);\n                return writeEndPendingSuspenseBoundary(destination, request.responseState);\n            } else {\n                // We can inline this boundary's content as a complete boundary.\n                writeStartCompletedSuspenseBoundary$1(destination, request.responseState);\n                var completedSegments = boundary.completedSegments;\n                if (completedSegments.length !== 1) {\n                    throw new Error(\"A previously unvisited boundary must have exactly one root segment. This is a bug in React.\");\n                }\n                var contentSegment = completedSegments[0];\n                flushSegment(request, destination, contentSegment);\n                return writeEndCompletedSuspenseBoundary$1(destination, request.responseState);\n            }\n        }\n        function flushClientRenderedBoundary(request, destination, boundary) {\n            return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);\n        }\n        function flushSegmentContainer(request, destination, segment) {\n            writeStartSegment(destination, request.responseState, segment.formatContext, segment.id);\n            flushSegment(request, destination, segment);\n            return writeEndSegment(destination, segment.formatContext);\n        }\n        function flushCompletedBoundary(request, destination, boundary) {\n            var completedSegments = boundary.completedSegments;\n            var i = 0;\n            for(; i < completedSegments.length; i++){\n                var segment = completedSegments[i];\n                flushPartiallyCompletedSegment(request, destination, boundary, segment);\n            }\n            completedSegments.length = 0;\n            return writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);\n        }\n        function flushPartialBoundary(request, destination, boundary) {\n            var completedSegments = boundary.completedSegments;\n            var i = 0;\n            for(; i < completedSegments.length; i++){\n                var segment = completedSegments[i];\n                if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {\n                    i++;\n                    completedSegments.splice(0, i); // Only write as much as the buffer wants. Something higher priority\n                    // might want to write later.\n                    return false;\n                }\n            }\n            completedSegments.splice(0, i);\n            return true;\n        }\n        function flushPartiallyCompletedSegment(request, destination, boundary, segment) {\n            if (segment.status === FLUSHED) {\n                // We've already flushed this inline.\n                return true;\n            }\n            var segmentID = segment.id;\n            if (segmentID === -1) {\n                // This segment wasn't previously referred to. This happens at the root of\n                // a boundary. We make kind of a leap here and assume this is the root.\n                var rootSegmentID = segment.id = boundary.rootSegmentID;\n                if (rootSegmentID === -1) {\n                    throw new Error(\"A root segment ID must have been assigned by now. This is a bug in React.\");\n                }\n                return flushSegmentContainer(request, destination, segment);\n            } else {\n                flushSegmentContainer(request, destination, segment);\n                return writeCompletedSegmentInstruction(destination, request.responseState, segmentID);\n            }\n        }\n        function flushCompletedQueues(request, destination) {\n            try {\n                // The structure of this is to go through each queue one by one and write\n                // until the sink tells us to stop. When we should stop, we still finish writing\n                // that item fully and then yield. At that point we remove the already completed\n                // items up until the point we completed them.\n                // TODO: Emit preloading.\n                // TODO: It's kind of unfortunate to keep checking this array after we've already\n                // emitted the root.\n                var completedRootSegment = request.completedRootSegment;\n                if (completedRootSegment !== null && request.pendingRootTasks === 0) {\n                    flushSegment(request, destination, completedRootSegment);\n                    request.completedRootSegment = null;\n                    writeCompletedRoot(destination, request.responseState);\n                } // We emit client rendering instructions for already emitted boundaries first.\n                // This is so that we can signal to the client to start client rendering them as\n                // soon as possible.\n                var clientRenderedBoundaries = request.clientRenderedBoundaries;\n                var i;\n                for(i = 0; i < clientRenderedBoundaries.length; i++){\n                    var boundary = clientRenderedBoundaries[i];\n                    if (!flushClientRenderedBoundary(request, destination, boundary)) {\n                        request.destination = null;\n                        i++;\n                        clientRenderedBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                clientRenderedBoundaries.splice(0, i); // Next we emit any complete boundaries. It's better to favor boundaries\n                // that are completely done since we can actually show them, than it is to emit\n                // any individual segments from a partially complete boundary.\n                var completedBoundaries = request.completedBoundaries;\n                for(i = 0; i < completedBoundaries.length; i++){\n                    var _boundary = completedBoundaries[i];\n                    if (!flushCompletedBoundary(request, destination, _boundary)) {\n                        request.destination = null;\n                        i++;\n                        completedBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                completedBoundaries.splice(0, i); // Allow anything written so far to flush to the underlying sink before\n                // we continue with lower priorities.\n                completeWriting(destination);\n                beginWriting(destination); // TODO: Here we'll emit data used by hydration.\n                // Next we emit any segments of any boundaries that are partially complete\n                // but not deeply complete.\n                var partialBoundaries = request.partialBoundaries;\n                for(i = 0; i < partialBoundaries.length; i++){\n                    var _boundary2 = partialBoundaries[i];\n                    if (!flushPartialBoundary(request, destination, _boundary2)) {\n                        request.destination = null;\n                        i++;\n                        partialBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                partialBoundaries.splice(0, i); // Next we check the completed boundaries again. This may have had\n                // boundaries added to it in case they were too larged to be inlined.\n                // New ones might be added in this loop.\n                var largeBoundaries = request.completedBoundaries;\n                for(i = 0; i < largeBoundaries.length; i++){\n                    var _boundary3 = largeBoundaries[i];\n                    if (!flushCompletedBoundary(request, destination, _boundary3)) {\n                        request.destination = null;\n                        i++;\n                        largeBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                largeBoundaries.splice(0, i);\n            } finally{\n                if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0 // We don't need to check any partially completed segments because\n                ) {\n                    {\n                        if (request.abortableTasks.size !== 0) {\n                            error(\"There was still abortable task at the root when we closed. This is a bug in React.\");\n                        }\n                    }\n                    close(destination);\n                }\n            }\n        }\n        function startWork(request) {\n            scheduleWork(function() {\n                return performWork(request);\n            });\n        }\n        function startFlowing(request, destination) {\n            if (request.status === CLOSING) {\n                request.status = CLOSED;\n                closeWithError(destination, request.fatalError);\n                return;\n            }\n            if (request.status === CLOSED) {\n                return;\n            }\n            if (request.destination !== null) {\n                // We're already flowing.\n                return;\n            }\n            request.destination = destination;\n            try {\n                flushCompletedQueues(request, destination);\n            } catch (error) {\n                logRecoverableError(request, error);\n                fatalError(request, error);\n            }\n        } // This is called to early terminate a request. It puts all pending boundaries in client rendered state.\n        function abort(request, reason) {\n            try {\n                var abortableTasks = request.abortableTasks;\n                abortableTasks.forEach(function(task) {\n                    return abortTask(task, request, reason);\n                });\n                abortableTasks.clear();\n                if (request.destination !== null) {\n                    flushCompletedQueues(request, request.destination);\n                }\n            } catch (error) {\n                logRecoverableError(request, error);\n                fatalError(request, error);\n            }\n        }\n        function onError() {}\n        function renderToStringImpl(children, options, generateStaticMarkup, abortReason) {\n            var didFatal = false;\n            var fatalError = null;\n            var result = \"\";\n            var destination = {\n                push: function(chunk) {\n                    if (chunk !== null) {\n                        result += chunk;\n                    }\n                    return true;\n                },\n                destroy: function(error) {\n                    didFatal = true;\n                    fatalError = error;\n                }\n            };\n            var readyToStream = false;\n            function onShellReady() {\n                readyToStream = true;\n            }\n            var request = createRequest(children, createResponseState$1(generateStaticMarkup, options ? options.identifierPrefix : undefined), createRootFormatContext(), Infinity, onError, undefined, onShellReady, undefined, undefined);\n            startWork(request); // If anything suspended and is still pending, we'll abort it before writing.\n            // That way we write only client-rendered boundaries from the start.\n            abort(request, abortReason);\n            startFlowing(request, destination);\n            if (didFatal) {\n                throw fatalError;\n            }\n            if (!readyToStream) {\n                // Note: This error message is the one we use on the client. It doesn't\n                // really make sense here. But this is the legacy server renderer, anyway.\n                // We're going to delete it soon.\n                throw new Error(\"A component suspended while responding to synchronous input. This \" + \"will cause the UI to be replaced with a loading indicator. To fix, \" + \"updates that suspend should be wrapped with startTransition.\");\n            }\n            return result;\n        }\n        function _inheritsLoose(subClass, superClass) {\n            subClass.prototype = Object.create(superClass.prototype);\n            subClass.prototype.constructor = subClass;\n            subClass.__proto__ = superClass;\n        }\n        var ReactMarkupReadableStream = /*#__PURE__*/ function(_Readable) {\n            _inheritsLoose(ReactMarkupReadableStream, _Readable);\n            function ReactMarkupReadableStream() {\n                var _this;\n                // Calls the stream.Readable(options) constructor. Consider exposing built-in\n                // features like highWaterMark in the future.\n                _this = _Readable.call(this, {}) || this;\n                _this.request = null;\n                _this.startedFlowing = false;\n                return _this;\n            }\n            var _proto = ReactMarkupReadableStream.prototype;\n            _proto._destroy = function _destroy(err, callback) {\n                abort(this.request); // $FlowFixMe: The type definition for the callback should allow undefined and null.\n                callback(err);\n            };\n            _proto._read = function _read(size) {\n                if (this.startedFlowing) {\n                    startFlowing(this.request, this);\n                }\n            };\n            return ReactMarkupReadableStream;\n        }(stream.Readable);\n        function onError$1() {}\n        function renderToNodeStreamImpl(children, options, generateStaticMarkup) {\n            function onAllReady() {\n                // We wait until everything has loaded before starting to write.\n                // That way we only end up with fully resolved HTML even if we suspend.\n                destination.startedFlowing = true;\n                startFlowing(request, destination);\n            }\n            var destination = new ReactMarkupReadableStream();\n            var request = createRequest(children, createResponseState$1(false, options ? options.identifierPrefix : undefined), createRootFormatContext(), Infinity, onError$1, onAllReady, undefined, undefined);\n            destination.request = request;\n            startWork(request);\n            return destination;\n        }\n        function renderToNodeStream(children, options) {\n            {\n                error(\"renderToNodeStream is deprecated. Use renderToPipeableStream instead.\");\n            }\n            return renderToNodeStreamImpl(children, options);\n        }\n        function renderToStaticNodeStream(children, options) {\n            return renderToNodeStreamImpl(children, options);\n        }\n        function renderToString(children, options) {\n            return renderToStringImpl(children, options, false, 'The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToPipeableStream\" which supports Suspense on the server');\n        }\n        function renderToStaticMarkup(children, options) {\n            return renderToStringImpl(children, options, true, 'The server used \"renderToStaticMarkup\" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to \"renderToPipeableStream\" which supports Suspense on the server');\n        }\n        exports.renderToNodeStream = renderToNodeStream;\n        exports.renderToStaticMarkup = renderToStaticMarkup;\n        exports.renderToStaticNodeStream = renderToStaticNodeStream;\n        exports.renderToString = renderToString;\n        exports.version = ReactVersion;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS1zZXJ2ZXItbGVnYWN5Lm5vZGUuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0NBUUMsR0FFRDtBQUVBLElBQUlBLElBQXFDLEVBQUU7SUFDeEM7UUFDSDtRQUVBLElBQUlDLFFBQVFDLG1CQUFPQSxDQUFDO1FBQ3BCLElBQUlDLFNBQVNELG1CQUFPQSxDQUFDO1FBRXJCLElBQUlFLGVBQWU7UUFFbkIsSUFBSUMsdUJBQXVCSixNQUFNSyxrREFBa0Q7UUFFbkYsK0NBQStDO1FBQy9DLEVBQUU7UUFDRiw4REFBOEQ7UUFDOUQscUNBQXFDO1FBRXJDLFNBQVNDLEtBQUtDLE1BQU07WUFDbEI7Z0JBQ0U7b0JBQ0UsSUFBSyxJQUFJQyxPQUFPQyxVQUFVQyxNQUFNLEVBQUVDLE9BQU8sSUFBSUMsTUFBTUosT0FBTyxJQUFJQSxPQUFPLElBQUksSUFBSUssT0FBTyxHQUFHQSxPQUFPTCxNQUFNSyxPQUFRO3dCQUMxR0YsSUFBSSxDQUFDRSxPQUFPLEVBQUUsR0FBR0osU0FBUyxDQUFDSSxLQUFLO29CQUNsQztvQkFFQUMsYUFBYSxRQUFRUCxRQUFRSTtnQkFDL0I7WUFDRjtRQUNGO1FBQ0EsU0FBU0ksTUFBTVIsTUFBTTtZQUNuQjtnQkFDRTtvQkFDRSxJQUFLLElBQUlTLFFBQVFQLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSSxRQUFRLElBQUlBLFFBQVEsSUFBSSxJQUFJQyxRQUFRLEdBQUdBLFFBQVFELE9BQU9DLFFBQVM7d0JBQ2pITixJQUFJLENBQUNNLFFBQVEsRUFBRSxHQUFHUixTQUFTLENBQUNRLE1BQU07b0JBQ3BDO29CQUVBSCxhQUFhLFNBQVNQLFFBQVFJO2dCQUNoQztZQUNGO1FBQ0Y7UUFFQSxTQUFTRyxhQUFhSSxLQUFLLEVBQUVYLE1B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NFAsMkJBQTJCbWhCLFVBQVVhLFdBQVc1SyxZQUFZaG5CLFdBQVdBO1lBQzNMM2lCLFlBQVlpcUMsT0FBTyxHQUFHQTtZQUN0QmlKLFVBQVVqSjtZQUNWLE9BQU9qcUM7UUFDVDtRQUVBLFNBQVN5MEMsbUJBQW1CeHBDLFFBQVEsRUFBRXFvQyxPQUFPO1lBQzNDO2dCQUNFMzBDLE1BQU07WUFDUjtZQUVBLE9BQU82MUMsdUJBQXVCdnBDLFVBQVVxb0M7UUFDMUM7UUFFQSxTQUFTb0IseUJBQXlCenBDLFFBQVEsRUFBRXFvQyxPQUFPO1lBQ2pELE9BQU9rQix1QkFBdUJ2cEMsVUFBVXFvQztRQUMxQztRQUVBLFNBQVNxQixlQUFlMXBDLFFBQVEsRUFBRXFvQyxPQUFPO1lBQ3ZDLE9BQU9ELG1CQUFtQnBvQyxVQUFVcW9DLFNBQVMsT0FBTztRQUN0RDtRQUVBLFNBQVNzQixxQkFBcUIzcEMsUUFBUSxFQUFFcW9DLE9BQU87WUFDN0MsT0FBT0QsbUJBQW1CcG9DLFVBQVVxb0MsU0FBUyxNQUFNO1FBQ3JEO1FBRUF1QiwwQkFBMEIsR0FBR0o7UUFDN0JJLDRCQUE0QixHQUFHRDtRQUMvQkMsZ0NBQWdDLEdBQUdIO1FBQ25DRyxzQkFBc0IsR0FBR0Y7UUFDekJFLGVBQWUsR0FBRzkyQztJQUNoQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGlyZXIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS1zZXJ2ZXItbGVnYWN5Lm5vZGUuZGV2ZWxvcG1lbnQuanM/Yjg2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1kb20tc2VydmVyLWxlZ2FjeS5ub2RlLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxudmFyIFJlYWN0VmVyc2lvbiA9ICcxOC4yLjAnO1xuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuLy8gYnkgY2FsbHMgdG8gdGhlc2UgbWV0aG9kcyBieSBhIEJhYmVsIHBsdWdpbi5cbi8vXG4vLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuLy8gdGhleSBhcmUgbGVmdCBhcyB0aGV5IGFyZSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiB3YXJuKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCd3YXJuJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVXb3JrKGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKCk7XG59XG5mdW5jdGlvbiBiZWdpbldyaXRpbmcoZGVzdGluYXRpb24pIHt9XG5mdW5jdGlvbiB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjaHVuaykge1xuICB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjaHVuayk7XG59XG5mdW5jdGlvbiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjaHVuaykge1xuICByZXR1cm4gZGVzdGluYXRpb24ucHVzaChjaHVuayk7XG59XG5mdW5jdGlvbiBjb21wbGV0ZVdyaXRpbmcoZGVzdGluYXRpb24pIHt9XG5mdW5jdGlvbiBjbG9zZShkZXN0aW5hdGlvbikge1xuICBkZXN0aW5hdGlvbi5wdXNoKG51bGwpO1xufVxuZnVuY3Rpb24gc3RyaW5nVG9DaHVuayhjb250ZW50KSB7XG4gIHJldHVybiBjb250ZW50O1xufVxuZnVuY3Rpb24gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGNvbnRlbnQpIHtcbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5mdW5jdGlvbiBjbG9zZVdpdGhFcnJvcihkZXN0aW5hdGlvbiwgZXJyb3IpIHtcbiAgLy8gJEZsb3dGaXhNZTogVGhpcyBpcyBhbiBFcnJvciBvYmplY3Qgb3IgdGhlIGRlc3RpbmF0aW9uIGFjY2VwdHMgb3RoZXIgdHlwZXMuXG4gIGRlc3RpbmF0aW9uLmRlc3Ryb3koZXJyb3IpO1xufVxuXG4vKlxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAqL1xuLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gIHtcbiAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XG4gICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGAlc2AgYXR0cmlidXRlIGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIGF0dHJpYnV0ZU5hbWUsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tDU1NQcm9wZXJ0eVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBwcm9wTmFtZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBgJXNgIENTUyBwcm9wZXJ0eSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCBwcm9wTmFtZSwgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBIVE1MIG1hcmt1cCB1c2VzIGEgdmFsdWUgb2YgdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8vIEEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuLy8gSXQgaXMgaGFuZGxlZCBieSBSZWFjdCBzZXBhcmF0ZWx5IGFuZCBzaG91bGRuJ3QgYmUgd3JpdHRlbiB0byB0aGUgRE9NLlxudmFyIFJFU0VSVkVEID0gMDsgLy8gQSBzaW1wbGUgc3RyaW5nIGF0dHJpYnV0ZS5cbi8vIEF0dHJpYnV0ZXMgdGhhdCBhcmVuJ3QgaW4gdGhlIGZpbHRlciBhcmUgcHJlc3VtZWQgdG8gaGF2ZSB0aGlzIHR5cGUuXG5cbnZhciBTVFJJTkcgPSAxOyAvLyBBIHN0cmluZyBhdHRyaWJ1dGUgdGhhdCBhY2NlcHRzIGJvb2xlYW5zIGluIFJlYWN0LiBJbiBIVE1MLCB0aGVzZSBhcmUgY2FsbGVkXG4vLyBcImVudW1lcmF0ZWRcIiBhdHRyaWJ1dGVzIHdpdGggXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIiBhcyBwb3NzaWJsZSB2YWx1ZXMuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBzZXQgdG8gYSBcInRydWVcIiBzdHJpbmcuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgc2V0IHRvIGEgXCJmYWxzZVwiIHN0cmluZy5cblxudmFyIEJPT0xFQU5JU0hfU1RSSU5HID0gMjsgLy8gQSByZWFsIGJvb2xlYW4gYXR0cmlidXRlLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgcHJlc2VudCAoc2V0IGVpdGhlciB0byBhbiBlbXB0eSBzdHJpbmcgb3IgaXRzIG5hbWUpLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIG9taXR0ZWQuXG5cbnZhciBCT09MRUFOID0gMzsgLy8gQW4gYXR0cmlidXRlIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgcHJlc2VudCAoc2V0IGVpdGhlciB0byBhbiBlbXB0eSBzdHJpbmcgb3IgaXRzIG5hbWUpLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIG9taXR0ZWQuXG4vLyBGb3IgYW55IG90aGVyIHZhbHVlLCBzaG91bGQgYmUgcHJlc2VudCB3aXRoIHRoYXQgdmFsdWUuXG5cbnZhciBPVkVSTE9BREVEX0JPT0xFQU4gPSA0OyAvLyBBbiBhdHRyaWJ1dGUgdGhhdCBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljLlxuLy8gV2hlbiBmYWxzeSwgaXQgc2hvdWxkIGJlIHJlbW92ZWQuXG5cbnZhciBOVU1FUklDID0gNTsgLy8gQW4gYXR0cmlidXRlIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgcG9zaXRpdmUgbnVtZXJpYy5cbi8vIFdoZW4gZmFsc3ksIGl0IHNob3VsZCBiZSByZW1vdmVkLlxuXG52YXIgUE9TSVRJVkVfTlVNRVJJQyA9IDY7XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbnZhciBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSID0gXCI6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXCI7XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxudmFyIEFUVFJJQlVURV9OQU1FX0NIQVIgPSBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgXCJcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MFwiO1xudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICddWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbnZhciB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzQXR0cmlidXRlTmFtZVNhZmUoYXR0cmlidXRlTmFtZSkge1xuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuXG4gIHtcbiAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogYCVzYCcsIGF0dHJpYnV0ZU5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCAmJiBwcm9wZXJ0eUluZm8udHlwZSA9PT0gUkVTRVJWRUQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzogLy8gJEZsb3dJc3N1ZSBzeW1ib2wgaXMgcGVyZmVjdGx5IHZhbGlkIGhlcmVcblxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAge1xuICAgICAgICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICFwcm9wZXJ0eUluZm8uYWNjZXB0c0Jvb2xlYW5zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeCAhPT0gJ2RhdGEtJyAmJiBwcmVmaXggIT09ICdhcmlhLSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFByb3BlcnR5SW5mbyhuYW1lKSB7XG4gIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gcHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCB0eXBlLCBtdXN0VXNlUHJvcGVydHksIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZU5hbWVzcGFjZSwgc2FuaXRpemVVUkwsIHJlbW92ZUVtcHR5U3RyaW5nKSB7XG4gIHRoaXMuYWNjZXB0c0Jvb2xlYW5zID0gdHlwZSA9PT0gQk9PTEVBTklTSF9TVFJJTkcgfHwgdHlwZSA9PT0gQk9PTEVBTiB8fCB0eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU47XG4gIHRoaXMuYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gIHRoaXMuYXR0cmlidXRlTmFtZXNwYWNlID0gYXR0cmlidXRlTmFtZXNwYWNlO1xuICB0aGlzLm11c3RVc2VQcm9wZXJ0eSA9IG11c3RVc2VQcm9wZXJ0eTtcbiAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBuYW1lO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnNhbml0aXplVVJMID0gc2FuaXRpemVVUkw7XG4gIHRoaXMucmVtb3ZlRW1wdHlTdHJpbmcgPSByZW1vdmVFbXB0eVN0cmluZztcbn0gLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGlzIGxpc3QsIGJlIHN1cmUgdG8gYWxzbyBhZGQgdGhlbSB0b1xuLy8gdGhlIGBwb3NzaWJsZVN0YW5kYXJkTmFtZXNgIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3Rcbi8vIG5hbWUgd2FybmluZ3MuXG5cblxudmFyIHByb3BlcnRpZXMgPSB7fTsgLy8gVGhlc2UgcHJvcHMgYXJlIHJlc2VydmVkIGJ5IFJlYWN0LiBUaGV5IHNob3VsZG4ndCBiZSB3cml0dGVuIHRvIHRoZSBET00uXG5cbnZhciByZXNlcnZlZFByb3BzID0gWydjaGlsZHJlbicsICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsIC8vIFRPRE86IFRoaXMgcHJldmVudHMgdGhlIGFzc2lnbm1lbnQgb2YgZGVmYXVsdFZhbHVlIHRvIHJlZ3VsYXJcbi8vIGVsZW1lbnRzIChub3QganVzdCBpbnB1dHMpLiBOb3cgdGhhdCBSZWFjdERPTUlucHV0IGFzc2lnbnMgdG8gdGhlXG4vLyBkZWZhdWx0VmFsdWUgcHJvcGVydHkgLS0gZG8gd2UgbmVlZCB0aGlzP1xuJ2RlZmF1bHRWYWx1ZScsICdkZWZhdWx0Q2hlY2tlZCcsICdpbm5lckhUTUwnLCAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJywgJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsICdzdHlsZSddO1xuXG5yZXNlcnZlZFByb3BzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgUkVTRVJWRUQsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBBIGZldyBSZWFjdCBzdHJpbmcgYXR0cmlidXRlcyBoYXZlIGEgZGlmZmVyZW50IG5hbWUuXG4vLyBUaGlzIGlzIGEgbWFwcGluZyBmcm9tIFJlYWN0IHByb3AgbmFtZXMgdG8gdGhlIGF0dHJpYnV0ZSBuYW1lcy5cblxuW1snYWNjZXB0Q2hhcnNldCcsICdhY2NlcHQtY2hhcnNldCddLCBbJ2NsYXNzTmFtZScsICdjbGFzcyddLCBbJ2h0bWxGb3InLCAnZm9yJ10sIFsnaHR0cEVxdWl2JywgJ2h0dHAtZXF1aXYnXV0uZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgbmFtZSA9IF9yZWZbMF0sXG4gICAgICBhdHRyaWJ1dGVOYW1lID0gX3JlZlsxXTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIFwiZW51bWVyYXRlZFwiIEhUTUwgYXR0cmlidXRlcyB0aGF0IGFjY2VwdCBcInRydWVcIiBhbmQgXCJmYWxzZVwiLlxuLy8gSW4gUmVhY3QsIHdlIGxldCB1c2VycyBwYXNzIGB0cnVlYCBhbmQgYGZhbHNlYCBldmVuIHRob3VnaCB0ZWNobmljYWxseVxuLy8gdGhlc2UgYXJlbid0IGJvb2xlYW4gYXR0cmlidXRlcyAodGhleSBhcmUgY29lcmNlZCB0byBzdHJpbmdzKS5cblxuWydjb250ZW50RWRpdGFibGUnLCAnZHJhZ2dhYmxlJywgJ3NwZWxsQ2hlY2snLCAndmFsdWUnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU5JU0hfU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgXCJlbnVtZXJhdGVkXCIgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBhY2NlcHQgXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIi5cbi8vIEluIFJlYWN0LCB3ZSBsZXQgdXNlcnMgcGFzcyBgdHJ1ZWAgYW5kIGBmYWxzZWAgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHlcbi8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG4vLyBTaW5jZSB0aGVzZSBhcmUgU1ZHIGF0dHJpYnV0ZXMsIHRoZWlyIGF0dHJpYnV0ZSBuYW1lcyBhcmUgY2FzZS1zZW5zaXRpdmUuXG5cblsnYXV0b1JldmVyc2UnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdmb2N1c2FibGUnLCAncHJlc2VydmVBbHBoYSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTklTSF9TVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgSFRNTCBib29sZWFuIGF0dHJpYnV0ZXMuXG5cblsnYWxsb3dGdWxsU2NyZWVuJywgJ2FzeW5jJywgLy8gTm90ZTogdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBwcmV2ZW50cyBpdCBmcm9tIGJlaW5nIHdyaXR0ZW4gdG8gdGhlIERPTVxuLy8gb24gdGhlIGNsaWVudCBzaWRlIGJlY2F1c2UgdGhlIGJyb3dzZXJzIGFyZSBpbmNvbnNpc3RlbnQuIEluc3RlYWQgd2UgY2FsbCBmb2N1cygpLlxuJ2F1dG9Gb2N1cycsICdhdXRvUGxheScsICdjb250cm9scycsICdkZWZhdWx0JywgJ2RlZmVyJywgJ2Rpc2FibGVkJywgJ2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJywgJ2Rpc2FibGVSZW1vdGVQbGF5YmFjaycsICdmb3JtTm9WYWxpZGF0ZScsICdoaWRkZW4nLCAnbG9vcCcsICdub01vZHVsZScsICdub1ZhbGlkYXRlJywgJ29wZW4nLCAncGxheXNJbmxpbmUnLCAncmVhZE9ubHknLCAncmVxdWlyZWQnLCAncmV2ZXJzZWQnLCAnc2NvcGVkJywgJ3NlYW1sZXNzJywgLy8gTWljcm9kYXRhXG4naXRlbVNjb3BlJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgdGhlIGZldyBSZWFjdCBwcm9wcyB0aGF0IHdlIHNldCBhcyBET00gcHJvcGVydGllc1xuLy8gcmF0aGVyIHRoYW4gYXR0cmlidXRlcy4gVGhlc2UgYXJlIGFsbCBib29sZWFucy5cblxuWydjaGVja2VkJywgLy8gTm90ZTogYG9wdGlvbi5zZWxlY3RlZGAgaXMgbm90IHVwZGF0ZWQgaWYgYHNlbGVjdC5tdWx0aXBsZWAgaXNcbi8vIGRpc2FibGVkIHdpdGggYHJlbW92ZUF0dHJpYnV0ZWAuIFdlIGhhdmUgc3BlY2lhbCBsb2dpYyBmb3IgaGFuZGxpbmcgdGhpcy5cbidtdWx0aXBsZScsICdtdXRlZCcsICdzZWxlY3RlZCcgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTiwgdHJ1ZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IGFyZSBcIm92ZXJsb2FkZWQgYm9vbGVhbnNcIjogdGhleSBiZWhhdmUgbGlrZVxuLy8gYm9vbGVhbnMsIGJ1dCBjYW4gYWxzbyBhY2NlcHQgYSBzdHJpbmcgdmFsdWUuXG5cblsnY2FwdHVyZScsICdkb3dubG9hZCcgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgT1ZFUkxPQURFRF9CT09MRUFOLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtYmVycy5cblxuWydjb2xzJywgJ3Jvd3MnLCAnc2l6ZScsICdzcGFuJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBQT1NJVElWRV9OVU1FUklDLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IG11c3QgYmUgbnVtYmVycy5cblxuWydyb3dTcGFuJywgJ3N0YXJ0J10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBOVU1FUklDLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pO1xudmFyIENBTUVMSVpFID0gL1tcXC1cXDpdKFthLXpdKS9nO1xuXG52YXIgY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICByZXR1cm4gdG9rZW5bMV0udG9VcHBlckNhc2UoKTtcbn07IC8vIFRoaXMgaXMgYSBsaXN0IG9mIGFsbCBTVkcgYXR0cmlidXRlcyB0aGF0IG5lZWQgc3BlY2lhbCBjYXNpbmcsIG5hbWVzcGFjaW5nLFxuLy8gb3IgYm9vbGVhbiB2YWx1ZSBhc3NpZ25tZW50LiBSZWd1bGFyIGF0dHJpYnV0ZXMgdGhhdCBqdXN0IGFjY2VwdCBzdHJpbmdzXG4vLyBhbmQgaGF2ZSB0aGUgc2FtZSBuYW1lcyBhcmUgb21pdHRlZCwganVzdCBsaWtlIGluIHRoZSBIVE1MIGF0dHJpYnV0ZSBmaWx0ZXIuXG4vLyBTb21lIG9mIHRoZXNlIGF0dHJpYnV0ZXMgY2FuIGJlIGhhcmQgdG8gZmluZC4gVGhpcyBsaXN0IHdhcyBjcmVhdGVkIGJ5XG4vLyBzY3JhcGluZyB0aGUgTUROIGRvY3VtZW50YXRpb24uXG5cblxuWydhY2NlbnQtaGVpZ2h0JywgJ2FsaWdubWVudC1iYXNlbGluZScsICdhcmFiaWMtZm9ybScsICdiYXNlbGluZS1zaGlmdCcsICdjYXAtaGVpZ2h0JywgJ2NsaXAtcGF0aCcsICdjbGlwLXJ1bGUnLCAnY29sb3ItaW50ZXJwb2xhdGlvbicsICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnY29sb3ItcHJvZmlsZScsICdjb2xvci1yZW5kZXJpbmcnLCAnZG9taW5hbnQtYmFzZWxpbmUnLCAnZW5hYmxlLWJhY2tncm91bmQnLCAnZmlsbC1vcGFjaXR5JywgJ2ZpbGwtcnVsZScsICdmbG9vZC1jb2xvcicsICdmbG9vZC1vcGFjaXR5JywgJ2ZvbnQtZmFtaWx5JywgJ2ZvbnQtc2l6ZScsICdmb250LXNpemUtYWRqdXN0JywgJ2ZvbnQtc3RyZXRjaCcsICdmb250LXN0eWxlJywgJ2ZvbnQtdmFyaWFudCcsICdmb250LXdlaWdodCcsICdnbHlwaC1uYW1lJywgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnLCAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnLCAnaG9yaXotYWR2LXgnLCAnaG9yaXotb3JpZ2luLXgnLCAnaW1hZ2UtcmVuZGVyaW5nJywgJ2xldHRlci1zcGFjaW5nJywgJ2xpZ2h0aW5nLWNvbG9yJywgJ21hcmtlci1lbmQnLCAnbWFya2VyLW1pZCcsICdtYXJrZXItc3RhcnQnLCAnb3ZlcmxpbmUtcG9zaXRpb24nLCAnb3ZlcmxpbmUtdGhpY2tuZXNzJywgJ3BhaW50LW9yZGVyJywgJ3Bhbm9zZS0xJywgJ3BvaW50ZXItZXZlbnRzJywgJ3JlbmRlcmluZy1pbnRlbnQnLCAnc2hhcGUtcmVuZGVyaW5nJywgJ3N0b3AtY29sb3InLCAnc3RvcC1vcGFjaXR5JywgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nLCAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnLCAnc3Ryb2tlLWRhc2hhcnJheScsICdzdHJva2UtZGFzaG9mZnNldCcsICdzdHJva2UtbGluZWNhcCcsICdzdHJva2UtbGluZWpvaW4nLCAnc3Ryb2tlLW1pdGVybGltaXQnLCAnc3Ryb2tlLW9wYWNpdHknLCAnc3Ryb2tlLXdpZHRoJywgJ3RleHQtYW5jaG9yJywgJ3RleHQtZGVjb3JhdGlvbicsICd0ZXh0LXJlbmRlcmluZycsICd1bmRlcmxpbmUtcG9zaXRpb24nLCAndW5kZXJsaW5lLXRoaWNrbmVzcycsICd1bmljb2RlLWJpZGknLCAndW5pY29kZS1yYW5nZScsICd1bml0cy1wZXItZW0nLCAndi1hbHBoYWJldGljJywgJ3YtaGFuZ2luZycsICd2LWlkZW9ncmFwaGljJywgJ3YtbWF0aGVtYXRpY2FsJywgJ3ZlY3Rvci1lZmZlY3QnLCAndmVydC1hZHYteScsICd2ZXJ0LW9yaWdpbi14JywgJ3ZlcnQtb3JpZ2luLXknLCAnd29yZC1zcGFjaW5nJywgJ3dyaXRpbmctbW9kZScsICd4bWxuczp4bGluaycsICd4LWhlaWdodCcgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gU3RyaW5nIFNWRyBhdHRyaWJ1dGVzIHdpdGggdGhlIHhsaW5rIG5hbWVzcGFjZS5cblxuWyd4bGluazphY3R1YXRlJywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6cm9sZScsICd4bGluazpzaG93JywgJ3hsaW5rOnRpdGxlJywgJ3hsaW5rOnR5cGUnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBTdHJpbmcgU1ZHIGF0dHJpYnV0ZXMgd2l0aCB0aGUgeG1sIG5hbWVzcGFjZS5cblxuWyd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnLCBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGF0dHJpYnV0ZSBleGlzdHMgYm90aCBpbiBIVE1MIGFuZCBTVkcuXG4vLyBUaGUgYXR0cmlidXRlIG5hbWUgaXMgY2FzZS1zZW5zaXRpdmUgaW4gU1ZHIHNvIHdlIGNhbid0IGp1c3QgdXNlXG4vLyB0aGUgUmVhY3QgbmFtZSBsaWtlIHdlIGRvIGZvciBhdHRyaWJ1dGVzIHRoYXQgZXhpc3Qgb25seSBpbiBIVE1MLlxuXG5bJ3RhYkluZGV4JywgJ2Nyb3NzT3JpZ2luJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICBwcm9wZXJ0aWVzW2F0dHJpYnV0ZU5hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChhdHRyaWJ1dGVOYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGF0dHJpYnV0ZXMgYWNjZXB0IFVSTHMuIFRoZXNlIG11c3Qgbm90IGFsbG93IGphdmFzY3JpcHQ6IFVSTFMuXG4vLyBUaGVzZSB3aWxsIGFsc28gbmVlZCB0byBhY2NlcHQgVHJ1c3RlZCBUeXBlcyBvYmplY3QgaW4gdGhlIGZ1dHVyZS5cblxudmFyIHhsaW5rSHJlZiA9ICd4bGlua0hyZWYnO1xucHJvcGVydGllc1t4bGlua0hyZWZdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZCgneGxpbmtIcmVmJywgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4neGxpbms6aHJlZicsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgdHJ1ZSwgLy8gc2FuaXRpemVVUkxcbmZhbHNlKTtcblsnc3JjJywgJ2hyZWYnLCAnYWN0aW9uJywgJ2Zvcm1BY3Rpb24nXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHByb3BlcnRpZXNbYXR0cmlidXRlTmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKGF0dHJpYnV0ZU5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIHRydWUsIC8vIHNhbml0aXplVVJMXG4gIHRydWUpO1xufSk7XG5cbi8qKlxuICogQ1NTIHByb3BlcnRpZXMgd2hpY2ggYWNjZXB0IG51bWJlcnMgYnV0IGFyZSBub3QgaW4gdW5pdHMgb2YgXCJweFwiLlxuICovXG52YXIgaXNVbml0bGVzc051bWJlciA9IHtcbiAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHRydWUsXG4gIGFzcGVjdFJhdGlvOiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBjb2x1bW5zOiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZEFyZWE6IHRydWUsXG4gIGdyaWRSb3c6IHRydWUsXG4gIGdyaWRSb3dFbmQ6IHRydWUsXG4gIGdyaWRSb3dTcGFuOiB0cnVlLFxuICBncmlkUm93U3RhcnQ6IHRydWUsXG4gIGdyaWRDb2x1bW46IHRydWUsXG4gIGdyaWRDb2x1bW5FbmQ6IHRydWUsXG4gIGdyaWRDb2x1bW5TcGFuOiB0cnVlLFxuICBncmlkQ29sdW1uU3RhcnQ6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIGZpbGxPcGFjaXR5OiB0cnVlLFxuICBmbG9vZE9wYWNpdHk6IHRydWUsXG4gIHN0b3BPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VEYXNoYXJyYXk6IHRydWUsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IHRydWUsXG4gIHN0cm9rZU1pdGVybGltaXQ6IHRydWUsXG4gIHN0cm9rZU9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZVdpZHRoOiB0cnVlXG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBzdHlsZSBuYW1lIHByZWZpeGVkIHdpdGggYHByZWZpeGAsIHByb3Blcmx5IGNhbWVsQ2FzZWQsIGVnOlxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXG4gKi9cblxuZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCwga2V5KSB7XG4gIHJldHVybiBwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xufVxuLyoqXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcbiAqIG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xuXG5cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107IC8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuXG5PYmplY3Qua2V5cyhpc1VuaXRsZXNzTnVtYmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxudmFyIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gIGJ1dHRvbjogdHJ1ZSxcbiAgY2hlY2tib3g6IHRydWUsXG4gIGltYWdlOiB0cnVlLFxuICBoaWRkZW46IHRydWUsXG4gIHJhZGlvOiB0cnVlLFxuICByZXNldDogdHJ1ZSxcbiAgc3VibWl0OiB0cnVlXG59O1xuZnVuY3Rpb24gY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyh0YWdOYW1lLCBwcm9wcykge1xuICB7XG4gICAgaWYgKCEoaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5vbklucHV0IHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkIHx8IHByb3BzLnZhbHVlID09IG51bGwpKSB7XG4gICAgICBlcnJvcignWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIShwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy5jaGVja2VkID09IG51bGwpKSB7XG4gICAgICBlcnJvcignWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzQ3VzdG9tQ29tcG9uZW50KHRhZ05hbWUsIHByb3BzKSB7XG4gIGlmICh0YWdOYW1lLmluZGV4T2YoJy0nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByb3BzLmlzID09PSAnc3RyaW5nJztcbiAgfVxuXG4gIHN3aXRjaCAodGFnTmFtZSkge1xuICAgIC8vIFRoZXNlIGFyZSByZXNlcnZlZCBTVkcgYW5kIE1hdGhNTCBlbGVtZW50cy5cbiAgICAvLyBXZSBkb24ndCBtaW5kIHRoaXMgbGlzdCB0b28gbXVjaCBiZWNhdXNlIHdlIGV4cGVjdCBpdCB0byBuZXZlciBncm93LlxuICAgIC8vIFRoZSBhbHRlcm5hdGl2ZSBpcyB0byB0cmFjayB0aGUgbmFtZXNwYWNlIGluIGEgZmV3IHBsYWNlcyB3aGljaCBpcyBjb252b2x1dGVkLlxuICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvY3VzdG9tLyNjdXN0b20tZWxlbWVudHMtY29yZS1jb25jZXB0c1xuICAgIGNhc2UgJ2Fubm90YXRpb24teG1sJzpcbiAgICBjYXNlICdjb2xvci1wcm9maWxlJzpcbiAgICBjYXNlICdmb250LWZhY2UnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1zcmMnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS11cmknOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1mb3JtYXQnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1uYW1lJzpcbiAgICBjYXNlICdtaXNzaW5nLWdseXBoJzpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG52YXIgYXJpYVByb3BlcnRpZXMgPSB7XG4gICdhcmlhLWN1cnJlbnQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1kZXNjcmlwdGlvbic6IDAsXG4gICdhcmlhLWRldGFpbHMnOiAwLFxuICAnYXJpYS1kaXNhYmxlZCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWhpZGRlbic6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWludmFsaWQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1rZXlzaG9ydGN1dHMnOiAwLFxuICAnYXJpYS1sYWJlbCc6IDAsXG4gICdhcmlhLXJvbGVkZXNjcmlwdGlvbic6IDAsXG4gIC8vIFdpZGdldCBBdHRyaWJ1dGVzXG4gICdhcmlhLWF1dG9jb21wbGV0ZSc6IDAsXG4gICdhcmlhLWNoZWNrZWQnOiAwLFxuICAnYXJpYS1leHBhbmRlZCc6IDAsXG4gICdhcmlhLWhhc3BvcHVwJzogMCxcbiAgJ2FyaWEtbGV2ZWwnOiAwLFxuICAnYXJpYS1tb2RhbCc6IDAsXG4gICdhcmlhLW11bHRpbGluZSc6IDAsXG4gICdhcmlhLW11bHRpc2VsZWN0YWJsZSc6IDAsXG4gICdhcmlhLW9yaWVudGF0aW9uJzogMCxcbiAgJ2FyaWEtcGxhY2Vob2xkZXInOiAwLFxuICAnYXJpYS1wcmVzc2VkJzogMCxcbiAgJ2FyaWEtcmVhZG9ubHknOiAwLFxuICAnYXJpYS1yZXF1aXJlZCc6IDAsXG4gICdhcmlhLXNlbGVjdGVkJzogMCxcbiAgJ2FyaWEtc29ydCc6IDAsXG4gICdhcmlhLXZhbHVlbWF4JzogMCxcbiAgJ2FyaWEtdmFsdWVtaW4nOiAwLFxuICAnYXJpYS12YWx1ZW5vdyc6IDAsXG4gICdhcmlhLXZhbHVldGV4dCc6IDAsXG4gIC8vIExpdmUgUmVnaW9uIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXRvbWljJzogMCxcbiAgJ2FyaWEtYnVzeSc6IDAsXG4gICdhcmlhLWxpdmUnOiAwLFxuICAnYXJpYS1yZWxldmFudCc6IDAsXG4gIC8vIERyYWctYW5kLURyb3AgQXR0cmlidXRlc1xuICAnYXJpYS1kcm9wZWZmZWN0JzogMCxcbiAgJ2FyaWEtZ3JhYmJlZCc6IDAsXG4gIC8vIFJlbGF0aW9uc2hpcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiAwLFxuICAnYXJpYS1jb2xjb3VudCc6IDAsXG4gICdhcmlhLWNvbGluZGV4JzogMCxcbiAgJ2FyaWEtY29sc3Bhbic6IDAsXG4gICdhcmlhLWNvbnRyb2xzJzogMCxcbiAgJ2FyaWEtZGVzY3JpYmVkYnknOiAwLFxuICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiAwLFxuICAnYXJpYS1mbG93dG8nOiAwLFxuICAnYXJpYS1sYWJlbGxlZGJ5JzogMCxcbiAgJ2FyaWEtb3ducyc6IDAsXG4gICdhcmlhLXBvc2luc2V0JzogMCxcbiAgJ2FyaWEtcm93Y291bnQnOiAwLFxuICAnYXJpYS1yb3dpbmRleCc6IDAsXG4gICdhcmlhLXJvd3NwYW4nOiAwLFxuICAnYXJpYS1zZXRzaXplJzogMFxufTtcblxudmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcbnZhciByQVJJQSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIHJBUklBQ2FtZWwgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkodGFnTmFtZSwgbmFtZSkge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcywgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHJBUklBQ2FtZWwudGVzdChuYW1lKSkge1xuICAgICAgdmFyIGFyaWFOYW1lID0gJ2FyaWEtJyArIG5hbWUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBjb3JyZWN0TmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGFyaWFOYW1lKSA/IGFyaWFOYW1lIDogbnVsbDsgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG5cbiAgICAgIGlmIChjb3JyZWN0TmFtZSA9PSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIEFSSUEgYXR0cmlidXRlcyBmb2xsb3cgdGhlIHBhdHRlcm4gYXJpYS0qIGFuZCBtdXN0IGJlIGxvd2VyY2FzZS4nLCBuYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuXG5cbiAgICAgIGlmIChuYW1lICE9PSBjb3JyZWN0TmFtZSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBjb3JyZWN0TmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyQVJJQS50ZXN0KG5hbWUpKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBudWxsOyAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cblxuICAgICAgaWYgKHN0YW5kYXJkTmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuXG5cbiAgICAgIGlmIChuYW1lICE9PSBzdGFuZGFyZE5hbWUpIHtcbiAgICAgICAgZXJyb3IoJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKSB7XG4gIHtcbiAgICB2YXIgaW52YWxpZFByb3BzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSh0eXBlLCBrZXkpO1xuXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgaW52YWxpZFByb3BzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSBpbnZhbGlkUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgICB9KS5qb2luKCcsICcpO1xuXG4gICAgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWFyaWEtcHJvcHMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfSBlbHNlIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID4gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWFyaWEtcHJvcHMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcykge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpO1xufVxuXG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpIHtcbiAge1xuICAgIGlmICh0eXBlICE9PSAnaW5wdXQnICYmIHR5cGUgIT09ICd0ZXh0YXJlYScgJiYgdHlwZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMgIT0gbnVsbCAmJiBwcm9wcy52YWx1ZSA9PT0gbnVsbCAmJiAhZGlkV2FyblZhbHVlTnVsbCkge1xuICAgICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlID09PSAnc2VsZWN0JyAmJiBwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgICBlcnJvcignYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgICcgKyAndG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJywgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IHN0cmluZyB0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgICcgKyAnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLicsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoZSBIVE1MIG9yIFNWRyBhbGxvd2VkIGF0dHJpYnV0ZSBsaXN0LCBiZSBzdXJlIHRvXG4vLyBhbHNvIGFkZCB0aGVtIHRvIHRoaXMgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdCBuYW1lXG4vLyB3YXJuaW5ncy5cbnZhciBwb3NzaWJsZVN0YW5kYXJkTmFtZXMgPSB7XG4gIC8vIEhUTUxcbiAgYWNjZXB0OiAnYWNjZXB0JyxcbiAgYWNjZXB0Y2hhcnNldDogJ2FjY2VwdENoYXJzZXQnLFxuICAnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG4gIGFjY2Vzc2tleTogJ2FjY2Vzc0tleScsXG4gIGFjdGlvbjogJ2FjdGlvbicsXG4gIGFsbG93ZnVsbHNjcmVlbjogJ2FsbG93RnVsbFNjcmVlbicsXG4gIGFsdDogJ2FsdCcsXG4gIGFzOiAnYXMnLFxuICBhc3luYzogJ2FzeW5jJyxcbiAgYXV0b2NhcGl0YWxpemU6ICdhdXRvQ2FwaXRhbGl6ZScsXG4gIGF1dG9jb21wbGV0ZTogJ2F1dG9Db21wbGV0ZScsXG4gIGF1dG9jb3JyZWN0OiAnYXV0b0NvcnJlY3QnLFxuICBhdXRvZm9jdXM6ICdhdXRvRm9jdXMnLFxuICBhdXRvcGxheTogJ2F1dG9QbGF5JyxcbiAgYXV0b3NhdmU6ICdhdXRvU2F2ZScsXG4gIGNhcHR1cmU6ICdjYXB0dXJlJyxcbiAgY2VsbHBhZGRpbmc6ICdjZWxsUGFkZGluZycsXG4gIGNlbGxzcGFjaW5nOiAnY2VsbFNwYWNpbmcnLFxuICBjaGFsbGVuZ2U6ICdjaGFsbGVuZ2UnLFxuICBjaGFyc2V0OiAnY2hhclNldCcsXG4gIGNoZWNrZWQ6ICdjaGVja2VkJyxcbiAgY2hpbGRyZW46ICdjaGlsZHJlbicsXG4gIGNpdGU6ICdjaXRlJyxcbiAgY2xhc3M6ICdjbGFzc05hbWUnLFxuICBjbGFzc2lkOiAnY2xhc3NJRCcsXG4gIGNsYXNzbmFtZTogJ2NsYXNzTmFtZScsXG4gIGNvbHM6ICdjb2xzJyxcbiAgY29sc3BhbjogJ2NvbFNwYW4nLFxuICBjb250ZW50OiAnY29udGVudCcsXG4gIGNvbnRlbnRlZGl0YWJsZTogJ2NvbnRlbnRFZGl0YWJsZScsXG4gIGNvbnRleHRtZW51OiAnY29udGV4dE1lbnUnLFxuICBjb250cm9sczogJ2NvbnRyb2xzJyxcbiAgY29udHJvbHNsaXN0OiAnY29udHJvbHNMaXN0JyxcbiAgY29vcmRzOiAnY29vcmRzJyxcbiAgY3Jvc3NvcmlnaW46ICdjcm9zc09yaWdpbicsXG4gIGRhbmdlcm91c2x5c2V0aW5uZXJodG1sOiAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLFxuICBkYXRhOiAnZGF0YScsXG4gIGRhdGV0aW1lOiAnZGF0ZVRpbWUnLFxuICBkZWZhdWx0OiAnZGVmYXVsdCcsXG4gIGRlZmF1bHRjaGVja2VkOiAnZGVmYXVsdENoZWNrZWQnLFxuICBkZWZhdWx0dmFsdWU6ICdkZWZhdWx0VmFsdWUnLFxuICBkZWZlcjogJ2RlZmVyJyxcbiAgZGlyOiAnZGlyJyxcbiAgZGlzYWJsZWQ6ICdkaXNhYmxlZCcsXG4gIGRpc2FibGVwaWN0dXJlaW5waWN0dXJlOiAnZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUnLFxuICBkaXNhYmxlcmVtb3RlcGxheWJhY2s6ICdkaXNhYmxlUmVtb3RlUGxheWJhY2snLFxuICBkb3dubG9hZDogJ2Rvd25sb2FkJyxcbiAgZHJhZ2dhYmxlOiAnZHJhZ2dhYmxlJyxcbiAgZW5jdHlwZTogJ2VuY1R5cGUnLFxuICBlbnRlcmtleWhpbnQ6ICdlbnRlcktleUhpbnQnLFxuICBmb3I6ICdodG1sRm9yJyxcbiAgZm9ybTogJ2Zvcm0nLFxuICBmb3JtbWV0aG9kOiAnZm9ybU1ldGhvZCcsXG4gIGZvcm1hY3Rpb246ICdmb3JtQWN0aW9uJyxcbiAgZm9ybWVuY3R5cGU6ICdmb3JtRW5jVHlwZScsXG4gIGZvcm1ub3ZhbGlkYXRlOiAnZm9ybU5vVmFsaWRhdGUnLFxuICBmb3JtdGFyZ2V0OiAnZm9ybVRhcmdldCcsXG4gIGZyYW1lYm9yZGVyOiAnZnJhbWVCb3JkZXInLFxuICBoZWFkZXJzOiAnaGVhZGVycycsXG4gIGhlaWdodDogJ2hlaWdodCcsXG4gIGhpZGRlbjogJ2hpZGRlbicsXG4gIGhpZ2g6ICdoaWdoJyxcbiAgaHJlZjogJ2hyZWYnLFxuICBocmVmbGFuZzogJ2hyZWZMYW5nJyxcbiAgaHRtbGZvcjogJ2h0bWxGb3InLFxuICBodHRwZXF1aXY6ICdodHRwRXF1aXYnLFxuICAnaHR0cC1lcXVpdic6ICdodHRwRXF1aXYnLFxuICBpY29uOiAnaWNvbicsXG4gIGlkOiAnaWQnLFxuICBpbWFnZXNpemVzOiAnaW1hZ2VTaXplcycsXG4gIGltYWdlc3Jjc2V0OiAnaW1hZ2VTcmNTZXQnLFxuICBpbm5lcmh0bWw6ICdpbm5lckhUTUwnLFxuICBpbnB1dG1vZGU6ICdpbnB1dE1vZGUnLFxuICBpbnRlZ3JpdHk6ICdpbnRlZ3JpdHknLFxuICBpczogJ2lzJyxcbiAgaXRlbWlkOiAnaXRlbUlEJyxcbiAgaXRlbXByb3A6ICdpdGVtUHJvcCcsXG4gIGl0ZW1yZWY6ICdpdGVtUmVmJyxcbiAgaXRlbXNjb3BlOiAnaXRlbVNjb3BlJyxcbiAgaXRlbXR5cGU6ICdpdGVtVHlwZScsXG4gIGtleXBhcmFtczogJ2tleVBhcmFtcycsXG4gIGtleXR5cGU6ICdrZXlUeXBlJyxcbiAga2luZDogJ2tpbmQnLFxuICBsYWJlbDogJ2xhYmVsJyxcbiAgbGFuZzogJ2xhbmcnLFxuICBsaXN0OiAnbGlzdCcsXG4gIGxvb3A6ICdsb29wJyxcbiAgbG93OiAnbG93JyxcbiAgbWFuaWZlc3Q6ICdtYW5pZmVzdCcsXG4gIG1hcmdpbndpZHRoOiAnbWFyZ2luV2lkdGgnLFxuICBtYXJnaW5oZWlnaHQ6ICdtYXJnaW5IZWlnaHQnLFxuICBtYXg6ICdtYXgnLFxuICBtYXhsZW5ndGg6ICdtYXhMZW5ndGgnLFxuICBtZWRpYTogJ21lZGlhJyxcbiAgbWVkaWFncm91cDogJ21lZGlhR3JvdXAnLFxuICBtZXRob2Q6ICdtZXRob2QnLFxuICBtaW46ICdtaW4nLFxuICBtaW5sZW5ndGg6ICdtaW5MZW5ndGgnLFxuICBtdWx0aXBsZTogJ211bHRpcGxlJyxcbiAgbXV0ZWQ6ICdtdXRlZCcsXG4gIG5hbWU6ICduYW1lJyxcbiAgbm9tb2R1bGU6ICdub01vZHVsZScsXG4gIG5vbmNlOiAnbm9uY2UnLFxuICBub3ZhbGlkYXRlOiAnbm9WYWxpZGF0ZScsXG4gIG9wZW46ICdvcGVuJyxcbiAgb3B0aW11bTogJ29wdGltdW0nLFxuICBwYXR0ZXJuOiAncGF0dGVybicsXG4gIHBsYWNlaG9sZGVyOiAncGxhY2Vob2xkZXInLFxuICBwbGF5c2lubGluZTogJ3BsYXlzSW5saW5lJyxcbiAgcG9zdGVyOiAncG9zdGVyJyxcbiAgcHJlbG9hZDogJ3ByZWxvYWQnLFxuICBwcm9maWxlOiAncHJvZmlsZScsXG4gIHJhZGlvZ3JvdXA6ICdyYWRpb0dyb3VwJyxcbiAgcmVhZG9ubHk6ICdyZWFkT25seScsXG4gIHJlZmVycmVycG9saWN5OiAncmVmZXJyZXJQb2xpY3knLFxuICByZWw6ICdyZWwnLFxuICByZXF1aXJlZDogJ3JlcXVpcmVkJyxcbiAgcmV2ZXJzZWQ6ICdyZXZlcnNlZCcsXG4gIHJvbGU6ICdyb2xlJyxcbiAgcm93czogJ3Jvd3MnLFxuICByb3dzcGFuOiAncm93U3BhbicsXG4gIHNhbmRib3g6ICdzYW5kYm94JyxcbiAgc2NvcGU6ICdzY29wZScsXG4gIHNjb3BlZDogJ3Njb3BlZCcsXG4gIHNjcm9sbGluZzogJ3Njcm9sbGluZycsXG4gIHNlYW1sZXNzOiAnc2VhbWxlc3MnLFxuICBzZWxlY3RlZDogJ3NlbGVjdGVkJyxcbiAgc2hhcGU6ICdzaGFwZScsXG4gIHNpemU6ICdzaXplJyxcbiAgc2l6ZXM6ICdzaXplcycsXG4gIHNwYW46ICdzcGFuJyxcbiAgc3BlbGxjaGVjazogJ3NwZWxsQ2hlY2snLFxuICBzcmM6ICdzcmMnLFxuICBzcmNkb2M6ICdzcmNEb2MnLFxuICBzcmNsYW5nOiAnc3JjTGFuZycsXG4gIHNyY3NldDogJ3NyY1NldCcsXG4gIHN0YXJ0OiAnc3RhcnQnLFxuICBzdGVwOiAnc3RlcCcsXG4gIHN0eWxlOiAnc3R5bGUnLFxuICBzdW1tYXJ5OiAnc3VtbWFyeScsXG4gIHRhYmluZGV4OiAndGFiSW5kZXgnLFxuICB0YXJnZXQ6ICd0YXJnZXQnLFxuICB0aXRsZTogJ3RpdGxlJyxcbiAgdHlwZTogJ3R5cGUnLFxuICB1c2VtYXA6ICd1c2VNYXAnLFxuICB2YWx1ZTogJ3ZhbHVlJyxcbiAgd2lkdGg6ICd3aWR0aCcsXG4gIHdtb2RlOiAnd21vZGUnLFxuICB3cmFwOiAnd3JhcCcsXG4gIC8vIFNWR1xuICBhYm91dDogJ2Fib3V0JyxcbiAgYWNjZW50aGVpZ2h0OiAnYWNjZW50SGVpZ2h0JyxcbiAgJ2FjY2VudC1oZWlnaHQnOiAnYWNjZW50SGVpZ2h0JyxcbiAgYWNjdW11bGF0ZTogJ2FjY3VtdWxhdGUnLFxuICBhZGRpdGl2ZTogJ2FkZGl0aXZlJyxcbiAgYWxpZ25tZW50YmFzZWxpbmU6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gICdhbGlnbm1lbnQtYmFzZWxpbmUnOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICBhbGxvd3Jlb3JkZXI6ICdhbGxvd1Jlb3JkZXInLFxuICBhbHBoYWJldGljOiAnYWxwaGFiZXRpYycsXG4gIGFtcGxpdHVkZTogJ2FtcGxpdHVkZScsXG4gIGFyYWJpY2Zvcm06ICdhcmFiaWNGb3JtJyxcbiAgJ2FyYWJpYy1mb3JtJzogJ2FyYWJpY0Zvcm0nLFxuICBhc2NlbnQ6ICdhc2NlbnQnLFxuICBhdHRyaWJ1dGVuYW1lOiAnYXR0cmlidXRlTmFtZScsXG4gIGF0dHJpYnV0ZXR5cGU6ICdhdHRyaWJ1dGVUeXBlJyxcbiAgYXV0b3JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gIGF6aW11dGg6ICdhemltdXRoJyxcbiAgYmFzZWZyZXF1ZW5jeTogJ2Jhc2VGcmVxdWVuY3knLFxuICBiYXNlbGluZXNoaWZ0OiAnYmFzZWxpbmVTaGlmdCcsXG4gICdiYXNlbGluZS1zaGlmdCc6ICdiYXNlbGluZVNoaWZ0JyxcbiAgYmFzZXByb2ZpbGU6ICdiYXNlUHJvZmlsZScsXG4gIGJib3g6ICdiYm94JyxcbiAgYmVnaW46ICdiZWdpbicsXG4gIGJpYXM6ICdiaWFzJyxcbiAgYnk6ICdieScsXG4gIGNhbGNtb2RlOiAnY2FsY01vZGUnLFxuICBjYXBoZWlnaHQ6ICdjYXBIZWlnaHQnLFxuICAnY2FwLWhlaWdodCc6ICdjYXBIZWlnaHQnLFxuICBjbGlwOiAnY2xpcCcsXG4gIGNsaXBwYXRoOiAnY2xpcFBhdGgnLFxuICAnY2xpcC1wYXRoJzogJ2NsaXBQYXRoJyxcbiAgY2xpcHBhdGh1bml0czogJ2NsaXBQYXRoVW5pdHMnLFxuICBjbGlwcnVsZTogJ2NsaXBSdWxlJyxcbiAgJ2NsaXAtcnVsZSc6ICdjbGlwUnVsZScsXG4gIGNvbG9yOiAnY29sb3InLFxuICBjb2xvcmludGVycG9sYXRpb246ICdjb2xvckludGVycG9sYXRpb24nLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbic6ICdjb2xvckludGVycG9sYXRpb24nLFxuICBjb2xvcmludGVycG9sYXRpb25maWx0ZXJzOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gIGNvbG9ycHJvZmlsZTogJ2NvbG9yUHJvZmlsZScsXG4gICdjb2xvci1wcm9maWxlJzogJ2NvbG9yUHJvZmlsZScsXG4gIGNvbG9ycmVuZGVyaW5nOiAnY29sb3JSZW5kZXJpbmcnLFxuICAnY29sb3ItcmVuZGVyaW5nJzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgY29udGVudHNjcmlwdHR5cGU6ICdjb250ZW50U2NyaXB0VHlwZScsXG4gIGNvbnRlbnRzdHlsZXR5cGU6ICdjb250ZW50U3R5bGVUeXBlJyxcbiAgY3Vyc29yOiAnY3Vyc29yJyxcbiAgY3g6ICdjeCcsXG4gIGN5OiAnY3knLFxuICBkOiAnZCcsXG4gIGRhdGF0eXBlOiAnZGF0YXR5cGUnLFxuICBkZWNlbGVyYXRlOiAnZGVjZWxlcmF0ZScsXG4gIGRlc2NlbnQ6ICdkZXNjZW50JyxcbiAgZGlmZnVzZWNvbnN0YW50OiAnZGlmZnVzZUNvbnN0YW50JyxcbiAgZGlyZWN0aW9uOiAnZGlyZWN0aW9uJyxcbiAgZGlzcGxheTogJ2Rpc3BsYXknLFxuICBkaXZpc29yOiAnZGl2aXNvcicsXG4gIGRvbWluYW50YmFzZWxpbmU6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgJ2RvbWluYW50LWJhc2VsaW5lJzogJ2RvbWluYW50QmFzZWxpbmUnLFxuICBkdXI6ICdkdXInLFxuICBkeDogJ2R4JyxcbiAgZHk6ICdkeScsXG4gIGVkZ2Vtb2RlOiAnZWRnZU1vZGUnLFxuICBlbGV2YXRpb246ICdlbGV2YXRpb24nLFxuICBlbmFibGViYWNrZ3JvdW5kOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gICdlbmFibGUtYmFja2dyb3VuZCc6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgZW5kOiAnZW5kJyxcbiAgZXhwb25lbnQ6ICdleHBvbmVudCcsXG4gIGV4dGVybmFscmVzb3VyY2VzcmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgZmlsbDogJ2ZpbGwnLFxuICBmaWxsb3BhY2l0eTogJ2ZpbGxPcGFjaXR5JyxcbiAgJ2ZpbGwtb3BhY2l0eSc6ICdmaWxsT3BhY2l0eScsXG4gIGZpbGxydWxlOiAnZmlsbFJ1bGUnLFxuICAnZmlsbC1ydWxlJzogJ2ZpbGxSdWxlJyxcbiAgZmlsdGVyOiAnZmlsdGVyJyxcbiAgZmlsdGVycmVzOiAnZmlsdGVyUmVzJyxcbiAgZmlsdGVydW5pdHM6ICdmaWx0ZXJVbml0cycsXG4gIGZsb29kb3BhY2l0eTogJ2Zsb29kT3BhY2l0eScsXG4gICdmbG9vZC1vcGFjaXR5JzogJ2Zsb29kT3BhY2l0eScsXG4gIGZsb29kY29sb3I6ICdmbG9vZENvbG9yJyxcbiAgJ2Zsb29kLWNvbG9yJzogJ2Zsb29kQ29sb3InLFxuICBmb2N1c2FibGU6ICdmb2N1c2FibGUnLFxuICBmb250ZmFtaWx5OiAnZm9udEZhbWlseScsXG4gICdmb250LWZhbWlseSc6ICdmb250RmFtaWx5JyxcbiAgZm9udHNpemU6ICdmb250U2l6ZScsXG4gICdmb250LXNpemUnOiAnZm9udFNpemUnLFxuICBmb250c2l6ZWFkanVzdDogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgJ2ZvbnQtc2l6ZS1hZGp1c3QnOiAnZm9udFNpemVBZGp1c3QnLFxuICBmb250c3RyZXRjaDogJ2ZvbnRTdHJldGNoJyxcbiAgJ2ZvbnQtc3RyZXRjaCc6ICdmb250U3RyZXRjaCcsXG4gIGZvbnRzdHlsZTogJ2ZvbnRTdHlsZScsXG4gICdmb250LXN0eWxlJzogJ2ZvbnRTdHlsZScsXG4gIGZvbnR2YXJpYW50OiAnZm9udFZhcmlhbnQnLFxuICAnZm9udC12YXJpYW50JzogJ2ZvbnRWYXJpYW50JyxcbiAgZm9udHdlaWdodDogJ2ZvbnRXZWlnaHQnLFxuICAnZm9udC13ZWlnaHQnOiAnZm9udFdlaWdodCcsXG4gIGZvcm1hdDogJ2Zvcm1hdCcsXG4gIGZyb206ICdmcm9tJyxcbiAgZng6ICdmeCcsXG4gIGZ5OiAnZnknLFxuICBnMTogJ2cxJyxcbiAgZzI6ICdnMicsXG4gIGdseXBobmFtZTogJ2dseXBoTmFtZScsXG4gICdnbHlwaC1uYW1lJzogJ2dseXBoTmFtZScsXG4gIGdseXBob3JpZW50YXRpb25ob3Jpem9udGFsOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCc6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gIGdseXBob3JpZW50YXRpb252ZXJ0aWNhbDogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCc6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICBnbHlwaHJlZjogJ2dseXBoUmVmJyxcbiAgZ3JhZGllbnR0cmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gIGdyYWRpZW50dW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgaGFuZ2luZzogJ2hhbmdpbmcnLFxuICBob3JpemFkdng6ICdob3JpekFkdlgnLFxuICAnaG9yaXotYWR2LXgnOiAnaG9yaXpBZHZYJyxcbiAgaG9yaXpvcmlnaW54OiAnaG9yaXpPcmlnaW5YJyxcbiAgJ2hvcml6LW9yaWdpbi14JzogJ2hvcml6T3JpZ2luWCcsXG4gIGlkZW9ncmFwaGljOiAnaWRlb2dyYXBoaWMnLFxuICBpbWFnZXJlbmRlcmluZzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgJ2ltYWdlLXJlbmRlcmluZyc6ICdpbWFnZVJlbmRlcmluZycsXG4gIGluMjogJ2luMicsXG4gIGluOiAnaW4nLFxuICBpbmxpc3Q6ICdpbmxpc3QnLFxuICBpbnRlcmNlcHQ6ICdpbnRlcmNlcHQnLFxuICBrMTogJ2sxJyxcbiAgazI6ICdrMicsXG4gIGszOiAnazMnLFxuICBrNDogJ2s0JyxcbiAgazogJ2snLFxuICBrZXJuZWxtYXRyaXg6ICdrZXJuZWxNYXRyaXgnLFxuICBrZXJuZWx1bml0bGVuZ3RoOiAna2VybmVsVW5pdExlbmd0aCcsXG4gIGtlcm5pbmc6ICdrZXJuaW5nJyxcbiAga2V5cG9pbnRzOiAna2V5UG9pbnRzJyxcbiAga2V5c3BsaW5lczogJ2tleVNwbGluZXMnLFxuICBrZXl0aW1lczogJ2tleVRpbWVzJyxcbiAgbGVuZ3RoYWRqdXN0OiAnbGVuZ3RoQWRqdXN0JyxcbiAgbGV0dGVyc3BhY2luZzogJ2xldHRlclNwYWNpbmcnLFxuICAnbGV0dGVyLXNwYWNpbmcnOiAnbGV0dGVyU3BhY2luZycsXG4gIGxpZ2h0aW5nY29sb3I6ICdsaWdodGluZ0NvbG9yJyxcbiAgJ2xpZ2h0aW5nLWNvbG9yJzogJ2xpZ2h0aW5nQ29sb3InLFxuICBsaW1pdGluZ2NvbmVhbmdsZTogJ2xpbWl0aW5nQ29uZUFuZ2xlJyxcbiAgbG9jYWw6ICdsb2NhbCcsXG4gIG1hcmtlcmVuZDogJ21hcmtlckVuZCcsXG4gICdtYXJrZXItZW5kJzogJ21hcmtlckVuZCcsXG4gIG1hcmtlcmhlaWdodDogJ21hcmtlckhlaWdodCcsXG4gIG1hcmtlcm1pZDogJ21hcmtlck1pZCcsXG4gICdtYXJrZXItbWlkJzogJ21hcmtlck1pZCcsXG4gIG1hcmtlcnN0YXJ0OiAnbWFya2VyU3RhcnQnLFxuICAnbWFya2VyLXN0YXJ0JzogJ21hcmtlclN0YXJ0JyxcbiAgbWFya2VydW5pdHM6ICdtYXJrZXJVbml0cycsXG4gIG1hcmtlcndpZHRoOiAnbWFya2VyV2lkdGgnLFxuICBtYXNrOiAnbWFzaycsXG4gIG1hc2tjb250ZW50dW5pdHM6ICdtYXNrQ29udGVudFVuaXRzJyxcbiAgbWFza3VuaXRzOiAnbWFza1VuaXRzJyxcbiAgbWF0aGVtYXRpY2FsOiAnbWF0aGVtYXRpY2FsJyxcbiAgbW9kZTogJ21vZGUnLFxuICBudW1vY3RhdmVzOiAnbnVtT2N0YXZlcycsXG4gIG9mZnNldDogJ29mZnNldCcsXG4gIG9wYWNpdHk6ICdvcGFjaXR5JyxcbiAgb3BlcmF0b3I6ICdvcGVyYXRvcicsXG4gIG9yZGVyOiAnb3JkZXInLFxuICBvcmllbnQ6ICdvcmllbnQnLFxuICBvcmllbnRhdGlvbjogJ29yaWVudGF0aW9uJyxcbiAgb3JpZ2luOiAnb3JpZ2luJyxcbiAgb3ZlcmZsb3c6ICdvdmVyZmxvdycsXG4gIG92ZXJsaW5lcG9zaXRpb246ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgJ292ZXJsaW5lLXBvc2l0aW9uJzogJ292ZXJsaW5lUG9zaXRpb24nLFxuICBvdmVybGluZXRoaWNrbmVzczogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ292ZXJsaW5lLXRoaWNrbmVzcyc6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gIHBhaW50b3JkZXI6ICdwYWludE9yZGVyJyxcbiAgJ3BhaW50LW9yZGVyJzogJ3BhaW50T3JkZXInLFxuICBwYW5vc2UxOiAncGFub3NlMScsXG4gICdwYW5vc2UtMSc6ICdwYW5vc2UxJyxcbiAgcGF0aGxlbmd0aDogJ3BhdGhMZW5ndGgnLFxuICBwYXR0ZXJuY29udGVudHVuaXRzOiAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gIHBhdHRlcm50cmFuc2Zvcm06ICdwYXR0ZXJuVHJhbnNmb3JtJyxcbiAgcGF0dGVybnVuaXRzOiAncGF0dGVyblVuaXRzJyxcbiAgcG9pbnRlcmV2ZW50czogJ3BvaW50ZXJFdmVudHMnLFxuICAncG9pbnRlci1ldmVudHMnOiAncG9pbnRlckV2ZW50cycsXG4gIHBvaW50czogJ3BvaW50cycsXG4gIHBvaW50c2F0eDogJ3BvaW50c0F0WCcsXG4gIHBvaW50c2F0eTogJ3BvaW50c0F0WScsXG4gIHBvaW50c2F0ejogJ3BvaW50c0F0WicsXG4gIHByZWZpeDogJ3ByZWZpeCcsXG4gIHByZXNlcnZlYWxwaGE6ICdwcmVzZXJ2ZUFscGhhJyxcbiAgcHJlc2VydmVhc3BlY3RyYXRpbzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICBwcmltaXRpdmV1bml0czogJ3ByaW1pdGl2ZVVuaXRzJyxcbiAgcHJvcGVydHk6ICdwcm9wZXJ0eScsXG4gIHI6ICdyJyxcbiAgcmFkaXVzOiAncmFkaXVzJyxcbiAgcmVmeDogJ3JlZlgnLFxuICByZWZ5OiAncmVmWScsXG4gIHJlbmRlcmluZ2ludGVudDogJ3JlbmRlcmluZ0ludGVudCcsXG4gICdyZW5kZXJpbmctaW50ZW50JzogJ3JlbmRlcmluZ0ludGVudCcsXG4gIHJlcGVhdGNvdW50OiAncmVwZWF0Q291bnQnLFxuICByZXBlYXRkdXI6ICdyZXBlYXREdXInLFxuICByZXF1aXJlZGV4dGVuc2lvbnM6ICdyZXF1aXJlZEV4dGVuc2lvbnMnLFxuICByZXF1aXJlZGZlYXR1cmVzOiAncmVxdWlyZWRGZWF0dXJlcycsXG4gIHJlc291cmNlOiAncmVzb3VyY2UnLFxuICByZXN0YXJ0OiAncmVzdGFydCcsXG4gIHJlc3VsdDogJ3Jlc3VsdCcsXG4gIHJlc3VsdHM6ICdyZXN1bHRzJyxcbiAgcm90YXRlOiAncm90YXRlJyxcbiAgcng6ICdyeCcsXG4gIHJ5OiAncnknLFxuICBzY2FsZTogJ3NjYWxlJyxcbiAgc2VjdXJpdHk6ICdzZWN1cml0eScsXG4gIHNlZWQ6ICdzZWVkJyxcbiAgc2hhcGVyZW5kZXJpbmc6ICdzaGFwZVJlbmRlcmluZycsXG4gICdzaGFwZS1yZW5kZXJpbmcnOiAnc2hhcGVSZW5kZXJpbmcnLFxuICBzbG9wZTogJ3Nsb3BlJyxcbiAgc3BhY2luZzogJ3NwYWNpbmcnLFxuICBzcGVjdWxhcmNvbnN0YW50OiAnc3BlY3VsYXJDb25zdGFudCcsXG4gIHNwZWN1bGFyZXhwb25lbnQ6ICdzcGVjdWxhckV4cG9uZW50JyxcbiAgc3BlZWQ6ICdzcGVlZCcsXG4gIHNwcmVhZG1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gIHN0YXJ0b2Zmc2V0OiAnc3RhcnRPZmZzZXQnLFxuICBzdGRkZXZpYXRpb246ICdzdGREZXZpYXRpb24nLFxuICBzdGVtaDogJ3N0ZW1oJyxcbiAgc3RlbXY6ICdzdGVtdicsXG4gIHN0aXRjaHRpbGVzOiAnc3RpdGNoVGlsZXMnLFxuICBzdG9wY29sb3I6ICdzdG9wQ29sb3InLFxuICAnc3RvcC1jb2xvcic6ICdzdG9wQ29sb3InLFxuICBzdG9wb3BhY2l0eTogJ3N0b3BPcGFjaXR5JyxcbiAgJ3N0b3Atb3BhY2l0eSc6ICdzdG9wT3BhY2l0eScsXG4gIHN0cmlrZXRocm91Z2hwb3NpdGlvbjogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJzogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gIHN0cmlrZXRocm91Z2h0aGlja25lc3M6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJzogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICBzdHJpbmc6ICdzdHJpbmcnLFxuICBzdHJva2U6ICdzdHJva2UnLFxuICBzdHJva2VkYXNoYXJyYXk6ICdzdHJva2VEYXNoYXJyYXknLFxuICAnc3Ryb2tlLWRhc2hhcnJheSc6ICdzdHJva2VEYXNoYXJyYXknLFxuICBzdHJva2VkYXNob2Zmc2V0OiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gICdzdHJva2UtZGFzaG9mZnNldCc6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgc3Ryb2tlbGluZWNhcDogJ3N0cm9rZUxpbmVjYXAnLFxuICAnc3Ryb2tlLWxpbmVjYXAnOiAnc3Ryb2tlTGluZWNhcCcsXG4gIHN0cm9rZWxpbmVqb2luOiAnc3Ryb2tlTGluZWpvaW4nLFxuICAnc3Ryb2tlLWxpbmVqb2luJzogJ3N0cm9rZUxpbmVqb2luJyxcbiAgc3Ryb2tlbWl0ZXJsaW1pdDogJ3N0cm9rZU1pdGVybGltaXQnLFxuICAnc3Ryb2tlLW1pdGVybGltaXQnOiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gIHN0cm9rZXdpZHRoOiAnc3Ryb2tlV2lkdGgnLFxuICAnc3Ryb2tlLXdpZHRoJzogJ3N0cm9rZVdpZHRoJyxcbiAgc3Ryb2tlb3BhY2l0eTogJ3N0cm9rZU9wYWNpdHknLFxuICAnc3Ryb2tlLW9wYWNpdHknOiAnc3Ryb2tlT3BhY2l0eScsXG4gIHN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZzogJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZycsXG4gIHN1cHByZXNzaHlkcmF0aW9ud2FybmluZzogJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsXG4gIHN1cmZhY2VzY2FsZTogJ3N1cmZhY2VTY2FsZScsXG4gIHN5c3RlbWxhbmd1YWdlOiAnc3lzdGVtTGFuZ3VhZ2UnLFxuICB0YWJsZXZhbHVlczogJ3RhYmxlVmFsdWVzJyxcbiAgdGFyZ2V0eDogJ3RhcmdldFgnLFxuICB0YXJnZXR5OiAndGFyZ2V0WScsXG4gIHRleHRhbmNob3I6ICd0ZXh0QW5jaG9yJyxcbiAgJ3RleHQtYW5jaG9yJzogJ3RleHRBbmNob3InLFxuICB0ZXh0ZGVjb3JhdGlvbjogJ3RleHREZWNvcmF0aW9uJyxcbiAgJ3RleHQtZGVjb3JhdGlvbic6ICd0ZXh0RGVjb3JhdGlvbicsXG4gIHRleHRsZW5ndGg6ICd0ZXh0TGVuZ3RoJyxcbiAgdGV4dHJlbmRlcmluZzogJ3RleHRSZW5kZXJpbmcnLFxuICAndGV4dC1yZW5kZXJpbmcnOiAndGV4dFJlbmRlcmluZycsXG4gIHRvOiAndG8nLFxuICB0cmFuc2Zvcm06ICd0cmFuc2Zvcm0nLFxuICB0eXBlb2Y6ICd0eXBlb2YnLFxuICB1MTogJ3UxJyxcbiAgdTI6ICd1MicsXG4gIHVuZGVybGluZXBvc2l0aW9uOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICAndW5kZXJsaW5lLXBvc2l0aW9uJzogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgdW5kZXJsaW5ldGhpY2tuZXNzOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ3VuZGVybGluZS10aGlja25lc3MnOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgdW5pY29kZTogJ3VuaWNvZGUnLFxuICB1bmljb2RlYmlkaTogJ3VuaWNvZGVCaWRpJyxcbiAgJ3VuaWNvZGUtYmlkaSc6ICd1bmljb2RlQmlkaScsXG4gIHVuaWNvZGVyYW5nZTogJ3VuaWNvZGVSYW5nZScsXG4gICd1bmljb2RlLXJhbmdlJzogJ3VuaWNvZGVSYW5nZScsXG4gIHVuaXRzcGVyZW06ICd1bml0c1BlckVtJyxcbiAgJ3VuaXRzLXBlci1lbSc6ICd1bml0c1BlckVtJyxcbiAgdW5zZWxlY3RhYmxlOiAndW5zZWxlY3RhYmxlJyxcbiAgdmFscGhhYmV0aWM6ICd2QWxwaGFiZXRpYycsXG4gICd2LWFscGhhYmV0aWMnOiAndkFscGhhYmV0aWMnLFxuICB2YWx1ZXM6ICd2YWx1ZXMnLFxuICB2ZWN0b3JlZmZlY3Q6ICd2ZWN0b3JFZmZlY3QnLFxuICAndmVjdG9yLWVmZmVjdCc6ICd2ZWN0b3JFZmZlY3QnLFxuICB2ZXJzaW9uOiAndmVyc2lvbicsXG4gIHZlcnRhZHZ5OiAndmVydEFkdlknLFxuICAndmVydC1hZHYteSc6ICd2ZXJ0QWR2WScsXG4gIHZlcnRvcmlnaW54OiAndmVydE9yaWdpblgnLFxuICAndmVydC1vcmlnaW4teCc6ICd2ZXJ0T3JpZ2luWCcsXG4gIHZlcnRvcmlnaW55OiAndmVydE9yaWdpblknLFxuICAndmVydC1vcmlnaW4teSc6ICd2ZXJ0T3JpZ2luWScsXG4gIHZoYW5naW5nOiAndkhhbmdpbmcnLFxuICAndi1oYW5naW5nJzogJ3ZIYW5naW5nJyxcbiAgdmlkZW9ncmFwaGljOiAndklkZW9ncmFwaGljJyxcbiAgJ3YtaWRlb2dyYXBoaWMnOiAndklkZW9ncmFwaGljJyxcbiAgdmlld2JveDogJ3ZpZXdCb3gnLFxuICB2aWV3dGFyZ2V0OiAndmlld1RhcmdldCcsXG4gIHZpc2liaWxpdHk6ICd2aXNpYmlsaXR5JyxcbiAgdm1hdGhlbWF0aWNhbDogJ3ZNYXRoZW1hdGljYWwnLFxuICAndi1tYXRoZW1hdGljYWwnOiAndk1hdGhlbWF0aWNhbCcsXG4gIHZvY2FiOiAndm9jYWInLFxuICB3aWR0aHM6ICd3aWR0aHMnLFxuICB3b3Jkc3BhY2luZzogJ3dvcmRTcGFjaW5nJyxcbiAgJ3dvcmQtc3BhY2luZyc6ICd3b3JkU3BhY2luZycsXG4gIHdyaXRpbmdtb2RlOiAnd3JpdGluZ01vZGUnLFxuICAnd3JpdGluZy1tb2RlJzogJ3dyaXRpbmdNb2RlJyxcbiAgeDE6ICd4MScsXG4gIHgyOiAneDInLFxuICB4OiAneCcsXG4gIHhjaGFubmVsc2VsZWN0b3I6ICd4Q2hhbm5lbFNlbGVjdG9yJyxcbiAgeGhlaWdodDogJ3hIZWlnaHQnLFxuICAneC1oZWlnaHQnOiAneEhlaWdodCcsXG4gIHhsaW5rYWN0dWF0ZTogJ3hsaW5rQWN0dWF0ZScsXG4gICd4bGluazphY3R1YXRlJzogJ3hsaW5rQWN0dWF0ZScsXG4gIHhsaW5rYXJjcm9sZTogJ3hsaW5rQXJjcm9sZScsXG4gICd4bGluazphcmNyb2xlJzogJ3hsaW5rQXJjcm9sZScsXG4gIHhsaW5raHJlZjogJ3hsaW5rSHJlZicsXG4gICd4bGluazpocmVmJzogJ3hsaW5rSHJlZicsXG4gIHhsaW5rcm9sZTogJ3hsaW5rUm9sZScsXG4gICd4bGluazpyb2xlJzogJ3hsaW5rUm9sZScsXG4gIHhsaW5rc2hvdzogJ3hsaW5rU2hvdycsXG4gICd4bGluazpzaG93JzogJ3hsaW5rU2hvdycsXG4gIHhsaW5rdGl0bGU6ICd4bGlua1RpdGxlJyxcbiAgJ3hsaW5rOnRpdGxlJzogJ3hsaW5rVGl0bGUnLFxuICB4bGlua3R5cGU6ICd4bGlua1R5cGUnLFxuICAneGxpbms6dHlwZSc6ICd4bGlua1R5cGUnLFxuICB4bWxiYXNlOiAneG1sQmFzZScsXG4gICd4bWw6YmFzZSc6ICd4bWxCYXNlJyxcbiAgeG1sbGFuZzogJ3htbExhbmcnLFxuICAneG1sOmxhbmcnOiAneG1sTGFuZycsXG4gIHhtbG5zOiAneG1sbnMnLFxuICAneG1sOnNwYWNlJzogJ3htbFNwYWNlJyxcbiAgeG1sbnN4bGluazogJ3htbG5zWGxpbmsnLFxuICAneG1sbnM6eGxpbmsnOiAneG1sbnNYbGluaycsXG4gIHhtbHNwYWNlOiAneG1sU3BhY2UnLFxuICB5MTogJ3kxJyxcbiAgeTI6ICd5MicsXG4gIHk6ICd5JyxcbiAgeWNoYW5uZWxzZWxlY3RvcjogJ3lDaGFubmVsU2VsZWN0b3InLFxuICB6OiAneicsXG4gIHpvb21hbmRwYW46ICd6b29tQW5kUGFuJ1xufTtcblxudmFyIHZhbGlkYXRlUHJvcGVydHkkMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciB3YXJuZWRQcm9wZXJ0aWVzJDEgPSB7fTtcbiAgdmFyIEVWRU5UX05BTUVfUkVHRVggPSAvXm9uLi87XG4gIHZhciBJTlZBTElEX0VWRU5UX05BTUVfUkVHRVggPSAvXm9uW15BLVpdLztcbiAgdmFyIHJBUklBJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbiAgdmFyIHJBUklBQ2FtZWwkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuICB2YWxpZGF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAodGFnTmFtZSwgbmFtZSwgdmFsdWUsIGV2ZW50UmVnaXN0cnkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzJDEsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c2luJyB8fCBsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNvdXQnKSB7XG4gICAgICBlcnJvcignUmVhY3QgdXNlcyBvbkZvY3VzIGFuZCBvbkJsdXIgaW5zdGVhZCBvZiBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQuICcgKyAnQWxsIFJlYWN0IGV2ZW50cyBhcmUgbm9ybWFsaXplZCB0byBidWJibGUsIHNvIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dCAnICsgJ2FyZSBub3QgbmVlZGVkL3N1cHBvcnRlZCBieSBSZWFjdC4nKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gV2UgY2FuJ3QgcmVseSBvbiB0aGUgZXZlbnQgc3lzdGVtIGJlaW5nIGluamVjdGVkIG9uIHRoZSBzZXJ2ZXIuXG5cblxuICAgIGlmIChldmVudFJlZ2lzdHJ5ICE9IG51bGwpIHtcbiAgICAgIHZhciByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzID0gZXZlbnRSZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLFxuICAgICAgICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSBldmVudFJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM7XG5cbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuXG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgcmVnaXN0cmF0aW9uTmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgICAgZXJyb3IoJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBJdCB3aWxsIGJlIGlnbm9yZWQuJywgbmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIElmIG5vIGV2ZW50IHBsdWdpbnMgaGF2ZSBiZWVuIGluamVjdGVkLCB3ZSBhcmUgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG4gICAgICAvLyBTbyB3ZSBjYW4ndCB0ZWxsIGlmIHRoZSBldmVudCBuYW1lIGlzIGNvcnJlY3QgZm9yIHN1cmUsIGJ1dCB3ZSBjYW4gZmlsdGVyXG4gICAgICAvLyBvdXQga25vd24gYmFkIG9uZXMgbGlrZSBgb25jbGlja2AuIFdlIGNhbid0IHN1Z2dlc3QgYSBzcGVjaWZpYyByZXBsYWNlbWVudCB0aG91Z2guXG4gICAgICBpZiAoSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiAnICsgJ1JlYWN0IGV2ZW50cyB1c2UgdGhlIGNhbWVsQ2FzZSBuYW1pbmcgY29udmVudGlvbiwgZm9yIGV4YW1wbGUgYG9uQ2xpY2tgLicsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBMZXQgdGhlIEFSSUEgYXR0cmlidXRlIGhvb2sgdmFsaWRhdGUgQVJJQSBhdHRyaWJ1dGVzXG5cblxuICAgIGlmIChyQVJJQSQxLnRlc3QobmFtZSkgfHwgckFSSUFDYW1lbCQxLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lubmVyaHRtbCcpIHtcbiAgICAgIGVycm9yKCdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdhcmlhJykge1xuICAgICAgZXJyb3IoJ1RoZSBgYXJpYWAgYXR0cmlidXRlIGlzIHJlc2VydmVkIGZvciBmdXR1cmUgdXNlIGluIFJlYWN0LiAnICsgJ1Bhc3MgaW5kaXZpZHVhbCBgYXJpYS1gIGF0dHJpYnV0ZXMgaW5zdGVhZC4nKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lzJyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhIGAlc2AgZm9yIGEgc3RyaW5nIGF0dHJpYnV0ZSBgaXNgLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgKyAndGhlIHZhbHVlIHRvIGEgc3RyaW5nLicsIHR5cGVvZiB2YWx1ZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4nLCBuYW1lKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gICAgdmFyIGlzUmVzZXJ2ZWQgPSBwcm9wZXJ0eUluZm8gIT09IG51bGwgJiYgcHJvcGVydHlJbmZvLnR5cGUgPT09IFJFU0VSVkVEOyAvLyBLbm93biBhdHRyaWJ1dGVzIHNob3VsZCBtYXRjaCB0aGUgY2FzaW5nIHNwZWNpZmllZCBpbiB0aGUgcHJvcGVydHkgY29uZmlnLlxuXG4gICAgaWYgKHBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBwb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdO1xuXG4gICAgICBpZiAoc3RhbmRhcmROYW1lICE9PSBuYW1lKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIERPTSBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBzdGFuZGFyZE5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQgJiYgbmFtZSAhPT0gbG93ZXJDYXNlZE5hbWUpIHtcbiAgICAgIC8vIFVua25vd24gYXR0cmlidXRlcyBzaG91bGQgaGF2ZSBsb3dlcmNhc2UgY2FzaW5nIHNpbmNlIHRoYXQncyBob3cgdGhleVxuICAgICAgLy8gd2lsbCBiZSBjYXNlZCBhbnl3YXkgd2l0aCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgICAgZXJyb3IoJ1JlYWN0IGRvZXMgbm90IHJlY29nbml6ZSB0aGUgYCVzYCBwcm9wIG9uIGEgRE9NIGVsZW1lbnQuIElmIHlvdSAnICsgJ2ludGVudGlvbmFsbHkgd2FudCBpdCB0byBhcHBlYXIgaW4gdGhlIERPTSBhcyBhIGN1c3RvbSAnICsgJ2F0dHJpYnV0ZSwgc3BlbGwgaXQgYXMgbG93ZXJjYXNlIGAlc2AgaW5zdGVhZC4gJyArICdJZiB5b3UgYWNjaWRlbnRhbGx5IHBhc3NlZCBpdCBmcm9tIGEgcGFyZW50IGNvbXBvbmVudCwgcmVtb3ZlICcgKyAnaXQgZnJvbSB0aGUgRE9NIGVsZW1lbnQuJywgbmFtZSwgbG93ZXJDYXNlZE5hbWUpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nICYmIHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVycm9yKCdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4nLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUsIG5hbWUsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBOb3cgdGhhdCB3ZSd2ZSB2YWxpZGF0ZWQgY2FzaW5nLCBkbyBub3QgdmFsaWRhdGVcbiAgICAvLyBkYXRhIHR5cGVzIGZvciByZXNlcnZlZCBwcm9wc1xuXG5cbiAgICBpZiAoaXNSZXNlcnZlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBXYXJuIHdoZW4gYSBrbm93biBhdHRyaWJ1dGUgaXMgYSBiYWQgdHlwZVxuXG5cbiAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gV2FybiB3aGVuIHBhc3NpbmcgdGhlIHN0cmluZ3MgJ2ZhbHNlJyBvciAndHJ1ZScgaW50byBhIGJvb2xlYW4gcHJvcFxuXG5cbiAgICBpZiAoKHZhbHVlID09PSAnZmFsc2UnIHx8IHZhbHVlID09PSAndHJ1ZScpICYmIHByb3BlcnR5SW5mbyAhPT0gbnVsbCAmJiBwcm9wZXJ0eUluZm8udHlwZSA9PT0gQk9PTEVBTikge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIHRoZSBzdHJpbmcgYCVzYCBmb3IgdGhlIGJvb2xlYW4gYXR0cmlidXRlIGAlc2AuICcgKyAnJXMgJyArICdEaWQgeW91IG1lYW4gJXM9eyVzfT8nLCB2YWx1ZSwgbmFtZSwgdmFsdWUgPT09ICdmYWxzZScgPyAnVGhlIGJyb3dzZXIgd2lsbCBpbnRlcnByZXQgaXQgYXMgYSB0cnV0aHkgdmFsdWUuJyA6ICdBbHRob3VnaCB0aGlzIHdvcmtzLCBpdCB3aWxsIG5vdCB3b3JrIGFzIGV4cGVjdGVkIGlmIHlvdSBwYXNzIHRoZSBzdHJpbmcgXCJmYWxzZVwiLicsIG5hbWUsIHZhbHVlKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG52YXIgd2FyblVua25vd25Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KSB7XG4gIHtcbiAgICB2YXIgdW5rbm93blByb3BzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSQxKHR5cGUsIGtleSwgcHJvcHNba2V5XSwgZXZlbnRSZWdpc3RyeSk7XG5cbiAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICB1bmtub3duUHJvcHMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmtub3duUHJvcFN0cmluZyA9IHVua25vd25Qcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICAgIH0pLmpvaW4oJywgJyk7XG5cbiAgICBpZiAodW5rbm93blByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIHByb3AgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgaXQgZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIGl0IGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yICcsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9IGVsc2UgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgICBlcnJvcignSW52YWxpZCB2YWx1ZXMgZm9yIHByb3BzICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIHRoZW0gaW4gdGhlIERPTS4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9hdHRyaWJ1dGUtYmVoYXZpb3IgJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpIHtcbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHdhcm5Vbmtub3duUHJvcGVydGllcyh0eXBlLCBwcm9wcywgZXZlbnRSZWdpc3RyeSk7XG59XG5cbnZhciB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIC8vICdtc1RyYW5zZm9ybScgaXMgY29ycmVjdCwgYnV0IHRoZSBvdGhlciBwcmVmaXhlcyBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcbiAgdmFyIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLztcbiAgdmFyIG1zUGF0dGVybiA9IC9eLW1zLS87XG4gIHZhciBoeXBoZW5QYXR0ZXJuID0gLy0oLikvZzsgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG5cbiAgdmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcbiAgdmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XG4gIHZhciB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gZmFsc2U7XG5cbiAgdmFyIGNhbWVsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShoeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignVW5zdXBwb3J0ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCAvLyBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gICAgLy8gKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICAgIC8vIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbiAgICBjYW1lbGl6ZShuYW1lLnJlcGxhY2UobXNQYXR0ZXJuLCAnbXMtJykpKTtcbiAgfTtcblxuICB2YXIgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG5cbiAgICBlcnJvcihcIlN0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvbi4gXCIgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc05hTiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRGb3JOYU5WYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZEZvck5hTlZhbHVlID0gdHJ1ZTtcblxuICAgIGVycm9yKCdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJywgbmFtZSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRGb3JJbmZpbml0eVZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IHRydWU7XG5cbiAgICBlcnJvcignYEluZmluaXR5YCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJywgbmFtZSk7XG4gIH07XG5cbiAgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4udGVzdChuYW1lKSkge1xuICAgICAgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNOYU4obmFtZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUkMSA9IHdhcm5WYWxpZFN0eWxlO1xuXG4vLyBjb2RlIGNvcGllZCBhbmQgbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbFxudmFyIG1hdGNoSHRtbFJlZ0V4cCA9IC9bXCInJjw+XS87XG4vKipcbiAqIEVzY2FwZXMgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBIVE1MIGVudGl0aWVzIGluIGEgZ2l2ZW4gaHRtbCBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJpbmcgSFRNTCBzdHJpbmcgdG8gZXNjYXBlIGZvciBsYXRlciBpbnNlcnRpb25cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xuICB7XG4gICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oc3RyaW5nKTtcbiAgfVxuXG4gIHZhciBzdHIgPSAnJyArIHN0cmluZztcbiAgdmFyIG1hdGNoID0gbWF0Y2hIdG1sUmVnRXhwLmV4ZWMoc3RyKTtcblxuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHZhciBlc2NhcGU7XG4gIHZhciBodG1sID0gJyc7XG4gIHZhciBpbmRleDtcbiAgdmFyIGxhc3RJbmRleCA9IDA7XG5cbiAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgY2FzZSAzNDpcbiAgICAgICAgLy8gXCJcbiAgICAgICAgZXNjYXBlID0gJyZxdW90Oyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM4OlxuICAgICAgICAvLyAmXG4gICAgICAgIGVzY2FwZSA9ICcmYW1wOyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM5OlxuICAgICAgICAvLyAnXG4gICAgICAgIGVzY2FwZSA9ICcmI3gyNzsnOyAvLyBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sOyB1c2VkIHRvIGJlICcmIzM5J1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDYwOlxuICAgICAgICAvLyA8XG4gICAgICAgIGVzY2FwZSA9ICcmbHQ7JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNjI6XG4gICAgICAgIC8vID5cbiAgICAgICAgZXNjYXBlID0gJyZndDsnO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGh0bWwgKz0gc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgaHRtbCArPSBlc2NhcGU7XG4gIH1cblxuICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbn0gLy8gZW5kIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGVzY2FwZVRleHRGb3JCcm93c2VyKHRleHQpIHtcbiAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHRleHQgPT09ICdudW1iZXInKSB7XG4gICAgLy8gdGhpcyBzaG9ydGNpcmN1aXQgaGVscHMgcGVyZiBmb3IgdHlwZXMgdGhhdCB3ZSBrbm93IHdpbGwgbmV2ZXIgaGF2ZVxuICAgIC8vIHNwZWNpYWwgY2hhcmFjdGVycywgZXNwZWNpYWxseSBnaXZlbiB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBvZnRlblxuICAgIC8vIGZvciBudW1lcmljIGRvbSBpZHMuXG4gICAgcmV0dXJuICcnICsgdGV4dDtcbiAgfVxuXG4gIHJldHVybiBlc2NhcGVIdG1sKHRleHQpO1xufVxuXG52YXIgdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG52YXIgbXNQYXR0ZXJuJDEgPSAvXm1zLS87XG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqL1xuXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUobmFtZSkge1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKHVwcGVyY2FzZVBhdHRlcm4sICctJDEnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UobXNQYXR0ZXJuJDEsICctbXMtJyk7XG59XG5cbi8vIGFuZCBhbnkgbmV3bGluZSBvciB0YWIgYXJlIGZpbHRlcmVkIG91dCBhcyBpZiB0aGV5J3JlIG5vdCBwYXJ0IG9mIHRoZSBVUkwuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybC1wYXJzaW5nXG4vLyBUYWIgb3IgbmV3bGluZSBhcmUgZGVmaW5lZCBhcyBcXHJcXG5cXHQ6XG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYXNjaWktdGFiLW9yLW5ld2xpbmVcbi8vIEEgQzAgY29udHJvbCBpcyBhIGNvZGUgcG9pbnQgaW4gdGhlIHJhbmdlIFxcdTAwMDAgTlVMTCB0byBcXHUwMDFGXG4vLyBJTkZPUk1BVElPTiBTRVBBUkFUT1IgT05FLCBpbmNsdXNpdmU6XG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYzAtY29udHJvbC1vci1zcGFjZVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbnZhciBpc0phdmFTY3JpcHRQcm90b2NvbCA9IC9eW1xcdTAwMDAtXFx1MDAxRiBdKmpbXFxyXFxuXFx0XSphW1xcclxcblxcdF0qdltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSpzW1xcclxcblxcdF0qY1tcXHJcXG5cXHRdKnJbXFxyXFxuXFx0XSppW1xcclxcblxcdF0qcFtcXHJcXG5cXHRdKnRbXFxyXFxuXFx0XSpcXDovaTtcbnZhciBkaWRXYXJuID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHNhbml0aXplVVJMKHVybCkge1xuICB7XG4gICAgaWYgKCFkaWRXYXJuICYmIGlzSmF2YVNjcmlwdFByb3RvY29sLnRlc3QodXJsKSkge1xuICAgICAgZGlkV2FybiA9IHRydWU7XG5cbiAgICAgIGVycm9yKCdBIGZ1dHVyZSB2ZXJzaW9uIG9mIFJlYWN0IHdpbGwgYmxvY2sgamF2YXNjcmlwdDogVVJMcyBhcyBhIHNlY3VyaXR5IHByZWNhdXRpb24uICcgKyAnVXNlIGV2ZW50IGhhbmRsZXJzIGluc3RlYWQgaWYgeW91IGNhbi4gSWYgeW91IG5lZWQgdG8gZ2VuZXJhdGUgdW5zYWZlIEhUTUwgdHJ5ICcgKyAndXNpbmcgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgaW5zdGVhZC4gUmVhY3Qgd2FzIHBhc3NlZCAlcy4nLCBKU09OLnN0cmluZ2lmeSh1cmwpKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG52YXIgc3RhcnRJbmxpbmVTY3JpcHQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxzY3JpcHQ+Jyk7XG52YXIgZW5kSW5saW5lU2NyaXB0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L3NjcmlwdD4nKTtcbnZhciBzdGFydFNjcmlwdFNyYyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHNjcmlwdCBzcmM9XCInKTtcbnZhciBzdGFydE1vZHVsZVNyYyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHNjcmlwdCB0eXBlPVwibW9kdWxlXCIgc3JjPVwiJyk7XG52YXIgZW5kQXN5bmNTY3JpcHQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGFzeW5jPVwiXCI+PC9zY3JpcHQ+Jyk7XG4vKipcbiAqIFRoaXMgZXNjYXBpbmcgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gd29yayB3aXRoIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQgb25seS5cbiAqIGJlY2F1c2Ugd2Uga25vdyB3ZSBhcmUgZXNjYXBpbmcgdGhlIGVudGlyZSBzY3JpcHQuIFdlIGNhbiBhdm9pZCBmb3IgaW5zdGFuY2VcbiAqIGVzY2FwaW5nIGh0bWwgY29tbWVudCBzdHJpbmcgc2VxdWVuY2VzIHRoYXQgYXJlIHZhbGlkIGphdmFzY3JpcHQgYXMgd2VsbCBiZWNhdXNlXG4gKiBpZiB0aGVyZSBhcmUgbm8gc2Vic2VxdWVudCA8c2NyaXB0IHNlcXVlbmNlcyB0aGUgaHRtbCBwYXJzZXIgd2lsbCBuZXZlciBlbnRlclxuICogc2NyaXB0IGRhdGEgZG91YmxlIGVzY2FwZWQgc3RhdGUgKHNlZTogaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1My9zeW50YXguaHRtbCNzY3JpcHQtZGF0YS1kb3VibGUtZXNjYXBlZC1zdGF0ZSlcbiAqXG4gKiBXaGlsZSB1bnRydXN0ZWQgc2NyaXB0IGNvbnRlbnQgc2hvdWxkIGJlIG1hZGUgc2FmZSBiZWZvcmUgdXNpbmcgdGhpcyBhcGkgaXQgd2lsbFxuICogZW5zdXJlIHRoYXQgdGhlIHNjcmlwdCBjYW5ub3QgYmUgZWFybHkgdGVybWluYXRlZCBvciBuZXZlciB0ZXJtaW5hdGVkIHN0YXRlXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlQm9vdHN0cmFwU2NyaXB0Q29udGVudChzY3JpcHRUZXh0KSB7XG4gIHtcbiAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihzY3JpcHRUZXh0KTtcbiAgfVxuXG4gIHJldHVybiAoJycgKyBzY3JpcHRUZXh0KS5yZXBsYWNlKHNjcmlwdFJlZ2V4LCBzY3JpcHRSZXBsYWNlcik7XG59XG5cbnZhciBzY3JpcHRSZWdleCA9IC8oPFxcL3w8KShzKShjcmlwdCkvZ2k7XG5cbnZhciBzY3JpcHRSZXBsYWNlciA9IGZ1bmN0aW9uIChtYXRjaCwgcHJlZml4LCBzLCBzdWZmaXgpIHtcbiAgcmV0dXJuIFwiXCIgKyBwcmVmaXggKyAocyA9PT0gJ3MnID8gXCJcXFxcdTAwNzNcIiA6IFwiXFxcXHUwMDUzXCIpICsgc3VmZml4O1xufTsgLy8gQWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2Ygd2hhdCB3ZSd2ZSBhbHJlYWR5IHdyaXR0ZW4gc28gd2UgY2FuIHJlZmVyIGJhY2sgdG8gaXQuXG5cblxuZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2VTdGF0ZShpZGVudGlmaWVyUHJlZml4LCBub25jZSwgYm9vdHN0cmFwU2NyaXB0Q29udGVudCwgYm9vdHN0cmFwU2NyaXB0cywgYm9vdHN0cmFwTW9kdWxlcykge1xuICB2YXIgaWRQcmVmaXggPSBpZGVudGlmaWVyUHJlZml4ID09PSB1bmRlZmluZWQgPyAnJyA6IGlkZW50aWZpZXJQcmVmaXg7XG4gIHZhciBpbmxpbmVTY3JpcHRXaXRoTm9uY2UgPSBub25jZSA9PT0gdW5kZWZpbmVkID8gc3RhcnRJbmxpbmVTY3JpcHQgOiBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxzY3JpcHQgbm9uY2U9XCInICsgZXNjYXBlVGV4dEZvckJyb3dzZXIobm9uY2UpICsgJ1wiPicpO1xuICB2YXIgYm9vdHN0cmFwQ2h1bmtzID0gW107XG5cbiAgaWYgKGJvb3RzdHJhcFNjcmlwdENvbnRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKGlubGluZVNjcmlwdFdpdGhOb25jZSwgc3RyaW5nVG9DaHVuayhlc2NhcGVCb290c3RyYXBTY3JpcHRDb250ZW50KGJvb3RzdHJhcFNjcmlwdENvbnRlbnQpKSwgZW5kSW5saW5lU2NyaXB0KTtcbiAgfVxuXG4gIGlmIChib290c3RyYXBTY3JpcHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb3RzdHJhcFNjcmlwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKHN0YXJ0U2NyaXB0U3JjLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGJvb3RzdHJhcFNjcmlwdHNbaV0pKSwgZW5kQXN5bmNTY3JpcHQpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChib290c3RyYXBNb2R1bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYm9vdHN0cmFwTW9kdWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKHN0YXJ0TW9kdWxlU3JjLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGJvb3RzdHJhcE1vZHVsZXNbX2ldKSksIGVuZEFzeW5jU2NyaXB0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJvb3RzdHJhcENodW5rczogYm9vdHN0cmFwQ2h1bmtzLFxuICAgIHN0YXJ0SW5saW5lU2NyaXB0OiBpbmxpbmVTY3JpcHRXaXRoTm9uY2UsXG4gICAgcGxhY2Vob2xkZXJQcmVmaXg6IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhpZFByZWZpeCArICdQOicpLFxuICAgIHNlZ21lbnRQcmVmaXg6IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhpZFByZWZpeCArICdTOicpLFxuICAgIGJvdW5kYXJ5UHJlZml4OiBpZFByZWZpeCArICdCOicsXG4gICAgaWRQcmVmaXg6IGlkUHJlZml4LFxuICAgIG5leHRTdXNwZW5zZUlEOiAwLFxuICAgIHNlbnRDb21wbGV0ZVNlZ21lbnRGdW5jdGlvbjogZmFsc2UsXG4gICAgc2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbjogZmFsc2UsXG4gICAgc2VudENsaWVudFJlbmRlckZ1bmN0aW9uOiBmYWxzZVxuICB9O1xufSAvLyBDb25zdGFudHMgZm9yIHRoZSBpbnNlcnRpb24gbW9kZSB3ZSdyZSBjdXJyZW50bHkgd3JpdGluZyBpbi4gV2UgZG9uJ3QgZW5jb2RlIGFsbCBIVE1MNSBpbnNlcnRpb25cbi8vIG1vZGVzLiBXZSBvbmx5IGluY2x1ZGUgdGhlIHZhcmlhbnRzIGFzIHRoZXkgbWF0dGVyIGZvciB0aGUgc2FrZSBvZiBvdXIgcHVycG9zZXMuXG4vLyBXZSBkb24ndCBhY3R1YWxseSBwcm92aWRlIHRoZSBuYW1lc3BhY2UgdGhlcmVmb3JlIHdlIHVzZSBjb25zdGFudHMgaW5zdGVhZCBvZiB0aGUgc3RyaW5nLlxuXG52YXIgUk9PVF9IVE1MX01PREUgPSAwOyAvLyBVc2VkIGZvciB0aGUgcm9vdCBtb3N0IGVsZW1lbnQgdGFnLlxuXG52YXIgSFRNTF9NT0RFID0gMTtcbnZhciBTVkdfTU9ERSA9IDI7XG52YXIgTUFUSE1MX01PREUgPSAzO1xudmFyIEhUTUxfVEFCTEVfTU9ERSA9IDQ7XG52YXIgSFRNTF9UQUJMRV9CT0RZX01PREUgPSA1O1xudmFyIEhUTUxfVEFCTEVfUk9XX01PREUgPSA2O1xudmFyIEhUTUxfQ09MR1JPVVBfTU9ERSA9IDc7IC8vIFdlIGhhdmUgYSBncmVhdGVyIHRoYW4gSFRNTF9UQUJMRV9NT0RFIGNoZWNrIGVsc2V3aGVyZS4gSWYgeW91IGFkZCBtb3JlIGNhc2VzIGhlcmUsIG1ha2Ugc3VyZSBpdFxuLy8gc3RpbGwgbWFrZXMgc2Vuc2VcblxuZnVuY3Rpb24gY3JlYXRlRm9ybWF0Q29udGV4dChpbnNlcnRpb25Nb2RlLCBzZWxlY3RlZFZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgaW5zZXJ0aW9uTW9kZTogaW5zZXJ0aW9uTW9kZSxcbiAgICBzZWxlY3RlZFZhbHVlOiBzZWxlY3RlZFZhbHVlXG4gIH07XG59XG5mdW5jdGlvbiBnZXRDaGlsZEZvcm1hdENvbnRleHQocGFyZW50Q29udGV4dCwgdHlwZSwgcHJvcHMpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfTU9ERSwgcHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogcHJvcHMuZGVmYXVsdFZhbHVlKTtcblxuICAgIGNhc2UgJ3N2Zyc6XG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChTVkdfTU9ERSwgbnVsbCk7XG5cbiAgICBjYXNlICdtYXRoJzpcbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KE1BVEhNTF9NT0RFLCBudWxsKTtcblxuICAgIGNhc2UgJ2ZvcmVpZ25PYmplY3QnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBudWxsKTtcbiAgICAvLyBUYWJsZSBwYXJlbnRzIGFyZSBzcGVjaWFsIGluIHRoYXQgdGhlaXIgY2hpbGRyZW4gY2FuIG9ubHkgYmUgY3JlYXRlZCBhdCBhbGwgaWYgdGhleSdyZVxuICAgIC8vIHdyYXBwZWQgaW4gYSB0YWJsZSBwYXJlbnQuIFNvIHdlIG5lZWQgdG8gZW5jb2RlIHRoYXQgd2UncmUgZW50ZXJpbmcgdGhpcyBtb2RlLlxuXG4gICAgY2FzZSAndGFibGUnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9UQUJMRV9NT0RFLCBudWxsKTtcblxuICAgIGNhc2UgJ3RoZWFkJzpcbiAgICBjYXNlICd0Ym9keSc6XG4gICAgY2FzZSAndGZvb3QnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9UQUJMRV9CT0RZX01PREUsIG51bGwpO1xuXG4gICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9DT0xHUk9VUF9NT0RFLCBudWxsKTtcblxuICAgIGNhc2UgJ3RyJzpcbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfVEFCTEVfUk9XX01PREUsIG51bGwpO1xuICB9XG5cbiAgaWYgKHBhcmVudENvbnRleHQuaW5zZXJ0aW9uTW9kZSA+PSBIVE1MX1RBQkxFX01PREUpIHtcbiAgICAvLyBXaGF0ZXZlciB0YWcgdGhpcyB3YXMsIGl0IHdhc24ndCBhIHRhYmxlIHBhcmVudCBvciBvdGhlciBzcGVjaWFsIHBhcmVudCwgc28gd2UgbXVzdCBoYXZlXG4gICAgLy8gZW50ZXJlZCBwbGFpbiBIVE1MIGFnYWluLlxuICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KEhUTUxfTU9ERSwgbnVsbCk7XG4gIH1cblxuICBpZiAocGFyZW50Q29udGV4dC5pbnNlcnRpb25Nb2RlID09PSBST09UX0hUTUxfTU9ERSkge1xuICAgIC8vIFdlJ3ZlIGVtaXR0ZWQgdGhlIHJvb3QgYW5kIGlzIG5vdyBpbiBwbGFpbiBIVE1MIG1vZGUuXG4gICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBudWxsKTtcbiAgfVxuXG4gIHJldHVybiBwYXJlbnRDb250ZXh0O1xufVxudmFyIFVOSU5JVElBTElaRURfU1VTUEVOU0VfQk9VTkRBUllfSUQgPSBudWxsO1xuZnVuY3Rpb24gYXNzaWduU3VzcGVuc2VCb3VuZGFyeUlEKHJlc3BvbnNlU3RhdGUpIHtcbiAgdmFyIGdlbmVyYXRlZElEID0gcmVzcG9uc2VTdGF0ZS5uZXh0U3VzcGVuc2VJRCsrO1xuICByZXR1cm4gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKHJlc3BvbnNlU3RhdGUuYm91bmRhcnlQcmVmaXggKyBnZW5lcmF0ZWRJRC50b1N0cmluZygxNikpO1xufVxuZnVuY3Rpb24gbWFrZUlkKHJlc3BvbnNlU3RhdGUsIHRyZWVJZCwgbG9jYWxJZCkge1xuICB2YXIgaWRQcmVmaXggPSByZXNwb25zZVN0YXRlLmlkUHJlZml4O1xuICB2YXIgaWQgPSAnOicgKyBpZFByZWZpeCArICdSJyArIHRyZWVJZDsgLy8gVW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IGlkIGF0IHRoaXMgbGV2ZWwsIGFwcGVuZCBhIG51bWJlciBhdCB0aGUgZW5kXG4gIC8vIHRoYXQgcmVwcmVzZW50cyB0aGUgcG9zaXRpb24gb2YgdGhpcyB1c2VJZCBob29rIGFtb25nIGFsbCB0aGUgdXNlSWRcbiAgLy8gaG9va3MgZm9yIHRoaXMgZmliZXIuXG5cbiAgaWYgKGxvY2FsSWQgPiAwKSB7XG4gICAgaWQgKz0gJ0gnICsgbG9jYWxJZC50b1N0cmluZygzMik7XG4gIH1cblxuICByZXR1cm4gaWQgKyAnOic7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUhUTUxUZXh0Tm9kZSh0ZXh0KSB7XG4gIHJldHVybiBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KTtcbn1cblxudmFyIHRleHRTZXBhcmF0b3IgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwhLS0gLS0+Jyk7XG5mdW5jdGlvbiBwdXNoVGV4dEluc3RhbmNlKHRhcmdldCwgdGV4dCwgcmVzcG9uc2VTdGF0ZSwgdGV4dEVtYmVkZGVkKSB7XG4gIGlmICh0ZXh0ID09PSAnJykge1xuICAgIC8vIEVtcHR5IHRleHQgZG9lc24ndCBoYXZlIGEgRE9NIG5vZGUgcmVwcmVzZW50YXRpb24gYW5kIHRoZSBoeWRyYXRpb24gaXMgYXdhcmUgb2YgdGhpcy5cbiAgICByZXR1cm4gdGV4dEVtYmVkZGVkO1xuICB9XG5cbiAgaWYgKHRleHRFbWJlZGRlZCkge1xuICAgIHRhcmdldC5wdXNoKHRleHRTZXBhcmF0b3IpO1xuICB9XG5cbiAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlbmNvZGVIVE1MVGV4dE5vZGUodGV4dCkpKTtcbiAgcmV0dXJuIHRydWU7XG59IC8vIENhbGxlZCB3aGVuIEZpenogaXMgZG9uZSB3aXRoIGEgU2VnbWVudC4gQ3VycmVudGx5IHRoZSBvbmx5IHB1cnBvc2UgaXMgdG8gY29uZGl0aW9uYWxseVxuLy8gZW1pdCBhIHRleHQgc2VwYXJhdG9yIHdoZW4gd2UgZG9uJ3Qga25vdyBmb3Igc3VyZSBpdCBpcyBzYWZlIHRvIG9taXRcblxuZnVuY3Rpb24gcHVzaFNlZ21lbnRGaW5hbGUodGFyZ2V0LCByZXNwb25zZVN0YXRlLCBsYXN0UHVzaGVkVGV4dCwgdGV4dEVtYmVkZGVkKSB7XG4gIGlmIChsYXN0UHVzaGVkVGV4dCAmJiB0ZXh0RW1iZWRkZWQpIHtcbiAgICB0YXJnZXQucHVzaCh0ZXh0U2VwYXJhdG9yKTtcbiAgfVxufVxudmFyIHN0eWxlTmFtZUNhY2hlID0gbmV3IE1hcCgpO1xuXG5mdW5jdGlvbiBwcm9jZXNzU3R5bGVOYW1lKHN0eWxlTmFtZSkge1xuICB2YXIgY2h1bmsgPSBzdHlsZU5hbWVDYWNoZS5nZXQoc3R5bGVOYW1lKTtcblxuICBpZiAoY2h1bmsgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjaHVuaztcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoaHlwaGVuYXRlU3R5bGVOYW1lKHN0eWxlTmFtZSkpKTtcbiAgc3R5bGVOYW1lQ2FjaGUuc2V0KHN0eWxlTmFtZSwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIHN0eWxlQXR0cmlidXRlU3RhcnQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyBzdHlsZT1cIicpO1xudmFyIHN0eWxlQXNzaWduID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc6Jyk7XG52YXIgc3R5bGVTZXBhcmF0b3IgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzsnKTtcblxuZnVuY3Rpb24gcHVzaFN0eWxlKHRhcmdldCwgcmVzcG9uc2VTdGF0ZSwgc3R5bGUpIHtcbiAgaWYgKHR5cGVvZiBzdHlsZSAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgJyArIFwibm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArICdlbSd9fSB3aGVuIFwiICsgJ3VzaW5nIEpTWC4nKTtcbiAgfVxuXG4gIHZhciBpc0ZpcnN0ID0gdHJ1ZTtcblxuICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGUpIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoc3R5bGUsIHN0eWxlTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdCBhcmJpdHJhcnkgQ1NTXG4gICAgLy8gd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAgIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gICAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXG4gICAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAgIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xuICAgIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxuXG5cbiAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlW3N0eWxlTmFtZV07XG5cbiAgICBpZiAoc3R5bGVWYWx1ZSA9PSBudWxsIHx8IHR5cGVvZiBzdHlsZVZhbHVlID09PSAnYm9vbGVhbicgfHwgc3R5bGVWYWx1ZSA9PT0gJycpIHtcbiAgICAgIC8vIFRPRE86IFdlIHVzZWQgdG8gc2V0IGVtcHR5IHN0cmluZyBhcyBhIHN0eWxlIHdpdGggYW4gZW1wdHkgdmFsdWUuIERvZXMgdGhhdCBldmVyIG1ha2Ugc2Vuc2U/XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgbmFtZUNodW5rID0gdm9pZCAwO1xuICAgIHZhciB2YWx1ZUNodW5rID0gdm9pZCAwO1xuICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG5cbiAgICBpZiAoaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgbmFtZUNodW5rID0gc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihzdHlsZU5hbWUpKTtcblxuICAgICAge1xuICAgICAgICBjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24oc3R5bGVWYWx1ZSwgc3R5bGVOYW1lKTtcbiAgICAgIH1cblxuICAgICAgdmFsdWVDaHVuayA9IHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoKCcnICsgc3R5bGVWYWx1ZSkudHJpbSgpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUkMShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBuYW1lQ2h1bmsgPSBwcm9jZXNzU3R5bGVOYW1lKHN0eWxlTmFtZSk7XG5cbiAgICAgIGlmICh0eXBlb2Ygc3R5bGVWYWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKHN0eWxlVmFsdWUgIT09IDAgJiYgIWhhc093blByb3BlcnR5LmNhbGwoaXNVbml0bGVzc051bWJlciwgc3R5bGVOYW1lKSkge1xuICAgICAgICAgIHZhbHVlQ2h1bmsgPSBzdHJpbmdUb0NodW5rKHN0eWxlVmFsdWUgKyAncHgnKTsgLy8gUHJlc3VtZXMgaW1wbGljaXQgJ3B4JyBzdWZmaXggZm9yIHVuaXRsZXNzIG51bWJlcnNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZUNodW5rID0gc3RyaW5nVG9DaHVuaygnJyArIHN0eWxlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tDU1NQcm9wZXJ0eVN0cmluZ0NvZXJjaW9uKHN0eWxlVmFsdWUsIHN0eWxlTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZUNodW5rID0gc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcigoJycgKyBzdHlsZVZhbHVlKS50cmltKCkpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgaXNGaXJzdCA9IGZhbHNlOyAvLyBJZiBpdCdzIGZpcnN0LCB3ZSBkb24ndCBuZWVkIGFueSBzZXBhcmF0b3JzIHByZWZpeGVkLlxuXG4gICAgICB0YXJnZXQucHVzaChzdHlsZUF0dHJpYnV0ZVN0YXJ0LCBuYW1lQ2h1bmssIHN0eWxlQXNzaWduLCB2YWx1ZUNodW5rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0LnB1c2goc3R5bGVTZXBhcmF0b3IsIG5hbWVDaHVuaywgc3R5bGVBc3NpZ24sIHZhbHVlQ2h1bmspO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaXNGaXJzdCkge1xuICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZUVuZCk7XG4gIH1cbn1cblxudmFyIGF0dHJpYnV0ZVNlcGFyYXRvciA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnICcpO1xudmFyIGF0dHJpYnV0ZUFzc2lnbiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPVwiJyk7XG52YXIgYXR0cmlidXRlRW5kID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIicpO1xudmFyIGF0dHJpYnV0ZUVtcHR5U3RyaW5nID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc9XCJcIicpO1xuXG5mdW5jdGlvbiBwdXNoQXR0cmlidXRlKHRhcmdldCwgcmVzcG9uc2VTdGF0ZSwgbmFtZSwgdmFsdWUpIHtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnc3R5bGUnOlxuICAgICAge1xuICAgICAgICBwdXNoU3R5bGUodGFyZ2V0LCByZXNwb25zZVN0YXRlLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2RlZmF1bHRWYWx1ZSc6XG4gICAgY2FzZSAnZGVmYXVsdENoZWNrZWQnOiAvLyBUaGVzZSBzaG91bGRuJ3QgYmUgc2V0IGFzIGF0dHJpYnV0ZXMgb24gZ2VuZXJpYyBIVE1MIGVsZW1lbnRzLlxuXG4gICAgY2FzZSAnaW5uZXJIVE1MJzogLy8gTXVzdCB1c2UgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgaW5zdGVhZC5cblxuICAgIGNhc2UgJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyc6XG4gICAgY2FzZSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJzpcbiAgICAgIC8vIElnbm9yZWQuIFRoZXNlIGFyZSBidWlsdC1pbiB0byBSZWFjdCBvbiB0aGUgY2xpZW50LlxuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCAvLyBzaG91bGRJZ25vcmVBdHRyaWJ1dGVcbiAgLy8gV2UgaGF2ZSBhbHJlYWR5IGZpbHRlcmVkIG91dCBudWxsL3VuZGVmaW5lZCBhbmQgcmVzZXJ2ZWQgd29yZHMuXG4gIG5hbWUubGVuZ3RoID4gMiAmJiAobmFtZVswXSA9PT0gJ28nIHx8IG5hbWVbMF0gPT09ICdPJykgJiYgKG5hbWVbMV0gPT09ICduJyB8fCBuYW1lWzFdID09PSAnTicpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcblxuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgLy8gc2hvdWxkUmVtb3ZlQXR0cmlidXRlXG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzogLy8gJEZsb3dJc3N1ZSBzeW1ib2wgaXMgcGVyZmVjdGx5IHZhbGlkIGhlcmVcblxuICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCFwcm9wZXJ0eUluZm8uYWNjZXB0c0Jvb2xlYW5zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcbiAgICB2YXIgYXR0cmlidXRlTmFtZUNodW5rID0gc3RyaW5nVG9DaHVuayhhdHRyaWJ1dGVOYW1lKTsgLy8gVE9ETzogSWYgaXQncyBrbm93biB3ZSBjYW4gY2FjaGUgdGhlIGNodW5rLlxuXG4gICAgc3dpdGNoIChwcm9wZXJ0eUluZm8udHlwZSkge1xuICAgICAgY2FzZSBCT09MRUFOOlxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIGF0dHJpYnV0ZU5hbWVDaHVuaywgYXR0cmlidXRlRW1wdHlTdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIE9WRVJMT0FERURfQk9PTEVBTjpcbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBhdHRyaWJ1dGVOYW1lQ2h1bmssIGF0dHJpYnV0ZUVtcHR5U3RyaW5nKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gZmFsc2UpIDsgZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBhdHRyaWJ1dGVOYW1lQ2h1bmssIGF0dHJpYnV0ZUFzc2lnbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSkpLCBhdHRyaWJ1dGVFbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIE5VTUVSSUM6XG4gICAgICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBhdHRyaWJ1dGVOYW1lQ2h1bmssIGF0dHJpYnV0ZUFzc2lnbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSkpLCBhdHRyaWJ1dGVFbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUE9TSVRJVkVfTlVNRVJJQzpcbiAgICAgICAgaWYgKCFpc05hTih2YWx1ZSkgJiYgdmFsdWUgPj0gMSkge1xuICAgICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgYXR0cmlidXRlTmFtZUNodW5rLCBhdHRyaWJ1dGVBc3NpZ24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpKSwgYXR0cmlidXRlRW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocHJvcGVydHlJbmZvLnNhbml0aXplVVJMKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgICAgIHNhbml0aXplVVJMKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgYXR0cmlidXRlTmFtZUNodW5rLCBhdHRyaWJ1dGVBc3NpZ24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpKSwgYXR0cmlidXRlRW5kKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgIC8vIHNob3VsZFJlbW92ZUF0dHJpYnV0ZVxuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICBjYXNlICdmdW5jdGlvbic6IC8vICRGbG93SXNzdWUgc3ltYm9sIGlzIHBlcmZlY3RseSB2YWxpZCBoZXJlXG5cbiAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG5cbiAgICAgICAgICBpZiAocHJlZml4ICE9PSAnZGF0YS0nICYmIHByZWZpeCAhPT0gJ2FyaWEtJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhuYW1lKSwgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksIGF0dHJpYnV0ZUVuZCk7XG4gIH1cbn1cblxudmFyIGVuZE9mU3RhcnRUYWcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJz4nKTtcbnZhciBlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJy8+Jyk7XG5cbmZ1bmN0aW9uIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKSB7XG4gIGlmIChpbm5lckhUTUwgIT0gbnVsbCkge1xuICAgIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5uZXJIVE1MICE9PSAnb2JqZWN0JyB8fCAhKCdfX2h0bWwnIGluIGlubmVySFRNTCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gJyArICdQbGVhc2UgdmlzaXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rhbmdlcm91c2x5LXNldC1pbm5lci1odG1sICcgKyAnZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgfVxuXG4gICAgdmFyIGh0bWwgPSBpbm5lckhUTUwuX19odG1sO1xuXG4gICAgaWYgKGh0bWwgIT09IG51bGwgJiYgaHRtbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKGh0bWwpO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXQucHVzaChzdHJpbmdUb0NodW5rKCcnICsgaHRtbCkpO1xuICAgIH1cbiAgfVxufSAvLyBUT0RPOiBNb3ZlIHRoZXNlIHRvIFJlc3BvbnNlU3RhdGUgc28gdGhhdCB3ZSB3YXJuIGZvciBldmVyeSByZXF1ZXN0LlxuLy8gSXQgd291bGQgaGVscCBkZWJ1Z2dpbmcgaW4gc3RhdGVmdWwgc2VydmVycyAoZS5nLiBzZXJ2aWNlIHdvcmtlcikuXG5cblxudmFyIGRpZFdhcm5EZWZhdWx0SW5wdXRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5EZWZhdWx0Q2hlY2tlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuRGVmYXVsdFRleHRhcmVhVmFsdWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuID0gZmFsc2U7XG52YXIgZGlkV2FybkludmFsaWRPcHRpb25Jbm5lckhUTUwgPSBmYWxzZTtcbnZhciBkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiA9IGZhbHNlO1xuXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3AocHJvcHMsIHByb3BOYW1lKSB7XG4gIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgdmFyIGFycmF5ID0gaXNBcnJheSh2YWx1ZSk7XG5cbiAgICAgIGlmIChwcm9wcy5tdWx0aXBsZSAmJiAhYXJyYXkpIHtcbiAgICAgICAgZXJyb3IoJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiAnICsgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4nLCBwcm9wTmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKCFwcm9wcy5tdWx0aXBsZSAmJiBhcnJheSkge1xuICAgICAgICBlcnJvcignVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyICcgKyAndmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS4nLCBwcm9wTmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGFydFNlbGVjdCh0YXJnZXQsIHByb3BzLCByZXNwb25zZVN0YXRlKSB7XG4gIHtcbiAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKCdzZWxlY3QnLCBwcm9wcyk7XG4gICAgY2hlY2tTZWxlY3RQcm9wKHByb3BzLCAndmFsdWUnKTtcbiAgICBjaGVja1NlbGVjdFByb3AocHJvcHMsICdkZWZhdWx0VmFsdWUnKTtcblxuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlKSB7XG4gICAgICBlcnJvcignU2VsZWN0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBzZWxlY3QgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuXG4gICAgICBkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKCdzZWxlY3QnKSk7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICAvLyBUT0RPOiBUaGlzIGRvZXNuJ3QgcmVhbGx5IG1ha2Ugc2Vuc2UgZm9yIHNlbGVjdCBzaW5jZSBpdCBjYW4ndCB1c2UgdGhlIGNvbnRyb2xsZWRcbiAgICAgICAgICAvLyB2YWx1ZSBpbiB0aGUgaW5uZXJIVE1MLlxuICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkZWZhdWx0VmFsdWUnOlxuICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgLy8gVGhlc2UgYXJlIHNldCBvbiB0aGUgQ29udGV4dCBpbnN0ZWFkIGFuZCBhcHBsaWVkIHRvIHRoZSBuZXN0ZWQgb3B0aW9ucy5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCByZXNwb25zZVN0YXRlLCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCBjaGlsZHJlbik7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gZmxhdHRlbk9wdGlvbkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBjb250ZW50ID0gJyc7IC8vIEZsYXR0ZW4gY2hpbGRyZW4gYW5kIHdhcm4gaWYgdGhleSBhcmVuJ3Qgc3RyaW5ncyBvciBudW1iZXJzO1xuICAvLyBpbnZhbGlkIHR5cGVzIGFyZSBpZ25vcmVkLlxuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGVudCArPSBjaGlsZDtcblxuICAgIHtcbiAgICAgIGlmICghZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiAmJiB0eXBlb2YgY2hpbGQgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBjaGlsZCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ0Nhbm5vdCBpbmZlciB0aGUgb3B0aW9uIHZhbHVlIG9mIGNvbXBsZXggY2hpbGRyZW4uICcgKyAnUGFzcyBhIGB2YWx1ZWAgcHJvcCBvciB1c2UgYSBwbGFpbiBzdHJpbmcgYXMgY2hpbGRyZW4gdG8gPG9wdGlvbj4uJyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbnZhciBzZWxlY3RlZE1hcmtlckF0dHJpYnV0ZSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnIHNlbGVjdGVkPVwiXCInKTtcblxuZnVuY3Rpb24gcHVzaFN0YXJ0T3B0aW9uKHRhcmdldCwgcHJvcHMsIHJlc3BvbnNlU3RhdGUsIGZvcm1hdENvbnRleHQpIHtcbiAgdmFyIHNlbGVjdGVkVmFsdWUgPSBmb3JtYXRDb250ZXh0LnNlbGVjdGVkVmFsdWU7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ29wdGlvbicpKTtcbiAgdmFyIGNoaWxkcmVuID0gbnVsbDtcbiAgdmFyIHZhbHVlID0gbnVsbDtcbiAgdmFyIHNlbGVjdGVkID0gbnVsbDtcbiAgdmFyIGlubmVySFRNTCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc2VsZWN0ZWQnOlxuICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAgIHNlbGVjdGVkID0gcHJvcFZhbHVlO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gVE9ETzogUmVtb3ZlIHN1cHBvcnQgZm9yIGBzZWxlY3RlZGAgaW4gPG9wdGlvbj4uXG4gICAgICAgICAgICBpZiAoIWRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uKSB7XG4gICAgICAgICAgICAgIGVycm9yKCdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiAnICsgJ3NldHRpbmcgYHNlbGVjdGVkYCBvbiA8b3B0aW9uPi4nKTtcblxuICAgICAgICAgICAgICBkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lLW5vLWZhbGx0aHJvdWdoXG5cbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIHZhbHVlID0gcHJvcFZhbHVlO1xuICAgICAgICAvLyBXZSBpbnRlbnRpb25hbGx5IGZhbGx0aHJvdWdoIHRvIGFsc28gc2V0IHRoZSBhdHRyaWJ1dGUgb24gdGhlIG5vZGUuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZS1uby1mYWxsdGhyb3VnaFxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHJlc3BvbnNlU3RhdGUsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHNlbGVjdGVkVmFsdWUgIT0gbnVsbCkge1xuICAgIHZhciBzdHJpbmdWYWx1ZTtcblxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCAndmFsdWUnKTtcbiAgICAgIH1cblxuICAgICAgc3RyaW5nVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIGlmIChpbm5lckhUTUwgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIWRpZFdhcm5JbnZhbGlkT3B0aW9uSW5uZXJIVE1MKSB7XG4gICAgICAgICAgICBkaWRXYXJuSW52YWxpZE9wdGlvbklubmVySFRNTCA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdQYXNzIGEgYHZhbHVlYCBwcm9wIGlmIHlvdSBzZXQgZGFuZ2Vyb3VzbHlJbm5lckhUTUwgc28gUmVhY3Qga25vd3MgJyArICd3aGljaCB2YWx1ZSBzaG91bGQgYmUgc2VsZWN0ZWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0cmluZ1ZhbHVlID0gZmxhdHRlbk9wdGlvbkNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShzZWxlY3RlZFZhbHVlKSkge1xuICAgICAgLy8gbXVsdGlwbGVcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWRWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihzZWxlY3RlZFZhbHVlW2ldLCAndmFsdWUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2ID0gJycgKyBzZWxlY3RlZFZhbHVlW2ldO1xuXG4gICAgICAgIGlmICh2ID09PSBzdHJpbmdWYWx1ZSkge1xuICAgICAgICAgIHRhcmdldC5wdXNoKHNlbGVjdGVkTWFya2VyQXR0cmlidXRlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24oc2VsZWN0ZWRWYWx1ZSwgJ3NlbGVjdC52YWx1ZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoJycgKyBzZWxlY3RlZFZhbHVlID09PSBzdHJpbmdWYWx1ZSkge1xuICAgICAgICB0YXJnZXQucHVzaChzZWxlY3RlZE1hcmtlckF0dHJpYnV0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHNlbGVjdGVkKSB7XG4gICAgdGFyZ2V0LnB1c2goc2VsZWN0ZWRNYXJrZXJBdHRyaWJ1dGUpO1xuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBwdXNoSW5wdXQodGFyZ2V0LCBwcm9wcywgcmVzcG9uc2VTdGF0ZSkge1xuICB7XG4gICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygnaW5wdXQnLCBwcm9wcyk7XG5cbiAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5EZWZhdWx0Q2hlY2tlZCkge1xuICAgICAgZXJyb3IoJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIGNoZWNrZWQgYW5kIGRlZmF1bHRDaGVja2VkIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycsICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuXG4gICAgICBkaWRXYXJuRGVmYXVsdENoZWNrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUpIHtcbiAgICAgIGVycm9yKCclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJywgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG5cbiAgICAgIGRpZFdhcm5EZWZhdWx0SW5wdXRWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZygnaW5wdXQnKSk7XG4gIHZhciB2YWx1ZSA9IG51bGw7XG4gIHZhciBkZWZhdWx0VmFsdWUgPSBudWxsO1xuICB2YXIgY2hlY2tlZCA9IG51bGw7XG4gIHZhciBkZWZhdWx0Q2hlY2tlZCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0JyArIFwiIGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgXCIgKyAndXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZS1uby1mYWxsdGhyb3VnaFxuXG4gICAgICAgIGNhc2UgJ2RlZmF1bHRDaGVja2VkJzpcbiAgICAgICAgICBkZWZhdWx0Q2hlY2tlZCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkZWZhdWx0VmFsdWUnOlxuICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdjaGVja2VkJzpcbiAgICAgICAgICBjaGVja2VkID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICB2YWx1ZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCByZXNwb25zZVN0YXRlLCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChjaGVja2VkICE9PSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHJlc3BvbnNlU3RhdGUsICdjaGVja2VkJywgY2hlY2tlZCk7XG4gIH0gZWxzZSBpZiAoZGVmYXVsdENoZWNrZWQgIT09IG51bGwpIHtcbiAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcmVzcG9uc2VTdGF0ZSwgJ2NoZWNrZWQnLCBkZWZhdWx0Q2hlY2tlZCk7XG4gIH1cblxuICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcmVzcG9uc2VTdGF0ZSwgJ3ZhbHVlJywgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGRlZmF1bHRWYWx1ZSAhPT0gbnVsbCkge1xuICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCByZXNwb25zZVN0YXRlLCAndmFsdWUnLCBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGFydFRleHRBcmVhKHRhcmdldCwgcHJvcHMsIHJlc3BvbnNlU3RhdGUpIHtcbiAge1xuICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoJ3RleHRhcmVhJywgcHJvcHMpO1xuXG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSkge1xuICAgICAgZXJyb3IoJ1RleHRhcmVhIGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCB0ZXh0YXJlYSAnICsgJ2FuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuXG4gICAgICBkaWRXYXJuRGVmYXVsdFRleHRhcmVhVmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ3RleHRhcmVhJykpO1xuICB2YXIgdmFsdWUgPSBudWxsO1xuICB2YXIgZGVmYXVsdFZhbHVlID0gbnVsbDtcbiAgdmFyIGNoaWxkcmVuID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgdmFsdWUgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGVmYXVsdFZhbHVlJzpcbiAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBkb2VzIG5vdCBtYWtlIHNlbnNlIG9uIDx0ZXh0YXJlYT4uJyk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZS1uby1mYWxsdGhyb3VnaFxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHJlc3BvbnNlU3RhdGUsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHZhbHVlID09PSBudWxsICYmIGRlZmF1bHRWYWx1ZSAhPT0gbnVsbCkge1xuICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7IC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBjaGlsZHJlbiBjb250ZW50IGluIDx0ZXh0YXJlYT4uXG5cbiAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICB7XG4gICAgICBlcnJvcignVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJyk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLicpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCc8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuJyk7XG4gICAgICB9IC8vIFRPRE86IHJlbW92ZSB0aGUgY29lcmNpb24gYW5kIHRoZSBERVYgY2hlY2sgYmVsb3cgYmVjYXVzZSBpdCB3aWxsXG4gICAgICAvLyBhbHdheXMgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIGNvZXJjaW9uIHNldmVyYWwgbGluZXMgYmVsb3cgaXQuICMyMjMwOVxuXG5cbiAgICAgIHtcbiAgICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oY2hpbGRyZW5bMF0pO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9ICcnICsgY2hpbGRyZW5bMF07XG4gICAgfVxuXG4gICAge1xuICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIHZhbHVlID0gJycgKyBjaGlsZHJlbjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlWzBdID09PSAnXFxuJykge1xuICAgIC8vIHRleHQvaHRtbCBpZ25vcmVzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlc2UgdGFncyBpZiBpdCdzIGEgbmV3bGluZVxuICAgIC8vIFByZWZlciB0byBicmVhayBhcHBsaWNhdGlvbi94bWwgb3ZlciB0ZXh0L2h0bWwgKGZvciBub3cpIGJ5IGFkZGluZ1xuICAgIC8vIGEgbmV3bGluZSBzcGVjaWZpY2FsbHkgdG8gZ2V0IGVhdGVuIGJ5IHRoZSBwYXJzZXIuIChBbHRlcm5hdGVseSBmb3JcbiAgICAvLyB0ZXh0YXJlYXMsIHJlcGxhY2luZyBcIl5cXG5cIiB3aXRoIFwiXFxyXFxuXCIgZG9lc24ndCBnZXQgZWF0ZW4sIGFuZCB0aGUgZmlyc3RcbiAgICAvLyBcXHIgaXMgbm9ybWFsaXplZCBvdXQgYnkgSFRNTFRleHRBcmVhRWxlbWVudCN2YWx1ZS4pXG4gICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbC1wb2x5Z2xvdC8jbmV3bGluZXMtaW4tdGV4dGFyZWEtYW5kLXByZT5cbiAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNlbGVtZW50LXJlc3RyaWN0aW9ucz5cbiAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNuZXdsaW5lcz5cbiAgICAvLyBTZWU6IFBhcnNpbmcgb2YgXCJ0ZXh0YXJlYVwiIFwibGlzdGluZ1wiIGFuZCBcInByZVwiIGVsZW1lbnRzXG4gICAgLy8gIGZyb20gPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHk+XG4gICAgdGFyZ2V0LnB1c2gobGVhZGluZ05ld2xpbmUpO1xuICB9IC8vIFRvU3RyaW5nIGFuZCBwdXNoIGRpcmVjdGx5IGluc3RlYWQgb2YgcmVjdXJzZSBvdmVyIGNoaWxkcmVuLlxuICAvLyBXZSBkb24ndCByZWFsbHkgc3VwcG9ydCBjb21wbGV4IGNoaWxkcmVuIGluIHRoZSB2YWx1ZSBhbnl3YXkuXG4gIC8vIFRoaXMgYWxzbyBjdXJyZW50bHkgYXZvaWRzIGEgdHJhaWxpbmcgY29tbWVudCBub2RlIHdoaWNoIGJyZWFrcyB0ZXh0YXJlYS5cblxuXG4gIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsICd2YWx1ZScpO1xuICAgIH1cblxuICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoZW5jb2RlSFRNTFRleHROb2RlKCcnICsgdmFsdWUpKSk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaFNlbGZDbG9zaW5nKHRhcmdldCwgcHJvcHMsIHRhZywgcmVzcG9uc2VTdGF0ZSkge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKHRhZykpO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRhZyArIFwiIGlzIGEgc2VsZi1jbG9zaW5nIHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgXCIgKyAndXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZS1uby1mYWxsdGhyb3VnaFxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHJlc3BvbnNlU3RhdGUsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZ1NlbGZDbG9zaW5nKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGFydE1lbnVJdGVtKHRhcmdldCwgcHJvcHMsIHJlc3BvbnNlU3RhdGUpIHtcbiAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZygnbWVudWl0ZW0nKSk7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21lbnVpdGVtcyBjYW5ub3QgaGF2ZSBgY2hpbGRyZW5gIG5vciBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUtbm8tZmFsbHRocm91Z2hcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCByZXNwb25zZVN0YXRlLCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXJ0VGl0bGUodGFyZ2V0LCBwcm9wcywgcmVzcG9uc2VTdGF0ZSkge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKCd0aXRsZScpKTtcbiAgdmFyIGNoaWxkcmVuID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRpdGxlPi4nKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lLW5vLWZhbGx0aHJvdWdoXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcmVzcG9uc2VTdGF0ZSwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcblxuICB7XG4gICAgdmFyIGNoaWxkID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiYgY2hpbGRyZW4ubGVuZ3RoIDwgMiA/IGNoaWxkcmVuWzBdIHx8IG51bGwgOiBjaGlsZHJlbjtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICBlcnJvcignQSB0aXRsZSBlbGVtZW50IHJlY2VpdmVkIGFuIGFycmF5IHdpdGggbW9yZSB0aGFuIDEgZWxlbWVudCBhcyBjaGlsZHJlbi4gJyArICdJbiBicm93c2VycyB0aXRsZSBFbGVtZW50cyBjYW4gb25seSBoYXZlIFRleHQgTm9kZXMgYXMgY2hpbGRyZW4uIElmICcgKyAndGhlIGNoaWxkcmVuIGJlaW5nIHJlbmRlcmVkIG91dHB1dCBtb3JlIHRoYW4gYSBzaW5nbGUgdGV4dCBub2RlIGluIGFnZ3JlZ2F0ZSB0aGUgYnJvd3NlciAnICsgJ3dpbGwgZGlzcGxheSBtYXJrdXAgYW5kIGNvbW1lbnRzIGFzIHRleHQgaW4gdGhlIHRpdGxlIGFuZCBoeWRyYXRpb24gd2lsbCBsaWtlbHkgZmFpbCBhbmQgJyArICdmYWxsIGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZycpO1xuICAgIH0gZWxzZSBpZiAoY2hpbGQgIT0gbnVsbCAmJiBjaGlsZC4kJHR5cGVvZiAhPSBudWxsKSB7XG4gICAgICBlcnJvcignQSB0aXRsZSBlbGVtZW50IHJlY2VpdmVkIGEgUmVhY3QgZWxlbWVudCBmb3IgY2hpbGRyZW4uICcgKyAnSW4gdGhlIGJyb3dzZXIgdGl0bGUgRWxlbWVudHMgY2FuIG9ubHkgaGF2ZSBUZXh0IE5vZGVzIGFzIGNoaWxkcmVuLiBJZiAnICsgJ3RoZSBjaGlsZHJlbiBiZWluZyByZW5kZXJlZCBvdXRwdXQgbW9yZSB0aGFuIGEgc2luZ2xlIHRleHQgbm9kZSBpbiBhZ2dyZWdhdGUgdGhlIGJyb3dzZXIgJyArICd3aWxsIGRpc3BsYXkgbWFya3VwIGFuZCBjb21tZW50cyBhcyB0ZXh0IGluIHRoZSB0aXRsZSBhbmQgaHlkcmF0aW9uIHdpbGwgbGlrZWx5IGZhaWwgYW5kICcgKyAnZmFsbCBiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcnKTtcbiAgICB9IGVsc2UgaWYgKGNoaWxkICE9IG51bGwgJiYgdHlwZW9mIGNoaWxkICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgY2hpbGQgIT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignQSB0aXRsZSBlbGVtZW50IHJlY2VpdmVkIGEgdmFsdWUgdGhhdCB3YXMgbm90IGEgc3RyaW5nIG9yIG51bWJlciBmb3IgY2hpbGRyZW4uICcgKyAnSW4gdGhlIGJyb3dzZXIgdGl0bGUgRWxlbWVudHMgY2FuIG9ubHkgaGF2ZSBUZXh0IE5vZGVzIGFzIGNoaWxkcmVuLiBJZiAnICsgJ3RoZSBjaGlsZHJlbiBiZWluZyByZW5kZXJlZCBvdXRwdXQgbW9yZSB0aGFuIGEgc2luZ2xlIHRleHQgbm9kZSBpbiBhZ2dyZWdhdGUgdGhlIGJyb3dzZXIgJyArICd3aWxsIGRpc3BsYXkgbWFya3VwIGFuZCBjb21tZW50cyBhcyB0ZXh0IGluIHRoZSB0aXRsZSBhbmQgaHlkcmF0aW9uIHdpbGwgbGlrZWx5IGZhaWwgYW5kICcgKyAnZmFsbCBiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KHRhcmdldCwgcHJvcHMsIHRhZywgcmVzcG9uc2VTdGF0ZSkge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKHRhZykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHJlc3BvbnNlU3RhdGUsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcblxuICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJykge1xuICAgIC8vIFNwZWNpYWwgY2FzZSBjaGlsZHJlbiBhcyBhIHN0cmluZyB0byBhdm9pZCB0aGUgdW5uZWNlc3NhcnkgY29tbWVudC5cbiAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBzcGVjaWFsIGNhc2UgYWZ0ZXIgdGhlIGdlbmVyYWwgb3B0aW1pemF0aW9uIGlzIGluIHBsYWNlLlxuICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoZW5jb2RlSFRNTFRleHROb2RlKGNoaWxkcmVuKSkpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBwdXNoU3RhcnRDdXN0b21FbGVtZW50KHRhcmdldCwgcHJvcHMsIHRhZywgcmVzcG9uc2VTdGF0ZSkge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKHRhZykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3N0eWxlJzpcbiAgICAgICAgICBwdXNoU3R5bGUodGFyZ2V0LCByZXNwb25zZVN0YXRlLCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyc6XG4gICAgICAgIGNhc2UgJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc6XG4gICAgICAgICAgLy8gSWdub3JlZC4gVGhlc2UgYXJlIGJ1aWx0LWluIHRvIFJlYWN0IG9uIHRoZSBjbGllbnQuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoaXNBdHRyaWJ1dGVOYW1lU2FmZShwcm9wS2V5KSAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIHN0cmluZ1RvQ2h1bmsocHJvcEtleSksIGF0dHJpYnV0ZUFzc2lnbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcihwcm9wVmFsdWUpKSwgYXR0cmlidXRlRW5kKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbnZhciBsZWFkaW5nTmV3bGluZSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXFxuJyk7XG5cbmZ1bmN0aW9uIHB1c2hTdGFydFByZWZvcm1hdHRlZEVsZW1lbnQodGFyZ2V0LCBwcm9wcywgdGFnLCByZXNwb25zZVN0YXRlKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSk7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcmVzcG9uc2VTdGF0ZSwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTsgLy8gdGV4dC9odG1sIGlnbm9yZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGVzZSB0YWdzIGlmIGl0J3MgYSBuZXdsaW5lXG4gIC8vIFByZWZlciB0byBicmVhayBhcHBsaWNhdGlvbi94bWwgb3ZlciB0ZXh0L2h0bWwgKGZvciBub3cpIGJ5IGFkZGluZ1xuICAvLyBhIG5ld2xpbmUgc3BlY2lmaWNhbGx5IHRvIGdldCBlYXRlbiBieSB0aGUgcGFyc2VyLiAoQWx0ZXJuYXRlbHkgZm9yXG4gIC8vIHRleHRhcmVhcywgcmVwbGFjaW5nIFwiXlxcblwiIHdpdGggXCJcXHJcXG5cIiBkb2Vzbid0IGdldCBlYXRlbiwgYW5kIHRoZSBmaXJzdFxuICAvLyBcXHIgaXMgbm9ybWFsaXplZCBvdXQgYnkgSFRNTFRleHRBcmVhRWxlbWVudCN2YWx1ZS4pXG4gIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWwtcG9seWdsb3QvI25ld2xpbmVzLWluLXRleHRhcmVhLWFuZC1wcmU+XG4gIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2VsZW1lbnQtcmVzdHJpY3Rpb25zPlxuICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNuZXdsaW5lcz5cbiAgLy8gU2VlOiBQYXJzaW5nIG9mIFwidGV4dGFyZWFcIiBcImxpc3RpbmdcIiBhbmQgXCJwcmVcIiBlbGVtZW50c1xuICAvLyAgZnJvbSA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keT5cbiAgLy8gVE9ETzogVGhpcyBkb2Vzbid0IGRlYWwgd2l0aCB0aGUgY2FzZSB3aGVyZSB0aGUgY2hpbGQgaXMgYW4gYXJyYXlcbiAgLy8gb3IgY29tcG9uZW50IHRoYXQgcmV0dXJucyBhIHN0cmluZy5cblxuICBpZiAoaW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGlubmVySFRNTCAhPT0gJ29iamVjdCcgfHwgISgnX19odG1sJyBpbiBpbm5lckhUTUwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuICcgKyAnUGxlYXNlIHZpc2l0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCAnICsgJ2ZvciBtb3JlIGluZm9ybWF0aW9uLicpO1xuICAgIH1cblxuICAgIHZhciBodG1sID0gaW5uZXJIVE1MLl9faHRtbDtcblxuICAgIGlmIChodG1sICE9PSBudWxsICYmIGh0bWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBodG1sID09PSAnc3RyaW5nJyAmJiBodG1sLmxlbmd0aCA+IDAgJiYgaHRtbFswXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgdGFyZ2V0LnB1c2gobGVhZGluZ05ld2xpbmUsIHN0cmluZ1RvQ2h1bmsoaHRtbCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKGh0bWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuaygnJyArIGh0bWwpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJyAmJiBjaGlsZHJlblswXSA9PT0gJ1xcbicpIHtcbiAgICB0YXJnZXQucHVzaChsZWFkaW5nTmV3bGluZSk7XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59IC8vIFdlIGFjY2VwdCBhbnkgdGFnIHRvIGJlIHJlbmRlcmVkIGJ1dCBzaW5jZSB0aGlzIGdldHMgaW5qZWN0ZWQgaW50byBhcmJpdHJhcnlcbi8vIEhUTUwsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgaXQncyBhIHNhZmUgdGFnLlxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVxuXG5cbnZhciBWQUxJRF9UQUdfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWjpfXFwuXFwtXFxkXSokLzsgLy8gU2ltcGxpZmllZCBzdWJzZXRcblxudmFyIHZhbGlkYXRlZFRhZ0NhY2hlID0gbmV3IE1hcCgpO1xuXG5mdW5jdGlvbiBzdGFydENodW5rRm9yVGFnKHRhZykge1xuICB2YXIgdGFnU3RhcnRDaHVuayA9IHZhbGlkYXRlZFRhZ0NhY2hlLmdldCh0YWcpO1xuXG4gIGlmICh0YWdTdGFydENodW5rID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoIVZBTElEX1RBR19SRUdFWC50ZXN0KHRhZykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdGFnOiBcIiArIHRhZyk7XG4gICAgfVxuXG4gICAgdGFnU3RhcnRDaHVuayA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPCcgKyB0YWcpO1xuICAgIHZhbGlkYXRlZFRhZ0NhY2hlLnNldCh0YWcsIHRhZ1N0YXJ0Q2h1bmspO1xuICB9XG5cbiAgcmV0dXJuIHRhZ1N0YXJ0Q2h1bms7XG59XG5cbnZhciBET0NUWVBFID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8IURPQ1RZUEUgaHRtbD4nKTtcbmZ1bmN0aW9uIHB1c2hTdGFydEluc3RhbmNlKHRhcmdldCwgdHlwZSwgcHJvcHMsIHJlc3BvbnNlU3RhdGUsIGZvcm1hdENvbnRleHQpIHtcbiAge1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCBudWxsKTtcblxuICAgIGlmICghcHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nICYmIHByb3BzLmNvbnRlbnRFZGl0YWJsZSAmJiBwcm9wcy5jaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBlcnJvcignQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLicpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUgIT09IFNWR19NT0RFICYmIGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSAhPT0gTUFUSE1MX01PREUpIHtcbiAgICAgIGlmICh0eXBlLmluZGV4T2YoJy0nKSA9PT0gLTEgJiYgdHlwZW9mIHByb3BzLmlzICE9PSAnc3RyaW5nJyAmJiB0eXBlLnRvTG93ZXJDYXNlKCkgIT09IHR5cGUpIHtcbiAgICAgICAgZXJyb3IoJzwlcyAvPiBpcyB1c2luZyBpbmNvcnJlY3QgY2FzaW5nLiAnICsgJ1VzZSBQYXNjYWxDYXNlIGZvciBSZWFjdCBjb21wb25lbnRzLCAnICsgJ29yIGxvd2VyY2FzZSBmb3IgSFRNTCBlbGVtZW50cy4nLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAvLyBTcGVjaWFsIHRhZ3NcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgcmV0dXJuIHB1c2hTdGFydFNlbGVjdCh0YXJnZXQsIHByb3BzLCByZXNwb25zZVN0YXRlKTtcblxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICByZXR1cm4gcHVzaFN0YXJ0T3B0aW9uKHRhcmdldCwgcHJvcHMsIHJlc3BvbnNlU3RhdGUsIGZvcm1hdENvbnRleHQpO1xuXG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgcmV0dXJuIHB1c2hTdGFydFRleHRBcmVhKHRhcmdldCwgcHJvcHMsIHJlc3BvbnNlU3RhdGUpO1xuXG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgcmV0dXJuIHB1c2hJbnB1dCh0YXJnZXQsIHByb3BzLCByZXNwb25zZVN0YXRlKTtcblxuICAgIGNhc2UgJ21lbnVpdGVtJzpcbiAgICAgIHJldHVybiBwdXNoU3RhcnRNZW51SXRlbSh0YXJnZXQsIHByb3BzLCByZXNwb25zZVN0YXRlKTtcblxuICAgIGNhc2UgJ3RpdGxlJzpcbiAgICAgIHJldHVybiBwdXNoU3RhcnRUaXRsZSh0YXJnZXQsIHByb3BzLCByZXNwb25zZVN0YXRlKTtcbiAgICAvLyBOZXdsaW5lIGVhdGluZyB0YWdzXG5cbiAgICBjYXNlICdsaXN0aW5nJzpcbiAgICBjYXNlICdwcmUnOlxuICAgICAge1xuICAgICAgICByZXR1cm4gcHVzaFN0YXJ0UHJlZm9ybWF0dGVkRWxlbWVudCh0YXJnZXQsIHByb3BzLCB0eXBlLCByZXNwb25zZVN0YXRlKTtcbiAgICAgIH1cbiAgICAvLyBPbWl0dGVkIGNsb3NlIHRhZ3NcblxuICAgIGNhc2UgJ2FyZWEnOlxuICAgIGNhc2UgJ2Jhc2UnOlxuICAgIGNhc2UgJ2JyJzpcbiAgICBjYXNlICdjb2wnOlxuICAgIGNhc2UgJ2VtYmVkJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaW1nJzpcbiAgICBjYXNlICdrZXlnZW4nOlxuICAgIGNhc2UgJ2xpbmsnOlxuICAgIGNhc2UgJ21ldGEnOlxuICAgIGNhc2UgJ3BhcmFtJzpcbiAgICBjYXNlICdzb3VyY2UnOlxuICAgIGNhc2UgJ3RyYWNrJzpcbiAgICBjYXNlICd3YnInOlxuICAgICAge1xuICAgICAgICByZXR1cm4gcHVzaFNlbGZDbG9zaW5nKHRhcmdldCwgcHJvcHMsIHR5cGUsIHJlc3BvbnNlU3RhdGUpO1xuICAgICAgfVxuICAgIC8vIFRoZXNlIGFyZSByZXNlcnZlZCBTVkcgYW5kIE1hdGhNTCBlbGVtZW50cywgdGhhdCBhcmUgbmV2ZXIgY3VzdG9tIGVsZW1lbnRzLlxuICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvY3VzdG9tLyNjdXN0b20tZWxlbWVudHMtY29yZS1jb25jZXB0c1xuXG4gICAgY2FzZSAnYW5ub3RhdGlvbi14bWwnOlxuICAgIGNhc2UgJ2NvbG9yLXByb2ZpbGUnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXNyYyc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXVyaSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLWZvcm1hdCc6XG4gICAgY2FzZSAnZm9udC1mYWNlLW5hbWUnOlxuICAgIGNhc2UgJ21pc3NpbmctZ2x5cGgnOlxuICAgICAge1xuICAgICAgICByZXR1cm4gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQodGFyZ2V0LCBwcm9wcywgdHlwZSwgcmVzcG9uc2VTdGF0ZSk7XG4gICAgICB9XG5cbiAgICBjYXNlICdodG1sJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSA9PT0gUk9PVF9IVE1MX01PREUpIHtcbiAgICAgICAgICAvLyBJZiB3ZSdyZSByZW5kZXJpbmcgdGhlIGh0bWwgdGFnIGFuZCB3ZSdyZSBhdCB0aGUgcm9vdCAoaS5lLiBub3QgaW4gZm9yZWlnbk9iamVjdClcbiAgICAgICAgICAvLyB0aGVuIHdlIGFsc28gZW1pdCB0aGUgRE9DVFlQRSBhcyBwYXJ0IG9mIHRoZSByb290IGNvbnRlbnQgYXMgYSBjb252ZW5pZW5jZSBmb3JcbiAgICAgICAgICAvLyByZW5kZXJpbmcgdGhlIHdob2xlIGRvY3VtZW50LlxuICAgICAgICAgIHRhcmdldC5wdXNoKERPQ1RZUEUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KHRhcmdldCwgcHJvcHMsIHR5cGUsIHJlc3BvbnNlU3RhdGUpO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGUuaW5kZXhPZignLScpID09PSAtMSAmJiB0eXBlb2YgcHJvcHMuaXMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gR2VuZXJpYyBlbGVtZW50XG4gICAgICAgICAgcmV0dXJuIHB1c2hTdGFydEdlbmVyaWNFbGVtZW50KHRhcmdldCwgcHJvcHMsIHR5cGUsIHJlc3BvbnNlU3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEN1c3RvbSBlbGVtZW50XG4gICAgICAgICAgcmV0dXJuIHB1c2hTdGFydEN1c3RvbUVsZW1lbnQodGFyZ2V0LCBwcm9wcywgdHlwZSwgcmVzcG9uc2VTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxufVxudmFyIGVuZFRhZzEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvJyk7XG52YXIgZW5kVGFnMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPicpO1xuZnVuY3Rpb24gcHVzaEVuZEluc3RhbmNlKHRhcmdldCwgdHlwZSwgcHJvcHMpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgLy8gT21pdHRlZCBjbG9zZSB0YWdzXG4gICAgLy8gVE9ETzogSW5zdGVhZCBvZiByZXBlYXRpbmcgdGhpcyBzd2l0Y2ggd2UgY291bGQgdHJ5IHRvIHBhc3MgYSBmbGFnIGZyb20gYWJvdmUuXG4gICAgLy8gVGhhdCB3b3VsZCByZXF1aXJlIHJldHVybmluZyBhIHR1cGxlLiBXaGljaCBtaWdodCBiZSBvayBpZiBpdCBnZXRzIGlubGluZWQuXG4gICAgY2FzZSAnYXJlYSc6XG4gICAgY2FzZSAnYmFzZSc6XG4gICAgY2FzZSAnYnInOlxuICAgIGNhc2UgJ2NvbCc6XG4gICAgY2FzZSAnZW1iZWQnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdpbWcnOlxuICAgIGNhc2UgJ2lucHV0JzpcbiAgICBjYXNlICdrZXlnZW4nOlxuICAgIGNhc2UgJ2xpbmsnOlxuICAgIGNhc2UgJ21ldGEnOlxuICAgIGNhc2UgJ3BhcmFtJzpcbiAgICBjYXNlICdzb3VyY2UnOlxuICAgIGNhc2UgJ3RyYWNrJzpcbiAgICBjYXNlICd3YnInOlxuICAgICAge1xuICAgICAgICAvLyBObyBjbG9zZSB0YWcgbmVlZGVkLlxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHRhcmdldC5wdXNoKGVuZFRhZzEsIHN0cmluZ1RvQ2h1bmsodHlwZSksIGVuZFRhZzIpO1xuICAgICAgfVxuICB9XG59XG5mdW5jdGlvbiB3cml0ZUNvbXBsZXRlZFJvb3QoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUpIHtcbiAgdmFyIGJvb3RzdHJhcENodW5rcyA9IHJlc3BvbnNlU3RhdGUuYm9vdHN0cmFwQ2h1bmtzO1xuICB2YXIgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBib290c3RyYXBDaHVua3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYm9vdHN0cmFwQ2h1bmtzW2ldKTtcbiAgfVxuXG4gIGlmIChpIDwgYm9vdHN0cmFwQ2h1bmtzLmxlbmd0aCkge1xuICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBib290c3RyYXBDaHVua3NbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59IC8vIFN0cnVjdHVyYWwgTm9kZXNcbi8vIEEgcGxhY2Vob2xkZXIgaXMgYSBub2RlIGluc2lkZSBhIGhpZGRlbiBwYXJ0aWFsIHRyZWUgdGhhdCBjYW4gYmUgZmlsbGVkIGluIGxhdGVyLCBidXQgYmVmb3JlXG4vLyBkaXNwbGF5LiBJdCdzIG5ldmVyIHZpc2libGUgdG8gdXNlcnMuIFdlIHVzZSB0aGUgdGVtcGxhdGUgdGFnIGJlY2F1c2UgaXQgY2FuIGJlIHVzZWQgaW4gZXZlcnlcbi8vIHR5cGUgb2YgcGFyZW50LiA8c2NyaXB0PiB0YWdzIGFsc28gd29yayBpbiBldmVyeSBvdGhlciB0YWcgZXhjZXB0IDxjb2xncm91cD4uXG5cbnZhciBwbGFjZWhvbGRlcjEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0ZW1wbGF0ZSBpZD1cIicpO1xudmFyIHBsYWNlaG9sZGVyMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+PC90ZW1wbGF0ZT4nKTtcbmZ1bmN0aW9uIHdyaXRlUGxhY2Vob2xkZXIoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUsIGlkKSB7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHBsYWNlaG9sZGVyMSk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUucGxhY2Vob2xkZXJQcmVmaXgpO1xuICB2YXIgZm9ybWF0dGVkSUQgPSBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGZvcm1hdHRlZElEKTtcbiAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHBsYWNlaG9sZGVyMik7XG59IC8vIFN1c3BlbnNlIGJvdW5kYXJpZXMgYXJlIGVuY29kZWQgYXMgY29tbWVudHMuXG5cbnZhciBzdGFydENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwhLS0kLS0+Jyk7XG52YXIgc3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwhLS0kPy0tPjx0ZW1wbGF0ZSBpZD1cIicpO1xudmFyIHN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj48L3RlbXBsYXRlPicpO1xudmFyIHN0YXJ0Q2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8IS0tJCEtLT4nKTtcbnZhciBlbmRTdXNwZW5zZUJvdW5kYXJ5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8IS0tLyQtLT4nKTtcbnZhciBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0ZW1wbGF0ZScpO1xudmFyIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yQXR0ckludGVyc3RpdGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCInKTtcbnZhciBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFBID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgZGF0YS1kZ3N0PVwiJyk7XG52YXIgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnIGRhdGEtbXNnPVwiJyk7XG52YXIgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnIGRhdGEtc3Rjaz1cIicpO1xudmFyIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPjwvdGVtcGxhdGU+Jyk7XG5mdW5jdGlvbiB3cml0ZVN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZSkge1xuICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5KTtcbn1cbmZ1bmN0aW9uIHdyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZSwgaWQpIHtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTEpO1xuXG4gIGlmIChpZCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQW4gSUQgbXVzdCBoYXZlIGJlZW4gYXNzaWduZWQgYmVmb3JlIHdlIGNhbiBjb21wbGV0ZSB0aGUgYm91bmRhcnkuJyk7XG4gIH1cblxuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBpZCk7XG4gIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5Mik7XG59XG5mdW5jdGlvbiB3cml0ZVN0YXJ0Q2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLCBlcnJvckRpZ2VzdCwgZXJyb3JNZXNzc2FnZSwgZXJyb3JDb21wb25lbnRTdGFjaykge1xuICB2YXIgcmVzdWx0O1xuICByZXN1bHQgPSB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMSk7XG5cbiAgaWYgKGVycm9yRGlnZXN0KSB7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQSk7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihlcnJvckRpZ2VzdCkpKTtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWwpO1xuICB9XG5cbiAge1xuICAgIGlmIChlcnJvck1lc3NzYWdlKSB7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFCKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIoZXJyb3JNZXNzc2FnZSkpKTtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yQXR0ckludGVyc3RpdGlhbCk7XG4gICAgfVxuXG4gICAgaWYgKGVycm9yQ29tcG9uZW50U3RhY2spIHtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUMpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihlcnJvckNvbXBvbmVudFN0YWNrKSkpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3JBdHRySW50ZXJzdGl0aWFsKTtcbiAgICB9XG4gIH1cblxuICByZXN1bHQgPSB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gd3JpdGVFbmRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlKSB7XG4gIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTdXNwZW5zZUJvdW5kYXJ5KTtcbn1cbmZ1bmN0aW9uIHdyaXRlRW5kUGVuZGluZ1N1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUpIHtcbiAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFN1c3BlbnNlQm91bmRhcnkpO1xufVxuZnVuY3Rpb24gd3JpdGVFbmRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUpIHtcbiAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFN1c3BlbnNlQm91bmRhcnkpO1xufVxudmFyIHN0YXJ0U2VnbWVudEhUTUwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxkaXYgaGlkZGVuIGlkPVwiJyk7XG52YXIgc3RhcnRTZWdtZW50SFRNTDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGVuZFNlZ21lbnRIVE1MID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L2Rpdj4nKTtcbnZhciBzdGFydFNlZ21lbnRTVkcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxzdmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIiBpZD1cIicpO1xudmFyIHN0YXJ0U2VnbWVudFNWRzIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGVuZFNlZ21lbnRTVkcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvc3ZnPicpO1xudmFyIHN0YXJ0U2VnbWVudE1hdGhNTCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPG1hdGggYXJpYS1oaWRkZW49XCJ0cnVlXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIiBpZD1cIicpO1xudmFyIHN0YXJ0U2VnbWVudE1hdGhNTDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGVuZFNlZ21lbnRNYXRoTUwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvbWF0aD4nKTtcbnZhciBzdGFydFNlZ21lbnRUYWJsZSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRhYmxlIGhpZGRlbiBpZD1cIicpO1xudmFyIHN0YXJ0U2VnbWVudFRhYmxlMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgZW5kU2VnbWVudFRhYmxlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L3RhYmxlPicpO1xudmFyIHN0YXJ0U2VnbWVudFRhYmxlQm9keSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRhYmxlIGhpZGRlbj48dGJvZHkgaWQ9XCInKTtcbnZhciBzdGFydFNlZ21lbnRUYWJsZUJvZHkyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj4nKTtcbnZhciBlbmRTZWdtZW50VGFibGVCb2R5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L3Rib2R5PjwvdGFibGU+Jyk7XG52YXIgc3RhcnRTZWdtZW50VGFibGVSb3cgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzx0YWJsZSBoaWRkZW4+PHRyIGlkPVwiJyk7XG52YXIgc3RhcnRTZWdtZW50VGFibGVSb3cyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj4nKTtcbnZhciBlbmRTZWdtZW50VGFibGVSb3cgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvdHI+PC90YWJsZT4nKTtcbnZhciBzdGFydFNlZ21lbnRDb2xHcm91cCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRhYmxlIGhpZGRlbj48Y29sZ3JvdXAgaWQ9XCInKTtcbnZhciBzdGFydFNlZ21lbnRDb2xHcm91cDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGVuZFNlZ21lbnRDb2xHcm91cCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC9jb2xncm91cD48L3RhYmxlPicpO1xuZnVuY3Rpb24gd3JpdGVTdGFydFNlZ21lbnQoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUsIGZvcm1hdENvbnRleHQsIGlkKSB7XG4gIHN3aXRjaCAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlKSB7XG4gICAgY2FzZSBST09UX0hUTUxfTU9ERTpcbiAgICBjYXNlIEhUTUxfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50SFRNTCk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUuc2VnbWVudFByZWZpeCk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSk7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRIVE1MMik7XG4gICAgICB9XG5cbiAgICBjYXNlIFNWR19NT0RFOlxuICAgICAge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRTVkcpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLnNlZ21lbnRQcmVmaXgpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpO1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50U1ZHMik7XG4gICAgICB9XG5cbiAgICBjYXNlIE1BVEhNTF9NT0RFOlxuICAgICAge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRNYXRoTUwpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLnNlZ21lbnRQcmVmaXgpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpO1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50TWF0aE1MMik7XG4gICAgICB9XG5cbiAgICBjYXNlIEhUTUxfVEFCTEVfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50VGFibGUpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLnNlZ21lbnRQcmVmaXgpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpO1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50VGFibGUyKTtcbiAgICAgIH1cbiAgICAvLyBUT0RPOiBGb3IgdGhlIHJlc3Qgb2YgdGhlc2UsIHRoZXJlIHdpbGwgYmUgZXh0cmEgd3JhcHBlciBub2RlcyB0aGF0IG5ldmVyXG4gICAgLy8gZ2V0IGRlbGV0ZWQgZnJvbSB0aGUgZG9jdW1lbnQuIFdlIG5lZWQgdG8gZGVsZXRlIHRoZSB0YWJsZSB0b28gYXMgcGFydFxuICAgIC8vIG9mIHRoZSBpbmplY3RlZCBzY3JpcHRzLiBUaGV5IGFyZSBpbnZpc2libGUgdGhvdWdoIHNvIGl0J3Mgbm90IHRvbyB0ZXJyaWJsZVxuICAgIC8vIGFuZCBpdCdzIGtpbmQgb2YgYW4gZWRnZSBjYXNlIHRvIHN1c3BlbmQgaW4gYSB0YWJsZS4gVG90YWxseSBzdXBwb3J0ZWQgdGhvdWdoLlxuXG4gICAgY2FzZSBIVE1MX1RBQkxFX0JPRFlfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50VGFibGVCb2R5KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZS5zZWdtZW50UHJlZml4KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFRhYmxlQm9keTIpO1xuICAgICAgfVxuXG4gICAgY2FzZSBIVE1MX1RBQkxFX1JPV19NT0RFOlxuICAgICAge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZVJvdyk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUuc2VnbWVudFByZWZpeCk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSk7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZVJvdzIpO1xuICAgICAgfVxuXG4gICAgY2FzZSBIVE1MX0NPTEdST1VQX01PREU6XG4gICAgICB7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudENvbEdyb3VwKTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZS5zZWdtZW50UHJlZml4KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudENvbEdyb3VwMik7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gaW5zZXJ0aW9uIG1vZGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHdyaXRlRW5kU2VnbWVudChkZXN0aW5hdGlvbiwgZm9ybWF0Q29udGV4dCkge1xuICBzd2l0Y2ggKGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSkge1xuICAgIGNhc2UgUk9PVF9IVE1MX01PREU6XG4gICAgY2FzZSBIVE1MX01PREU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50SFRNTCk7XG4gICAgICB9XG5cbiAgICBjYXNlIFNWR19NT0RFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU2VnbWVudFNWRyk7XG4gICAgICB9XG5cbiAgICBjYXNlIE1BVEhNTF9NT0RFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU2VnbWVudE1hdGhNTCk7XG4gICAgICB9XG5cbiAgICBjYXNlIEhUTUxfVEFCTEVfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRUYWJsZSk7XG4gICAgICB9XG5cbiAgICBjYXNlIEhUTUxfVEFCTEVfQk9EWV9NT0RFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU2VnbWVudFRhYmxlQm9keSk7XG4gICAgICB9XG5cbiAgICBjYXNlIEhUTUxfVEFCTEVfUk9XX01PREU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50VGFibGVSb3cpO1xuICAgICAgfVxuXG4gICAgY2FzZSBIVE1MX0NPTEdST1VQX01PREU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50Q29sR3JvdXApO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGluc2VydGlvbiBtb2RlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuICB9XG59IC8vIEluc3RydWN0aW9uIFNldFxuLy8gVGhlIGZvbGxvd2luZyBjb2RlIGlzIHRoZSBzb3VyY2Ugc2NyaXB0cyB0aGF0IHdlIHRoZW4gbWluaWZ5IGFuZCBpbmxpbmUgYmVsb3csXG4vLyB3aXRoIHJlbmFtZWQgZnVuY3Rpb24gbmFtZXMgdGhhdCB3ZSBob3BlIGRvbid0IGNvbGxpZGU6XG4vLyBjb25zdCBDT01NRU5UX05PREUgPSA4O1xuLy8gY29uc3QgU1VTUEVOU0VfU1RBUlRfREFUQSA9ICckJztcbi8vIGNvbnN0IFNVU1BFTlNFX0VORF9EQVRBID0gJy8kJztcbi8vIGNvbnN0IFNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQSA9ICckPyc7XG4vLyBjb25zdCBTVVNQRU5TRV9GQUxMQkFDS19TVEFSVF9EQVRBID0gJyQhJztcbi8vXG4vLyBmdW5jdGlvbiBjbGllbnRSZW5kZXJCb3VuZGFyeShzdXNwZW5zZUJvdW5kYXJ5SUQsIGVycm9yRGlnZXN0LCBlcnJvck1zZywgZXJyb3JDb21wb25lbnRTdGFjaykge1xuLy8gICAvLyBGaW5kIHRoZSBmYWxsYmFjaydzIGZpcnN0IGVsZW1lbnQuXG4vLyAgIGNvbnN0IHN1c3BlbnNlSWROb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc3VzcGVuc2VCb3VuZGFyeUlEKTtcbi8vICAgaWYgKCFzdXNwZW5zZUlkTm9kZSkge1xuLy8gICAgIC8vIFRoZSB1c2VyIG11c3QgaGF2ZSBhbHJlYWR5IG5hdmlnYXRlZCBhd2F5IGZyb20gdGhpcyB0cmVlLlxuLy8gICAgIC8vIEUuZy4gYmVjYXVzZSB0aGUgcGFyZW50IHdhcyBoeWRyYXRlZC5cbi8vICAgICByZXR1cm47XG4vLyAgIH1cbi8vICAgLy8gRmluZCB0aGUgYm91bmRhcnkgYXJvdW5kIHRoZSBmYWxsYmFjay4gVGhpcyBpcyBhbHdheXMgdGhlIHByZXZpb3VzIG5vZGUuXG4vLyAgIGNvbnN0IHN1c3BlbnNlTm9kZSA9IHN1c3BlbnNlSWROb2RlLnByZXZpb3VzU2libGluZztcbi8vICAgLy8gVGFnIGl0IHRvIGJlIGNsaWVudCByZW5kZXJlZC5cbi8vICAgc3VzcGVuc2VOb2RlLmRhdGEgPSBTVVNQRU5TRV9GQUxMQkFDS19TVEFSVF9EQVRBO1xuLy8gICAvLyBhc3NpZ24gZXJyb3IgbWV0YWRhdGEgdG8gZmlyc3Qgc2libGluZ1xuLy8gICBsZXQgZGF0YXNldCA9IHN1c3BlbnNlSWROb2RlLmRhdGFzZXQ7XG4vLyAgIGlmIChlcnJvckRpZ2VzdCkgZGF0YXNldC5kZ3N0ID0gZXJyb3JEaWdlc3Q7XG4vLyAgIGlmIChlcnJvck1zZykgZGF0YXNldC5tc2cgPSBlcnJvck1zZztcbi8vICAgaWYgKGVycm9yQ29tcG9uZW50U3RhY2spIGRhdGFzZXQuc3RjayA9IGVycm9yQ29tcG9uZW50U3RhY2s7XG4vLyAgIC8vIFRlbGwgUmVhY3QgdG8gcmV0cnkgaXQgaWYgdGhlIHBhcmVudCBhbHJlYWR5IGh5ZHJhdGVkLlxuLy8gICBpZiAoc3VzcGVuc2VOb2RlLl9yZWFjdFJldHJ5KSB7XG4vLyAgICAgc3VzcGVuc2VOb2RlLl9yZWFjdFJldHJ5KCk7XG4vLyAgIH1cbi8vIH1cbi8vXG4vLyBmdW5jdGlvbiBjb21wbGV0ZUJvdW5kYXJ5KHN1c3BlbnNlQm91bmRhcnlJRCwgY29udGVudElEKSB7XG4vLyAgIC8vIEZpbmQgdGhlIGZhbGxiYWNrJ3MgZmlyc3QgZWxlbWVudC5cbi8vICAgY29uc3Qgc3VzcGVuc2VJZE5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzdXNwZW5zZUJvdW5kYXJ5SUQpO1xuLy8gICBjb25zdCBjb250ZW50Tm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbnRlbnRJRCk7XG4vLyAgIC8vIFdlJ2xsIGRldGFjaCB0aGUgY29udGVudCBub2RlIHNvIHRoYXQgcmVnYXJkbGVzcyBvZiB3aGF0IGhhcHBlbnMgbmV4dCB3ZSBkb24ndCBsZWF2ZSBpbiB0aGUgdHJlZS5cbi8vICAgLy8gVGhpcyBtaWdodCBhbHNvIGhlbHAgYnkgbm90IGNhdXNpbmcgcmVjYWxjaW5nIGVhY2ggdGltZSB3ZSBtb3ZlIGEgY2hpbGQgZnJvbSBoZXJlIHRvIHRoZSB0YXJnZXQuXG4vLyAgIGNvbnRlbnROb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY29udGVudE5vZGUpO1xuLy8gICBpZiAoIXN1c3BlbnNlSWROb2RlKSB7XG4vLyAgICAgLy8gVGhlIHVzZXIgbXVzdCBoYXZlIGFscmVhZHkgbmF2aWdhdGVkIGF3YXkgZnJvbSB0aGlzIHRyZWUuXG4vLyAgICAgLy8gRS5nLiBiZWNhdXNlIHRoZSBwYXJlbnQgd2FzIGh5ZHJhdGVkLiBUaGF0J3MgZmluZSB0aGVyZSdzIG5vdGhpbmcgdG8gZG9cbi8vICAgICAvLyBidXQgd2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCB3ZSBhbHJlYWR5IGRlbGV0ZWQgdGhlIGNvbnRhaW5lciBub2RlLlxuLy8gICAgIHJldHVybjtcbi8vICAgfVxuLy8gICAvLyBGaW5kIHRoZSBib3VuZGFyeSBhcm91bmQgdGhlIGZhbGxiYWNrLiBUaGlzIGlzIGFsd2F5cyB0aGUgcHJldmlvdXMgbm9kZS5cbi8vICAgY29uc3Qgc3VzcGVuc2VOb2RlID0gc3VzcGVuc2VJZE5vZGUucHJldmlvdXNTaWJsaW5nO1xuLy9cbi8vICAgLy8gQ2xlYXIgYWxsIHRoZSBleGlzdGluZyBjaGlsZHJlbi4gVGhpcyBpcyBjb21wbGljYXRlZCBiZWNhdXNlXG4vLyAgIC8vIHRoZXJlIGNhbiBiZSBlbWJlZGRlZCBTdXNwZW5zZSBib3VuZGFyaWVzIGluIHRoZSBmYWxsYmFjay5cbi8vICAgLy8gVGhpcyBpcyBzaW1pbGFyIHRvIGNsZWFyU3VzcGVuc2VCb3VuZGFyeSBpbiBSZWFjdERPTUhvc3RDb25maWcuXG4vLyAgIC8vIFRPRE86IFdlIGNvdWxkIGF2b2lkIHRoaXMgaWYgd2UgbmV2ZXIgZW1pdHRlZCBzdXNwZW5zZSBib3VuZGFyaWVzIGluIGZhbGxiYWNrIHRyZWVzLlxuLy8gICAvLyBUaGV5IG5ldmVyIGh5ZHJhdGUgYW55d2F5LiBIb3dldmVyLCBjdXJyZW50bHkgd2Ugc3VwcG9ydCBpbmNyZW1lbnRhbGx5IGxvYWRpbmcgdGhlIGZhbGxiYWNrLlxuLy8gICBjb25zdCBwYXJlbnRJbnN0YW5jZSA9IHN1c3BlbnNlTm9kZS5wYXJlbnROb2RlO1xuLy8gICBsZXQgbm9kZSA9IHN1c3BlbnNlTm9kZS5uZXh0U2libGluZztcbi8vICAgbGV0IGRlcHRoID0gMDtcbi8vICAgZG8ge1xuLy8gICAgIGlmIChub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuLy8gICAgICAgY29uc3QgZGF0YSA9IG5vZGUuZGF0YTtcbi8vICAgICAgIGlmIChkYXRhID09PSBTVVNQRU5TRV9FTkRfREFUQSkge1xuLy8gICAgICAgICBpZiAoZGVwdGggPT09IDApIHtcbi8vICAgICAgICAgICBicmVhaztcbi8vICAgICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgICBkZXB0aC0tO1xuLy8gICAgICAgICB9XG4vLyAgICAgICB9IGVsc2UgaWYgKFxuLy8gICAgICAgICBkYXRhID09PSBTVVNQRU5TRV9TVEFSVF9EQVRBIHx8XG4vLyAgICAgICAgIGRhdGEgPT09IFNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQSB8fFxuLy8gICAgICAgICBkYXRhID09PSBTVVNQRU5TRV9GQUxMQkFDS19TVEFSVF9EQVRBXG4vLyAgICAgICApIHtcbi8vICAgICAgICAgZGVwdGgrKztcbi8vICAgICAgIH1cbi8vICAgICB9XG4vL1xuLy8gICAgIGNvbnN0IG5leHROb2RlID0gbm9kZS5uZXh0U2libGluZztcbi8vICAgICBwYXJlbnRJbnN0YW5jZS5yZW1vdmVDaGlsZChub2RlKTtcbi8vICAgICBub2RlID0gbmV4dE5vZGU7XG4vLyAgIH0gd2hpbGUgKG5vZGUpO1xuLy9cbi8vICAgY29uc3QgZW5kT2ZCb3VuZGFyeSA9IG5vZGU7XG4vL1xuLy8gICAvLyBJbnNlcnQgYWxsIHRoZSBjaGlsZHJlbiBmcm9tIHRoZSBjb250ZW50Tm9kZSBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kIG9mIHN1c3BlbnNlIGJvdW5kYXJ5LlxuLy8gICB3aGlsZSAoY29udGVudE5vZGUuZmlyc3RDaGlsZCkge1xuLy8gICAgIHBhcmVudEluc3RhbmNlLmluc2VydEJlZm9yZShjb250ZW50Tm9kZS5maXJzdENoaWxkLCBlbmRPZkJvdW5kYXJ5KTtcbi8vICAgfVxuLy8gICBzdXNwZW5zZU5vZGUuZGF0YSA9IFNVU1BFTlNFX1NUQVJUX0RBVEE7XG4vLyAgIGlmIChzdXNwZW5zZU5vZGUuX3JlYWN0UmV0cnkpIHtcbi8vICAgICBzdXNwZW5zZU5vZGUuX3JlYWN0UmV0cnkoKTtcbi8vICAgfVxuLy8gfVxuLy9cbi8vIGZ1bmN0aW9uIGNvbXBsZXRlU2VnbWVudChjb250YWluZXJJRCwgcGxhY2Vob2xkZXJJRCkge1xuLy8gICBjb25zdCBzZWdtZW50Q29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29udGFpbmVySUQpO1xuLy8gICBjb25zdCBwbGFjZWhvbGRlck5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwbGFjZWhvbGRlcklEKTtcbi8vICAgLy8gV2UgYWx3YXlzIGV4cGVjdCBib3RoIG5vZGVzIHRvIGV4aXN0IGhlcmUgYmVjYXVzZSwgd2hpbGUgd2UgbWlnaHRcbi8vICAgLy8gaGF2ZSBuYXZpZ2F0ZWQgYXdheSBmcm9tIHRoZSBtYWluIHRyZWUsIHdlIHN0aWxsIGV4cGVjdCB0aGUgZGV0YWNoZWRcbi8vICAgLy8gdHJlZSB0byBleGlzdC5cbi8vICAgc2VnbWVudENvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNlZ21lbnRDb250YWluZXIpO1xuLy8gICB3aGlsZSAoc2VnbWVudENvbnRhaW5lci5maXJzdENoaWxkKSB7XG4vLyAgICAgcGxhY2Vob2xkZXJOb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKFxuLy8gICAgICAgc2VnbWVudENvbnRhaW5lci5maXJzdENoaWxkLFxuLy8gICAgICAgcGxhY2Vob2xkZXJOb2RlLFxuLy8gICAgICk7XG4vLyAgIH1cbi8vICAgcGxhY2Vob2xkZXJOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocGxhY2Vob2xkZXJOb2RlKTtcbi8vIH1cblxudmFyIGNvbXBsZXRlU2VnbWVudEZ1bmN0aW9uID0gJ2Z1bmN0aW9uICRSUyhhLGIpe2E9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYSk7Yj1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChiKTtmb3IoYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpO2EuZmlyc3RDaGlsZDspYi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLmZpcnN0Q2hpbGQsYik7Yi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpfSc7XG52YXIgY29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uID0gJ2Z1bmN0aW9uICRSQyhhLGIpe2E9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYSk7Yj1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChiKTtiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYik7aWYoYSl7YT1hLnByZXZpb3VzU2libGluZzt2YXIgZj1hLnBhcmVudE5vZGUsYz1hLm5leHRTaWJsaW5nLGU9MDtkb3tpZihjJiY4PT09Yy5ub2RlVHlwZSl7dmFyIGQ9Yy5kYXRhO2lmKFwiLyRcIj09PWQpaWYoMD09PWUpYnJlYWs7ZWxzZSBlLS07ZWxzZVwiJFwiIT09ZCYmXCIkP1wiIT09ZCYmXCIkIVwiIT09ZHx8ZSsrfWQ9Yy5uZXh0U2libGluZztmLnJlbW92ZUNoaWxkKGMpO2M9ZH13aGlsZShjKTtmb3IoO2IuZmlyc3RDaGlsZDspZi5pbnNlcnRCZWZvcmUoYi5maXJzdENoaWxkLGMpO2EuZGF0YT1cIiRcIjthLl9yZWFjdFJldHJ5JiZhLl9yZWFjdFJldHJ5KCl9fSc7XG52YXIgY2xpZW50UmVuZGVyRnVuY3Rpb24gPSAnZnVuY3Rpb24gJFJYKGIsYyxkLGUpe3ZhciBhPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGIpO2EmJihiPWEucHJldmlvdXNTaWJsaW5nLGIuZGF0YT1cIiQhXCIsYT1hLmRhdGFzZXQsYyYmKGEuZGdzdD1jKSxkJiYoYS5tc2c9ZCksZSYmKGEuc3Rjaz1lKSxiLl9yZWFjdFJldHJ5JiZiLl9yZWFjdFJldHJ5KCkpfSc7XG52YXIgY29tcGxldGVTZWdtZW50U2NyaXB0MUZ1bGwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoY29tcGxldGVTZWdtZW50RnVuY3Rpb24gKyAnOyRSUyhcIicpO1xudmFyIGNvbXBsZXRlU2VnbWVudFNjcmlwdDFQYXJ0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCckUlMoXCInKTtcbnZhciBjb21wbGV0ZVNlZ21lbnRTY3JpcHQyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIixcIicpO1xudmFyIGNvbXBsZXRlU2VnbWVudFNjcmlwdDMgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiKTwvc2NyaXB0PicpO1xuZnVuY3Rpb24gd3JpdGVDb21wbGV0ZWRTZWdtZW50SW5zdHJ1Y3Rpb24oZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUsIGNvbnRlbnRTZWdtZW50SUQpIHtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZS5zdGFydElubGluZVNjcmlwdCk7XG5cbiAgaWYgKCFyZXNwb25zZVN0YXRlLnNlbnRDb21wbGV0ZVNlZ21lbnRGdW5jdGlvbikge1xuICAgIC8vIFRoZSBmaXJzdCB0aW1lIHdlIHdyaXRlIHRoaXMsIHdlJ2xsIG5lZWQgdG8gaW5jbHVkZSB0aGUgZnVsbCBpbXBsZW1lbnRhdGlvbi5cbiAgICByZXNwb25zZVN0YXRlLnNlbnRDb21wbGV0ZVNlZ21lbnRGdW5jdGlvbiA9IHRydWU7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVTZWdtZW50U2NyaXB0MUZ1bGwpO1xuICB9IGVsc2Uge1xuICAgIC8vIEZ1dHVyZSBjYWxscyBjYW4ganVzdCByZXVzZSB0aGUgc2FtZSBmdW5jdGlvbi5cbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZVNlZ21lbnRTY3JpcHQxUGFydGlhbCk7XG4gIH1cblxuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLnNlZ21lbnRQcmVmaXgpO1xuICB2YXIgZm9ybWF0dGVkSUQgPSBzdHJpbmdUb0NodW5rKGNvbnRlbnRTZWdtZW50SUQudG9TdHJpbmcoMTYpKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZm9ybWF0dGVkSUQpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZVNlZ21lbnRTY3JpcHQyKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZS5wbGFjZWhvbGRlclByZWZpeCk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGZvcm1hdHRlZElEKTtcbiAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNvbXBsZXRlU2VnbWVudFNjcmlwdDMpO1xufVxudmFyIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQxRnVsbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhjb21wbGV0ZUJvdW5kYXJ5RnVuY3Rpb24gKyAnOyRSQyhcIicpO1xudmFyIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQxUGFydGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnJFJDKFwiJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeVNjcmlwdDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiLFwiJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeVNjcmlwdDMgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiKTwvc2NyaXB0PicpO1xuZnVuY3Rpb24gd3JpdGVDb21wbGV0ZWRCb3VuZGFyeUluc3RydWN0aW9uKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLCBib3VuZGFyeUlELCBjb250ZW50U2VnbWVudElEKSB7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUuc3RhcnRJbmxpbmVTY3JpcHQpO1xuXG4gIGlmICghcmVzcG9uc2VTdGF0ZS5zZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uKSB7XG4gICAgLy8gVGhlIGZpcnN0IHRpbWUgd2Ugd3JpdGUgdGhpcywgd2UnbGwgbmVlZCB0byBpbmNsdWRlIHRoZSBmdWxsIGltcGxlbWVudGF0aW9uLlxuICAgIHJlc3BvbnNlU3RhdGUuc2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbiA9IHRydWU7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdDFGdWxsKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBGdXR1cmUgY2FsbHMgY2FuIGp1c3QgcmV1c2UgdGhlIHNhbWUgZnVuY3Rpb24uXG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdDFQYXJ0aWFsKTtcbiAgfVxuXG4gIGlmIChib3VuZGFyeUlEID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBbiBJRCBtdXN0IGhhdmUgYmVlbiBhc3NpZ25lZCBiZWZvcmUgd2UgY2FuIGNvbXBsZXRlIHRoZSBib3VuZGFyeS4nKTtcbiAgfVxuXG4gIHZhciBmb3JtYXR0ZWRDb250ZW50SUQgPSBzdHJpbmdUb0NodW5rKGNvbnRlbnRTZWdtZW50SUQudG9TdHJpbmcoMTYpKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYm91bmRhcnlJRCk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQyKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZS5zZWdtZW50UHJlZml4KTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZm9ybWF0dGVkQ29udGVudElEKTtcbiAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNvbXBsZXRlQm91bmRhcnlTY3JpcHQzKTtcbn1cbnZhciBjbGllbnRSZW5kZXJTY3JpcHQxRnVsbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhjbGllbnRSZW5kZXJGdW5jdGlvbiArICc7JFJYKFwiJyk7XG52YXIgY2xpZW50UmVuZGVyU2NyaXB0MVBhcnRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyRSWChcIicpO1xudmFyIGNsaWVudFJlbmRlclNjcmlwdDFBID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIicpO1xudmFyIGNsaWVudFJlbmRlclNjcmlwdDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyk8L3NjcmlwdD4nKTtcbnZhciBjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnLCcpO1xuZnVuY3Rpb24gd3JpdGVDbGllbnRSZW5kZXJCb3VuZGFyeUluc3RydWN0aW9uKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLCBib3VuZGFyeUlELCBlcnJvckRpZ2VzdCwgZXJyb3JNZXNzYWdlLCBlcnJvckNvbXBvbmVudFN0YWNrKSB7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUuc3RhcnRJbmxpbmVTY3JpcHQpO1xuXG4gIGlmICghcmVzcG9uc2VTdGF0ZS5zZW50Q2xpZW50UmVuZGVyRnVuY3Rpb24pIHtcbiAgICAvLyBUaGUgZmlyc3QgdGltZSB3ZSB3cml0ZSB0aGlzLCB3ZSdsbCBuZWVkIHRvIGluY2x1ZGUgdGhlIGZ1bGwgaW1wbGVtZW50YXRpb24uXG4gICAgcmVzcG9uc2VTdGF0ZS5zZW50Q2xpZW50UmVuZGVyRnVuY3Rpb24gPSB0cnVlO1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlclNjcmlwdDFGdWxsKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBGdXR1cmUgY2FsbHMgY2FuIGp1c3QgcmV1c2UgdGhlIHNhbWUgZnVuY3Rpb24uXG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyU2NyaXB0MVBhcnRpYWwpO1xuICB9XG5cbiAgaWYgKGJvdW5kYXJ5SUQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIElEIG11c3QgaGF2ZSBiZWVuIGFzc2lnbmVkIGJlZm9yZSB3ZSBjYW4gY29tcGxldGUgdGhlIGJvdW5kYXJ5LicpO1xuICB9XG5cbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgYm91bmRhcnlJRCk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlclNjcmlwdDFBKTtcblxuICBpZiAoZXJyb3JEaWdlc3QgfHwgZXJyb3JNZXNzYWdlIHx8IGVycm9yQ29tcG9uZW50U3RhY2spIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbCk7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVKU1N0cmluZ3NGb3JJbnN0cnVjdGlvblNjcmlwdHMoZXJyb3JEaWdlc3QgfHwgJycpKSk7XG4gIH1cblxuICBpZiAoZXJyb3JNZXNzYWdlIHx8IGVycm9yQ29tcG9uZW50U3RhY2spIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbCk7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVKU1N0cmluZ3NGb3JJbnN0cnVjdGlvblNjcmlwdHMoZXJyb3JNZXNzYWdlIHx8ICcnKSkpO1xuICB9XG5cbiAgaWYgKGVycm9yQ29tcG9uZW50U3RhY2spIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbCk7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVKU1N0cmluZ3NGb3JJbnN0cnVjdGlvblNjcmlwdHMoZXJyb3JDb21wb25lbnRTdGFjaykpKTtcbiAgfVxuXG4gIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJTY3JpcHQyKTtcbn1cbnZhciByZWdleEZvckpTU3RyaW5nc0luU2NyaXB0cyA9IC9bPFxcdTIwMjhcXHUyMDI5XS9nO1xuXG5mdW5jdGlvbiBlc2NhcGVKU1N0cmluZ3NGb3JJbnN0cnVjdGlvblNjcmlwdHMoaW5wdXQpIHtcbiAgdmFyIGVzY2FwZWQgPSBKU09OLnN0cmluZ2lmeShpbnB1dCk7XG4gIHJldHVybiBlc2NhcGVkLnJlcGxhY2UocmVnZXhGb3JKU1N0cmluZ3NJblNjcmlwdHMsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHN3aXRjaCAobWF0Y2gpIHtcbiAgICAgIC8vIHNhbnRpemluZyBicmVha2luZyBvdXQgb2Ygc3RyaW5ncyBhbmQgc2NyaXB0IHRhZ3NcbiAgICAgIGNhc2UgJzwnOlxuICAgICAgICByZXR1cm4gXCJcXFxcdTAwM2NcIjtcblxuICAgICAgY2FzZSBcIlxcdTIwMjhcIjpcbiAgICAgICAgcmV0dXJuIFwiXFxcXHUyMDI4XCI7XG5cbiAgICAgIGNhc2UgXCJcXHUyMDI5XCI6XG4gICAgICAgIHJldHVybiBcIlxcXFx1MjAyOVwiO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyBlbmNvdW50ZXJlZCBhIG1hdGNoIGl0IGRvZXMgbm90IGtub3cgaG93IHRvIHJlcGxhY2UuIHRoaXMgbWVhbnMgdGhlIG1hdGNoIHJlZ2V4IGFuZCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBhcmUgbm8gbG9uZ2VyIGluIHN5bmMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlU3RhdGUkMShnZW5lcmF0ZVN0YXRpY01hcmt1cCwgaWRlbnRpZmllclByZWZpeCkge1xuICB2YXIgcmVzcG9uc2VTdGF0ZSA9IGNyZWF0ZVJlc3BvbnNlU3RhdGUoaWRlbnRpZmllclByZWZpeCwgdW5kZWZpbmVkKTtcbiAgcmV0dXJuIHtcbiAgICAvLyBLZWVwIHRoaXMgaW4gc3luYyB3aXRoIFJlYWN0RE9NU2VydmVyRm9ybWF0Q29uZmlnXG4gICAgYm9vdHN0cmFwQ2h1bmtzOiByZXNwb25zZVN0YXRlLmJvb3RzdHJhcENodW5rcyxcbiAgICBzdGFydElubGluZVNjcmlwdDogcmVzcG9uc2VTdGF0ZS5zdGFydElubGluZVNjcmlwdCxcbiAgICBwbGFjZWhvbGRlclByZWZpeDogcmVzcG9uc2VTdGF0ZS5wbGFjZWhvbGRlclByZWZpeCxcbiAgICBzZWdtZW50UHJlZml4OiByZXNwb25zZVN0YXRlLnNlZ21lbnRQcmVmaXgsXG4gICAgYm91bmRhcnlQcmVmaXg6IHJlc3BvbnNlU3RhdGUuYm91bmRhcnlQcmVmaXgsXG4gICAgaWRQcmVmaXg6IHJlc3BvbnNlU3RhdGUuaWRQcmVmaXgsXG4gICAgbmV4dFN1c3BlbnNlSUQ6IHJlc3BvbnNlU3RhdGUubmV4dFN1c3BlbnNlSUQsXG4gICAgc2VudENvbXBsZXRlU2VnbWVudEZ1bmN0aW9uOiByZXNwb25zZVN0YXRlLnNlbnRDb21wbGV0ZVNlZ21lbnRGdW5jdGlvbixcbiAgICBzZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uOiByZXNwb25zZVN0YXRlLnNlbnRDb21wbGV0ZUJvdW5kYXJ5RnVuY3Rpb24sXG4gICAgc2VudENsaWVudFJlbmRlckZ1bmN0aW9uOiByZXNwb25zZVN0YXRlLnNlbnRDbGllbnRSZW5kZXJGdW5jdGlvbixcbiAgICAvLyBUaGlzIGlzIGFuIGV4dHJhIGZpZWxkIGZvciB0aGUgbGVnYWN5IHJlbmRlcmVyXG4gICAgZ2VuZXJhdGVTdGF0aWNNYXJrdXA6IGdlbmVyYXRlU3RhdGljTWFya3VwXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSb290Rm9ybWF0Q29udGV4dCgpIHtcbiAgcmV0dXJuIHtcbiAgICBpbnNlcnRpb25Nb2RlOiBIVE1MX01PREUsXG4gICAgLy8gV2Ugc2tpcCB0aGUgcm9vdCBtb2RlIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBlbWl0IHRoZSBET0NUWVBFIGluIGxlZ2FjeSBtb2RlLlxuICAgIHNlbGVjdGVkVmFsdWU6IG51bGxcbiAgfTtcbn1cbmZ1bmN0aW9uIHB1c2hUZXh0SW5zdGFuY2UkMSh0YXJnZXQsIHRleHQsIHJlc3BvbnNlU3RhdGUsIHRleHRFbWJlZGRlZCkge1xuICBpZiAocmVzcG9uc2VTdGF0ZS5nZW5lcmF0ZVN0YXRpY01hcmt1cCkge1xuICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodGV4dCkpKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHB1c2hUZXh0SW5zdGFuY2UodGFyZ2V0LCB0ZXh0LCByZXNwb25zZVN0YXRlLCB0ZXh0RW1iZWRkZWQpO1xuICB9XG59XG5mdW5jdGlvbiBwdXNoU2VnbWVudEZpbmFsZSQxKHRhcmdldCwgcmVzcG9uc2VTdGF0ZSwgbGFzdFB1c2hlZFRleHQsIHRleHRFbWJlZGRlZCkge1xuICBpZiAocmVzcG9uc2VTdGF0ZS5nZW5lcmF0ZVN0YXRpY01hcmt1cCkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHVzaFNlZ21lbnRGaW5hbGUodGFyZ2V0LCByZXNwb25zZVN0YXRlLCBsYXN0UHVzaGVkVGV4dCwgdGV4dEVtYmVkZGVkKTtcbiAgfVxufVxuZnVuY3Rpb24gd3JpdGVTdGFydENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkkMShkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZSkge1xuICBpZiAocmVzcG9uc2VTdGF0ZS5nZW5lcmF0ZVN0YXRpY01hcmt1cCkge1xuICAgIC8vIEEgY29tcGxldGVkIGJvdW5kYXJ5IGlzIGRvbmUgYW5kIGRvZXNuJ3QgbmVlZCBhIHJlcHJlc2VudGF0aW9uIGluIHRoZSBIVE1MXG4gICAgLy8gaWYgd2UncmUgbm90IGdvaW5nIHRvIGJlIGh5ZHJhdGluZyBpdC5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB3cml0ZVN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbik7XG59XG5mdW5jdGlvbiB3cml0ZVN0YXJ0Q2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5JDEoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUsIC8vIGZsdXNoaW5nIHRoZXNlIGVycm9yIGFyZ3VtZW50cyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgaW4gdGhpcyBsZWdhY3kgc3RyZWFtaW5nIGZvcm1hdC5cbmVycm9yRGlnZXN0LCBlcnJvck1lc3NhZ2UsIGVycm9yQ29tcG9uZW50U3RhY2spIHtcbiAgaWYgKHJlc3BvbnNlU3RhdGUuZ2VuZXJhdGVTdGF0aWNNYXJrdXApIHtcbiAgICAvLyBBIGNsaWVudCByZW5kZXJlZCBib3VuZGFyeSBpcyBkb25lIGFuZCBkb2Vzbid0IG5lZWQgYSByZXByZXNlbnRhdGlvbiBpbiB0aGUgSFRNTFxuICAgIC8vIHNpbmNlIHdlJ2xsIG5ldmVyIGh5ZHJhdGUgaXQuIFRoaXMgaXMgYXJndWFibHkgYW4gZXJyb3IgaW4gc3RhdGljIGdlbmVyYXRpb24uXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gd3JpdGVTdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZSwgZXJyb3JEaWdlc3QsIGVycm9yTWVzc2FnZSwgZXJyb3JDb21wb25lbnRTdGFjayk7XG59XG5mdW5jdGlvbiB3cml0ZUVuZENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkkMShkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZSkge1xuICBpZiAocmVzcG9uc2VTdGF0ZS5nZW5lcmF0ZVN0YXRpY01hcmt1cCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHdyaXRlRW5kQ29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbik7XG59XG5mdW5jdGlvbiB3cml0ZUVuZENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSQxKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlKSB7XG4gIGlmIChyZXNwb25zZVN0YXRlLmdlbmVyYXRlU3RhdGljTWFya3VwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gd3JpdGVFbmRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24pO1xufVxuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJyk7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG52YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO1xudmFyIFJFQUNUX1NFUlZFUl9DT05URVhUX0RFRkFVTFRfVkFMVUVfTk9UX0xPQURFRCA9IFN5bWJvbC5mb3IoJ3JlYWN0LmRlZmF1bHRfdmFsdWUnKTtcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICggIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVDbGFzc0NvbXBvbmVudEZyYW1lKGN0b3IsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoY3RvciwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dDtcblxue1xuICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQgPSB7fTtcbn1cblxudmFyIGVtcHR5Q29udGV4dE9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlDb250ZXh0T2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gZ2V0TWFza2VkQ29udGV4dCh0eXBlLCB1bm1hc2tlZENvbnRleHQpIHtcbiAge1xuICAgIHZhciBjb250ZXh0VHlwZXMgPSB0eXBlLmNvbnRleHRUeXBlcztcblxuICAgIGlmICghY29udGV4dFR5cGVzKSB7XG4gICAgICByZXR1cm4gZW1wdHlDb250ZXh0T2JqZWN0O1xuICAgIH1cblxuICAgIHZhciBjb250ZXh0ID0ge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgICBjb250ZXh0W2tleV0gPSB1bm1hc2tlZENvbnRleHRba2V5XTtcbiAgICB9XG5cbiAgICB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCAnVW5rbm93bic7XG4gICAgICBjaGVja1Byb3BUeXBlcyhjb250ZXh0VHlwZXMsIGNvbnRleHQsICdjb250ZXh0JywgbmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQoaW5zdGFuY2UsIHR5cGUsIHBhcmVudENvbnRleHQsIGNoaWxkQ29udGV4dFR5cGVzKSB7XG4gIHtcbiAgICAvLyBUT0RPIChidmF1Z2huKSBSZXBsYWNlIHRoaXMgYmVoYXZpb3Igd2l0aCBhbiBpbnZhcmlhbnQoKSBpbiB0aGUgZnV0dXJlLlxuICAgIC8vIEl0IGhhcyBvbmx5IGJlZW4gYWRkZWQgaW4gRmliZXIgdG8gbWF0Y2ggdGhlICh1bmludGVudGlvbmFsKSBiZWhhdmlvciBpbiBTdGFjay5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgaWYgKCF3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzLmNoaWxkQ29udGV4dFR5cGVzIGlzIHNwZWNpZmllZCBidXQgdGhlcmUgaXMgbm8gZ2V0Q2hpbGRDb250ZXh0KCkgbWV0aG9kICcgKyAnb24gdGhlIGluc3RhbmNlLiBZb3UgY2FuIGVpdGhlciBkZWZpbmUgZ2V0Q2hpbGRDb250ZXh0KCkgb24gJXMgb3IgcmVtb3ZlICcgKyAnY2hpbGRDb250ZXh0VHlwZXMgZnJvbSBpdC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyZW50Q29udGV4dDtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRDb250ZXh0ID0gaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0KCk7XG5cbiAgICBmb3IgKHZhciBjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dCkge1xuICAgICAgaWYgKCEoY29udGV4dEtleSBpbiBjaGlsZENvbnRleHRUeXBlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ1Vua25vd24nKSArIFwiLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXFxcIlwiICsgY29udGV4dEtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBpbiBjaGlsZENvbnRleHRUeXBlcy5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ1Vua25vd24nO1xuICAgICAgY2hlY2tQcm9wVHlwZXMoY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dCwgJ2NoaWxkIGNvbnRleHQnLCBuYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXNzaWduKHt9LCBwYXJlbnRDb250ZXh0LCBjaGlsZENvbnRleHQpO1xuICB9XG59XG5cbnZhciByZW5kZXJlclNpZ2lsO1xuXG57XG4gIC8vIFVzZSB0aGlzIHRvIGRldGVjdCBtdWx0aXBsZSByZW5kZXJlcnMgdXNpbmcgdGhlIHNhbWUgY29udGV4dFxuICByZW5kZXJlclNpZ2lsID0ge307XG59IC8vIFVzZWQgdG8gc3RvcmUgdGhlIHBhcmVudCBwYXRoIG9mIGFsbCBjb250ZXh0IG92ZXJyaWRlcyBpbiBhIHNoYXJlZCBsaW5rZWQgbGlzdC5cbi8vIEZvcm1pbmcgYSByZXZlcnNlIHRyZWUuXG5cblxudmFyIHJvb3RDb250ZXh0U25hcHNob3QgPSBudWxsOyAvLyBXZSBhc3N1bWUgdGhhdCB0aGlzIHJ1bnRpbWUgb3ducyB0aGUgXCJjdXJyZW50XCIgZmllbGQgb24gYWxsIFJlYWN0Q29udGV4dCBpbnN0YW5jZXMuXG4vLyBUaGlzIGdsb2JhbCAoYWN0dWFsbHkgdGhyZWFkIGxvY2FsKSBzdGF0ZSByZXByZXNlbnRzIHdoYXQgc3RhdGUgYWxsIHRob3NlIFwiY3VycmVudFwiLFxuLy8gZmllbGRzIGFyZSBjdXJyZW50bHkgaW4uXG5cbnZhciBjdXJyZW50QWN0aXZlU25hcHNob3QgPSBudWxsO1xuXG5mdW5jdGlvbiBwb3BOb2RlKHByZXYpIHtcbiAge1xuICAgIHByZXYuY29udGV4dC5fY3VycmVudFZhbHVlMiA9IHByZXYucGFyZW50VmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaE5vZGUobmV4dCkge1xuICB7XG4gICAgbmV4dC5jb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gbmV4dC52YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvcihwcmV2LCBuZXh0KSB7XG4gIGlmIChwcmV2ID09PSBuZXh0KSA7IGVsc2Uge1xuICAgIHBvcE5vZGUocHJldik7XG4gICAgdmFyIHBhcmVudFByZXYgPSBwcmV2LnBhcmVudDtcbiAgICB2YXIgcGFyZW50TmV4dCA9IG5leHQucGFyZW50O1xuXG4gICAgaWYgKHBhcmVudFByZXYgPT09IG51bGwpIHtcbiAgICAgIGlmIChwYXJlbnROZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN0YWNrcyBtdXN0IHJlYWNoIHRoZSByb290IGF0IHRoZSBzYW1lIHRpbWUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwYXJlbnROZXh0ID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN0YWNrcyBtdXN0IHJlYWNoIHRoZSByb290IGF0IHRoZSBzYW1lIHRpbWUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG5cbiAgICAgIHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHBhcmVudFByZXYsIHBhcmVudE5leHQpO1xuICAgIH0gLy8gT24gdGhlIHdheSBiYWNrLCB3ZSBwdXNoIHRoZSBuZXcgb25lcyB0aGF0IHdlcmVuJ3QgY29tbW9uLlxuXG5cbiAgICBwdXNoTm9kZShuZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BBbGxQcmV2aW91cyhwcmV2KSB7XG4gIHBvcE5vZGUocHJldik7XG4gIHZhciBwYXJlbnRQcmV2ID0gcHJldi5wYXJlbnQ7XG5cbiAgaWYgKHBhcmVudFByZXYgIT09IG51bGwpIHtcbiAgICBwb3BBbGxQcmV2aW91cyhwYXJlbnRQcmV2KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoQWxsTmV4dChuZXh0KSB7XG4gIHZhciBwYXJlbnROZXh0ID0gbmV4dC5wYXJlbnQ7XG5cbiAgaWYgKHBhcmVudE5leHQgIT09IG51bGwpIHtcbiAgICBwdXNoQWxsTmV4dChwYXJlbnROZXh0KTtcbiAgfVxuXG4gIHB1c2hOb2RlKG5leHQpO1xufVxuXG5mdW5jdGlvbiBwb3BQcmV2aW91c1RvQ29tbW9uTGV2ZWwocHJldiwgbmV4dCkge1xuICBwb3BOb2RlKHByZXYpO1xuICB2YXIgcGFyZW50UHJldiA9IHByZXYucGFyZW50O1xuXG4gIGlmIChwYXJlbnRQcmV2ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGVwdGggbXVzdCBlcXVhbCBhdCBsZWFzdCBhdCB6ZXJvIGJlZm9yZSByZWFjaGluZyB0aGUgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgfVxuXG4gIGlmIChwYXJlbnRQcmV2LmRlcHRoID09PSBuZXh0LmRlcHRoKSB7XG4gICAgLy8gV2UgZm91bmQgdGhlIHNhbWUgbGV2ZWwuIE5vdyB3ZSBqdXN0IG5lZWQgdG8gZmluZCBhIHNoYXJlZCBhbmNlc3Rvci5cbiAgICBwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvcihwYXJlbnRQcmV2LCBuZXh0KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBtdXN0IHN0aWxsIGJlIGRlZXBlci5cbiAgICBwb3BQcmV2aW91c1RvQ29tbW9uTGV2ZWwocGFyZW50UHJldiwgbmV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wTmV4dFRvQ29tbW9uTGV2ZWwocHJldiwgbmV4dCkge1xuICB2YXIgcGFyZW50TmV4dCA9IG5leHQucGFyZW50O1xuXG4gIGlmIChwYXJlbnROZXh0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGVwdGggbXVzdCBlcXVhbCBhdCBsZWFzdCBhdCB6ZXJvIGJlZm9yZSByZWFjaGluZyB0aGUgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgfVxuXG4gIGlmIChwcmV2LmRlcHRoID09PSBwYXJlbnROZXh0LmRlcHRoKSB7XG4gICAgLy8gV2UgZm91bmQgdGhlIHNhbWUgbGV2ZWwuIE5vdyB3ZSBqdXN0IG5lZWQgdG8gZmluZCBhIHNoYXJlZCBhbmNlc3Rvci5cbiAgICBwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvcihwcmV2LCBwYXJlbnROZXh0KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBtdXN0IHN0aWxsIGJlIGRlZXBlci5cbiAgICBwb3BOZXh0VG9Db21tb25MZXZlbChwcmV2LCBwYXJlbnROZXh0KTtcbiAgfVxuXG4gIHB1c2hOb2RlKG5leHQpO1xufSAvLyBQZXJmb3JtIGNvbnRleHQgc3dpdGNoaW5nIHRvIHRoZSBuZXcgc25hcHNob3QuXG4vLyBUbyBtYWtlIGl0IGNoZWFwIHRvIHJlYWQgbWFueSBjb250ZXh0cywgd2hpbGUgbm90IHN1c3BlbmRpbmcsIHdlIG1ha2UgdGhlIHN3aXRjaCBlYWdlcmx5IGJ5XG4vLyB1cGRhdGluZyBhbGwgdGhlIGNvbnRleHQncyBjdXJyZW50IHZhbHVlcy4gVGhhdCB3YXkgcmVhZHMsIGFsd2F5cyBqdXN0IHJlYWQgdGhlIGN1cnJlbnQgdmFsdWUuXG4vLyBBdCB0aGUgY29zdCBvZiB1cGRhdGluZyBjb250ZXh0cyBldmVuIGlmIHRoZXkncmUgbmV2ZXIgcmVhZCBieSB0aGlzIHN1YnRyZWUuXG5cblxuZnVuY3Rpb24gc3dpdGNoQ29udGV4dChuZXdTbmFwc2hvdCkge1xuICAvLyBUaGUgYmFzaWMgYWxnb3JpdGhtIHdlIG5lZWQgdG8gZG8gaXMgdG8gcG9wIGJhY2sgYW55IGNvbnRleHRzIHRoYXQgYXJlIG5vIGxvbmdlciBvbiB0aGUgc3RhY2suXG4gIC8vIFdlIGFsc28gbmVlZCB0byB1cGRhdGUgYW55IG5ldyBjb250ZXh0cyB0aGF0IGFyZSBub3cgb24gdGhlIHN0YWNrIHdpdGggdGhlIGRlZXBlc3QgdmFsdWUuXG4gIC8vIFRoZSBlYXNpZXN0IHdheSB0byB1cGRhdGUgbmV3IGNvbnRleHRzIGlzIHRvIGp1c3QgcmVhcHBseSB0aGVtIGluIHJldmVyc2Ugb3JkZXIgZnJvbSB0aGVcbiAgLy8gcGVyc3BlY3RpdmUgb2YgdGhlIGJhY2twb2ludGVycy4gVG8gYXZvaWQgYWxsb2NhdGluZyBhIGxvdCB3aGVuIHN3aXRjaGluZywgd2UgdXNlIHRoZSBzdGFja1xuICAvLyBmb3IgdGhhdC4gVGhlcmVmb3JlIHRoaXMgYWxnb3JpdGhtIGlzIHJlY3Vyc2l2ZS5cbiAgLy8gMSkgRmlyc3Qgd2UgcG9wIHdoaWNoIGV2ZXIgc25hcHNob3QgdHJlZSB3YXMgZGVlcGVzdC4gUG9wcGluZyBvbGQgY29udGV4dHMgYXMgd2UgZ28uXG4gIC8vIDIpIFRoZW4gd2UgZmluZCB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgZnJvbSB0aGVyZS4gUG9wcGluZyBvbGQgY29udGV4dHMgYXMgd2UgZ28uXG4gIC8vIDMpIFRoZW4gd2UgcmVhcHBseSBuZXcgY29udGV4dHMgb24gdGhlIHdheSBiYWNrIHVwIHRoZSBzdGFjay5cbiAgdmFyIHByZXYgPSBjdXJyZW50QWN0aXZlU25hcHNob3Q7XG4gIHZhciBuZXh0ID0gbmV3U25hcHNob3Q7XG5cbiAgaWYgKHByZXYgIT09IG5leHQpIHtcbiAgICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgICAgLy8gJEZsb3dGaXhNZTogVGhpcyBoYXMgdG8gYmUgbm9uLW51bGwgc2luY2UgaXQncyBub3QgZXF1YWwgdG8gcHJldi5cbiAgICAgIHB1c2hBbGxOZXh0KG5leHQpO1xuICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgcG9wQWxsUHJldmlvdXMocHJldik7XG4gICAgfSBlbHNlIGlmIChwcmV2LmRlcHRoID09PSBuZXh0LmRlcHRoKSB7XG4gICAgICBwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvcihwcmV2LCBuZXh0KTtcbiAgICB9IGVsc2UgaWYgKHByZXYuZGVwdGggPiBuZXh0LmRlcHRoKSB7XG4gICAgICBwb3BQcmV2aW91c1RvQ29tbW9uTGV2ZWwocHJldiwgbmV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcE5leHRUb0NvbW1vbkxldmVsKHByZXYsIG5leHQpO1xuICAgIH1cblxuICAgIGN1cnJlbnRBY3RpdmVTbmFwc2hvdCA9IG5leHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHB1c2hQcm92aWRlcihjb250ZXh0LCBuZXh0VmFsdWUpIHtcbiAgdmFyIHByZXZWYWx1ZTtcblxuICB7XG4gICAgcHJldlZhbHVlID0gY29udGV4dC5fY3VycmVudFZhbHVlMjtcbiAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gbmV4dFZhbHVlO1xuXG4gICAge1xuICAgICAgaWYgKGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICE9PSBudWxsICYmIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgIT09IHJlbmRlcmVyU2lnaWwpIHtcbiAgICAgICAgZXJyb3IoJ0RldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSAnICsgJ3NhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPSByZW5kZXJlclNpZ2lsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcmV2Tm9kZSA9IGN1cnJlbnRBY3RpdmVTbmFwc2hvdDtcbiAgdmFyIG5ld05vZGUgPSB7XG4gICAgcGFyZW50OiBwcmV2Tm9kZSxcbiAgICBkZXB0aDogcHJldk5vZGUgPT09IG51bGwgPyAwIDogcHJldk5vZGUuZGVwdGggKyAxLFxuICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgcGFyZW50VmFsdWU6IHByZXZWYWx1ZSxcbiAgICB2YWx1ZTogbmV4dFZhbHVlXG4gIH07XG4gIGN1cnJlbnRBY3RpdmVTbmFwc2hvdCA9IG5ld05vZGU7XG4gIHJldHVybiBuZXdOb2RlO1xufVxuZnVuY3Rpb24gcG9wUHJvdmlkZXIoY29udGV4dCkge1xuICB2YXIgcHJldlNuYXBzaG90ID0gY3VycmVudEFjdGl2ZVNuYXBzaG90O1xuXG4gIGlmIChwcmV2U25hcHNob3QgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyaWVkIHRvIHBvcCBhIENvbnRleHQgYXQgdGhlIHJvb3Qgb2YgdGhlIGFwcC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAocHJldlNuYXBzaG90LmNvbnRleHQgIT09IGNvbnRleHQpIHtcbiAgICAgIGVycm9yKCdUaGUgcGFyZW50IGNvbnRleHQgaXMgbm90IHRoZSBleHBlY3RlZCBjb250ZXh0LiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICB2YXIgX3ZhbHVlID0gcHJldlNuYXBzaG90LnBhcmVudFZhbHVlO1xuXG4gICAgaWYgKF92YWx1ZSA9PT0gUkVBQ1RfU0VSVkVSX0NPTlRFWFRfREVGQVVMVF9WQUxVRV9OT1RfTE9BREVEKSB7XG4gICAgICBwcmV2U25hcHNob3QuY29udGV4dC5fY3VycmVudFZhbHVlMiA9IHByZXZTbmFwc2hvdC5jb250ZXh0Ll9kZWZhdWx0VmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXZTbmFwc2hvdC5jb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gX3ZhbHVlO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICE9PSB1bmRlZmluZWQgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiAhPT0gbnVsbCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICE9PSByZW5kZXJlclNpZ2lsKSB7XG4gICAgICAgIGVycm9yKCdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArICdzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLicpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gcmVuZGVyZXJTaWdpbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3VycmVudEFjdGl2ZVNuYXBzaG90ID0gcHJldlNuYXBzaG90LnBhcmVudDtcbn1cbmZ1bmN0aW9uIGdldEFjdGl2ZUNvbnRleHQoKSB7XG4gIHJldHVybiBjdXJyZW50QWN0aXZlU25hcHNob3Q7XG59XG5mdW5jdGlvbiByZWFkQ29udGV4dChjb250ZXh0KSB7XG4gIHZhciB2YWx1ZSA9ICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbW9kdWxlIGlzIGN1cnJlbnRseSBzaGFyZWQgYW5kIGFzc3VtZWQgdG8gYmUgc3RhdGVsZXNzLlxuICogSWYgdGhpcyBiZWNvbWVzIGFuIGFjdHVhbCBNYXAsIHRoYXQgd2lsbCBicmVhay5cbiAqL1xuZnVuY3Rpb24gZ2V0KGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFscztcbn1cbmZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gIGtleS5fcmVhY3RJbnRlcm5hbHMgPSB2YWx1ZTtcbn1cblxudmFyIGRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnQgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50ID0ge307XG52YXIgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlO1xudmFyIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZTtcbnZhciBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlO1xudmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZTtcbnZhciB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGU7XG52YXIgd2Fybk9uSW52YWxpZENhbGxiYWNrO1xudmFyIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlO1xudmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzO1xudmFyIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZTtcblxue1xuICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZSA9IG5ldyBTZXQoKTtcbiAgdmFyIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjayA9IG5ldyBTZXQoKTtcblxuICB3YXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICBpZiAoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGtleSA9IGNhbGxlck5hbWUgKyAnXycgKyBjYWxsYmFjaztcblxuICAgIGlmICghZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmhhcyhrZXkpKSB7XG4gICAgICBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suYWRkKGtleSk7XG5cbiAgICAgIGVycm9yKCclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGVyTmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfTtcblxuICB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUgPSBmdW5jdGlvbiAodHlwZSwgcGFydGlhbFN0YXRlKSB7XG4gICAgaWYgKHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZXJyb3IoJyVzLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpOiBBIHZhbGlkIHN0YXRlIG9iamVjdCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gJyArICdZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICB7XG4gICAgdmFyIF9jb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gX2NvbnN0cnVjdG9yICYmIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShfY29uc3RydWN0b3IpIHx8ICdSZWFjdENsYXNzJztcbiAgICB2YXIgd2FybmluZ0tleSA9IGNvbXBvbmVudE5hbWUgKyAnLicgKyBjYWxsZXJOYW1lO1xuXG4gICAgaWYgKGRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlcnJvcignJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb3V0c2lkZSBjb21wb25lbnRXaWxsTW91bnQoKSBvbiB0aGUgc2VydmVyLiAnICsgJ1RoaXMgaXMgYSBuby1vcC5cXG5cXG5QbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICBkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuXG52YXIgY2xhc3NDb21wb25lbnRVcGRhdGVyID0ge1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBpbnRlcm5hbHMgPSBnZXQoaW5zdCk7XG5cbiAgICBpZiAoaW50ZXJuYWxzLnF1ZXVlID09PSBudWxsKSB7XG4gICAgICB3YXJuTm9vcChpbnN0LCAnc2V0U3RhdGUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJuYWxzLnF1ZXVlLnB1c2gocGF5bG9hZCk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAoaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgaW50ZXJuYWxzID0gZ2V0KGluc3QpO1xuICAgIGludGVybmFscy5yZXBsYWNlID0gdHJ1ZTtcbiAgICBpbnRlcm5hbHMucXVldWUgPSBbcGF5bG9hZF07XG5cbiAgICB7XG4gICAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoaW5zdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgaW50ZXJuYWxzID0gZ2V0KGluc3QpO1xuXG4gICAgaWYgKGludGVybmFscy5xdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgd2Fybk5vb3AoaW5zdCwgJ2ZvcmNlVXBkYXRlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhpbnN0YW5jZSwgY3RvciwgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBwcmV2U3RhdGUsIG5leHRQcm9wcykge1xuICB2YXIgcGFydGlhbFN0YXRlID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcblxuICB7XG4gICAgd2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlKGN0b3IsIHBhcnRpYWxTdGF0ZSk7XG4gIH0gLy8gTWVyZ2UgdGhlIHBhcnRpYWwgc3RhdGUgYW5kIHRoZSBwcmV2aW91cyBzdGF0ZS5cblxuXG4gIHZhciBuZXdTdGF0ZSA9IHBhcnRpYWxTdGF0ZSA9PT0gbnVsbCB8fCBwYXJ0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCA/IHByZXZTdGF0ZSA6IGFzc2lnbih7fSwgcHJldlN0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdENsYXNzSW5zdGFuY2UoY3RvciwgcHJvcHMsIG1hc2tlZExlZ2FjeUNvbnRleHQpIHtcbiAgdmFyIGNvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gIHZhciBjb250ZXh0VHlwZSA9IGN0b3IuY29udGV4dFR5cGU7XG5cbiAge1xuICAgIGlmICgnY29udGV4dFR5cGUnIGluIGN0b3IpIHtcbiAgICAgIHZhciBpc1ZhbGlkID0gLy8gQWxsb3cgbnVsbCBmb3IgY29uZGl0aW9uYWwgZGVjbGFyYXRpb25cbiAgICAgIGNvbnRleHRUeXBlID09PSBudWxsIHx8IGNvbnRleHRUeXBlICE9PSB1bmRlZmluZWQgJiYgY29udGV4dFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSAmJiBjb250ZXh0VHlwZS5fY29udGV4dCA9PT0gdW5kZWZpbmVkOyAvLyBOb3QgYSA8Q29udGV4dC5Db25zdW1lcj5cblxuICAgICAgaWYgKCFpc1ZhbGlkICYmICFkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuaGFzKGN0b3IpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5hZGQoY3Rvcik7XG4gICAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuXG4gICAgICAgIGlmIChjb250ZXh0VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byB1bmRlZmluZWQuICcgKyAnVGhpcyBjYW4gYmUgY2F1c2VkIGJ5IGEgdHlwbyBvciBieSBtaXhpbmcgdXAgbmFtZWQgYW5kIGRlZmF1bHQgaW1wb3J0cy4gJyArICdUaGlzIGNhbiBhbHNvIGhhcHBlbiBkdWUgdG8gYSBjaXJjdWxhciBkZXBlbmRlbmN5LCBzbyAnICsgJ3RyeSBtb3ZpbmcgdGhlIGNyZWF0ZUNvbnRleHQoKSBjYWxsIHRvIGEgc2VwYXJhdGUgZmlsZS4nO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGEgJyArIHR5cGVvZiBjb250ZXh0VHlwZSArICcuJztcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSkge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LlByb3ZpZGVyIGluc3RlYWQ/JztcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0VHlwZS5fY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gPENvbnRleHQuQ29uc3VtZXI+XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuQ29uc3VtZXIgaW5zdGVhZD8nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYW4gb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNvbnRleHRUeXBlKS5qb2luKCcsICcpICsgJ30uJztcbiAgICAgICAgfVxuXG4gICAgICAgIGVycm9yKCclcyBkZWZpbmVzIGFuIGludmFsaWQgY29udGV4dFR5cGUuICcgKyAnY29udGV4dFR5cGUgc2hvdWxkIHBvaW50IHRvIHRoZSBDb250ZXh0IG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVDb250ZXh0KCkuJXMnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCcsIGFkZGVuZHVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIGNvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dCA9IG1hc2tlZExlZ2FjeUNvbnRleHQ7XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSBuZXcgY3Rvcihwcm9wcywgY29udGV4dCk7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgKGluc3RhbmNlLnN0YXRlID09PSBudWxsIHx8IGluc3RhbmNlLnN0YXRlID09PSB1bmRlZmluZWQpKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZXJyb3IoJ2Alc2AgdXNlcyBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBidXQgaXRzIGluaXRpYWwgc3RhdGUgaXMgJyArICclcy4gVGhpcyBpcyBub3QgcmVjb21tZW5kZWQuIEluc3RlYWQsIGRlZmluZSB0aGUgaW5pdGlhbCBzdGF0ZSBieSAnICsgJ2Fzc2lnbmluZyBhbiBvYmplY3QgdG8gYHRoaXMuc3RhdGVgIGluIHRoZSBjb25zdHJ1Y3RvciBvZiBgJXNgLiAnICsgJ1RoaXMgZW5zdXJlcyB0aGF0IGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGFyZ3VtZW50cyBoYXZlIGEgY29uc2lzdGVudCBzaGFwZS4nLCBjb21wb25lbnROYW1lLCBpbnN0YW5jZS5zdGF0ZSA9PT0gbnVsbCA/ICdudWxsJyA6ICd1bmRlZmluZWQnLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9IC8vIElmIG5ldyBjb21wb25lbnQgQVBJcyBhcmUgZGVmaW5lZCwgXCJ1bnNhZmVcIiBsaWZlY3ljbGVzIHdvbid0IGJlIGNhbGxlZC5cbiAgICAvLyBXYXJuIGFib3V0IHRoZXNlIGxpZmVjeWNsZXMgaWYgdGhleSBhcmUgcHJlc2VudC5cbiAgICAvLyBEb24ndCB3YXJuIGFib3V0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgbWV0aG9kcyB0aG91Z2guXG5cblxuICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgZm91bmRXaWxsTW91bnROYW1lID0gbnVsbDtcbiAgICAgIHZhciBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gbnVsbDtcbiAgICAgIHZhciBmb3VuZFdpbGxVcGRhdGVOYW1lID0gbnVsbDtcblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ2NvbXBvbmVudFdpbGxNb3VudCc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9ICdjb21wb25lbnRXaWxsVXBkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm91bmRXaWxsTW91bnROYW1lICE9PSBudWxsIHx8IGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgIT09IG51bGwgfHwgZm91bmRXaWxsVXBkYXRlTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgICAgdmFyIG5ld0FwaU5hbWUgPSB0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgPyAnZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCknIDogJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlKCknO1xuXG4gICAgICAgIGlmICghZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5oYXMoX2NvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgICAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5hZGQoX2NvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgICAgZXJyb3IoJ1Vuc2FmZSBsZWdhY3kgbGlmZWN5Y2xlcyB3aWxsIG5vdCBiZSBjYWxsZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgbmV3IGNvbXBvbmVudCBBUElzLlxcblxcbicgKyAnJXMgdXNlcyAlcyBidXQgYWxzbyBjb250YWlucyB0aGUgZm9sbG93aW5nIGxlZ2FjeSBsaWZlY3ljbGVzOiVzJXMlc1xcblxcbicgKyAnVGhlIGFib3ZlIGxpZmVjeWNsZXMgc2hvdWxkIGJlIHJlbW92ZWQuIExlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6XFxuJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzJywgX2NvbXBvbmVudE5hbWUsIG5ld0FwaU5hbWUsIGZvdW5kV2lsbE1vdW50TmFtZSAhPT0gbnVsbCA/IFwiXFxuICBcIiArIGZvdW5kV2lsbE1vdW50TmFtZSA6ICcnLCBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lICE9PSBudWxsID8gXCJcXG4gIFwiICsgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA6ICcnLCBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsID8gXCJcXG4gIFwiICsgZm91bmRXaWxsVXBkYXRlTmFtZSA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tDbGFzc0luc3RhbmNlKGluc3RhbmNlLCBjdG9yLCBuZXdQcm9wcykge1xuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG4gICAgdmFyIHJlbmRlclByZXNlbnQgPSBpbnN0YW5jZS5yZW5kZXI7XG5cbiAgICBpZiAoIXJlbmRlclByZXNlbnQpIHtcbiAgICAgIGlmIChjdG9yLnByb3RvdHlwZSAmJiB0eXBlb2YgY3Rvci5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yKCclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiBkaWQgeW91IGFjY2lkZW50YWxseSByZXR1cm4gYW4gb2JqZWN0IGZyb20gdGhlIGNvbnN0cnVjdG9yPycsIG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IoJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLicsIG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUgJiYgIWluc3RhbmNlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCAmJiAhaW5zdGFuY2Uuc3RhdGUpIHtcbiAgICAgIGVycm9yKCdnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGRlZmluZSBhIHN0YXRlIHByb3BlcnR5IGluc3RlYWQ/JywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmdldERlZmF1bHRQcm9wcyAmJiAhaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ1VzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLnByb3BUeXBlcykge1xuICAgICAgZXJyb3IoJ3Byb3BUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIHByb3BUeXBlcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5jb250ZXh0VHlwZSkge1xuICAgICAgZXJyb3IoJ2NvbnRleHRUeXBlIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGUgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoaW5zdGFuY2UuY29udGV4dFR5cGVzKSB7XG4gICAgICAgIGVycm9yKCdjb250ZXh0VHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZXMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN0b3IuY29udGV4dFR5cGUgJiYgY3Rvci5jb250ZXh0VHlwZXMgJiYgIWRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzLmhhcyhjdG9yKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcy5hZGQoY3Rvcik7XG5cbiAgICAgICAgZXJyb3IoJyVzIGRlY2xhcmVzIGJvdGggY29udGV4dFR5cGVzIGFuZCBjb250ZXh0VHlwZSBzdGF0aWMgcHJvcGVydGllcy4gJyArICdUaGUgbGVnYWN5IGNvbnRleHRUeXBlcyBwcm9wZXJ0eSB3aWxsIGJlIGlnbm9yZWQuJywgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoY3Rvci5wcm90b3R5cGUgJiYgY3Rvci5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgJiYgdHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpLiAnICsgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZSBzaG91bGQgbm90IGJlIHVzZWQgd2hlbiBleHRlbmRpbmcgUmVhY3QuUHVyZUNvbXBvbmVudC4gJyArICdQbGVhc2UgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgaXMgdXNlZC4nLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0EgcHVyZSBjb21wb25lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0RpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpPycsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0lmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCAnICsgJ3VzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yICcgKyAncnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBoYXNNdXRhdGVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcyAhPT0gbmV3UHJvcHM7XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IHVuZGVmaW5lZCAmJiBoYXNNdXRhdGVkUHJvcHMpIHtcbiAgICAgIGVycm9yKCclcyguLi4pOiBXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyAnICsgXCJ1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50J3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC5cIiwgbmFtZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZXJyb3IoJ1NldHRpbmcgZGVmYXVsdFByb3BzIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgaWdub3JlZC4nICsgJyBJbnN0ZWFkLCBkZWZpbmUgZGVmYXVsdFByb3BzIGFzIGEgc3RhdGljIHByb3BlcnR5IG9uICVzLicsIG5hbWUsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJyAmJiAhZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmhhcyhjdG9yKSkge1xuICAgICAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmFkZChjdG9yKTtcblxuICAgICAgZXJyb3IoJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIHNob3VsZCBiZSB1c2VkIHdpdGggY29tcG9uZW50RGlkVXBkYXRlKCkuICcgKyAnVGhpcyBjb21wb25lbnQgZGVmaW5lcyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIG9ubHkuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXM6IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcigpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgaXMgZGVmaW5lZCBhcyBhIHN0YXRpYyBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGFuIGluc3RhbmNlIG1ldGhvZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgX3N0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG5cbiAgICBpZiAoX3N0YXRlICYmICh0eXBlb2YgX3N0YXRlICE9PSAnb2JqZWN0JyB8fCBpc0FycmF5KF9zdGF0ZSkpKSB7XG4gICAgICBlcnJvcignJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGN0b3IuY2hpbGRDb250ZXh0VHlwZXMgIT09ICdvYmplY3QnKSB7XG4gICAgICBlcnJvcignJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byAnICsgJ3VzZSBnZXRDaGlsZENvbnRleHQoKS4nLCBuYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxNb3VudCh0eXBlLCBpbnN0YW5jZSkge1xuICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcblxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIGlmICggaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgIGlmICghZGlkV2FybkFib3V0RGVwcmVjYXRlZFdpbGxNb3VudFtjb21wb25lbnROYW1lXSkge1xuICAgICAgICAgIHdhcm4oIC8vIGtlZXAgdGhpcyB3YXJuaW5nIGluIHN5bmMgd2l0aCBSZWFjdFN0cmljdE1vZGVXYXJuaW5nLmpzXG4gICAgICAgICAgJ2NvbXBvbmVudFdpbGxNb3VudCBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgY29kZSBmcm9tIGNvbXBvbmVudFdpbGxNb3VudCB0byBjb21wb25lbnREaWRNb3VudCAocHJlZmVycmVkIGluIG1vc3QgY2FzZXMpICcgKyAnb3IgdGhlIGNvbnN0cnVjdG9yLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICB9XG5cbiAgaWYgKG9sZFN0YXRlICE9PSBpbnN0YW5jZS5zdGF0ZSkge1xuICAgIHtcbiAgICAgIGVycm9yKCclcy5jb21wb25lbnRXaWxsTW91bnQoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgJyArIFwiZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8ICdDb21wb25lbnQnKTtcbiAgICB9XG5cbiAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZShpbnRlcm5hbEluc3RhbmNlLCBpbnN0LCBwcm9wcywgbWFza2VkTGVnYWN5Q29udGV4dCkge1xuICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5xdWV1ZSAhPT0gbnVsbCAmJiBpbnRlcm5hbEluc3RhbmNlLnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgb2xkUXVldWUgPSBpbnRlcm5hbEluc3RhbmNlLnF1ZXVlO1xuICAgIHZhciBvbGRSZXBsYWNlID0gaW50ZXJuYWxJbnN0YW5jZS5yZXBsYWNlO1xuICAgIGludGVybmFsSW5zdGFuY2UucXVldWUgPSBudWxsO1xuICAgIGludGVybmFsSW5zdGFuY2UucmVwbGFjZSA9IGZhbHNlO1xuXG4gICAgaWYgKG9sZFJlcGxhY2UgJiYgb2xkUXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICBpbnN0LnN0YXRlID0gb2xkUXVldWVbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuZXh0U3RhdGUgPSBvbGRSZXBsYWNlID8gb2xkUXVldWVbMF0gOiBpbnN0LnN0YXRlO1xuICAgICAgdmFyIGRvbnRNdXRhdGUgPSB0cnVlO1xuXG4gICAgICBmb3IgKHZhciBpID0gb2xkUmVwbGFjZSA/IDEgOiAwOyBpIDwgb2xkUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnRpYWwgPSBvbGRRdWV1ZVtpXTtcbiAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZSA9IHR5cGVvZiBwYXJ0aWFsID09PSAnZnVuY3Rpb24nID8gcGFydGlhbC5jYWxsKGluc3QsIG5leHRTdGF0ZSwgcHJvcHMsIG1hc2tlZExlZ2FjeUNvbnRleHQpIDogcGFydGlhbDtcblxuICAgICAgICBpZiAocGFydGlhbFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoZG9udE11dGF0ZSkge1xuICAgICAgICAgICAgZG9udE11dGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgbmV4dFN0YXRlID0gYXNzaWduKHt9LCBuZXh0U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFzc2lnbihuZXh0U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGluc3Quc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGludGVybmFsSW5zdGFuY2UucXVldWUgPSBudWxsO1xuICB9XG59IC8vIEludm9rZXMgdGhlIG1vdW50IGxpZmUtY3ljbGVzIG9uIGEgcHJldmlvdXNseSBuZXZlciByZW5kZXJlZCBpbnN0YW5jZS5cblxuXG5mdW5jdGlvbiBtb3VudENsYXNzSW5zdGFuY2UoaW5zdGFuY2UsIGN0b3IsIG5ld1Byb3BzLCBtYXNrZWRMZWdhY3lDb250ZXh0KSB7XG4gIHtcbiAgICBjaGVja0NsYXNzSW5zdGFuY2UoaW5zdGFuY2UsIGN0b3IsIG5ld1Byb3BzKTtcbiAgfVxuXG4gIHZhciBpbml0aWFsU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSAhPT0gdW5kZWZpbmVkID8gaW5zdGFuY2Uuc3RhdGUgOiBudWxsO1xuICBpbnN0YW5jZS51cGRhdGVyID0gY2xhc3NDb21wb25lbnRVcGRhdGVyO1xuICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IGluaXRpYWxTdGF0ZTsgLy8gV2UgZG9uJ3QgYm90aGVyIGluaXRpYWxpemluZyB0aGUgcmVmcyBvYmplY3Qgb24gdGhlIHNlcnZlciwgc2luY2Ugd2UncmUgbm90IGdvaW5nIHRvIHJlc29sdmUgdGhlbSBhbnl3YXkuXG4gIC8vIFRoZSBpbnRlcm5hbCBpbnN0YW5jZSB3aWxsIGJlIHVzZWQgdG8gbWFuYWdlIHVwZGF0ZXMgdGhhdCBoYXBwZW4gZHVyaW5nIHRoaXMgbW91bnQuXG5cbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSB7XG4gICAgcXVldWU6IFtdLFxuICAgIHJlcGxhY2U6IGZhbHNlXG4gIH07XG4gIHNldChpbnN0YW5jZSwgaW50ZXJuYWxJbnN0YW5jZSk7XG4gIHZhciBjb250ZXh0VHlwZSA9IGN0b3IuY29udGV4dFR5cGU7XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gcmVhZENvbnRleHQoY29udGV4dFR5cGUpO1xuICB9IGVsc2Uge1xuICAgIGluc3RhbmNlLmNvbnRleHQgPSBtYXNrZWRMZWdhY3lDb250ZXh0O1xuICB9XG5cbiAge1xuICAgIGlmIChpbnN0YW5jZS5zdGF0ZSA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdG8gYXNzaWduIHByb3BzIGRpcmVjdGx5IHRvIHN0YXRlICcgKyBcImJlY2F1c2UgdXBkYXRlcyB0byBwcm9wcyB3b24ndCBiZSByZWZsZWN0ZWQgaW4gc3RhdGUuIFwiICsgJ0luIG1vc3QgY2FzZXMsIGl0IGlzIGJldHRlciB0byB1c2UgcHJvcHMgZGlyZWN0bHkuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhpbnN0YW5jZSwgY3RvciwgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBpbml0aWFsU3RhdGUsIG5ld1Byb3BzKTtcbiAgfSAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cblxuXG4gIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSkge1xuICAgIGNhbGxDb21wb25lbnRXaWxsTW91bnQoY3RvciwgaW5zdGFuY2UpOyAvLyBJZiB3ZSBoYWQgYWRkaXRpb25hbCBzdGF0ZSB1cGRhdGVzIGR1cmluZyB0aGlzIGxpZmUtY3ljbGUsIGxldCdzXG4gICAgLy8gcHJvY2VzcyB0aGVtIG5vdy5cblxuICAgIHByb2Nlc3NVcGRhdGVRdWV1ZShpbnRlcm5hbEluc3RhbmNlLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG1hc2tlZExlZ2FjeUNvbnRleHQpO1xuICB9XG59XG5cbi8vIElkcyBhcmUgYmFzZSAzMiBzdHJpbmdzIHdob3NlIGJpbmFyeSByZXByZXNlbnRhdGlvbiBjb3JyZXNwb25kcyB0byB0aGVcbi8vIHBvc2l0aW9uIG9mIGEgbm9kZSBpbiBhIHRyZWUuXG4vLyBFdmVyeSB0aW1lIHRoZSB0cmVlIGZvcmtzIGludG8gbXVsdGlwbGUgY2hpbGRyZW4sIHdlIGFkZCBhZGRpdGlvbmFsIGJpdHMgdG9cbi8vIHRoZSBsZWZ0IG9mIHRoZSBzZXF1ZW5jZSB0aGF0IHJlcHJlc2VudCB0aGUgcG9zaXRpb24gb2YgdGhlIGNoaWxkIHdpdGhpbiB0aGVcbi8vIGN1cnJlbnQgbGV2ZWwgb2YgY2hpbGRyZW4uXG4vL1xuLy8gICAgICAwMDEwMSAgICAgICAwMDAxMDAwMTAxMTAxMDEwMVxuLy8gICAgICDilbDilIDilKzilIDila8gICAgICAg4pWw4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pWvXG4vLyAgIEZvcmsgNSBvZiAyMCAgICAgICBQYXJlbnQgaWRcbi8vXG4vLyBUaGUgbGVhZGluZyAwcyBhcmUgaW1wb3J0YW50LiBJbiB0aGUgYWJvdmUgZXhhbXBsZSwgeW91IG9ubHkgbmVlZCAzIGJpdHMgdG9cbi8vIHJlcHJlc2VudCBzbG90IDUuIEhvd2V2ZXIsIHlvdSBuZWVkIDUgYml0cyB0byByZXByZXNlbnQgYWxsIHRoZSBmb3JrcyBhdFxuLy8gdGhlIGN1cnJlbnQgbGV2ZWwsIHNvIHdlIG11c3QgYWNjb3VudCBmb3IgdGhlIGVtcHR5IGJpdHMgYXQgdGhlIGVuZC5cbi8vXG4vLyBGb3IgdGhpcyBzYW1lIHJlYXNvbiwgc2xvdHMgYXJlIDEtaW5kZXhlZCBpbnN0ZWFkIG9mIDAtaW5kZXhlZC4gT3RoZXJ3aXNlLFxuLy8gdGhlIHplcm90aCBpZCBhdCBhIGxldmVsIHdvdWxkIGJlIGluZGlzdGluZ3Vpc2hhYmxlIGZyb20gaXRzIHBhcmVudC5cbi8vXG4vLyBJZiBhIG5vZGUgaGFzIG9ubHkgb25lIGNoaWxkLCBhbmQgZG9lcyBub3QgbWF0ZXJpYWxpemUgYW4gaWQgKGkuZS4gZG9lcyBub3Rcbi8vIGNvbnRhaW4gYSB1c2VJZCBob29rKSwgdGhlbiB3ZSBkb24ndCBuZWVkIHRvIGFsbG9jYXRlIGFueSBzcGFjZSBpbiB0aGVcbi8vIHNlcXVlbmNlLiBJdCdzIHRyZWF0ZWQgYXMgYSB0cmFuc3BhcmVudCBpbmRpcmVjdGlvbi4gRm9yIGV4YW1wbGUsIHRoZXNlIHR3b1xuLy8gdHJlZXMgcHJvZHVjZSB0aGUgc2FtZSBpZHM6XG4vL1xuLy8gPD4gICAgICAgICAgICAgICAgICAgICAgICAgIDw+XG4vLyAgIDxJbmRpcmVjdGlvbj4gICAgICAgICAgICAgICA8QSAvPlxuLy8gICAgIDxBIC8+ICAgICAgICAgICAgICAgICAgICAgPEIgLz5cbi8vICAgPC9JbmRpcmVjdGlvbj4gICAgICAgICAgICA8Lz5cbi8vICAgPEIgLz5cbi8vIDwvPlxuLy9cbi8vIEhvd2V2ZXIsIHdlIGNhbm5vdCBza2lwIGFueSBub2RlIHRoYXQgbWF0ZXJpYWxpemVzIGFuIGlkLiBPdGhlcndpc2UsIGEgcGFyZW50XG4vLyBpZCB0aGF0IGRvZXMgbm90IGZvcmsgd291bGQgYmUgaW5kaXN0aW5ndWlzaGFibGUgZnJvbSBpdHMgY2hpbGQgaWQuIEZvclxuLy8gZXhhbXBsZSwgdGhpcyB0cmVlIGRvZXMgbm90IGZvcmssIGJ1dCB0aGUgcGFyZW50IGFuZCBjaGlsZCBtdXN0IGhhdmVcbi8vIGRpZmZlcmVudCBpZHMuXG4vL1xuLy8gPFBhcmVudD5cbi8vICAgPENoaWxkIC8+XG4vLyA8L1BhcmVudD5cbi8vXG4vLyBUbyBoYW5kbGUgdGhpcyBzY2VuYXJpbywgZXZlcnkgdGltZSB3ZSBtYXRlcmlhbGl6ZSBhbiBpZCwgd2UgYWxsb2NhdGUgYVxuLy8gbmV3IGxldmVsIHdpdGggYSBzaW5nbGUgc2xvdC4gWW91IGNhbiB0aGluayBvZiB0aGlzIGFzIGEgZm9yayB3aXRoIG9ubHkgb25lXG4vLyBwcm9uZywgb3IgYW4gYXJyYXkgb2YgY2hpbGRyZW4gd2l0aCBsZW5ndGggMS5cbi8vXG4vLyBJdCdzIHBvc3NpYmxlIGZvciB0aGUgc2l6ZSBvZiB0aGUgc2VxdWVuY2UgdG8gZXhjZWVkIDMyIGJpdHMsIHRoZSBtYXhcbi8vIHNpemUgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucy4gV2hlbiB0aGlzIGhhcHBlbnMsIHdlIG1ha2UgbW9yZSByb29tIGJ5XG4vLyBjb252ZXJ0aW5nIHRoZSByaWdodCBwYXJ0IG9mIHRoZSBpZCB0byBhIHN0cmluZyBhbmQgc3RvcmluZyBpdCBpbiBhbiBvdmVyZmxvd1xuLy8gdmFyaWFibGUuIFdlIHVzZSBhIGJhc2UgMzIgc3RyaW5nIHJlcHJlc2VudGF0aW9uLCBiZWNhdXNlIDMyIGlzIHRoZSBsYXJnZXN0XG4vLyBwb3dlciBvZiAyIHRoYXQgaXMgc3VwcG9ydGVkIGJ5IHRvU3RyaW5nKCkuIFdlIHdhbnQgdGhlIGJhc2UgdG8gYmUgbGFyZ2Ugc29cbi8vIHRoYXQgdGhlIHJlc3VsdGluZyBpZHMgYXJlIGNvbXBhY3QsIGFuZCB3ZSB3YW50IHRoZSBiYXNlIHRvIGJlIGEgcG93ZXIgb2YgMlxuLy8gYmVjYXVzZSBldmVyeSBsb2cyKGJhc2UpIGJpdHMgY29ycmVzcG9uZHMgdG8gYSBzaW5nbGUgY2hhcmFjdGVyLCBpLmUuIGV2ZXJ5XG4vLyBsb2cyKDMyKSA9IDUgYml0cy4gVGhhdCBtZWFucyB3ZSBjYW4gbG9wIGJpdHMgb2ZmIHRoZSBlbmQgNSBhdCBhIHRpbWUgd2l0aG91dFxuLy8gYWZmZWN0aW5nIHRoZSBmaW5hbCByZXN1bHQuXG52YXIgZW1wdHlUcmVlQ29udGV4dCA9IHtcbiAgaWQ6IDEsXG4gIG92ZXJmbG93OiAnJ1xufTtcbmZ1bmN0aW9uIGdldFRyZWVJZChjb250ZXh0KSB7XG4gIHZhciBvdmVyZmxvdyA9IGNvbnRleHQub3ZlcmZsb3c7XG4gIHZhciBpZFdpdGhMZWFkaW5nQml0ID0gY29udGV4dC5pZDtcbiAgdmFyIGlkID0gaWRXaXRoTGVhZGluZ0JpdCAmIH5nZXRMZWFkaW5nQml0KGlkV2l0aExlYWRpbmdCaXQpO1xuICByZXR1cm4gaWQudG9TdHJpbmcoMzIpICsgb3ZlcmZsb3c7XG59XG5mdW5jdGlvbiBwdXNoVHJlZUNvbnRleHQoYmFzZUNvbnRleHQsIHRvdGFsQ2hpbGRyZW4sIGluZGV4KSB7XG4gIHZhciBiYXNlSWRXaXRoTGVhZGluZ0JpdCA9IGJhc2VDb250ZXh0LmlkO1xuICB2YXIgYmFzZU92ZXJmbG93ID0gYmFzZUNvbnRleHQub3ZlcmZsb3c7IC8vIFRoZSBsZWZ0bW9zdCAxIG1hcmtzIHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlLCBub24taW5jbHVzaXZlLiBJdCdzIG5vdCBwYXJ0XG4gIC8vIG9mIHRoZSBpZDsgd2UgdXNlIGl0IHRvIGFjY291bnQgZm9yIGxlYWRpbmcgMHMuXG5cbiAgdmFyIGJhc2VMZW5ndGggPSBnZXRCaXRMZW5ndGgoYmFzZUlkV2l0aExlYWRpbmdCaXQpIC0gMTtcbiAgdmFyIGJhc2VJZCA9IGJhc2VJZFdpdGhMZWFkaW5nQml0ICYgfigxIDw8IGJhc2VMZW5ndGgpO1xuICB2YXIgc2xvdCA9IGluZGV4ICsgMTtcbiAgdmFyIGxlbmd0aCA9IGdldEJpdExlbmd0aCh0b3RhbENoaWxkcmVuKSArIGJhc2VMZW5ndGg7IC8vIDMwIGlzIHRoZSBtYXggbGVuZ3RoIHdlIGNhbiBzdG9yZSB3aXRob3V0IG92ZXJmbG93aW5nLCB0YWtpbmcgaW50b1xuICAvLyBjb25zaWRlcmF0aW9uIHRoZSBsZWFkaW5nIDEgd2UgdXNlIHRvIG1hcmsgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UuXG5cbiAgaWYgKGxlbmd0aCA+IDMwKSB7XG4gICAgLy8gV2Ugb3ZlcmZsb3dlZCB0aGUgYml0d2lzZS1zYWZlIHJhbmdlLiBGYWxsIGJhY2sgdG8gc2xvd2VyIGFsZ29yaXRobS5cbiAgICAvLyBUaGlzIGJyYW5jaCBhc3N1bWVzIHRoZSBsZW5ndGggb2YgdGhlIGJhc2UgaWQgaXMgZ3JlYXRlciB0aGFuIDU7IGl0IHdvbid0XG4gICAgLy8gd29yayBmb3Igc21hbGxlciBpZHMsIGJlY2F1c2UgeW91IG5lZWQgNSBiaXRzIHBlciBjaGFyYWN0ZXIuXG4gICAgLy9cbiAgICAvLyBXZSBlbmNvZGUgdGhlIGlkIGluIG11bHRpcGxlIHN0ZXBzOiBmaXJzdCB0aGUgYmFzZSBpZCwgdGhlbiB0aGVcbiAgICAvLyByZW1haW5pbmcgZGlnaXRzLlxuICAgIC8vXG4gICAgLy8gRWFjaCA1IGJpdCBzZXF1ZW5jZSBjb3JyZXNwb25kcyB0byBhIHNpbmdsZSBiYXNlIDMyIGNoYXJhY3Rlci4gU28gZm9yXG4gICAgLy8gZXhhbXBsZSwgaWYgdGhlIGN1cnJlbnQgaWQgaXMgMjMgYml0cyBsb25nLCB3ZSBjYW4gY29udmVydCAyMCBvZiB0aG9zZVxuICAgIC8vIGJpdHMgaW50byBhIHN0cmluZyBvZiA0IGNoYXJhY3RlcnMsIHdpdGggMyBiaXRzIGxlZnQgb3Zlci5cbiAgICAvL1xuICAgIC8vIEZpcnN0IGNhbGN1bGF0ZSBob3cgbWFueSBiaXRzIGluIHRoZSBiYXNlIGlkIHJlcHJlc2VudCBhIGNvbXBsZXRlXG4gICAgLy8gc2VxdWVuY2Ugb2YgY2hhcmFjdGVycy5cbiAgICB2YXIgbnVtYmVyT2ZPdmVyZmxvd0JpdHMgPSBiYXNlTGVuZ3RoIC0gYmFzZUxlbmd0aCAlIDU7IC8vIFRoZW4gY3JlYXRlIGEgYml0bWFzayB0aGF0IHNlbGVjdHMgb25seSB0aG9zZSBiaXRzLlxuXG4gICAgdmFyIG5ld092ZXJmbG93Qml0cyA9ICgxIDw8IG51bWJlck9mT3ZlcmZsb3dCaXRzKSAtIDE7IC8vIFNlbGVjdCB0aGUgYml0cywgYW5kIGNvbnZlcnQgdGhlbSB0byBhIGJhc2UgMzIgc3RyaW5nLlxuXG4gICAgdmFyIG5ld092ZXJmbG93ID0gKGJhc2VJZCAmIG5ld092ZXJmbG93Qml0cykudG9TdHJpbmcoMzIpOyAvLyBOb3cgd2UgY2FuIHJlbW92ZSB0aG9zZSBiaXRzIGZyb20gdGhlIGJhc2UgaWQuXG5cbiAgICB2YXIgcmVzdE9mQmFzZUlkID0gYmFzZUlkID4+IG51bWJlck9mT3ZlcmZsb3dCaXRzO1xuICAgIHZhciByZXN0T2ZCYXNlTGVuZ3RoID0gYmFzZUxlbmd0aCAtIG51bWJlck9mT3ZlcmZsb3dCaXRzOyAvLyBGaW5hbGx5LCBlbmNvZGUgdGhlIHJlc3Qgb2YgdGhlIGJpdHMgdXNpbmcgdGhlIG5vcm1hbCBhbGdvcml0aG0uIEJlY2F1c2VcbiAgICAvLyB3ZSBtYWRlIG1vcmUgcm9vbSwgdGhpcyB0aW1lIGl0IHdvbid0IG92ZXJmbG93LlxuXG4gICAgdmFyIHJlc3RPZkxlbmd0aCA9IGdldEJpdExlbmd0aCh0b3RhbENoaWxkcmVuKSArIHJlc3RPZkJhc2VMZW5ndGg7XG4gICAgdmFyIHJlc3RPZk5ld0JpdHMgPSBzbG90IDw8IHJlc3RPZkJhc2VMZW5ndGg7XG4gICAgdmFyIGlkID0gcmVzdE9mTmV3Qml0cyB8IHJlc3RPZkJhc2VJZDtcbiAgICB2YXIgb3ZlcmZsb3cgPSBuZXdPdmVyZmxvdyArIGJhc2VPdmVyZmxvdztcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IDEgPDwgcmVzdE9mTGVuZ3RoIHwgaWQsXG4gICAgICBvdmVyZmxvdzogb3ZlcmZsb3dcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIE5vcm1hbCBwYXRoXG4gICAgdmFyIG5ld0JpdHMgPSBzbG90IDw8IGJhc2VMZW5ndGg7XG5cbiAgICB2YXIgX2lkID0gbmV3Qml0cyB8IGJhc2VJZDtcblxuICAgIHZhciBfb3ZlcmZsb3cgPSBiYXNlT3ZlcmZsb3c7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiAxIDw8IGxlbmd0aCB8IF9pZCxcbiAgICAgIG92ZXJmbG93OiBfb3ZlcmZsb3dcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEJpdExlbmd0aChudW1iZXIpIHtcbiAgcmV0dXJuIDMyIC0gY2x6MzIobnVtYmVyKTtcbn1cblxuZnVuY3Rpb24gZ2V0TGVhZGluZ0JpdChpZCkge1xuICByZXR1cm4gMSA8PCBnZXRCaXRMZW5ndGgoaWQpIC0gMTtcbn0gLy8gVE9ETzogTWF0aC5jbHozMiBpcyBzdXBwb3J0ZWQgaW4gTm9kZSAxMisuIE1heWJlIHdlIGNhbiBkcm9wIHRoZSBmYWxsYmFjay5cblxuXG52YXIgY2x6MzIgPSBNYXRoLmNsejMyID8gTWF0aC5jbHozMiA6IGNsejMyRmFsbGJhY2s7IC8vIENvdW50IGxlYWRpbmcgemVyb3MuXG4vLyBCYXNlZCBvbjpcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvY2x6MzJcblxudmFyIGxvZyA9IE1hdGgubG9nO1xudmFyIExOMiA9IE1hdGguTE4yO1xuXG5mdW5jdGlvbiBjbHozMkZhbGxiYWNrKHgpIHtcbiAgdmFyIGFzVWludCA9IHggPj4+IDA7XG5cbiAgaWYgKGFzVWludCA9PT0gMCkge1xuICAgIHJldHVybiAzMjtcbiAgfVxuXG4gIHJldHVybiAzMSAtIChsb2coYXNVaW50KSAvIExOMiB8IDApIHwgMDtcbn1cblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICByZXR1cm4geCA9PT0geSAmJiAoeCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkpIHx8IHggIT09IHggJiYgeSAhPT0geSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICA7XG59XG5cbnZhciBvYmplY3RJcyA9IHR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpcztcblxudmFyIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IG51bGw7XG52YXIgY3VycmVudGx5UmVuZGVyaW5nVGFzayA9IG51bGw7XG52YXIgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xudmFyIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7IC8vIFdoZXRoZXIgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgaG9vayBpcyBhIHJlLXJlbmRlcmVkIGhvb2tcblxudmFyIGlzUmVSZW5kZXIgPSBmYWxzZTsgLy8gV2hldGhlciBhbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBkdXJpbmcgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgcmVuZGVyIHBhc3MuXG5cbnZhciBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7IC8vIENvdW50cyB0aGUgbnVtYmVyIG9mIHVzZUlkIGhvb2tzIGluIHRoaXMgY29tcG9uZW50XG5cbnZhciBsb2NhbElkQ291bnRlciA9IDA7IC8vIExhemlseSBjcmVhdGVkIG1hcCBvZiByZW5kZXItcGhhc2UgdXBkYXRlc1xuXG52YXIgcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDsgLy8gQ291bnRlciB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLlxuXG52YXIgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xudmFyIFJFX1JFTkRFUl9MSU1JVCA9IDI1O1xudmFyIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlOyAvLyBJbiBERVYsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgcHJpbWl0aXZlIGhvb2tcblxudmFyIGN1cnJlbnRIb29rTmFtZUluRGV2O1xuXG5mdW5jdGlvbiByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCkge1xuICBpZiAoY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yJyArICcgb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4nICsgJzEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbicgKyAnMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbicgKyAnMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcbicgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uJyk7XG4gIH1cblxuICB7XG4gICAgaWYgKGlzSW5Ib29rVXNlckNvZGVJbkRldikge1xuICAgICAgZXJyb3IoJ0RvIG5vdCBjYWxsIEhvb2tzIGluc2lkZSB1c2VFZmZlY3QoLi4uKSwgdXNlTWVtbyguLi4pLCBvciBvdGhlciBidWlsdC1pbiBIb29rcy4gJyArICdZb3UgY2FuIG9ubHkgY2FsbCBIb29rcyBhdCB0aGUgdG9wIGxldmVsIG9mIHlvdXIgUmVhY3QgZnVuY3Rpb24uICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ydWxlcy1vZi1ob29rcycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQ7XG59XG5cbmZ1bmN0aW9uIGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpIHtcbiAgaWYgKHByZXZEZXBzID09PSBudWxsKSB7XG4gICAge1xuICAgICAgZXJyb3IoJyVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyAnICsgJ3RoZSBwcmV2aW91cyByZW5kZXIuIEV2ZW4gdGhvdWdoIHRoZSBmaW5hbCBhcmd1bWVudCBpcyBvcHRpb25hbCwgJyArICdpdHMgdHlwZSBjYW5ub3QgY2hhbmdlIGJldHdlZW4gcmVuZGVycy4nLCBjdXJyZW50SG9va05hbWVJbkRldik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAge1xuICAgIC8vIERvbid0IGJvdGhlciBjb21wYXJpbmcgbGVuZ3RocyBpbiBwcm9kIGJlY2F1c2UgdGhlc2UgYXJyYXlzIHNob3VsZCBiZVxuICAgIC8vIHBhc3NlZCBpbmxpbmUuXG4gICAgaWYgKG5leHREZXBzLmxlbmd0aCAhPT0gcHJldkRlcHMubGVuZ3RoKSB7XG4gICAgICBlcnJvcignVGhlIGZpbmFsIGFyZ3VtZW50IHBhc3NlZCB0byAlcyBjaGFuZ2VkIHNpemUgYmV0d2VlbiByZW5kZXJzLiBUaGUgJyArICdvcmRlciBhbmQgc2l6ZSBvZiB0aGlzIGFycmF5IG11c3QgcmVtYWluIGNvbnN0YW50LlxcblxcbicgKyAnUHJldmlvdXM6ICVzXFxuJyArICdJbmNvbWluZzogJXMnLCBjdXJyZW50SG9va05hbWVJbkRldiwgXCJbXCIgKyBuZXh0RGVwcy5qb2luKCcsICcpICsgXCJdXCIsIFwiW1wiICsgcHJldkRlcHMuam9pbignLCAnKSArIFwiXVwiKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZEZXBzLmxlbmd0aCAmJiBpIDwgbmV4dERlcHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAob2JqZWN0SXMobmV4dERlcHNbaV0sIHByZXZEZXBzW2ldKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhvb2soKSB7XG4gIGlmIChudW1iZXJPZlJlUmVuZGVycyA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlcmVkIG1vcmUgaG9va3MgdGhhbiBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlcicpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtZW1vaXplZFN0YXRlOiBudWxsLFxuICAgIHF1ZXVlOiBudWxsLFxuICAgIG5leHQ6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgaG9vayBpbiB0aGUgbGlzdFxuICAgIGlmIChmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCkge1xuICAgICAgaXNSZVJlbmRlciA9IGZhbHNlO1xuICAgICAgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVIb29rKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIHdvcmstaW4tcHJvZ3Jlc3MuIFJldXNlIGl0LlxuICAgICAgaXNSZVJlbmRlciA9IHRydWU7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBmaXJzdFdvcmtJblByb2dyZXNzSG9vaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID09PSBudWxsKSB7XG4gICAgICBpc1JlUmVuZGVyID0gZmFsc2U7IC8vIEFwcGVuZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0XG5cbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gY3JlYXRlSG9vaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSdzIGFscmVhZHkgYSB3b3JrLWluLXByb2dyZXNzLiBSZXVzZSBpdC5cbiAgICAgIGlzUmVSZW5kZXIgPSB0cnVlO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvVXNlSG9va3ModGFzaywgY29tcG9uZW50SWRlbnRpdHkpIHtcbiAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gY29tcG9uZW50SWRlbnRpdHk7XG4gIGN1cnJlbnRseVJlbmRlcmluZ1Rhc2sgPSB0YXNrO1xuXG4gIHtcbiAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTtcbiAgfSAvLyBUaGUgZm9sbG93aW5nIHNob3VsZCBoYXZlIGFscmVhZHkgYmVlbiByZXNldFxuICAvLyBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIC8vIGxvY2FsSWRDb3VudGVyID0gMDtcbiAgLy8gZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICAvLyBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG4gIC8vIHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGw7XG4gIC8vIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG5cblxuICBsb2NhbElkQ291bnRlciA9IDA7XG59XG5mdW5jdGlvbiBmaW5pc2hIb29rcyhDb21wb25lbnQsIHByb3BzLCBjaGlsZHJlbiwgcmVmT3JDb250ZXh0KSB7XG4gIC8vIFRoaXMgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgZXZlcnkgZnVuY3Rpb24gY29tcG9uZW50IHRvIHByZXZlbnQgaG9va3MgZnJvbVxuICAvLyBiZWluZyB1c2VkIGluIGNsYXNzZXMuXG4gIHdoaWxlIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlKSB7XG4gICAgLy8gVXBkYXRlcyB3ZXJlIHNjaGVkdWxlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gVGhleSBhcmUgc3RvcmVkIGluXG4gICAgLy8gdGhlIGByZW5kZXJQaGFzZVVwZGF0ZXNgIG1hcC4gQ2FsbCB0aGUgY29tcG9uZW50IGFnYWluLCByZXVzaW5nIHRoZVxuICAgIC8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9va3MgYW5kIGFwcGx5aW5nIHRoZSBhZGRpdGlvbmFsIHVwZGF0ZXMgb24gdG9wLiBLZWVwXG4gICAgLy8gcmVzdGFydGluZyB1bnRpbCBubyBtb3JlIHVwZGF0ZXMgYXJlIHNjaGVkdWxlZC5cbiAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gICAgbG9jYWxJZENvdW50ZXIgPSAwO1xuICAgIG51bWJlck9mUmVSZW5kZXJzICs9IDE7IC8vIFN0YXJ0IG92ZXIgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0XG5cbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICAgIGNoaWxkcmVuID0gQ29tcG9uZW50KHByb3BzLCByZWZPckNvbnRleHQpO1xuICB9XG5cbiAgcmVzZXRIb29rc1N0YXRlKCk7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cbmZ1bmN0aW9uIGNoZWNrRGlkUmVuZGVySWRIb29rKCkge1xuICAvLyBUaGlzIHNob3VsZCBiZSBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgZXZlcnkgZmluaXNoSG9va3MgY2FsbC5cbiAgLy8gQ29uY2VwdHVhbGx5LCBpdCdzIHBhcnQgb2YgdGhlIHJldHVybiB2YWx1ZSBvZiBmaW5pc2hIb29rczsgaXQncyBvbmx5IGFcbiAgLy8gc2VwYXJhdGUgZnVuY3Rpb24gdG8gYXZvaWQgdXNpbmcgYW4gYXJyYXkgdHVwbGUuXG4gIHZhciBkaWRSZW5kZXJJZEhvb2sgPSBsb2NhbElkQ291bnRlciAhPT0gMDtcbiAgcmV0dXJuIGRpZFJlbmRlcklkSG9vaztcbn0gLy8gUmVzZXQgdGhlIGludGVybmFsIGhvb2tzIHN0YXRlIGlmIGFuIGVycm9yIG9jY3VycyB3aGlsZSByZW5kZXJpbmcgYSBjb21wb25lbnRcblxuZnVuY3Rpb24gcmVzZXRIb29rc1N0YXRlKCkge1xuICB7XG4gICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gIH1cblxuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSBudWxsO1xuICBjdXJyZW50bHlSZW5kZXJpbmdUYXNrID0gbnVsbDtcbiAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuICBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbiAgcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVhZENvbnRleHQkMShjb250ZXh0KSB7XG4gIHtcbiAgICBpZiAoaXNJbkhvb2tVc2VyQ29kZUluRGV2KSB7XG4gICAgICBlcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiB1c2VDb250ZXh0KGNvbnRleHQpIHtcbiAge1xuICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICB9XG5cbiAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIGJhc2ljU3RhdGVSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgLy8gJEZsb3dGaXhNZTogRmxvdyBkb2Vzbid0IGxpa2UgbWl4ZWQgdHlwZXNcbiAgcmV0dXJuIHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicgPyBhY3Rpb24oc3RhdGUpIDogYWN0aW9uO1xufVxuXG5mdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAge1xuICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgfVxuXG4gIHJldHVybiB1c2VSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyLCAvLyB1c2VSZWR1Y2VyIGhhcyBhIHNwZWNpYWwgY2FzZSB0byBzdXBwb3J0IGxhenkgdXNlU3RhdGUgaW5pdGlhbGl6ZXJzXG4gIGluaXRpYWxTdGF0ZSk7XG59XG5mdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAge1xuICAgIGlmIChyZWR1Y2VyICE9PSBiYXNpY1N0YXRlUmVkdWNlcikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgfVxuICB9XG5cbiAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcblxuICBpZiAoaXNSZVJlbmRlcikge1xuICAgIC8vIFRoaXMgaXMgYSByZS1yZW5kZXIuIEFwcGx5IHRoZSBuZXcgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgdG8gdGhlIHByZXZpb3VzXG4gICAgLy8gY3VycmVudCBob29rLlxuICAgIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzSG9vay5xdWV1ZTtcbiAgICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaDtcblxuICAgIGlmIChyZW5kZXJQaGFzZVVwZGF0ZXMgIT09IG51bGwpIHtcbiAgICAgIC8vIFJlbmRlciBwaGFzZSB1cGRhdGVzIGFyZSBzdG9yZWQgaW4gYSBtYXAgb2YgcXVldWUgLT4gbGlua2VkIGxpc3RcbiAgICAgIHZhciBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gcmVuZGVyUGhhc2VVcGRhdGVzLmdldChxdWV1ZSk7XG5cbiAgICAgIGlmIChmaXJzdFJlbmRlclBoYXNlVXBkYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzLmRlbGV0ZShxdWV1ZSk7XG4gICAgICAgIHZhciBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgICB2YXIgdXBkYXRlID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgLy8gUHJvY2VzcyB0aGlzIHJlbmRlciBwaGFzZSB1cGRhdGUuIFdlIGRvbid0IGhhdmUgdG8gY2hlY2sgdGhlXG4gICAgICAgICAgLy8gcHJpb3JpdHkgYmVjYXVzZSBpdCB3aWxsIGFsd2F5cyBiZSB0aGUgc2FtZSBhcyB0aGUgY3VycmVudFxuICAgICAgICAgIC8vIHJlbmRlcidzLlxuICAgICAgICAgIHZhciBhY3Rpb24gPSB1cGRhdGUuYWN0aW9uO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXdTdGF0ZSA9IHJlZHVjZXIobmV3U3RhdGUsIGFjdGlvbik7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICAgICAgfSB3aGlsZSAodXBkYXRlICE9PSBudWxsKTtcblxuICAgICAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICByZXR1cm4gW25ld1N0YXRlLCBkaXNwYXRjaF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFt3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSwgZGlzcGF0Y2hdO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGluaXRpYWxTdGF0ZTtcblxuICAgIGlmIChyZWR1Y2VyID09PSBiYXNpY1N0YXRlUmVkdWNlcikge1xuICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBgdXNlU3RhdGVgLlxuICAgICAgaW5pdGlhbFN0YXRlID0gdHlwZW9mIGluaXRpYWxBcmcgPT09ICdmdW5jdGlvbicgPyBpbml0aWFsQXJnKCkgOiBpbml0aWFsQXJnO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbml0aWFsU3RhdGUgPSBpbml0ICE9PSB1bmRlZmluZWQgPyBpbml0KGluaXRpYWxBcmcpIDogaW5pdGlhbEFyZztcbiAgICB9XG5cbiAgICB7XG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcblxuICAgIHZhciBfcXVldWUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sucXVldWUgPSB7XG4gICAgICBsYXN0OiBudWxsLFxuICAgICAgZGlzcGF0Y2g6IG51bGxcbiAgICB9O1xuXG4gICAgdmFyIF9kaXNwYXRjaCA9IF9xdWV1ZS5kaXNwYXRjaCA9IGRpc3BhdGNoQWN0aW9uLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50LCBfcXVldWUpO1xuXG4gICAgcmV0dXJuIFt3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSwgX2Rpc3BhdGNoXTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzSG9vayAhPT0gbnVsbCkge1xuICAgIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChuZXh0RGVwcyAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcHJldkRlcHMgPSBwcmV2U3RhdGVbMV07XG5cbiAgICAgICAgaWYgKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSB0cnVlO1xuICB9XG5cbiAgdmFyIG5leHRWYWx1ZSA9IG5leHRDcmVhdGUoKTtcblxuICB7XG4gICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0VmFsdWUsIG5leHREZXBzXTtcbiAgcmV0dXJuIG5leHRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlUmVmKGluaXRpYWxWYWx1ZSkge1xuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgcHJldmlvdXNSZWYgPSB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAocHJldmlvdXNSZWYgPT09IG51bGwpIHtcbiAgICB2YXIgcmVmID0ge1xuICAgICAgY3VycmVudDogaW5pdGlhbFZhbHVlXG4gICAgfTtcblxuICAgIHtcbiAgICAgIE9iamVjdC5zZWFsKHJlZik7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSByZWY7XG4gICAgcmV0dXJuIHJlZjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJldmlvdXNSZWY7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgaW5wdXRzKSB7XG4gIHtcbiAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuXG4gICAgZXJyb3IoJ3VzZUxheW91dEVmZmVjdCBkb2VzIG5vdGhpbmcgb24gdGhlIHNlcnZlciwgYmVjYXVzZSBpdHMgZWZmZWN0IGNhbm5vdCAnICsgXCJiZSBlbmNvZGVkIGludG8gdGhlIHNlcnZlciByZW5kZXJlcidzIG91dHB1dCBmb3JtYXQuIFRoaXMgd2lsbCBsZWFkIFwiICsgJ3RvIGEgbWlzbWF0Y2ggYmV0d2VlbiB0aGUgaW5pdGlhbCwgbm9uLWh5ZHJhdGVkIFVJIGFuZCB0aGUgaW50ZW5kZWQgJyArICdVSS4gVG8gYXZvaWQgdGhpcywgdXNlTGF5b3V0RWZmZWN0IHNob3VsZCBvbmx5IGJlIHVzZWQgaW4gJyArICdjb21wb25lbnRzIHRoYXQgcmVuZGVyIGV4Y2x1c2l2ZWx5IG9uIHRoZSBjbGllbnQuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91c2VsYXlvdXRlZmZlY3Qtc3NyIGZvciBjb21tb24gZml4ZXMuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb24oY29tcG9uZW50SWRlbnRpdHksIHF1ZXVlLCBhY3Rpb24pIHtcbiAgaWYgKG51bWJlck9mUmVSZW5kZXJzID49IFJFX1JFTkRFUl9MSU1JVCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVG9vIG1hbnkgcmUtcmVuZGVycy4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgcmVuZGVycyB0byBwcmV2ZW50ICcgKyAnYW4gaW5maW5pdGUgbG9vcC4nKTtcbiAgfVxuXG4gIGlmIChjb21wb25lbnRJZGVudGl0eSA9PT0gY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIFN0YXNoIGl0IGluIGEgbGF6aWx5LWNyZWF0ZWQgbWFwIG9mXG4gICAgLy8gcXVldWUgLT4gbGlua2VkIGxpc3Qgb2YgdXBkYXRlcy4gQWZ0ZXIgdGhpcyByZW5kZXIgcGFzcywgd2UnbGwgcmVzdGFydFxuICAgIC8vIGFuZCBhcHBseSB0aGUgc3Rhc2hlZCB1cGRhdGVzIG9uIHRvcCBvZiB0aGUgd29yay1pbi1wcm9ncmVzcyBob29rLlxuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSB0cnVlO1xuICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKHJlbmRlclBoYXNlVXBkYXRlcyA9PT0gbnVsbCkge1xuICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIHZhciBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gcmVuZGVyUGhhc2VVcGRhdGVzLmdldChxdWV1ZSk7XG5cbiAgICBpZiAoZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZW5kZXJQaGFzZVVwZGF0ZXMuc2V0KHF1ZXVlLCB1cGRhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICAgICAgdmFyIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGU7XG5cbiAgICAgIHdoaWxlIChsYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dCAhPT0gbnVsbCkge1xuICAgICAgICBsYXN0UmVuZGVyUGhhc2VVcGRhdGUgPSBsYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dDtcbiAgICAgIH1cblxuICAgICAgbGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQgPSB1cGRhdGU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHJldHVybiB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2s7XG4gIH0sIGRlcHMpO1xufSAvLyBUT0RPIERlY2lkZSBvbiBob3cgdG8gaW1wbGVtZW50IHRoaXMgaG9vayBmb3Igc2VydmVyIHJlbmRlcmluZy5cbi8vIElmIGEgbXV0YXRpb24gb2NjdXJzIGR1cmluZyByZW5kZXIsIGNvbnNpZGVyIHRyaWdnZXJpbmcgYSBTdXNwZW5zZSBib3VuZGFyeVxuLy8gYW5kIGZhbGxpbmcgYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLlxuXG5mdW5jdGlvbiB1c2VNdXRhYmxlU291cmNlKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHJldHVybiBnZXRTbmFwc2hvdChzb3VyY2UuX3NvdXJjZSk7XG59XG5cbmZ1bmN0aW9uIHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gIGlmIChnZXRTZXJ2ZXJTbmFwc2hvdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGdldFNlcnZlclNuYXBzaG90LCB3aGljaCBpcyByZXF1aXJlZCBmb3IgJyArICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gV2lsbCByZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy4nKTtcbiAgfVxuXG4gIHJldHVybiBnZXRTZXJ2ZXJTbmFwc2hvdCgpO1xufVxuXG5mdW5jdGlvbiB1c2VEZWZlcnJlZFZhbHVlKHZhbHVlKSB7XG4gIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB1bnN1cHBvcnRlZFN0YXJ0VHJhbnNpdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdzdGFydFRyYW5zaXRpb24gY2Fubm90IGJlIGNhbGxlZCBkdXJpbmcgc2VydmVyIHJlbmRlcmluZy4nKTtcbn1cblxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvbigpIHtcbiAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICByZXR1cm4gW2ZhbHNlLCB1bnN1cHBvcnRlZFN0YXJ0VHJhbnNpdGlvbl07XG59XG5cbmZ1bmN0aW9uIHVzZUlkKCkge1xuICB2YXIgdGFzayA9IGN1cnJlbnRseVJlbmRlcmluZ1Rhc2s7XG4gIHZhciB0cmVlSWQgPSBnZXRUcmVlSWQodGFzay50cmVlQ29udGV4dCk7XG4gIHZhciByZXNwb25zZVN0YXRlID0gY3VycmVudFJlc3BvbnNlU3RhdGU7XG5cbiAgaWYgKHJlc3BvbnNlU3RhdGUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LicpO1xuICB9XG5cbiAgdmFyIGxvY2FsSWQgPSBsb2NhbElkQ291bnRlcisrO1xuICByZXR1cm4gbWFrZUlkKHJlc3BvbnNlU3RhdGUsIHRyZWVJZCwgbG9jYWxJZCk7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgRGlzcGF0Y2hlciA9IHtcbiAgcmVhZENvbnRleHQ6IHJlYWRDb250ZXh0JDEsXG4gIHVzZUNvbnRleHQ6IHVzZUNvbnRleHQsXG4gIHVzZU1lbW86IHVzZU1lbW8sXG4gIHVzZVJlZHVjZXI6IHVzZVJlZHVjZXIsXG4gIHVzZVJlZjogdXNlUmVmLFxuICB1c2VTdGF0ZTogdXNlU3RhdGUsXG4gIHVzZUluc2VydGlvbkVmZmVjdDogbm9vcCxcbiAgdXNlTGF5b3V0RWZmZWN0OiB1c2VMYXlvdXRFZmZlY3QsXG4gIHVzZUNhbGxiYWNrOiB1c2VDYWxsYmFjayxcbiAgLy8gdXNlSW1wZXJhdGl2ZUhhbmRsZSBpcyBub3QgcnVuIGluIHRoZSBzZXJ2ZXIgZW52aXJvbm1lbnRcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogbm9vcCxcbiAgLy8gRWZmZWN0cyBhcmUgbm90IHJ1biBpbiB0aGUgc2VydmVyIGVudmlyb25tZW50LlxuICB1c2VFZmZlY3Q6IG5vb3AsXG4gIC8vIERlYnVnZ2luZyBlZmZlY3RcbiAgdXNlRGVidWdWYWx1ZTogbm9vcCxcbiAgdXNlRGVmZXJyZWRWYWx1ZTogdXNlRGVmZXJyZWRWYWx1ZSxcbiAgdXNlVHJhbnNpdGlvbjogdXNlVHJhbnNpdGlvbixcbiAgdXNlSWQ6IHVzZUlkLFxuICAvLyBTdWJzY3JpcHRpb25zIGFyZSBub3Qgc2V0dXAgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG4gIHVzZU11dGFibGVTb3VyY2U6IHVzZU11dGFibGVTb3VyY2UsXG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVxufTtcblxudmFyIGN1cnJlbnRSZXNwb25zZVN0YXRlID0gbnVsbDtcbmZ1bmN0aW9uIHNldEN1cnJlbnRSZXNwb25zZVN0YXRlKHJlc3BvbnNlU3RhdGUpIHtcbiAgY3VycmVudFJlc3BvbnNlU3RhdGUgPSByZXNwb25zZVN0YXRlO1xufVxuXG5mdW5jdGlvbiBnZXRTdGFja0J5Q29tcG9uZW50U3RhY2tOb2RlKGNvbXBvbmVudFN0YWNrKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICB2YXIgbm9kZSA9IGNvbXBvbmVudFN0YWNrO1xuXG4gICAgZG8ge1xuICAgICAgc3dpdGNoIChub2RlLnRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgaW5mbyArPSBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShub2RlLnR5cGUsIG51bGwsIG51bGwpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpbmZvICs9IGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShub2RlLnR5cGUsIG51bGwsIG51bGwpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBpbmZvICs9IGRlc2NyaWJlQ2xhc3NDb21wb25lbnRGcmFtZShub2RlLnR5cGUsIG51bGwsIG51bGwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgfSB3aGlsZSAobm9kZSk7XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfSBjYXRjaCAoeCkge1xuICAgIHJldHVybiAnXFxuRXJyb3IgZ2VuZXJhdGluZyBzdGFjazogJyArIHgubWVzc2FnZSArICdcXG4nICsgeC5zdGFjaztcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xudmFyIFBFTkRJTkcgPSAwO1xudmFyIENPTVBMRVRFRCA9IDE7XG52YXIgRkxVU0hFRCA9IDI7XG52YXIgQUJPUlRFRCA9IDM7XG52YXIgRVJST1JFRCA9IDQ7XG52YXIgT1BFTiA9IDA7XG52YXIgQ0xPU0lORyA9IDE7XG52YXIgQ0xPU0VEID0gMjtcbi8vIFRoaXMgaXMgYSBkZWZhdWx0IGhldXJpc3RpYyBmb3IgaG93IHRvIHNwbGl0IHVwIHRoZSBIVE1MIGNvbnRlbnQgaW50byBwcm9ncmVzc2l2ZVxuLy8gbG9hZGluZy4gT3VyIGdvYWwgaXMgdG8gYmUgYWJsZSB0byBkaXNwbGF5IGFkZGl0aW9uYWwgbmV3IGNvbnRlbnQgYWJvdXQgZXZlcnkgNTAwbXMuXG4vLyBGYXN0ZXIgdGhhbiB0aGF0IGlzIHVubmVjZXNzYXJ5IGFuZCBzaG91bGQgYmUgdGhyb3R0bGVkIG9uIHRoZSBjbGllbnQuIEl0IGFsc29cbi8vIGFkZHMgdW5uZWNlc3Nhcnkgb3ZlcmhlYWQgdG8gZG8gbW9yZSBzcGxpdHMuIFdlIGRvbid0IGtub3cgaWYgaXQncyBhIGhpZ2hlciBvciBsb3dlclxuLy8gZW5kIGRldmljZSBidXQgaGlnaGVyIGVuZCBzdWZmZXIgbGVzcyBmcm9tIHRoZSBvdmVyaGVhZCB0aGFuIGxvd2VyIGVuZCBkb2VzIGZyb21cbi8vIG5vdCBnZXR0aW5nIHNtYWxsIGVub3VnaCBwaWVjZXMuIFdlIGVycm9yIG9uIHRoZSBzaWRlIG9mIGxvdyBlbmQuXG4vLyBXZSBiYXNlIHRoaXMgb24gbG93IGVuZCAzRyBzcGVlZHMgd2hpY2ggaXMgYWJvdXQgNTAwa2JpdHMgcGVyIHNlY29uZC4gV2UgYXNzdW1lXG4vLyB0aGF0IHRoZXJlIGNhbiBiZSBhIHJlYXNvbmFibGUgZHJvcCBvZmYgZnJvbSBtYXggYmFuZHdpZHRoIHdoaWNoIGxlYXZlcyB5b3Ugd2l0aFxuLy8gYXMgbGl0dGxlIGFzIDgwJS4gV2UgY2FuIHJlY2VpdmUgaGFsZiBvZiB0aGF0IGVhY2ggNTAwbXMgLSBhdCBiZXN0LiBJbiBwcmFjdGljZSxcbi8vIGEgbGl0dGxlIGJhbmR3aWR0aCBpcyBsb3N0IHRvIHByb2Nlc3NpbmcgYW5kIGNvbnRlbnRpb24gLSBlLmcuIENTUyBhbmQgaW1hZ2VzIHRoYXRcbi8vIGFyZSBkb3dubG9hZGVkIGFsb25nIHdpdGggdGhlIG1haW4gY29udGVudC4gU28gd2UgZXN0aW1hdGUgYWJvdXQgaGFsZiBvZiB0aGF0IHRvIGJlXG4vLyB0aGUgbG93ZXIgZW5kIHRocm91Z2hwdXQuIEluIG90aGVyIHdvcmRzLCB3ZSBleHBlY3QgdGhhdCB5b3UgY2FuIGF0IGxlYXN0IHNob3dcbi8vIGFib3V0IDEyLjVrYiBvZiBjb250ZW50IHBlciA1MDBtcy4gTm90IGNvdW50aW5nIHN0YXJ0aW5nIGxhdGVuY3kgZm9yIHRoZSBmaXJzdFxuLy8gcGFpbnQuXG4vLyA1MDAgKiAxMDI0IC8gOCAqIC44ICogMC41IC8gMlxudmFyIERFRkFVTFRfUFJPR1JFU1NJVkVfQ0hVTktfU0laRSA9IDEyODAwO1xuXG5mdW5jdGlvbiBkZWZhdWx0RXJyb3JIYW5kbGVyKGVycm9yKSB7XG4gIGNvbnNvbGVbJ2Vycm9yJ10oZXJyb3IpOyAvLyBEb24ndCB0cmFuc2Zvcm0gdG8gb3VyIHdyYXBwZXJcblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gbm9vcCQxKCkge31cblxuZnVuY3Rpb24gY3JlYXRlUmVxdWVzdChjaGlsZHJlbiwgcmVzcG9uc2VTdGF0ZSwgcm9vdEZvcm1hdENvbnRleHQsIHByb2dyZXNzaXZlQ2h1bmtTaXplLCBvbkVycm9yLCBvbkFsbFJlYWR5LCBvblNoZWxsUmVhZHksIG9uU2hlbGxFcnJvciwgb25GYXRhbEVycm9yKSB7XG4gIHZhciBwaW5nZWRUYXNrcyA9IFtdO1xuICB2YXIgYWJvcnRTZXQgPSBuZXcgU2V0KCk7XG4gIHZhciByZXF1ZXN0ID0ge1xuICAgIGRlc3RpbmF0aW9uOiBudWxsLFxuICAgIHJlc3BvbnNlU3RhdGU6IHJlc3BvbnNlU3RhdGUsXG4gICAgcHJvZ3Jlc3NpdmVDaHVua1NpemU6IHByb2dyZXNzaXZlQ2h1bmtTaXplID09PSB1bmRlZmluZWQgPyBERUZBVUxUX1BST0dSRVNTSVZFX0NIVU5LX1NJWkUgOiBwcm9ncmVzc2l2ZUNodW5rU2l6ZSxcbiAgICBzdGF0dXM6IE9QRU4sXG4gICAgZmF0YWxFcnJvcjogbnVsbCxcbiAgICBuZXh0U2VnbWVudElkOiAwLFxuICAgIGFsbFBlbmRpbmdUYXNrczogMCxcbiAgICBwZW5kaW5nUm9vdFRhc2tzOiAwLFxuICAgIGNvbXBsZXRlZFJvb3RTZWdtZW50OiBudWxsLFxuICAgIGFib3J0YWJsZVRhc2tzOiBhYm9ydFNldCxcbiAgICBwaW5nZWRUYXNrczogcGluZ2VkVGFza3MsXG4gICAgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzOiBbXSxcbiAgICBjb21wbGV0ZWRCb3VuZGFyaWVzOiBbXSxcbiAgICBwYXJ0aWFsQm91bmRhcmllczogW10sXG4gICAgb25FcnJvcjogb25FcnJvciA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdEVycm9ySGFuZGxlciA6IG9uRXJyb3IsXG4gICAgb25BbGxSZWFkeTogb25BbGxSZWFkeSA9PT0gdW5kZWZpbmVkID8gbm9vcCQxIDogb25BbGxSZWFkeSxcbiAgICBvblNoZWxsUmVhZHk6IG9uU2hlbGxSZWFkeSA9PT0gdW5kZWZpbmVkID8gbm9vcCQxIDogb25TaGVsbFJlYWR5LFxuICAgIG9uU2hlbGxFcnJvcjogb25TaGVsbEVycm9yID09PSB1bmRlZmluZWQgPyBub29wJDEgOiBvblNoZWxsRXJyb3IsXG4gICAgb25GYXRhbEVycm9yOiBvbkZhdGFsRXJyb3IgPT09IHVuZGVmaW5lZCA/IG5vb3AkMSA6IG9uRmF0YWxFcnJvclxuICB9OyAvLyBUaGlzIHNlZ21lbnQgcmVwcmVzZW50cyB0aGUgcm9vdCBmYWxsYmFjay5cblxuICB2YXIgcm9vdFNlZ21lbnQgPSBjcmVhdGVQZW5kaW5nU2VnbWVudChyZXF1ZXN0LCAwLCBudWxsLCByb290Rm9ybWF0Q29udGV4dCwgLy8gUm9vdCBzZWdtZW50cyBhcmUgbmV2ZXIgZW1iZWRkZWQgaW4gVGV4dCBvbiBlaXRoZXIgZWRnZVxuICBmYWxzZSwgZmFsc2UpOyAvLyBUaGVyZSBpcyBubyBwYXJlbnQgc28gY29uY2VwdHVhbGx5LCB3ZSdyZSB1bmJsb2NrZWQgdG8gZmx1c2ggdGhpcyBzZWdtZW50LlxuXG4gIHJvb3RTZWdtZW50LnBhcmVudEZsdXNoZWQgPSB0cnVlO1xuICB2YXIgcm9vdFRhc2sgPSBjcmVhdGVUYXNrKHJlcXVlc3QsIGNoaWxkcmVuLCBudWxsLCByb290U2VnbWVudCwgYWJvcnRTZXQsIGVtcHR5Q29udGV4dE9iamVjdCwgcm9vdENvbnRleHRTbmFwc2hvdCwgZW1wdHlUcmVlQ29udGV4dCk7XG4gIHBpbmdlZFRhc2tzLnB1c2gocm9vdFRhc2spO1xuICByZXR1cm4gcmVxdWVzdDtcbn1cblxuZnVuY3Rpb24gcGluZ1Rhc2socmVxdWVzdCwgdGFzaykge1xuICB2YXIgcGluZ2VkVGFza3MgPSByZXF1ZXN0LnBpbmdlZFRhc2tzO1xuICBwaW5nZWRUYXNrcy5wdXNoKHRhc2spO1xuXG4gIGlmIChwaW5nZWRUYXNrcy5sZW5ndGggPT09IDEpIHtcbiAgICBzY2hlZHVsZVdvcmsoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHBlcmZvcm1Xb3JrKHJlcXVlc3QpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkocmVxdWVzdCwgZmFsbGJhY2tBYm9ydGFibGVUYXNrcykge1xuICByZXR1cm4ge1xuICAgIGlkOiBVTklOSVRJQUxJWkVEX1NVU1BFTlNFX0JPVU5EQVJZX0lELFxuICAgIHJvb3RTZWdtZW50SUQ6IC0xLFxuICAgIHBhcmVudEZsdXNoZWQ6IGZhbHNlLFxuICAgIHBlbmRpbmdUYXNrczogMCxcbiAgICBmb3JjZUNsaWVudFJlbmRlcjogZmFsc2UsXG4gICAgY29tcGxldGVkU2VnbWVudHM6IFtdLFxuICAgIGJ5dGVTaXplOiAwLFxuICAgIGZhbGxiYWNrQWJvcnRhYmxlVGFza3M6IGZhbGxiYWNrQWJvcnRhYmxlVGFza3MsXG4gICAgZXJyb3JEaWdlc3Q6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGFzayhyZXF1ZXN0LCBub2RlLCBibG9ja2VkQm91bmRhcnksIGJsb2NrZWRTZWdtZW50LCBhYm9ydFNldCwgbGVnYWN5Q29udGV4dCwgY29udGV4dCwgdHJlZUNvbnRleHQpIHtcbiAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MrKztcblxuICBpZiAoYmxvY2tlZEJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzKys7XG4gIH0gZWxzZSB7XG4gICAgYmxvY2tlZEJvdW5kYXJ5LnBlbmRpbmdUYXNrcysrO1xuICB9XG5cbiAgdmFyIHRhc2sgPSB7XG4gICAgbm9kZTogbm9kZSxcbiAgICBwaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGluZ1Rhc2socmVxdWVzdCwgdGFzayk7XG4gICAgfSxcbiAgICBibG9ja2VkQm91bmRhcnk6IGJsb2NrZWRCb3VuZGFyeSxcbiAgICBibG9ja2VkU2VnbWVudDogYmxvY2tlZFNlZ21lbnQsXG4gICAgYWJvcnRTZXQ6IGFib3J0U2V0LFxuICAgIGxlZ2FjeUNvbnRleHQ6IGxlZ2FjeUNvbnRleHQsXG4gICAgY29udGV4dDogY29udGV4dCxcbiAgICB0cmVlQ29udGV4dDogdHJlZUNvbnRleHRcbiAgfTtcblxuICB7XG4gICAgdGFzay5jb21wb25lbnRTdGFjayA9IG51bGw7XG4gIH1cblxuICBhYm9ydFNldC5hZGQodGFzayk7XG4gIHJldHVybiB0YXNrO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQZW5kaW5nU2VnbWVudChyZXF1ZXN0LCBpbmRleCwgYm91bmRhcnksIGZvcm1hdENvbnRleHQsIGxhc3RQdXNoZWRUZXh0LCB0ZXh0RW1iZWRkZWQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXM6IFBFTkRJTkcsXG4gICAgaWQ6IC0xLFxuICAgIC8vIGxhemlseSBhc3NpZ25lZCBsYXRlclxuICAgIGluZGV4OiBpbmRleCxcbiAgICBwYXJlbnRGbHVzaGVkOiBmYWxzZSxcbiAgICBjaHVua3M6IFtdLFxuICAgIGNoaWxkcmVuOiBbXSxcbiAgICBmb3JtYXRDb250ZXh0OiBmb3JtYXRDb250ZXh0LFxuICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICBsYXN0UHVzaGVkVGV4dDogbGFzdFB1c2hlZFRleHQsXG4gICAgdGV4dEVtYmVkZGVkOiB0ZXh0RW1iZWRkZWRcbiAgfTtcbn0gLy8gREVWLW9ubHkgZ2xvYmFsIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyB0YXNrXG5cblxudmFyIGN1cnJlbnRUYXNrSW5ERVYgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50U3RhY2tJbkRFVigpIHtcbiAge1xuICAgIGlmIChjdXJyZW50VGFza0luREVWID09PSBudWxsIHx8IGN1cnJlbnRUYXNrSW5ERVYuY29tcG9uZW50U3RhY2sgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0U3RhY2tCeUNvbXBvbmVudFN0YWNrTm9kZShjdXJyZW50VGFza0luREVWLmNvbXBvbmVudFN0YWNrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoQnVpbHRJbkNvbXBvbmVudFN0YWNrSW5ERVYodGFzaywgdHlwZSkge1xuICB7XG4gICAgdGFzay5jb21wb25lbnRTdGFjayA9IHtcbiAgICAgIHRhZzogMCxcbiAgICAgIHBhcmVudDogdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgIHR5cGU6IHR5cGVcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hGdW5jdGlvbkNvbXBvbmVudFN0YWNrSW5ERVYodGFzaywgdHlwZSkge1xuICB7XG4gICAgdGFzay5jb21wb25lbnRTdGFjayA9IHtcbiAgICAgIHRhZzogMSxcbiAgICAgIHBhcmVudDogdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgIHR5cGU6IHR5cGVcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hDbGFzc0NvbXBvbmVudFN0YWNrSW5ERVYodGFzaywgdHlwZSkge1xuICB7XG4gICAgdGFzay5jb21wb25lbnRTdGFjayA9IHtcbiAgICAgIHRhZzogMixcbiAgICAgIHBhcmVudDogdGFzay5jb21wb25lbnRTdGFjayxcbiAgICAgIHR5cGU6IHR5cGVcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvcENvbXBvbmVudFN0YWNrSW5ERVYodGFzaykge1xuICB7XG4gICAgaWYgKHRhc2suY29tcG9uZW50U3RhY2sgPT09IG51bGwpIHtcbiAgICAgIGVycm9yKCdVbmV4cGVjdGVkbHkgcG9wcGVkIHRvbyBtYW55IHN0YWNrIGZyYW1lcy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHRhc2suY29tcG9uZW50U3RhY2sucGFyZW50O1xuICAgIH1cbiAgfVxufSAvLyBzdGFzaCB0aGUgY29tcG9uZW50IHN0YWNrIG9mIGFuIHVud2luZGluZyBlcnJvciB1bnRpbCBpdCBpcyBwcm9jZXNzZWRcblxuXG52YXIgbGFzdEJvdW5kYXJ5RXJyb3JDb21wb25lbnRTdGFja0RldiA9IG51bGw7XG5cbmZ1bmN0aW9uIGNhcHR1cmVCb3VuZGFyeUVycm9yRGV0YWlsc0Rldihib3VuZGFyeSwgZXJyb3IpIHtcbiAge1xuICAgIHZhciBlcnJvck1lc3NhZ2U7XG5cbiAgICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3I7XG4gICAgfSBlbHNlIGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgICAgZXJyb3JNZXNzYWdlID0gU3RyaW5nKGVycm9yKTtcbiAgICB9XG5cbiAgICB2YXIgZXJyb3JDb21wb25lbnRTdGFjayA9IGxhc3RCb3VuZGFyeUVycm9yQ29tcG9uZW50U3RhY2tEZXYgfHwgZ2V0Q3VycmVudFN0YWNrSW5ERVYoKTtcbiAgICBsYXN0Qm91bmRhcnlFcnJvckNvbXBvbmVudFN0YWNrRGV2ID0gbnVsbDtcbiAgICBib3VuZGFyeS5lcnJvck1lc3NhZ2UgPSBlcnJvck1lc3NhZ2U7XG4gICAgYm91bmRhcnkuZXJyb3JDb21wb25lbnRTdGFjayA9IGVycm9yQ29tcG9uZW50U3RhY2s7XG4gIH1cbn1cblxuZnVuY3Rpb24gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvcikge1xuICAvLyBJZiB0aGlzIGNhbGxiYWNrIGVycm9ycywgd2UgaW50ZW50aW9uYWxseSBsZXQgdGhhdCBlcnJvciBidWJibGUgdXAgdG8gYmVjb21lIGEgZmF0YWwgZXJyb3JcbiAgLy8gc28gdGhhdCBzb21lb25lIGZpeGVzIHRoZSBlcnJvciByZXBvcnRpbmcgaW5zdGVhZCBvZiBoaWRpbmcgaXQuXG4gIHZhciBlcnJvckRpZ2VzdCA9IHJlcXVlc3Qub25FcnJvcihlcnJvcik7XG5cbiAgaWYgKGVycm9yRGlnZXN0ICE9IG51bGwgJiYgdHlwZW9mIGVycm9yRGlnZXN0ICE9PSAnc3RyaW5nJykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgdGhyb3cgbmV3IEVycm9yKFwib25FcnJvciByZXR1cm5lZCBzb21ldGhpbmcgd2l0aCBhIHR5cGUgb3RoZXIgdGhhbiBcXFwic3RyaW5nXFxcIi4gb25FcnJvciBzaG91bGQgcmV0dXJuIGEgc3RyaW5nIGFuZCBtYXkgcmV0dXJuIG51bGwgb3IgdW5kZWZpbmVkIGJ1dCBtdXN0IG5vdCByZXR1cm4gYW55dGhpbmcgZWxzZS4gSXQgcmVjZWl2ZWQgc29tZXRoaW5nIG9mIHR5cGUgXFxcIlwiICsgdHlwZW9mIGVycm9yRGlnZXN0ICsgXCJcXFwiIGluc3RlYWRcIik7XG4gIH1cblxuICByZXR1cm4gZXJyb3JEaWdlc3Q7XG59XG5cbmZ1bmN0aW9uIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IpIHtcbiAgLy8gVGhpcyBpcyBjYWxsZWQgb3V0c2lkZSBlcnJvciBoYW5kbGluZyBjb2RlIHN1Y2ggYXMgaWYgdGhlIHJvb3QgZXJyb3JzIG91dHNpZGVcbiAgLy8gYSBzdXNwZW5zZSBib3VuZGFyeSBvciBpZiB0aGUgcm9vdCBzdXNwZW5zZSBib3VuZGFyeSdzIGZhbGxiYWNrIGVycm9ycy5cbiAgLy8gSXQncyBhbHNvIGNhbGxlZCBpZiBSZWFjdCBpdHNlbGYgb3IgaXRzIGhvc3QgY29uZmlncyBlcnJvcnMuXG4gIHZhciBvblNoZWxsRXJyb3IgPSByZXF1ZXN0Lm9uU2hlbGxFcnJvcjtcbiAgb25TaGVsbEVycm9yKGVycm9yKTtcbiAgdmFyIG9uRmF0YWxFcnJvciA9IHJlcXVlc3Qub25GYXRhbEVycm9yO1xuICBvbkZhdGFsRXJyb3IoZXJyb3IpO1xuXG4gIGlmIChyZXF1ZXN0LmRlc3RpbmF0aW9uICE9PSBudWxsKSB7XG4gICAgcmVxdWVzdC5zdGF0dXMgPSBDTE9TRUQ7XG4gICAgY2xvc2VXaXRoRXJyb3IocmVxdWVzdC5kZXN0aW5hdGlvbiwgZXJyb3IpO1xuICB9IGVsc2Uge1xuICAgIHJlcXVlc3Quc3RhdHVzID0gQ0xPU0lORztcbiAgICByZXF1ZXN0LmZhdGFsRXJyb3IgPSBlcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJTdXNwZW5zZUJvdW5kYXJ5KHJlcXVlc3QsIHRhc2ssIHByb3BzKSB7XG4gIHB1c2hCdWlsdEluQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrLCAnU3VzcGVuc2UnKTtcbiAgdmFyIHBhcmVudEJvdW5kYXJ5ID0gdGFzay5ibG9ja2VkQm91bmRhcnk7XG4gIHZhciBwYXJlbnRTZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDsgLy8gRWFjaCB0aW1lIHdlIGVudGVyIGEgc3VzcGVuc2UgYm91bmRhcnksIHdlIHNwbGl0IG91dCBpbnRvIGEgbmV3IHNlZ21lbnQgZm9yXG4gIC8vIHRoZSBmYWxsYmFjayBzbyB0aGF0IHdlIGNhbiBsYXRlciByZXBsYWNlIHRoYXQgc2VnbWVudCB3aXRoIHRoZSBjb250ZW50LlxuICAvLyBUaGlzIGFsc28gbGV0cyB1cyBzcGxpdCBvdXQgdGhlIG1haW4gY29udGVudCBldmVuIGlmIGl0IGRvZXNuJ3Qgc3VzcGVuZCxcbiAgLy8gaW4gY2FzZSBpdCBlbmRzIHVwIGdlbmVyYXRpbmcgYSBsYXJnZSBzdWJ0cmVlIG9mIGNvbnRlbnQuXG5cbiAgdmFyIGZhbGxiYWNrID0gcHJvcHMuZmFsbGJhY2s7XG4gIHZhciBjb250ZW50ID0gcHJvcHMuY2hpbGRyZW47XG4gIHZhciBmYWxsYmFja0Fib3J0U2V0ID0gbmV3IFNldCgpO1xuICB2YXIgbmV3Qm91bmRhcnkgPSBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5KHJlcXVlc3QsIGZhbGxiYWNrQWJvcnRTZXQpO1xuICB2YXIgaW5zZXJ0aW9uSW5kZXggPSBwYXJlbnRTZWdtZW50LmNodW5rcy5sZW5ndGg7IC8vIFRoZSBjaGlsZHJlbiBvZiB0aGUgYm91bmRhcnkgc2VnbWVudCBpcyBhY3R1YWxseSB0aGUgZmFsbGJhY2suXG5cbiAgdmFyIGJvdW5kYXJ5U2VnbWVudCA9IGNyZWF0ZVBlbmRpbmdTZWdtZW50KHJlcXVlc3QsIGluc2VydGlvbkluZGV4LCBuZXdCb3VuZGFyeSwgcGFyZW50U2VnbWVudC5mb3JtYXRDb250ZXh0LCAvLyBib3VuZGFyaWVzIG5ldmVyIHJlcXVpcmUgdGV4dCBlbWJlZGRpbmcgYXQgdGhlaXIgZWRnZXMgYmVjYXVzZSBjb21tZW50IG5vZGVzIGJvdW5kIHRoZW1cbiAgZmFsc2UsIGZhbHNlKTtcbiAgcGFyZW50U2VnbWVudC5jaGlsZHJlbi5wdXNoKGJvdW5kYXJ5U2VnbWVudCk7IC8vIFRoZSBwYXJlbnRTZWdtZW50IGhhcyBhIGNoaWxkIFNlZ21lbnQgYXQgdGhpcyBpbmRleCBzbyB3ZSByZXNldCB0aGUgbGFzdFB1c2hlZFRleHQgbWFya2VyIG9uIHRoZSBwYXJlbnRcblxuICBwYXJlbnRTZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gZmFsc2U7IC8vIFRoaXMgc2VnbWVudCBpcyB0aGUgYWN0dWFsIGNoaWxkIGNvbnRlbnQuIFdlIGNhbiBzdGFydCByZW5kZXJpbmcgdGhhdCBpbW1lZGlhdGVseS5cblxuICB2YXIgY29udGVudFJvb3RTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQocmVxdWVzdCwgMCwgbnVsbCwgcGFyZW50U2VnbWVudC5mb3JtYXRDb250ZXh0LCAvLyBib3VuZGFyaWVzIG5ldmVyIHJlcXVpcmUgdGV4dCBlbWJlZGRpbmcgYXQgdGhlaXIgZWRnZXMgYmVjYXVzZSBjb21tZW50IG5vZGVzIGJvdW5kIHRoZW1cbiAgZmFsc2UsIGZhbHNlKTsgLy8gV2UgbWFyayB0aGUgcm9vdCBzZWdtZW50IGFzIGhhdmluZyBpdHMgcGFyZW50IGZsdXNoZWQuIEl0J3Mgbm90IHJlYWxseSBmbHVzaGVkIGJ1dCB0aGVyZSBpc1xuICAvLyBubyBwYXJlbnQgc2VnbWVudCBzbyB0aGVyZSdzIG5vdGhpbmcgdG8gd2FpdCBvbi5cblxuICBjb250ZW50Um9vdFNlZ21lbnQucGFyZW50Rmx1c2hlZCA9IHRydWU7IC8vIEN1cnJlbnRseSB0aGlzIGlzIHJ1bm5pbmcgc3luY2hyb25vdXNseS4gV2UgY291bGQgaW5zdGVhZCBzY2hlZHVsZSB0aGlzIHRvIHBpbmdlZFRhc2tzLlxuICAvLyBJIHN1c3BlY3QgdGhhdCB0aGVyZSBtaWdodCBiZSBzb21lIGVmZmljaWVuY3kgYmVuZWZpdHMgZnJvbSBub3QgY3JlYXRpbmcgdGhlIHN1c3BlbmRlZCB0YXNrXG4gIC8vIGFuZCBpbnN0ZWFkIGp1c3QgdXNpbmcgdGhlIHN0YWNrIGlmIHBvc3NpYmxlLlxuICAvLyBUT0RPOiBDYWxsIHRoaXMgZGlyZWN0bHkgaW5zdGVhZCBvZiBtZXNzaW5nIHdpdGggc2F2aW5nIGFuZCByZXN0b3JpbmcgY29udGV4dHMuXG4gIC8vIFdlIGNhbiByZXVzZSB0aGUgY3VycmVudCBjb250ZXh0IGFuZCB0YXNrIHRvIHJlbmRlciB0aGUgY29udGVudCBpbW1lZGlhdGVseSB3aXRob3V0XG4gIC8vIGNvbnRleHQgc3dpdGNoaW5nLiBXZSBqdXN0IG5lZWQgdG8gdGVtcG9yYXJpbHkgc3dpdGNoIHdoaWNoIGJvdW5kYXJ5IGFuZCB3aGljaCBzZWdtZW50XG4gIC8vIHdlJ3JlIHdyaXRpbmcgdG8uIElmIHNvbWV0aGluZyBzdXNwZW5kcywgaXQnbGwgc3Bhd24gbmV3IHN1c3BlbmRlZCB0YXNrIHdpdGggdGhhdCBjb250ZXh0LlxuXG4gIHRhc2suYmxvY2tlZEJvdW5kYXJ5ID0gbmV3Qm91bmRhcnk7XG4gIHRhc2suYmxvY2tlZFNlZ21lbnQgPSBjb250ZW50Um9vdFNlZ21lbnQ7XG5cbiAgdHJ5IHtcbiAgICAvLyBXZSB1c2UgdGhlIHNhZmUgZm9ybSBiZWNhdXNlIHdlIGRvbid0IGhhbmRsZSBzdXNwZW5kaW5nIGhlcmUuIE9ubHkgZXJyb3IgaGFuZGxpbmcuXG4gICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjb250ZW50KTtcbiAgICBwdXNoU2VnbWVudEZpbmFsZSQxKGNvbnRlbnRSb290U2VnbWVudC5jaHVua3MsIHJlcXVlc3QucmVzcG9uc2VTdGF0ZSwgY29udGVudFJvb3RTZWdtZW50Lmxhc3RQdXNoZWRUZXh0LCBjb250ZW50Um9vdFNlZ21lbnQudGV4dEVtYmVkZGVkKTtcbiAgICBjb250ZW50Um9vdFNlZ21lbnQuc3RhdHVzID0gQ09NUExFVEVEO1xuICAgIHF1ZXVlQ29tcGxldGVkU2VnbWVudChuZXdCb3VuZGFyeSwgY29udGVudFJvb3RTZWdtZW50KTtcblxuICAgIGlmIChuZXdCb3VuZGFyeS5wZW5kaW5nVGFza3MgPT09IDApIHtcbiAgICAgIC8vIFRoaXMgbXVzdCBoYXZlIGJlZW4gdGhlIGxhc3Qgc2VnbWVudCB3ZSB3ZXJlIHdhaXRpbmcgb24uIFRoaXMgYm91bmRhcnkgaXMgbm93IGNvbXBsZXRlLlxuICAgICAgLy8gVGhlcmVmb3JlIHdlIHdvbid0IG5lZWQgdGhlIGZhbGxiYWNrLiBXZSBlYXJseSByZXR1cm4gc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGNyZWF0ZVxuICAgICAgLy8gdGhlIGZhbGxiYWNrLlxuICAgICAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29udGVudFJvb3RTZWdtZW50LnN0YXR1cyA9IEVSUk9SRUQ7XG4gICAgbmV3Qm91bmRhcnkuZm9yY2VDbGllbnRSZW5kZXIgPSB0cnVlO1xuICAgIG5ld0JvdW5kYXJ5LmVycm9yRGlnZXN0ID0gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG5cbiAgICB7XG4gICAgICBjYXB0dXJlQm91bmRhcnlFcnJvckRldGFpbHNEZXYobmV3Qm91bmRhcnksIGVycm9yKTtcbiAgICB9IC8vIFdlIGRvbid0IG5lZWQgdG8gZGVjcmVtZW50IGFueSB0YXNrIG51bWJlcnMgYmVjYXVzZSB3ZSBkaWRuJ3Qgc3Bhd24gYW55IG5ldyB0YXNrLlxuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gc2NoZWR1bGUgYW55IHRhc2sgYmVjYXVzZSB3ZSBrbm93IHRoZSBwYXJlbnQgaGFzIHdyaXR0ZW4geWV0LlxuICAgIC8vIFdlIGRvIG5lZWQgdG8gZmFsbHRocm91Z2ggdG8gY3JlYXRlIHRoZSBmYWxsYmFjayB0aG91Z2guXG5cbiAgfSBmaW5hbGx5IHtcbiAgICB0YXNrLmJsb2NrZWRCb3VuZGFyeSA9IHBhcmVudEJvdW5kYXJ5O1xuICAgIHRhc2suYmxvY2tlZFNlZ21lbnQgPSBwYXJlbnRTZWdtZW50O1xuICB9IC8vIFdlIGNyZWF0ZSBzdXNwZW5kZWQgdGFzayBmb3IgdGhlIGZhbGxiYWNrIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBhY3R1YWxseSB3b3JrXG4gIC8vIG9uIGl0IHlldCBpbiBjYXNlIHdlIGZpbmlzaCB0aGUgbWFpbiBjb250ZW50LCBzbyB3ZSBxdWV1ZSBmb3IgbGF0ZXIuXG5cblxuICB2YXIgc3VzcGVuZGVkRmFsbGJhY2tUYXNrID0gY3JlYXRlVGFzayhyZXF1ZXN0LCBmYWxsYmFjaywgcGFyZW50Qm91bmRhcnksIGJvdW5kYXJ5U2VnbWVudCwgZmFsbGJhY2tBYm9ydFNldCwgdGFzay5sZWdhY3lDb250ZXh0LCB0YXNrLmNvbnRleHQsIHRhc2sudHJlZUNvbnRleHQpO1xuXG4gIHtcbiAgICBzdXNwZW5kZWRGYWxsYmFja1Rhc2suY29tcG9uZW50U3RhY2sgPSB0YXNrLmNvbXBvbmVudFN0YWNrO1xuICB9IC8vIFRPRE86IFRoaXMgc2hvdWxkIGJlIHF1ZXVlZCBhdCBhIHNlcGFyYXRlIGxvd2VyIHByaW9yaXR5IHF1ZXVlIHNvIHRoYXQgd2Ugb25seSB3b3JrXG4gIC8vIG9uIHByZXBhcmluZyBmYWxsYmFja3MgaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBtYWluIGNvbnRlbnQgdG8gdGFzayBvbi5cblxuXG4gIHJlcXVlc3QucGluZ2VkVGFza3MucHVzaChzdXNwZW5kZWRGYWxsYmFja1Rhc2spO1xuICBwb3BDb21wb25lbnRTdGFja0luREVWKHRhc2spO1xufVxuXG5mdW5jdGlvbiByZW5kZXJIb3N0RWxlbWVudChyZXF1ZXN0LCB0YXNrLCB0eXBlLCBwcm9wcykge1xuICBwdXNoQnVpbHRJbkNvbXBvbmVudFN0YWNrSW5ERVYodGFzaywgdHlwZSk7XG4gIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgdmFyIGNoaWxkcmVuID0gcHVzaFN0YXJ0SW5zdGFuY2Uoc2VnbWVudC5jaHVua3MsIHR5cGUsIHByb3BzLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUsIHNlZ21lbnQuZm9ybWF0Q29udGV4dCk7XG4gIHNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSBmYWxzZTtcbiAgdmFyIHByZXZDb250ZXh0ID0gc2VnbWVudC5mb3JtYXRDb250ZXh0O1xuICBzZWdtZW50LmZvcm1hdENvbnRleHQgPSBnZXRDaGlsZEZvcm1hdENvbnRleHQocHJldkNvbnRleHQsIHR5cGUsIHByb3BzKTsgLy8gV2UgdXNlIHRoZSBub24tZGVzdHJ1Y3RpdmUgZm9ybSBiZWNhdXNlIGlmIHNvbWV0aGluZyBzdXNwZW5kcywgd2Ugc3RpbGxcbiAgLy8gbmVlZCB0byBwb3AgYmFjayB1cCBhbmQgZmluaXNoIHRoaXMgc3VidHJlZSBvZiBIVE1MLlxuXG4gIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgY2hpbGRyZW4pOyAvLyBXZSBleHBlY3QgdGhhdCBlcnJvcnMgd2lsbCBmYXRhbCB0aGUgd2hvbGUgdGFzayBhbmQgdGhhdCB3ZSBkb24ndCBuZWVkXG4gIC8vIHRoZSBjb3JyZWN0IGNvbnRleHQuIFRoZXJlZm9yZSB0aGlzIGlzIG5vdCBpbiBhIGZpbmFsbHkuXG5cbiAgc2VnbWVudC5mb3JtYXRDb250ZXh0ID0gcHJldkNvbnRleHQ7XG4gIHB1c2hFbmRJbnN0YW5jZShzZWdtZW50LmNodW5rcywgdHlwZSk7XG4gIHNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSBmYWxzZTtcbiAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0JDEoQ29tcG9uZW50KSB7XG4gIHJldHVybiBDb21wb25lbnQucHJvdG90eXBlICYmIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudDtcbn1cblxuZnVuY3Rpb24gcmVuZGVyV2l0aEhvb2tzKHJlcXVlc3QsIHRhc2ssIENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZykge1xuICB2YXIgY29tcG9uZW50SWRlbnRpdHkgPSB7fTtcbiAgcHJlcGFyZVRvVXNlSG9va3ModGFzaywgY29tcG9uZW50SWRlbnRpdHkpO1xuICB2YXIgcmVzdWx0ID0gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpO1xuICByZXR1cm4gZmluaXNoSG9va3MoQ29tcG9uZW50LCBwcm9wcywgcmVzdWx0LCBzZWNvbmRBcmcpO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hDbGFzc0NvbXBvbmVudChyZXF1ZXN0LCB0YXNrLCBpbnN0YW5jZSwgQ29tcG9uZW50LCBwcm9wcykge1xuICB2YXIgbmV4dENoaWxkcmVuID0gaW5zdGFuY2UucmVuZGVyKCk7XG5cbiAge1xuICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gcHJvcHMpIHtcbiAgICAgIGlmICghZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcykge1xuICAgICAgICBlcnJvcignSXQgbG9va3MgbGlrZSAlcyBpcyByZWFzc2lnbmluZyBpdHMgb3duIGB0aGlzLnByb3BzYCB3aGlsZSByZW5kZXJpbmcuICcgKyAnVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCBjYW4gbGVhZCB0byBjb25mdXNpbmcgYnVncy4nLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnYSBjb21wb25lbnQnKTtcbiAgICAgIH1cblxuICAgICAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcztcblxuICAgIGlmIChjaGlsZENvbnRleHRUeXBlcyAhPT0gbnVsbCAmJiBjaGlsZENvbnRleHRUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcHJldmlvdXNDb250ZXh0ID0gdGFzay5sZWdhY3lDb250ZXh0O1xuICAgICAgdmFyIG1lcmdlZENvbnRleHQgPSBwcm9jZXNzQ2hpbGRDb250ZXh0KGluc3RhbmNlLCBDb21wb25lbnQsIHByZXZpb3VzQ29udGV4dCwgY2hpbGRDb250ZXh0VHlwZXMpO1xuICAgICAgdGFzay5sZWdhY3lDb250ZXh0ID0gbWVyZ2VkQ29udGV4dDtcbiAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgdGFzay5sZWdhY3lDb250ZXh0ID0gcHJldmlvdXNDb250ZXh0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBuZXh0Q2hpbGRyZW4pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJDbGFzc0NvbXBvbmVudChyZXF1ZXN0LCB0YXNrLCBDb21wb25lbnQsIHByb3BzKSB7XG4gIHB1c2hDbGFzc0NvbXBvbmVudFN0YWNrSW5ERVYodGFzaywgQ29tcG9uZW50KTtcbiAgdmFyIG1hc2tlZENvbnRleHQgPSAgZ2V0TWFza2VkQ29udGV4dChDb21wb25lbnQsIHRhc2subGVnYWN5Q29udGV4dCkgO1xuICB2YXIgaW5zdGFuY2UgPSBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKENvbXBvbmVudCwgcHJvcHMsIG1hc2tlZENvbnRleHQpO1xuICBtb3VudENsYXNzSW5zdGFuY2UoaW5zdGFuY2UsIENvbXBvbmVudCwgcHJvcHMsIG1hc2tlZENvbnRleHQpO1xuICBmaW5pc2hDbGFzc0NvbXBvbmVudChyZXF1ZXN0LCB0YXNrLCBpbnN0YW5jZSwgQ29tcG9uZW50LCBwcm9wcyk7XG4gIHBvcENvbXBvbmVudFN0YWNrSW5ERVYodGFzayk7XG59XG5cbnZhciBkaWRXYXJuQWJvdXRCYWRDbGFzcyA9IHt9O1xudmFyIGRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnQgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG52YXIgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9IGZhbHNlO1xudmFyIGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgPSBmYWxzZTtcbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG52YXIgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyID0gZmFsc2U7IC8vIFRoaXMgd291bGQgdHlwaWNhbGx5IGJlIGEgZnVuY3Rpb24gY29tcG9uZW50IGJ1dCB3ZSBzdGlsbCBzdXBwb3J0IG1vZHVsZSBwYXR0ZXJuXG4vLyBjb21wb25lbnRzIGZvciBzb21lIHJlYXNvbi5cblxuZnVuY3Rpb24gcmVuZGVySW5kZXRlcm1pbmF0ZUNvbXBvbmVudChyZXF1ZXN0LCB0YXNrLCBDb21wb25lbnQsIHByb3BzKSB7XG4gIHZhciBsZWdhY3lDb250ZXh0O1xuXG4gIHtcbiAgICBsZWdhY3lDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dChDb21wb25lbnQsIHRhc2subGVnYWN5Q29udGV4dCk7XG4gIH1cblxuICBwdXNoRnVuY3Rpb25Db21wb25lbnRTdGFja0luREVWKHRhc2ssIENvbXBvbmVudCk7XG5cbiAge1xuICAgIGlmIChDb21wb25lbnQucHJvdG90eXBlICYmIHR5cGVvZiBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB2YWx1ZSA9IHJlbmRlcldpdGhIb29rcyhyZXF1ZXN0LCB0YXNrLCBDb21wb25lbnQsIHByb3BzLCBsZWdhY3lDb250ZXh0KTtcbiAgdmFyIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcblxuICB7XG4gICAgLy8gU3VwcG9ydCBmb3IgbW9kdWxlIGNvbXBvbmVudHMgaXMgZGVwcmVjYXRlZCBhbmQgaXMgcmVtb3ZlZCBiZWhpbmQgYSBmbGFnLlxuICAgIC8vIFdoZXRoZXIgb3Igbm90IGl0IHdvdWxkIGNyYXNoIGxhdGVyLCB3ZSB3YW50IHRvIHNob3cgYSBnb29kIG1lc3NhZ2UgaW4gREVWIGZpcnN0LlxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZS5yZW5kZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsdWUuJCR0eXBlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnRbX2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGJlIGEgZnVuY3Rpb24gY29tcG9uZW50IHRoYXQgcmV0dXJucyBhIGNsYXNzIGluc3RhbmNlLiAnICsgJ0NoYW5nZSAlcyB0byBhIGNsYXNzIHRoYXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4gJyArIFwiSWYgeW91IGNhbid0IHVzZSBhIGNsYXNzIHRyeSBhc3NpZ25pbmcgdGhlIHByb3RvdHlwZSBvbiB0aGUgZnVuY3Rpb24gYXMgYSB3b3JrYXJvdW5kLiBcIiArIFwiYCVzLnByb3RvdHlwZSA9IFJlYWN0LkNvbXBvbmVudC5wcm90b3R5cGVgLiBEb24ndCB1c2UgYW4gYXJyb3cgZnVuY3Rpb24gc2luY2UgaXQgXCIgKyAnY2Fubm90IGJlIGNhbGxlZCB3aXRoIGBuZXdgIGJ5IFJlYWN0LicsIF9jb21wb25lbnROYW1lLCBfY29tcG9uZW50TmFtZSwgX2NvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnRbX2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIC8vIFJ1biB0aGVzZSBjaGVja3MgaW4gcHJvZHVjdGlvbiBvbmx5IGlmIHRoZSBmbGFnIGlzIG9mZi5cbiAgLy8gRXZlbnR1YWxseSB3ZSdsbCBkZWxldGUgdGhpcyBicmFuY2ggYWx0b2dldGhlci5cbiAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZS4kJHR5cGVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lMiA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lMl0pIHtcbiAgICAgICAgZXJyb3IoJ1RoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2UuICcgKyAnQ2hhbmdlICVzIHRvIGEgY2xhc3MgdGhhdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLiAnICsgXCJJZiB5b3UgY2FuJ3QgdXNlIGEgY2xhc3MgdHJ5IGFzc2lnbmluZyB0aGUgcHJvdG90eXBlIG9uIHRoZSBmdW5jdGlvbiBhcyBhIHdvcmthcm91bmQuIFwiICsgXCJgJXMucHJvdG90eXBlID0gUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZWAuIERvbid0IHVzZSBhbiBhcnJvdyBmdW5jdGlvbiBzaW5jZSBpdCBcIiArICdjYW5ub3QgYmUgY2FsbGVkIHdpdGggYG5ld2AgYnkgUmVhY3QuJywgX2NvbXBvbmVudE5hbWUyLCBfY29tcG9uZW50TmFtZTIsIF9jb21wb25lbnROYW1lMik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtb3VudENsYXNzSW5zdGFuY2UodmFsdWUsIENvbXBvbmVudCwgcHJvcHMsIGxlZ2FjeUNvbnRleHQpO1xuICAgIGZpbmlzaENsYXNzQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIHZhbHVlLCBDb21wb25lbnQsIHByb3BzKTtcbiAgfSBlbHNlIHtcblxuICAgIHtcbiAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldihDb21wb25lbnQpO1xuICAgIH0gLy8gV2UncmUgbm93IHN1Y2Nlc3NmdWxseSBwYXN0IHRoaXMgdGFzaywgYW5kIHdlIGRvbid0IGhhdmUgdG8gcG9wIGJhY2sgdG9cbiAgICAvLyB0aGUgcHJldmlvdXMgdGFzayBldmVyeSBhZ2Fpbiwgc28gd2UgY2FuIHVzZSB0aGUgZGVzdHJ1Y3RpdmUgcmVjdXJzaXZlIGZvcm0uXG5cblxuICAgIGlmIChoYXNJZCkge1xuICAgICAgLy8gVGhpcyBjb21wb25lbnQgbWF0ZXJpYWxpemVkIGFuIGlkLiBXZSB0cmVhdCB0aGlzIGFzIGl0cyBvd24gbGV2ZWwsIHdpdGhcbiAgICAgIC8vIGEgc2luZ2xlIFwiY2hpbGRcIiBzbG90LlxuICAgICAgdmFyIHByZXZUcmVlQ29udGV4dCA9IHRhc2sudHJlZUNvbnRleHQ7XG4gICAgICB2YXIgdG90YWxDaGlsZHJlbiA9IDE7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdGFzay50cmVlQ29udGV4dCA9IHB1c2hUcmVlQ29udGV4dChwcmV2VHJlZUNvbnRleHQsIHRvdGFsQ2hpbGRyZW4sIGluZGV4KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIHZhbHVlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwcmV2VHJlZUNvbnRleHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KENvbXBvbmVudCkge1xuICB7XG4gICAgaWYgKENvbXBvbmVudCkge1xuICAgICAgaWYgKENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcykge1xuICAgICAgICBlcnJvcignJXMoLi4uKTogY2hpbGRDb250ZXh0VHlwZXMgY2Fubm90IGJlIGRlZmluZWQgb24gYSBmdW5jdGlvbiBjb21wb25lbnQuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTMgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTNdKSB7XG4gICAgICAgIGVycm9yKCclczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuJywgX2NvbXBvbmVudE5hbWUzKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM10gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgQ29tcG9uZW50LmNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBDb21wb25lbnQuY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTQgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lNF0pIHtcbiAgICAgICAgZXJyb3IoJyVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGNvbnRleHRUeXBlLicsIF9jb21wb25lbnROYW1lNCk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lNF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgYmFzZVByb3BzKSB7XG4gIGlmIChDb21wb25lbnQgJiYgQ29tcG9uZW50LmRlZmF1bHRQcm9wcykge1xuICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wcy4gVGFrZW4gZnJvbSBSZWFjdEVsZW1lbnRcbiAgICB2YXIgcHJvcHMgPSBhc3NpZ24oe30sIGJhc2VQcm9wcyk7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IENvbXBvbmVudC5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcm9wcztcbiAgfVxuXG4gIHJldHVybiBiYXNlUHJvcHM7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckZvcndhcmRSZWYocmVxdWVzdCwgdGFzaywgdHlwZSwgcHJvcHMsIHJlZikge1xuICBwdXNoRnVuY3Rpb25Db21wb25lbnRTdGFja0luREVWKHRhc2ssIHR5cGUucmVuZGVyKTtcbiAgdmFyIGNoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKHJlcXVlc3QsIHRhc2ssIHR5cGUucmVuZGVyLCBwcm9wcywgcmVmKTtcbiAgdmFyIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcblxuICBpZiAoaGFzSWQpIHtcbiAgICAvLyBUaGlzIGNvbXBvbmVudCBtYXRlcmlhbGl6ZWQgYW4gaWQuIFdlIHRyZWF0IHRoaXMgYXMgaXRzIG93biBsZXZlbCwgd2l0aFxuICAgIC8vIGEgc2luZ2xlIFwiY2hpbGRcIiBzbG90LlxuICAgIHZhciBwcmV2VHJlZUNvbnRleHQgPSB0YXNrLnRyZWVDb250ZXh0O1xuICAgIHZhciB0b3RhbENoaWxkcmVuID0gMTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHRhc2sudHJlZUNvbnRleHQgPSBwdXNoVHJlZUNvbnRleHQocHJldlRyZWVDb250ZXh0LCB0b3RhbENoaWxkcmVuLCBpbmRleCk7XG5cbiAgICB0cnkge1xuICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGFzay50cmVlQ29udGV4dCA9IHByZXZUcmVlQ29udGV4dDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuKTtcbiAgfVxuXG4gIHBvcENvbXBvbmVudFN0YWNrSW5ERVYodGFzayk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlck1lbW8ocmVxdWVzdCwgdGFzaywgdHlwZSwgcHJvcHMsIHJlZikge1xuICB2YXIgaW5uZXJUeXBlID0gdHlwZS50eXBlO1xuICB2YXIgcmVzb2x2ZWRQcm9wcyA9IHJlc29sdmVEZWZhdWx0UHJvcHMoaW5uZXJUeXBlLCBwcm9wcyk7XG4gIHJlbmRlckVsZW1lbnQocmVxdWVzdCwgdGFzaywgaW5uZXJUeXBlLCByZXNvbHZlZFByb3BzLCByZWYpO1xufVxuXG5mdW5jdGlvbiByZW5kZXJDb250ZXh0Q29uc3VtZXIocmVxdWVzdCwgdGFzaywgY29udGV4dCwgcHJvcHMpIHtcbiAgLy8gVGhlIGxvZ2ljIGJlbG93IGZvciBDb250ZXh0IGRpZmZlcnMgZGVwZW5kaW5nIG9uIFBST0Qgb3IgREVWIG1vZGUuIEluXG4gIC8vIERFViBtb2RlLCB3ZSBjcmVhdGUgYSBzZXBhcmF0ZSBvYmplY3QgZm9yIENvbnRleHQuQ29uc3VtZXIgdGhhdCBhY3RzXG4gIC8vIGxpa2UgYSBwcm94eSB0byBDb250ZXh0LiBUaGlzIHByb3h5IG9iamVjdCBhZGRzIHVubmVjZXNzYXJ5IGNvZGUgaW4gUFJPRFxuICAvLyBzbyB3ZSB1c2UgdGhlIG9sZCBiZWhhdmlvdXIgKENvbnRleHQuQ29uc3VtZXIgcmVmZXJlbmNlcyBDb250ZXh0KSB0b1xuICAvLyByZWR1Y2Ugc2l6ZSBhbmQgb3ZlcmhlYWQuIFRoZSBzZXBhcmF0ZSBvYmplY3QgcmVmZXJlbmNlcyBjb250ZXh0IHZpYVxuICAvLyBhIHByb3BlcnR5IGNhbGxlZCBcIl9jb250ZXh0XCIsIHdoaWNoIGFsc28gZ2l2ZXMgdXMgdGhlIGFiaWxpdHkgdG8gY2hlY2tcbiAgLy8gaW4gREVWIG1vZGUgaWYgdGhpcyBwcm9wZXJ0eSBleGlzdHMgb3Igbm90IGFuZCB3YXJuIGlmIGl0IGRvZXMgbm90LlxuICB7XG4gICAgaWYgKGNvbnRleHQuX2NvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gVGhpcyBtYXkgYmUgYmVjYXVzZSBpdCdzIGEgQ29udGV4dCAocmF0aGVyIHRoYW4gYSBDb25zdW1lcikuXG4gICAgICAvLyBPciBpdCBtYXkgYmUgYmVjYXVzZSBpdCdzIG9sZGVyIFJlYWN0IHdoZXJlIHRoZXkncmUgdGhlIHNhbWUgdGhpbmcuXG4gICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gd2FybiBpZiB3ZSdyZSBzdXJlIGl0J3MgYSBuZXcgUmVhY3QuXG4gICAgICBpZiAoY29udGV4dCAhPT0gY29udGV4dC5Db25zdW1lcikge1xuICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lcikge1xuICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lciA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0PiBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LkNvbnN1bWVyPiBpbnN0ZWFkPycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQgPSBjb250ZXh0Ll9jb250ZXh0O1xuICAgIH1cbiAgfVxuXG4gIHZhciByZW5kZXIgPSBwcm9wcy5jaGlsZHJlbjtcblxuICB7XG4gICAgaWYgKHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdBIGNvbnRleHQgY29uc3VtZXIgd2FzIHJlbmRlcmVkIHdpdGggbXVsdGlwbGUgY2hpbGRyZW4sIG9yIGEgY2hpbGQgJyArIFwidGhhdCBpc24ndCBhIGZ1bmN0aW9uLiBBIGNvbnRleHQgY29uc3VtZXIgZXhwZWN0cyBhIHNpbmdsZSBjaGlsZCBcIiArICd0aGF0IGlzIGEgZnVuY3Rpb24uIElmIHlvdSBkaWQgcGFzcyBhIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdGhlcmUgJyArICdpcyBubyB0cmFpbGluZyBvciBsZWFkaW5nIHdoaXRlc3BhY2UgYXJvdW5kIGl0LicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBuZXdWYWx1ZSA9IHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICB2YXIgbmV3Q2hpbGRyZW4gPSByZW5kZXIobmV3VmFsdWUpO1xuICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbmV3Q2hpbGRyZW4pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJDb250ZXh0UHJvdmlkZXIocmVxdWVzdCwgdGFzaywgdHlwZSwgcHJvcHMpIHtcbiAgdmFyIGNvbnRleHQgPSB0eXBlLl9jb250ZXh0O1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gIHZhciBwcmV2U25hcHNob3Q7XG5cbiAge1xuICAgIHByZXZTbmFwc2hvdCA9IHRhc2suY29udGV4dDtcbiAgfVxuXG4gIHRhc2suY29udGV4dCA9IHB1c2hQcm92aWRlcihjb250ZXh0LCB2YWx1ZSk7XG4gIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbik7XG4gIHRhc2suY29udGV4dCA9IHBvcFByb3ZpZGVyKGNvbnRleHQpO1xuXG4gIHtcbiAgICBpZiAocHJldlNuYXBzaG90ICE9PSB0YXNrLmNvbnRleHQpIHtcbiAgICAgIGVycm9yKCdQb3BwaW5nIHRoZSBjb250ZXh0IHByb3ZpZGVyIGRpZCBub3QgcmV0dXJuIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHNuYXBzaG90LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJMYXp5Q29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIGxhenlDb21wb25lbnQsIHByb3BzLCByZWYpIHtcbiAgcHVzaEJ1aWx0SW5Db21wb25lbnRTdGFja0luREVWKHRhc2ssICdMYXp5Jyk7XG4gIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuICB2YXIgQ29tcG9uZW50ID0gaW5pdChwYXlsb2FkKTtcbiAgdmFyIHJlc29sdmVkUHJvcHMgPSByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgcHJvcHMpO1xuICByZW5kZXJFbGVtZW50KHJlcXVlc3QsIHRhc2ssIENvbXBvbmVudCwgcmVzb2x2ZWRQcm9wcywgcmVmKTtcbiAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCB0eXBlLCBwcm9wcywgcmVmKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChzaG91bGRDb25zdHJ1Y3QkMSh0eXBlKSkge1xuICAgICAgcmVuZGVyQ2xhc3NDb21wb25lbnQocmVxdWVzdCwgdGFzaywgdHlwZSwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW5kZXJJbmRldGVybWluYXRlQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIHR5cGUsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVuZGVySG9zdEVsZW1lbnQocmVxdWVzdCwgdGFzaywgdHlwZSwgcHJvcHMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIC8vIFRPRE86IExlZ2FjeUhpZGRlbiBhY3RzIHRoZSBzYW1lIGFzIGEgZnJhZ21lbnQuIFRoaXMgb25seSB3b3Jrc1xuICAgIC8vIGJlY2F1c2Ugd2UgY3VycmVudGx5IGFzc3VtZSB0aGF0IGV2ZXJ5IGluc3RhbmNlIG9mIExlZ2FjeUhpZGRlbiBpc1xuICAgIC8vIGFjY29tcGFuaWVkIGJ5IGEgaG9zdCBjb21wb25lbnQgd3JhcHBlci4gSW4gdGhlIGhpZGRlbiBtb2RlLCB0aGUgaG9zdFxuICAgIC8vIGNvbXBvbmVudCBpcyBnaXZlbiBhIGBoaWRkZW5gIGF0dHJpYnV0ZSwgd2hpY2ggZW5zdXJlcyB0aGF0IHRoZVxuICAgIC8vIGluaXRpYWwgSFRNTCBpcyBub3QgdmlzaWJsZS4gVG8gc3VwcG9ydCB0aGUgdXNlIG9mIExlZ2FjeUhpZGRlbiBhcyBhXG4gICAgLy8gdHJ1ZSBmcmFnbWVudCwgd2l0aG91dCBhbiBleHRyYSBET00gbm9kZSwgd2Ugd291bGQgaGF2ZSB0byBoaWRlIHRoZVxuICAgIC8vIGluaXRpYWwgSFRNTCBpbiBzb21lIG90aGVyIHdheS5cbiAgICAvLyBUT0RPOiBBZGQgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgaGVyZSB0b28gd2l0aCB0aGUgc2FtZSBjYXBhYmlsaXR5LlxuICAgIGNhc2UgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFOlxuICAgIGNhc2UgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEU6XG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICB7XG4gICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBwcm9wcy5jaGlsZHJlbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAge1xuICAgICAgICBwdXNoQnVpbHRJbkNvbXBvbmVudFN0YWNrSW5ERVYodGFzaywgJ1N1c3BlbnNlTGlzdCcpOyAvLyBUT0RPOiBTdXNwZW5zZUxpc3Qgc2hvdWxkIGNvbnRyb2wgdGhlIGJvdW5kYXJpZXMuXG5cbiAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIHByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBSRUFDVF9TQ09QRV9UWVBFOlxuICAgICAge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVhY3RET01TZXJ2ZXIgZG9lcyBub3QgeWV0IHN1cHBvcnQgc2NvcGUgY29tcG9uZW50cy4nKTtcbiAgICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUtbm8tZmFsbHRocm91Z2hcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHJlbmRlclN1c3BlbnNlQm91bmRhcnkocmVxdWVzdCwgdGFzaywgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICByZW5kZXJGb3J3YXJkUmVmKHJlcXVlc3QsIHRhc2ssIHR5cGUsIHByb3BzLCByZWYpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHJlbmRlck1lbW8ocmVxdWVzdCwgdGFzaywgdHlwZSwgcHJvcHMsIHJlZik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHJlbmRlckNvbnRleHRQcm92aWRlcihyZXF1ZXN0LCB0YXNrLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmVuZGVyQ29udGV4dENvbnN1bWVyKHJlcXVlc3QsIHRhc2ssIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICByZW5kZXJMYXp5Q29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaW5mbyA9ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgXCIgKyAnbmFtZWQgaW1wb3J0cy4nO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gJyArICdjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpICcgKyAoXCJidXQgZ290OiBcIiArICh0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUpICsgXCIuXCIgKyBpbmZvKSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlSXRlcmFibGUoaXRlcmFibGUsIGl0ZXJhdG9yRm4pIHtcbiAge1xuICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgcmVuZGVyaW5nIEdlbmVyYXRvcnMgYmVjYXVzZSBpdCdzIGEgbXV0YXRpb24uXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTI5OTVcbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IHRvU3RyaW5nVGFnXG4gICAgaXRlcmFibGVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0dlbmVyYXRvcicpIHtcbiAgICAgIGlmICghZGlkV2FybkFib3V0R2VuZXJhdG9ycykge1xuICAgICAgICBlcnJvcignVXNpbmcgR2VuZXJhdG9ycyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMgYmVjYXVzZSBlbnVtZXJhdGluZyBhIGdlbmVyYXRvciBtdXRhdGVzIGl0LiAnICsgJ1lvdSBtYXkgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIGBBcnJheS5mcm9tKClgIG9yIHRoZSAnICsgJ2BbLi4uc3ByZWFkXWAgb3BlcmF0b3IgYmVmb3JlIHJlbmRlcmluZy4gS2VlcCBpbiBtaW5kICcgKyAneW91IG1pZ2h0IG5lZWQgdG8gcG9seWZpbGwgdGhlc2UgZmVhdHVyZXMgZm9yIG9sZGVyIGJyb3dzZXJzLicpO1xuICAgICAgfVxuXG4gICAgICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gdHJ1ZTtcbiAgICB9IC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuXG5cbiAgICBpZiAoaXRlcmFibGUuZW50cmllcyA9PT0gaXRlcmF0b3JGbikge1xuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNYXBzKSB7XG4gICAgICAgIGVycm9yKCdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKTtcbiAgICAgIH1cblxuICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBub2RlKSB7XG4gIHtcbiAgICAvLyBJbiBEZXYgd2Ugd3JhcCByZW5kZXJOb2RlRGVzdHJ1Y3RpdmVJbXBsIGluIGEgdHJ5IC8gY2F0Y2ggc28gd2UgY2FuIGNhcHR1cmVcbiAgICAvLyBhIGNvbXBvbmVudCBzdGFjayBhdCB0aGUgcmlnaHQgcGxhY2UgaW4gdGhlIHRyZWUuIFdlIGRvbid0IGRvIHRoaXMgaW4gcmVuZGVyTm9kZVxuICAgIC8vIGJlY3Vhc2UgaXQgaXMgbm90IGNhbGxlZCBhdCBldmVyeSBsYXllciBvZiB0aGUgdHJlZSBhbmQgd2UgbWF5IGxvc2UgZnJhbWVzXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmVJbXBsKHJlcXVlc3QsIHRhc2ssIG5vZGUpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCAmJiB0eXBlb2YgeC50aGVuID09PSAnZnVuY3Rpb24nKSA7IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIGVycm9yLCBzdGFzaCB0aGUgY29tcG9uZW50IHN0YWNrIGlmIGl0IGlzIG51bGwuXG4gICAgICAgIGxhc3RCb3VuZGFyeUVycm9yQ29tcG9uZW50U3RhY2tEZXYgPSBsYXN0Qm91bmRhcnlFcnJvckNvbXBvbmVudFN0YWNrRGV2ICE9PSBudWxsID8gbGFzdEJvdW5kYXJ5RXJyb3JDb21wb25lbnRTdGFja0RldiA6IGdldEN1cnJlbnRTdGFja0luREVWKCk7XG4gICAgICB9IC8vIHJldGhyb3cgc28gbm9ybWFsIHN1c3BlbnNlIGxvZ2ljIGNhbiBoYW5kbGUgdGhyb3duIHZhbHVlIGFjY29yZGluZ2x5XG5cblxuICAgICAgdGhyb3cgeDtcbiAgICB9XG4gIH1cbn0gLy8gVGhpcyBmdW5jdGlvbiBieSBpdCBzZWxmIHJlbmRlcnMgYSBub2RlIGFuZCBjb25zdW1lcyB0aGUgdGFzayBieSBtdXRhdGluZyBpdFxuLy8gdG8gdXBkYXRlIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBzdGF0ZS5cblxuXG5mdW5jdGlvbiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmVJbXBsKHJlcXVlc3QsIHRhc2ssIG5vZGUpIHtcbiAgLy8gU3Rhc2ggdGhlIG5vZGUgd2UncmUgd29ya2luZyBvbi4gV2UnbGwgcGljayB1cCBmcm9tIHRoaXMgdGFzayBpbiBjYXNlXG4gIC8vIHNvbWV0aGluZyBzdXNwZW5kcy5cbiAgdGFzay5ub2RlID0gbm9kZTsgLy8gSGFuZGxlIG9iamVjdCB0eXBlc1xuXG4gIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZSAhPT0gbnVsbCkge1xuICAgIHN3aXRjaCAobm9kZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IG5vZGU7XG4gICAgICAgICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgICAgICAgdmFyIHByb3BzID0gZWxlbWVudC5wcm9wcztcbiAgICAgICAgICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gICAgICAgICAgcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCB0eXBlLCBwcm9wcywgcmVmKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3J0YWxzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSB0aGUgc2VydmVyIHJlbmRlcmVyLiAnICsgJ1JlbmRlciB0aGVtIGNvbmRpdGlvbmFsbHkgc28gdGhhdCB0aGV5IG9ubHkgYXBwZWFyIG9uIHRoZSBjbGllbnQgcmVuZGVyLicpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lLW5vLWZhbGx0aHJvdWdoXG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlOb2RlID0gbm9kZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlOb2RlLl9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eU5vZGUuX2luaXQ7XG4gICAgICAgICAgdmFyIHJlc29sdmVkTm9kZTtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlc29sdmVkTm9kZSA9IGluaXQocGF5bG9hZCk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCAmJiB0eXBlb2YgeC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBMYXp5IGluaXRpYWxpemVyIGlzIHN1c3BlbmRpbmcuIHB1c2ggYSB0ZW1wb3JhcnkgZnJhbWUgb250byB0aGUgc3RhY2sgc28gaXQgY2FuIGJlXG4gICAgICAgICAgICAgICAgLy8gcG9wcGVkIG9mZiBpbiBzcGF3bk5ld1N1c3BlbmRlZFRhc2suIFRoaXMgYWxpZ25zIHN0YWNrIGJlaGF2aW9yIGJldHdlZW4gTGF6eSBpbiBlbGVtZW50IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgLy8gdnMgQ29tcG9uZW50IHBvc2l0aW9uLiBXZSBkbyBub3Qgd2FudCB0aGUgZnJhbWUgZm9yIEVycm9ycyBzbyB3ZSBleGNsdXNpdmVseSBkbyB0aGlzIGluXG4gICAgICAgICAgICAgICAgLy8gdGhlIHdha2VhYmxlIGJyYW5jaFxuICAgICAgICAgICAgICAgIHB1c2hCdWlsdEluQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrLCAnTGF6eScpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhyb3cgeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgcmVzb2x2ZWROb2RlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0LCB0YXNrLCBub2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAge1xuICAgICAgICB2YWxpZGF0ZUl0ZXJhYmxlKG5vZGUsIGl0ZXJhdG9yRm4pO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG5cbiAgICAgIGlmIChpdGVyYXRvcikge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGtub3cgaG93IG1hbnkgdG90YWwgY2hpbGRyZW4gYXJlIGluIHRoaXMgc2V0LCBzbyB0aGF0IHdlXG4gICAgICAgIC8vIGNhbiBhbGxvY2F0ZSBlbm91Z2ggaWQgc2xvdHMgdG8gYWNvbW1vZGF0ZSB0aGVtLiBTbyB3ZSBtdXN0IGV4aGF1c3RcbiAgICAgICAgLy8gdGhlIGl0ZXJhdG9yIGJlZm9yZSB3ZSBzdGFydCByZWN1cnNpdmVseSByZW5kZXJpbmcgdGhlIGNoaWxkcmVuLlxuICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIG5vdCBncmVhdCBidXQgSSB0aGluayBpdCdzIGluaGVyZW50IHRvIHRoZSBpZFxuICAgICAgICAvLyBnZW5lcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7IC8vIElmIHRoZXJlIGFyZSBub3QgZW50cmllcywgd2UgbmVlZCB0byBwdXNoIGFuIGVtcHR5IHNvIHdlIHN0YXJ0IGJ5IGNoZWNraW5nIHRoYXQuXG5cbiAgICAgICAgaWYgKCFzdGVwLmRvbmUpIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goc3RlcC52YWx1ZSk7XG4gICAgICAgICAgICBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIH0gd2hpbGUgKCFzdGVwLmRvbmUpO1xuXG4gICAgICAgICAgcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGlsZFN0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChub2RlKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICsgKGNoaWxkU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMobm9kZSkuam9pbignLCAnKSArICd9JyA6IGNoaWxkU3RyaW5nKSArIFwiKS4gXCIgKyAnSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQuJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgIHNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSBwdXNoVGV4dEluc3RhbmNlJDEodGFzay5ibG9ja2VkU2VnbWVudC5jaHVua3MsIG5vZGUsIHJlcXVlc3QucmVzcG9uc2VTdGF0ZSwgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBub2RlID09PSAnbnVtYmVyJykge1xuICAgIHZhciBfc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG4gICAgX3NlZ21lbnQubGFzdFB1c2hlZFRleHQgPSBwdXNoVGV4dEluc3RhbmNlJDEodGFzay5ibG9ja2VkU2VnbWVudC5jaHVua3MsICcnICsgbm9kZSwgcmVxdWVzdC5yZXNwb25zZVN0YXRlLCBfc2VnbWVudC5sYXN0UHVzaGVkVGV4dCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LicpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJDaGlsZHJlbkFycmF5KHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuKSB7XG4gIHZhciB0b3RhbENoaWxkcmVuID0gY2hpbGRyZW4ubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWxDaGlsZHJlbjsgaSsrKSB7XG4gICAgdmFyIHByZXZUcmVlQ29udGV4dCA9IHRhc2sudHJlZUNvbnRleHQ7XG4gICAgdGFzay50cmVlQ29udGV4dCA9IHB1c2hUcmVlQ29udGV4dChwcmV2VHJlZUNvbnRleHQsIHRvdGFsQ2hpbGRyZW4sIGkpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gdXNlIHRoZSBub24tZGVzdHJ1Y3RpdmUgZm9ybSBzbyB0aGF0IHdlIGNhbiBzYWZlbHkgcG9wIGJhY2tcbiAgICAgIC8vIHVwIGFuZCByZW5kZXIgdGhlIHNpYmxpbmcgaWYgc29tZXRoaW5nIHN1c3BlbmRzLlxuICAgICAgcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbltpXSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwcmV2VHJlZUNvbnRleHQ7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNwYXduTmV3U3VzcGVuZGVkVGFzayhyZXF1ZXN0LCB0YXNrLCB4KSB7XG4gIC8vIFNvbWV0aGluZyBzdXNwZW5kZWQsIHdlJ2xsIG5lZWQgdG8gY3JlYXRlIGEgbmV3IHNlZ21lbnQgYW5kIHJlc29sdmUgaXQgbGF0ZXIuXG4gIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgdmFyIGluc2VydGlvbkluZGV4ID0gc2VnbWVudC5jaHVua3MubGVuZ3RoO1xuICB2YXIgbmV3U2VnbWVudCA9IGNyZWF0ZVBlbmRpbmdTZWdtZW50KHJlcXVlc3QsIGluc2VydGlvbkluZGV4LCBudWxsLCBzZWdtZW50LmZvcm1hdENvbnRleHQsIC8vIEFkb3B0IHRoZSBwYXJlbnQgc2VnbWVudCdzIGxlYWRpbmcgdGV4dCBlbWJlZFxuICBzZWdtZW50Lmxhc3RQdXNoZWRUZXh0LCAvLyBBc3N1bWUgd2UgYXJlIHRleHQgZW1iZWRkZWQgYXQgdGhlIHRyYWlsaW5nIGVkZ2VcbiAgdHJ1ZSk7XG4gIHNlZ21lbnQuY2hpbGRyZW4ucHVzaChuZXdTZWdtZW50KTsgLy8gUmVzZXQgbGFzdFB1c2hlZFRleHQgZm9yIGN1cnJlbnQgU2VnbWVudCBzaW5jZSB0aGUgbmV3IFNlZ21lbnQgXCJjb25zdW1lZFwiIGl0XG5cbiAgc2VnbWVudC5sYXN0UHVzaGVkVGV4dCA9IGZhbHNlO1xuICB2YXIgbmV3VGFzayA9IGNyZWF0ZVRhc2socmVxdWVzdCwgdGFzay5ub2RlLCB0YXNrLmJsb2NrZWRCb3VuZGFyeSwgbmV3U2VnbWVudCwgdGFzay5hYm9ydFNldCwgdGFzay5sZWdhY3lDb250ZXh0LCB0YXNrLmNvbnRleHQsIHRhc2sudHJlZUNvbnRleHQpO1xuXG4gIHtcbiAgICBpZiAodGFzay5jb21wb25lbnRTdGFjayAhPT0gbnVsbCkge1xuICAgICAgLy8gV2UgcG9wIG9uZSB0YXNrIG9mZiB0aGUgc3RhY2sgYmVjYXVzZSB0aGUgbm9kZSB0aGF0IHN1c3BlbmRlZCB3aWxsIGJlIHRyaWVkIGFnYWluLFxuICAgICAgLy8gd2hpY2ggd2lsbCBhZGQgaXQgYmFjayBvbnRvIHRoZSBzdGFjay5cbiAgICAgIG5ld1Rhc2suY29tcG9uZW50U3RhY2sgPSB0YXNrLmNvbXBvbmVudFN0YWNrLnBhcmVudDtcbiAgICB9XG4gIH1cblxuICB2YXIgcGluZyA9IG5ld1Rhc2sucGluZztcbiAgeC50aGVuKHBpbmcsIHBpbmcpO1xufSAvLyBUaGlzIGlzIGEgbm9uLWRlc3RydWN0aXZlIGZvcm0gb2YgcmVuZGVyaW5nIGEgbm9kZS4gSWYgaXQgc3VzcGVuZHMgaXQgc3Bhd25zXG4vLyBhIG5ldyB0YXNrIGFuZCByZXN0b3JlcyB0aGUgY29udGV4dCBvZiB0aGlzIHRhc2sgdG8gd2hhdCBpdCB3YXMgYmVmb3JlLlxuXG5cbmZ1bmN0aW9uIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgbm9kZSkge1xuICAvLyBUT0RPOiBTdG9yZSBzZWdtZW50LmNoaWxkcmVuLmxlbmd0aCBoZXJlIGFuZCByZXNldCBpdCBpbiBjYXNlIHNvbWV0aGluZ1xuICAvLyBzdXNwZW5kZWQgcGFydGlhbGx5IHRocm91Z2ggd3JpdGluZyBzb21ldGhpbmcuXG4gIC8vIFNuYXBzaG90IHRoZSBjdXJyZW50IGNvbnRleHQgaW4gY2FzZSBzb21ldGhpbmcgdGhyb3dzIHRvIGludGVycnVwdCB0aGVcbiAgLy8gcHJvY2Vzcy5cbiAgdmFyIHByZXZpb3VzRm9ybWF0Q29udGV4dCA9IHRhc2suYmxvY2tlZFNlZ21lbnQuZm9ybWF0Q29udGV4dDtcbiAgdmFyIHByZXZpb3VzTGVnYWN5Q29udGV4dCA9IHRhc2subGVnYWN5Q29udGV4dDtcbiAgdmFyIHByZXZpb3VzQ29udGV4dCA9IHRhc2suY29udGV4dDtcbiAgdmFyIHByZXZpb3VzQ29tcG9uZW50U3RhY2sgPSBudWxsO1xuXG4gIHtcbiAgICBwcmV2aW91c0NvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjaztcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBub2RlKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIHJlc2V0SG9va3NTdGF0ZSgpO1xuXG4gICAgaWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsICYmIHR5cGVvZiB4LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNwYXduTmV3U3VzcGVuZGVkVGFzayhyZXF1ZXN0LCB0YXNrLCB4KTsgLy8gUmVzdG9yZSB0aGUgY29udGV4dC4gV2UgYXNzdW1lIHRoYXQgdGhpcyB3aWxsIGJlIHJlc3RvcmVkIGJ5IHRoZSBpbm5lclxuICAgICAgLy8gZnVuY3Rpb25zIGluIGNhc2Ugbm90aGluZyB0aHJvd3Mgc28gd2UgZG9uJ3QgdXNlIFwiZmluYWxseVwiIGhlcmUuXG5cbiAgICAgIHRhc2suYmxvY2tlZFNlZ21lbnQuZm9ybWF0Q29udGV4dCA9IHByZXZpb3VzRm9ybWF0Q29udGV4dDtcbiAgICAgIHRhc2subGVnYWN5Q29udGV4dCA9IHByZXZpb3VzTGVnYWN5Q29udGV4dDtcbiAgICAgIHRhc2suY29udGV4dCA9IHByZXZpb3VzQ29udGV4dDsgLy8gUmVzdG9yZSBhbGwgYWN0aXZlIFJlYWN0Q29udGV4dHMgdG8gd2hhdCB0aGV5IHdlcmUgYmVmb3JlLlxuXG4gICAgICBzd2l0Y2hDb250ZXh0KHByZXZpb3VzQ29udGV4dCk7XG5cbiAgICAgIHtcbiAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVzdG9yZSB0aGUgY29udGV4dC4gV2UgYXNzdW1lIHRoYXQgdGhpcyB3aWxsIGJlIHJlc3RvcmVkIGJ5IHRoZSBpbm5lclxuICAgICAgLy8gZnVuY3Rpb25zIGluIGNhc2Ugbm90aGluZyB0aHJvd3Mgc28gd2UgZG9uJ3QgdXNlIFwiZmluYWxseVwiIGhlcmUuXG4gICAgICB0YXNrLmJsb2NrZWRTZWdtZW50LmZvcm1hdENvbnRleHQgPSBwcmV2aW91c0Zvcm1hdENvbnRleHQ7XG4gICAgICB0YXNrLmxlZ2FjeUNvbnRleHQgPSBwcmV2aW91c0xlZ2FjeUNvbnRleHQ7XG4gICAgICB0YXNrLmNvbnRleHQgPSBwcmV2aW91c0NvbnRleHQ7IC8vIFJlc3RvcmUgYWxsIGFjdGl2ZSBSZWFjdENvbnRleHRzIHRvIHdoYXQgdGhleSB3ZXJlIGJlZm9yZS5cblxuICAgICAgc3dpdGNoQ29udGV4dChwcmV2aW91c0NvbnRleHQpO1xuXG4gICAgICB7XG4gICAgICAgIHRhc2suY29tcG9uZW50U3RhY2sgPSBwcmV2aW91c0NvbXBvbmVudFN0YWNrO1xuICAgICAgfSAvLyBXZSBhc3N1bWUgdGhhdCB3ZSBkb24ndCBuZWVkIHRoZSBjb3JyZWN0IGNvbnRleHQuXG4gICAgICAvLyBMZXQncyB0ZXJtaW5hdGUgdGhlIHJlc3Qgb2YgdGhlIHRyZWUgYW5kIGRvbid0IHJlbmRlciBhbnkgc2libGluZ3MuXG5cblxuICAgICAgdGhyb3cgeDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZXJyb3JlZFRhc2socmVxdWVzdCwgYm91bmRhcnksIHNlZ21lbnQsIGVycm9yKSB7XG4gIC8vIFJlcG9ydCB0aGUgZXJyb3IgdG8gYSBnbG9iYWwgaGFuZGxlci5cbiAgdmFyIGVycm9yRGlnZXN0ID0gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG5cbiAgaWYgKGJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG4gIH0gZWxzZSB7XG4gICAgYm91bmRhcnkucGVuZGluZ1Rhc2tzLS07XG5cbiAgICBpZiAoIWJvdW5kYXJ5LmZvcmNlQ2xpZW50UmVuZGVyKSB7XG4gICAgICBib3VuZGFyeS5mb3JjZUNsaWVudFJlbmRlciA9IHRydWU7XG4gICAgICBib3VuZGFyeS5lcnJvckRpZ2VzdCA9IGVycm9yRGlnZXN0O1xuXG4gICAgICB7XG4gICAgICAgIGNhcHR1cmVCb3VuZGFyeUVycm9yRGV0YWlsc0Rldihib3VuZGFyeSwgZXJyb3IpO1xuICAgICAgfSAvLyBSZWdhcmRsZXNzIG9mIHdoYXQgaGFwcGVucyBuZXh0LCB0aGlzIGJvdW5kYXJ5IHdvbid0IGJlIGRpc3BsYXllZCxcbiAgICAgIC8vIHNvIHdlIGNhbiBmbHVzaCBpdCwgaWYgdGhlIHBhcmVudCBhbHJlYWR5IGZsdXNoZWQuXG5cblxuICAgICAgaWYgKGJvdW5kYXJ5LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBhIHByZWZlcmVuY2Ugd2hlcmUgaW4gdGhlIHF1ZXVlIHRoaXMgZ29lcyBzaW5jZSBpdCdzIGxpa2VseVxuICAgICAgICAvLyB0byBlcnJvciBvbiB0aGUgY2xpZW50IGFueXdheS4gSG93ZXZlciwgaW50ZW50aW9uYWxseSBjbGllbnQtcmVuZGVyZWRcbiAgICAgICAgLy8gYm91bmRhcmllcyBzaG91bGQgYmUgZmx1c2hlZCBlYXJsaWVyIHNvIHRoYXQgdGhleSBjYW4gc3RhcnQgb24gdGhlIGNsaWVudC5cbiAgICAgICAgLy8gV2UgcmV1c2UgdGhlIHNhbWUgcXVldWUgZm9yIGVycm9ycy5cbiAgICAgICAgcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MtLTtcblxuICBpZiAocmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgPT09IDApIHtcbiAgICB2YXIgb25BbGxSZWFkeSA9IHJlcXVlc3Qub25BbGxSZWFkeTtcbiAgICBvbkFsbFJlYWR5KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWJvcnRUYXNrU29mdCh0YXNrKSB7XG4gIC8vIFRoaXMgYWJvcnRzIHRhc2sgd2l0aG91dCBhYm9ydGluZyB0aGUgcGFyZW50IGJvdW5kYXJ5IHRoYXQgaXQgYmxvY2tzLlxuICAvLyBJdCdzIHVzZWQgZm9yIHdoZW4gd2UgZGlkbid0IG5lZWQgdGhpcyB0YXNrIHRvIGNvbXBsZXRlIHRoZSB0cmVlLlxuICAvLyBJZiB0YXNrIHdhcyBuZWVkZWQsIHRoZW4gaXQgc2hvdWxkIHVzZSBhYm9ydFRhc2sgaW5zdGVhZC5cbiAgdmFyIHJlcXVlc3QgPSB0aGlzO1xuICB2YXIgYm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeTtcbiAgdmFyIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICBzZWdtZW50LnN0YXR1cyA9IEFCT1JURUQ7XG4gIGZpbmlzaGVkVGFzayhyZXF1ZXN0LCBib3VuZGFyeSwgc2VnbWVudCk7XG59XG5cbmZ1bmN0aW9uIGFib3J0VGFzayh0YXNrLCByZXF1ZXN0LCByZWFzb24pIHtcbiAgLy8gVGhpcyBhYm9ydHMgdGhlIHRhc2sgYW5kIGFib3J0cyB0aGUgcGFyZW50IHRoYXQgaXQgYmxvY2tzLCBwdXR0aW5nIGl0IGludG9cbiAgLy8gY2xpZW50IHJlbmRlcmVkIG1vZGUuXG4gIHZhciBib3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5O1xuICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG4gIHNlZ21lbnQuc3RhdHVzID0gQUJPUlRFRDtcblxuICBpZiAoYm91bmRhcnkgPT09IG51bGwpIHtcbiAgICByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcy0tOyAvLyBXZSBkaWRuJ3QgY29tcGxldGUgdGhlIHJvb3Qgc28gd2UgaGF2ZSBub3RoaW5nIHRvIHNob3cuIFdlIGNhbiBjbG9zZVxuICAgIC8vIHRoZSByZXF1ZXN0O1xuXG4gICAgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSBDTE9TRUQpIHtcbiAgICAgIHJlcXVlc3Quc3RhdHVzID0gQ0xPU0VEO1xuXG4gICAgICBpZiAocmVxdWVzdC5kZXN0aW5hdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICBjbG9zZShyZXF1ZXN0LmRlc3RpbmF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYm91bmRhcnkucGVuZGluZ1Rhc2tzLS07XG5cbiAgICBpZiAoIWJvdW5kYXJ5LmZvcmNlQ2xpZW50UmVuZGVyKSB7XG4gICAgICBib3VuZGFyeS5mb3JjZUNsaWVudFJlbmRlciA9IHRydWU7XG5cbiAgICAgIHZhciBfZXJyb3IgPSByZWFzb24gPT09IHVuZGVmaW5lZCA/IG5ldyBFcnJvcignVGhlIHJlbmRlciB3YXMgYWJvcnRlZCBieSB0aGUgc2VydmVyIHdpdGhvdXQgYSByZWFzb24uJykgOiByZWFzb247XG5cbiAgICAgIGJvdW5kYXJ5LmVycm9yRGlnZXN0ID0gcmVxdWVzdC5vbkVycm9yKF9lcnJvcik7XG5cbiAgICAgIHtcbiAgICAgICAgdmFyIGVycm9yUHJlZml4ID0gJ1RoZSBzZXJ2ZXIgZGlkIG5vdCBmaW5pc2ggdGhpcyBTdXNwZW5zZSBib3VuZGFyeTogJztcblxuICAgICAgICBpZiAoX2Vycm9yICYmIHR5cGVvZiBfZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBfZXJyb3IgPSBlcnJvclByZWZpeCArIF9lcnJvci5tZXNzYWdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgICAgICAgIF9lcnJvciA9IGVycm9yUHJlZml4ICsgU3RyaW5nKF9lcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJldmlvdXNUYXNrSW5EZXYgPSBjdXJyZW50VGFza0luREVWO1xuICAgICAgICBjdXJyZW50VGFza0luREVWID0gdGFzaztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNhcHR1cmVCb3VuZGFyeUVycm9yRGV0YWlsc0Rldihib3VuZGFyeSwgX2Vycm9yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBjdXJyZW50VGFza0luREVWID0gcHJldmlvdXNUYXNrSW5EZXY7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGJvdW5kYXJ5LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgICAgcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSk7XG4gICAgICB9XG4gICAgfSAvLyBJZiB0aGlzIGJvdW5kYXJ5IHdhcyBzdGlsbCBwZW5kaW5nIHRoZW4gd2UgaGF2ZW4ndCBhbHJlYWR5IGNhbmNlbGxlZCBpdHMgZmFsbGJhY2tzLlxuICAgIC8vIFdlJ2xsIG5lZWQgdG8gYWJvcnQgdGhlIGZhbGxiYWNrcywgd2hpY2ggd2lsbCBhbHNvIGVycm9yIHRoYXQgcGFyZW50IGJvdW5kYXJ5LlxuXG5cbiAgICBib3VuZGFyeS5mYWxsYmFja0Fib3J0YWJsZVRhc2tzLmZvckVhY2goZnVuY3Rpb24gKGZhbGxiYWNrVGFzaykge1xuICAgICAgcmV0dXJuIGFib3J0VGFzayhmYWxsYmFja1Rhc2ssIHJlcXVlc3QsIHJlYXNvbik7XG4gICAgfSk7XG4gICAgYm91bmRhcnkuZmFsbGJhY2tBYm9ydGFibGVUYXNrcy5jbGVhcigpO1xuICAgIHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzLS07XG5cbiAgICBpZiAocmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgPT09IDApIHtcbiAgICAgIHZhciBvbkFsbFJlYWR5ID0gcmVxdWVzdC5vbkFsbFJlYWR5O1xuICAgICAgb25BbGxSZWFkeSgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBxdWV1ZUNvbXBsZXRlZFNlZ21lbnQoYm91bmRhcnksIHNlZ21lbnQpIHtcbiAgaWYgKHNlZ21lbnQuY2h1bmtzLmxlbmd0aCA9PT0gMCAmJiBzZWdtZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBzZWdtZW50LmNoaWxkcmVuWzBdLmJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyBhbiBlbXB0eSBzZWdtZW50LiBUaGVyZSdzIG5vdGhpbmcgdG8gd3JpdGUsIHNvIHdlIGNhbiBpbnN0ZWFkIHRyYW5zZmVyIHRoZSBJRFxuICAgIC8vIHRvIHRoZSBjaGlsZC4gVGhhdCB3YXkgYW55IGV4aXN0aW5nIHJlZmVyZW5jZXMgcG9pbnQgdG8gdGhlIGNoaWxkLlxuICAgIHZhciBjaGlsZFNlZ21lbnQgPSBzZWdtZW50LmNoaWxkcmVuWzBdO1xuICAgIGNoaWxkU2VnbWVudC5pZCA9IHNlZ21lbnQuaWQ7XG4gICAgY2hpbGRTZWdtZW50LnBhcmVudEZsdXNoZWQgPSB0cnVlO1xuXG4gICAgaWYgKGNoaWxkU2VnbWVudC5zdGF0dXMgPT09IENPTVBMRVRFRCkge1xuICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBjaGlsZFNlZ21lbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cztcbiAgICBjb21wbGV0ZWRTZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaGVkVGFzayhyZXF1ZXN0LCBib3VuZGFyeSwgc2VnbWVudCkge1xuICBpZiAoYm91bmRhcnkgPT09IG51bGwpIHtcbiAgICBpZiAoc2VnbWVudC5wYXJlbnRGbHVzaGVkKSB7XG4gICAgICBpZiAocmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGNhbiBvbmx5IGJlIG9uZSByb290IHNlZ21lbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3QuY29tcGxldGVkUm9vdFNlZ21lbnQgPSBzZWdtZW50O1xuICAgIH1cblxuICAgIHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcy0tO1xuXG4gICAgaWYgKHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcyA9PT0gMCkge1xuICAgICAgLy8gV2UgaGF2ZSBjb21wbGV0ZWQgdGhlIHNoZWxsIHNvIHRoZSBzaGVsbCBjYW4ndCBlcnJvciBhbnltb3JlLlxuICAgICAgcmVxdWVzdC5vblNoZWxsRXJyb3IgPSBub29wJDE7XG4gICAgICB2YXIgb25TaGVsbFJlYWR5ID0gcmVxdWVzdC5vblNoZWxsUmVhZHk7XG4gICAgICBvblNoZWxsUmVhZHkoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYm91bmRhcnkucGVuZGluZ1Rhc2tzLS07XG5cbiAgICBpZiAoYm91bmRhcnkuZm9yY2VDbGllbnRSZW5kZXIpIDsgZWxzZSBpZiAoYm91bmRhcnkucGVuZGluZ1Rhc2tzID09PSAwKSB7XG4gICAgICAvLyBUaGlzIG11c3QgaGF2ZSBiZWVuIHRoZSBsYXN0IHNlZ21lbnQgd2Ugd2VyZSB3YWl0aW5nIG9uLiBUaGlzIGJvdW5kYXJ5IGlzIG5vdyBjb21wbGV0ZS5cbiAgICAgIGlmIChzZWdtZW50LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgICAgLy8gT3VyIHBhcmVudCBzZWdtZW50IGFscmVhZHkgZmx1c2hlZCwgc28gd2UgbmVlZCB0byBzY2hlZHVsZSB0aGlzIHNlZ21lbnQgdG8gYmUgZW1pdHRlZC5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSBzZWdtZW50IHRoYXQgd2FzIGFib3J0ZWQsIHdlJ2xsIHdyaXRlIG90aGVyIGNvbnRlbnQgaW5zdGVhZCBzbyB3ZSBkb24ndCBuZWVkXG4gICAgICAgIC8vIHRvIGVtaXQgaXQuXG4gICAgICAgIGlmIChzZWdtZW50LnN0YXR1cyA9PT0gQ09NUExFVEVEKSB7XG4gICAgICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBzZWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYm91bmRhcnkucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICAvLyBUaGUgc2VnbWVudCBtaWdodCBiZSBwYXJ0IG9mIGEgc2VnbWVudCB0aGF0IGRpZG4ndCBmbHVzaCB5ZXQsIGJ1dCBpZiB0aGUgYm91bmRhcnknc1xuICAgICAgICAvLyBwYXJlbnQgZmx1c2hlZCwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgYm91bmRhcnkgdG8gYmUgZW1pdHRlZC5cbiAgICAgICAgcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpO1xuICAgICAgfSAvLyBXZSBjYW4gbm93IGNhbmNlbCBhbnkgcGVuZGluZyB0YXNrIG9uIHRoZSBmYWxsYmFjayBzaW5jZSB3ZSB3b24ndCBuZWVkIHRvIHNob3cgaXQgYW55bW9yZS5cbiAgICAgIC8vIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGFmdGVyIHdlIHJlYWQgdGhlIHBhcmVudEZsdXNoZWQgZmxhZ3MgYmVjYXVzZSBhYm9ydGluZyBjYW4gZmluaXNoXG4gICAgICAvLyB3b3JrIHdoaWNoIGNhbiB0cmlnZ2VyIHVzZXIgY29kZSwgd2hpY2ggY2FuIHN0YXJ0IGZsdXNoaW5nLCB3aGljaCBjYW4gY2hhbmdlIHRob3NlIGZsYWdzLlxuXG5cbiAgICAgIGJvdW5kYXJ5LmZhbGxiYWNrQWJvcnRhYmxlVGFza3MuZm9yRWFjaChhYm9ydFRhc2tTb2Z0LCByZXF1ZXN0KTtcbiAgICAgIGJvdW5kYXJ5LmZhbGxiYWNrQWJvcnRhYmxlVGFza3MuY2xlYXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNlZ21lbnQucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICAvLyBPdXIgcGFyZW50IGFscmVhZHkgZmx1c2hlZCwgc28gd2UgbmVlZCB0byBzY2hlZHVsZSB0aGlzIHNlZ21lbnQgdG8gYmUgZW1pdHRlZC5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSBzZWdtZW50IHRoYXQgd2FzIGFib3J0ZWQsIHdlJ2xsIHdyaXRlIG90aGVyIGNvbnRlbnQgaW5zdGVhZCBzbyB3ZSBkb24ndCBuZWVkXG4gICAgICAgIC8vIHRvIGVtaXQgaXQuXG4gICAgICAgIGlmIChzZWdtZW50LnN0YXR1cyA9PT0gQ09NUExFVEVEKSB7XG4gICAgICAgICAgcXVldWVDb21wbGV0ZWRTZWdtZW50KGJvdW5kYXJ5LCBzZWdtZW50KTtcbiAgICAgICAgICB2YXIgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cztcblxuICAgICAgICAgIGlmIChjb21wbGV0ZWRTZWdtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgc2luY2Ugd2UgbGFzdCBmbHVzaGVkIHRoYXQgd2UgY29tcGxldGVkIGFueXRoaW5nLlxuICAgICAgICAgICAgLy8gV2UgY2FuIHNjaGVkdWxlIHRoaXMgYm91bmRhcnkgdG8gZW1pdCBpdHMgcGFydGlhbGx5IGNvbXBsZXRlZCBzZWdtZW50cyBlYXJseVxuICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgcGFyZW50IGhhcyBhbHJlYWR5IGJlZW4gZmx1c2hlZC5cbiAgICAgICAgICAgIGlmIChib3VuZGFyeS5wYXJlbnRGbHVzaGVkKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QucGFydGlhbEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MtLTtcblxuICBpZiAocmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgPT09IDApIHtcbiAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGNhbGxlZCBhdCB0aGUgdmVyeSBlbmQgc28gdGhhdCB3ZSBjYW4gc3luY2hyb25vdXNseSB3cml0ZSB0aGUgcmVzdWx0XG4gICAgLy8gaW4gdGhlIGNhbGxiYWNrIGlmIG5lZWRlZC5cbiAgICB2YXIgb25BbGxSZWFkeSA9IHJlcXVlc3Qub25BbGxSZWFkeTtcbiAgICBvbkFsbFJlYWR5KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV0cnlUYXNrKHJlcXVlc3QsIHRhc2spIHtcbiAgdmFyIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuXG4gIGlmIChzZWdtZW50LnN0YXR1cyAhPT0gUEVORElORykge1xuICAgIC8vIFdlIGNvbXBsZXRlZCB0aGlzIGJ5IG90aGVyIG1lYW5zIGJlZm9yZSB3ZSBoYWQgYSBjaGFuY2UgdG8gcmV0cnkgaXQuXG4gICAgcmV0dXJuO1xuICB9IC8vIFdlIHJlc3RvcmUgdGhlIGNvbnRleHQgdG8gd2hhdCBpdCB3YXMgd2hlbiB3ZSBzdXNwZW5kZWQuXG4gIC8vIFdlIGRvbid0IHJlc3RvcmUgaXQgYWZ0ZXIgd2UgbGVhdmUgYmVjYXVzZSBpdCdzIGxpa2VseSB0aGF0IHdlJ2xsIGVuZCB1cFxuICAvLyBuZWVkaW5nIGEgdmVyeSBzaW1pbGFyIGNvbnRleHQgc29vbiBhZ2Fpbi5cblxuXG4gIHN3aXRjaENvbnRleHQodGFzay5jb250ZXh0KTtcbiAgdmFyIHByZXZUYXNrSW5ERVYgPSBudWxsO1xuXG4gIHtcbiAgICBwcmV2VGFza0luREVWID0gY3VycmVudFRhc2tJbkRFVjtcbiAgICBjdXJyZW50VGFza0luREVWID0gdGFzaztcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gV2UgY2FsbCB0aGUgZGVzdHJ1Y3RpdmUgZm9ybSB0aGF0IG11dGF0ZXMgdGhpcyB0YXNrLiBUaGF0IHdheSBpZiBzb21ldGhpbmdcbiAgICAvLyBzdXNwZW5kcyBhZ2Fpbiwgd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRhc2sgaW5zdGVhZCBvZiBzcGF3bmluZyBhIG5ldyBvbmUuXG4gICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIHRhc2subm9kZSk7XG4gICAgcHVzaFNlZ21lbnRGaW5hbGUkMShzZWdtZW50LmNodW5rcywgcmVxdWVzdC5yZXNwb25zZVN0YXRlLCBzZWdtZW50Lmxhc3RQdXNoZWRUZXh0LCBzZWdtZW50LnRleHRFbWJlZGRlZCk7XG4gICAgdGFzay5hYm9ydFNldC5kZWxldGUodGFzayk7XG4gICAgc2VnbWVudC5zdGF0dXMgPSBDT01QTEVURUQ7XG4gICAgZmluaXNoZWRUYXNrKHJlcXVlc3QsIHRhc2suYmxvY2tlZEJvdW5kYXJ5LCBzZWdtZW50KTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIHJlc2V0SG9va3NTdGF0ZSgpO1xuXG4gICAgaWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsICYmIHR5cGVvZiB4LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzdXNwZW5kZWQgYWdhaW4sIGxldCdzIHBpY2sgaXQgYmFjayB1cCBsYXRlci5cbiAgICAgIHZhciBwaW5nID0gdGFzay5waW5nO1xuICAgICAgeC50aGVuKHBpbmcsIHBpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXNrLmFib3J0U2V0LmRlbGV0ZSh0YXNrKTtcbiAgICAgIHNlZ21lbnQuc3RhdHVzID0gRVJST1JFRDtcbiAgICAgIGVycm9yZWRUYXNrKHJlcXVlc3QsIHRhc2suYmxvY2tlZEJvdW5kYXJ5LCBzZWdtZW50LCB4KTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAge1xuICAgICAgY3VycmVudFRhc2tJbkRFViA9IHByZXZUYXNrSW5ERVY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1Xb3JrKHJlcXVlc3QpIHtcbiAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSBDTE9TRUQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcHJldkNvbnRleHQgPSBnZXRBY3RpdmVDb250ZXh0KCk7XG4gIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IERpc3BhdGNoZXI7XG4gIHZhciBwcmV2R2V0Q3VycmVudFN0YWNrSW1wbDtcblxuICB7XG4gICAgcHJldkdldEN1cnJlbnRTdGFja0ltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuZ2V0Q3VycmVudFN0YWNrO1xuICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5nZXRDdXJyZW50U3RhY2sgPSBnZXRDdXJyZW50U3RhY2tJbkRFVjtcbiAgfVxuXG4gIHZhciBwcmV2UmVzcG9uc2VTdGF0ZSA9IGN1cnJlbnRSZXNwb25zZVN0YXRlO1xuICBzZXRDdXJyZW50UmVzcG9uc2VTdGF0ZShyZXF1ZXN0LnJlc3BvbnNlU3RhdGUpO1xuXG4gIHRyeSB7XG4gICAgdmFyIHBpbmdlZFRhc2tzID0gcmVxdWVzdC5waW5nZWRUYXNrcztcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBwaW5nZWRUYXNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRhc2sgPSBwaW5nZWRUYXNrc1tpXTtcbiAgICAgIHJldHJ5VGFzayhyZXF1ZXN0LCB0YXNrKTtcbiAgICB9XG5cbiAgICBwaW5nZWRUYXNrcy5zcGxpY2UoMCwgaSk7XG5cbiAgICBpZiAocmVxdWVzdC5kZXN0aW5hdGlvbiAhPT0gbnVsbCkge1xuICAgICAgZmx1c2hDb21wbGV0ZWRRdWV1ZXMocmVxdWVzdCwgcmVxdWVzdC5kZXN0aW5hdGlvbik7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICAgIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICB9IGZpbmFsbHkge1xuICAgIHNldEN1cnJlbnRSZXNwb25zZVN0YXRlKHByZXZSZXNwb25zZVN0YXRlKTtcbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuXG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLmdldEN1cnJlbnRTdGFjayA9IHByZXZHZXRDdXJyZW50U3RhY2tJbXBsO1xuICAgIH1cblxuICAgIGlmIChwcmV2RGlzcGF0Y2hlciA9PT0gRGlzcGF0Y2hlcikge1xuICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IHdlIHdlcmUgaW4gYSByZWVudHJhbnQgd29yayBsb29wLiBUaGlzIGNvdWxkIGhhcHBlblxuICAgICAgLy8gaW4gYSByZW5kZXJlciB0aGF0IHN1cHBvcnRzIHN5bmNocm9ub3VzIHdvcmsgbGlrZSByZW5kZXJUb1N0cmluZyxcbiAgICAgIC8vIHdoZW4gaXQncyBjYWxsZWQgZnJvbSB3aXRoaW4gYW5vdGhlciByZW5kZXJlci5cbiAgICAgIC8vIE5vcm1hbGx5IHdlIGRvbid0IGJvdGhlciBzd2l0Y2hpbmcgdGhlIGNvbnRleHRzIHRvIHRoZWlyIHJvb3QvZGVmYXVsdFxuICAgICAgLy8gdmFsdWVzIHdoZW4gbGVhdmluZyBiZWNhdXNlIHdlJ2xsIGxpa2VseSBuZWVkIHRoZSBzYW1lIG9yIHNpbWlsYXJcbiAgICAgIC8vIGNvbnRleHQgYWdhaW4uIEhvd2V2ZXIsIHdoZW4gd2UncmUgaW5zaWRlIGEgc3luY2hyb25vdXMgbG9vcCBsaWtlIHRoaXNcbiAgICAgIC8vIHdlJ2xsIHRvIHJlc3RvcmUgdGhlIGNvbnRleHQgdG8gd2hhdCBpdCB3YXMgYmVmb3JlIHJldHVybmluZy5cbiAgICAgIHN3aXRjaENvbnRleHQocHJldkNvbnRleHQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQpIHtcbiAgc2VnbWVudC5wYXJlbnRGbHVzaGVkID0gdHJ1ZTtcblxuICBzd2l0Y2ggKHNlZ21lbnQuc3RhdHVzKSB7XG4gICAgY2FzZSBQRU5ESU5HOlxuICAgICAge1xuICAgICAgICAvLyBXZSdyZSBlbWl0dGluZyBhIHBsYWNlaG9sZGVyIGZvciB0aGlzIHNlZ21lbnQgdG8gYmUgZmlsbGVkIGluIGxhdGVyLlxuICAgICAgICAvLyBUaGVyZWZvcmUgd2UnbGwgbmVlZCB0byBhc3NpZ24gaXQgYW4gSUQgLSB0byByZWZlciB0byBpdCBieS5cbiAgICAgICAgdmFyIHNlZ21lbnRJRCA9IHNlZ21lbnQuaWQgPSByZXF1ZXN0Lm5leHRTZWdtZW50SWQrKzsgLy8gV2hlbiB0aGlzIHNlZ21lbnQgZmluYWxseSBjb21wbGV0ZXMgaXQgd29uJ3QgYmUgZW1iZWRkZWQgaW4gdGV4dCBzaW5jZSBpdCB3aWxsIGZsdXNoIHNlcGFyYXRlbHlcblxuICAgICAgICBzZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gZmFsc2U7XG4gICAgICAgIHNlZ21lbnQudGV4dEVtYmVkZGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB3cml0ZVBsYWNlaG9sZGVyKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUsIHNlZ21lbnRJRCk7XG4gICAgICB9XG5cbiAgICBjYXNlIENPTVBMRVRFRDpcbiAgICAgIHtcbiAgICAgICAgc2VnbWVudC5zdGF0dXMgPSBGTFVTSEVEO1xuICAgICAgICB2YXIgciA9IHRydWU7XG4gICAgICAgIHZhciBjaHVua3MgPSBzZWdtZW50LmNodW5rcztcbiAgICAgICAgdmFyIGNodW5rSWR4ID0gMDtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gc2VnbWVudC5jaGlsZHJlbjtcblxuICAgICAgICBmb3IgKHZhciBjaGlsZElkeCA9IDA7IGNoaWxkSWR4IDwgY2hpbGRyZW4ubGVuZ3RoOyBjaGlsZElkeCsrKSB7XG4gICAgICAgICAgdmFyIG5leHRDaGlsZCA9IGNoaWxkcmVuW2NoaWxkSWR4XTsgLy8gV3JpdGUgYWxsIHRoZSBjaHVua3MgdXAgdW50aWwgdGhlIG5leHQgY2hpbGQuXG5cbiAgICAgICAgICBmb3IgKDsgY2h1bmtJZHggPCBuZXh0Q2hpbGQuaW5kZXg7IGNodW5rSWR4KyspIHtcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNodW5rc1tjaHVua0lkeF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHIgPSBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIG5leHRDaGlsZCk7XG4gICAgICAgIH0gLy8gRmluYWxseSBqdXN0IHdyaXRlIGFsbCB0aGUgcmVtYWluaW5nIGNodW5rc1xuXG5cbiAgICAgICAgZm9yICg7IGNodW5rSWR4IDwgY2h1bmtzLmxlbmd0aCAtIDE7IGNodW5rSWR4KyspIHtcbiAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjaHVua3NbY2h1bmtJZHhdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaHVua0lkeCA8IGNodW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICByID0gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY2h1bmtzW2NodW5rSWR4XSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQWJvcnRlZCwgZXJyb3JlZCBvciBhbHJlYWR5IGZsdXNoZWQgYm91bmRhcmllcyBzaG91bGQgbm90IGJlIGZsdXNoZWQgYWdhaW4uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KSB7XG4gIHZhciBib3VuZGFyeSA9IHNlZ21lbnQuYm91bmRhcnk7XG5cbiAgaWYgKGJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgLy8gTm90IGEgc3VzcGVuc2UgYm91bmRhcnkuXG4gICAgcmV0dXJuIGZsdXNoU3VidHJlZShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCk7XG4gIH1cblxuICBib3VuZGFyeS5wYXJlbnRGbHVzaGVkID0gdHJ1ZTsgLy8gVGhpcyBzZWdtZW50IGlzIGEgU3VzcGVuc2UgYm91bmRhcnkuIFdlIG5lZWQgdG8gZGVjaWRlIHdoZXRoZXIgdG9cbiAgLy8gZW1pdCB0aGUgY29udGVudCBvciB0aGUgZmFsbGJhY2sgbm93LlxuXG4gIGlmIChib3VuZGFyeS5mb3JjZUNsaWVudFJlbmRlcikge1xuICAgIC8vIEVtaXQgYSBjbGllbnQgcmVuZGVyZWQgc3VzcGVuc2UgYm91bmRhcnkgd3JhcHBlci5cbiAgICAvLyBXZSBuZXZlciBxdWV1ZSB0aGUgaW5uZXIgYm91bmRhcnkgc28gd2UnbGwgbmV2ZXIgZW1pdCBpdHMgY29udGVudCBvciBwYXJ0aWFsIHNlZ21lbnRzLlxuICAgIHdyaXRlU3RhcnRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkkMShkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXNwb25zZVN0YXRlLCBib3VuZGFyeS5lcnJvckRpZ2VzdCwgYm91bmRhcnkuZXJyb3JNZXNzYWdlLCBib3VuZGFyeS5lcnJvckNvbXBvbmVudFN0YWNrKTsgLy8gRmx1c2ggdGhlIGZhbGxiYWNrLlxuXG4gICAgZmx1c2hTdWJ0cmVlKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KTtcbiAgICByZXR1cm4gd3JpdGVFbmRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkkMShkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXNwb25zZVN0YXRlKTtcbiAgfSBlbHNlIGlmIChib3VuZGFyeS5wZW5kaW5nVGFza3MgPiAwKSB7XG4gICAgLy8gVGhpcyBib3VuZGFyeSBpcyBzdGlsbCBsb2FkaW5nLiBFbWl0IGEgcGVuZGluZyBzdXNwZW5zZSBib3VuZGFyeSB3cmFwcGVyLlxuICAgIC8vIEFzc2lnbiBhbiBJRCB0byByZWZlciB0byB0aGUgZnV0dXJlIGNvbnRlbnQgYnkuXG4gICAgYm91bmRhcnkucm9vdFNlZ21lbnRJRCA9IHJlcXVlc3QubmV4dFNlZ21lbnRJZCsrO1xuXG4gICAgaWYgKGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIElmIHRoaXMgaXMgYXQgbGVhc3QgcGFydGlhbGx5IGNvbXBsZXRlLCB3ZSBjYW4gcXVldWUgaXQgdG8gYmUgcGFydGlhbGx5IGVtaXR0ZWQgZWFybHkuXG4gICAgICByZXF1ZXN0LnBhcnRpYWxCb3VuZGFyaWVzLnB1c2goYm91bmRhcnkpO1xuICAgIH0gLy8vIFRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgd2Ugc2hvdWxkIGhhdmUgcmVmZXJlbmNlZCB0aGlzIElELlxuXG5cbiAgICB2YXIgaWQgPSBib3VuZGFyeS5pZCA9IGFzc2lnblN1c3BlbnNlQm91bmRhcnlJRChyZXF1ZXN0LnJlc3BvbnNlU3RhdGUpO1xuICAgIHdyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXNwb25zZVN0YXRlLCBpZCk7IC8vIEZsdXNoIHRoZSBmYWxsYmFjay5cblxuICAgIGZsdXNoU3VidHJlZShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCk7XG4gICAgcmV0dXJuIHdyaXRlRW5kUGVuZGluZ1N1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlcXVlc3QucmVzcG9uc2VTdGF0ZSk7XG4gIH0gZWxzZSBpZiAoYm91bmRhcnkuYnl0ZVNpemUgPiByZXF1ZXN0LnByb2dyZXNzaXZlQ2h1bmtTaXplKSB7XG4gICAgLy8gVGhpcyBib3VuZGFyeSBpcyBsYXJnZSBhbmQgd2lsbCBiZSBlbWl0dGVkIHNlcGFyYXRlbHkgc28gdGhhdCB3ZSBjYW4gcHJvZ3Jlc3NpdmVseSBzaG93XG4gICAgLy8gb3RoZXIgY29udGVudC4gV2UgYWRkIGl0IHRvIHRoZSBxdWV1ZSBkdXJpbmcgdGhlIGZsdXNoIGJlY2F1c2Ugd2UgaGF2ZSB0byBlbnN1cmUgdGhhdFxuICAgIC8vIHRoZSBwYXJlbnQgZmx1c2hlcyBmaXJzdCBzbyB0aGF0IHRoZXJlJ3Mgc29tZXRoaW5nIHRvIGluamVjdCBpdCBpbnRvLlxuICAgIC8vIFdlIGFsc28gaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCBpdCdzIGVtaXR0ZWQgaW50byB0aGUgcXVldWUgaW4gYSBkZXRlcm1pbmlzdGljIHNsb3QuXG4gICAgLy8gSS5lLiB3ZSBjYW4ndCBpbnNlcnQgaXQgaGVyZSB3aGVuIGl0IGNvbXBsZXRlcy5cbiAgICAvLyBBc3NpZ24gYW4gSUQgdG8gcmVmZXIgdG8gdGhlIGZ1dHVyZSBjb250ZW50IGJ5LlxuICAgIGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQgPSByZXF1ZXN0Lm5leHRTZWdtZW50SWQrKztcbiAgICByZXF1ZXN0LmNvbXBsZXRlZEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSk7IC8vIEVtaXQgYSBwZW5kaW5nIHJlbmRlcmVkIHN1c3BlbnNlIGJvdW5kYXJ5IHdyYXBwZXIuXG5cbiAgICB3cml0ZVN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlcXVlc3QucmVzcG9uc2VTdGF0ZSwgYm91bmRhcnkuaWQpOyAvLyBGbHVzaCB0aGUgZmFsbGJhY2suXG5cbiAgICBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQpO1xuICAgIHJldHVybiB3cml0ZUVuZFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIGNhbiBpbmxpbmUgdGhpcyBib3VuZGFyeSdzIGNvbnRlbnQgYXMgYSBjb21wbGV0ZSBib3VuZGFyeS5cbiAgICB3cml0ZVN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSQxKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUpO1xuICAgIHZhciBjb21wbGV0ZWRTZWdtZW50cyA9IGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzO1xuXG4gICAgaWYgKGNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHByZXZpb3VzbHkgdW52aXNpdGVkIGJvdW5kYXJ5IG11c3QgaGF2ZSBleGFjdGx5IG9uZSByb290IHNlZ21lbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRlbnRTZWdtZW50ID0gY29tcGxldGVkU2VnbWVudHNbMF07XG4gICAgZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBjb250ZW50U2VnbWVudCk7XG4gICAgcmV0dXJuIHdyaXRlRW5kQ29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSQxKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoQ2xpZW50UmVuZGVyZWRCb3VuZGFyeShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgYm91bmRhcnkpIHtcbiAgcmV0dXJuIHdyaXRlQ2xpZW50UmVuZGVyQm91bmRhcnlJbnN0cnVjdGlvbihkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXNwb25zZVN0YXRlLCBib3VuZGFyeS5pZCwgYm91bmRhcnkuZXJyb3JEaWdlc3QsIGJvdW5kYXJ5LmVycm9yTWVzc2FnZSwgYm91bmRhcnkuZXJyb3JDb21wb25lbnRTdGFjayk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoU2VnbWVudENvbnRhaW5lcihyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCkge1xuICB3cml0ZVN0YXJ0U2VnbWVudChkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXNwb25zZVN0YXRlLCBzZWdtZW50LmZvcm1hdENvbnRleHQsIHNlZ21lbnQuaWQpO1xuICBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQpO1xuICByZXR1cm4gd3JpdGVFbmRTZWdtZW50KGRlc3RpbmF0aW9uLCBzZWdtZW50LmZvcm1hdENvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBmbHVzaENvbXBsZXRlZEJvdW5kYXJ5KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBib3VuZGFyeSkge1xuICB2YXIgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cztcbiAgdmFyIGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgY29tcGxldGVkU2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2VnbWVudCA9IGNvbXBsZXRlZFNlZ21lbnRzW2ldO1xuICAgIGZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgYm91bmRhcnksIHNlZ21lbnQpO1xuICB9XG5cbiAgY29tcGxldGVkU2VnbWVudHMubGVuZ3RoID0gMDtcbiAgcmV0dXJuIHdyaXRlQ29tcGxldGVkQm91bmRhcnlJbnN0cnVjdGlvbihkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXNwb25zZVN0YXRlLCBib3VuZGFyeS5pZCwgYm91bmRhcnkucm9vdFNlZ21lbnRJRCk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUGFydGlhbEJvdW5kYXJ5KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBib3VuZGFyeSkge1xuICB2YXIgY29tcGxldGVkU2VnbWVudHMgPSBib3VuZGFyeS5jb21wbGV0ZWRTZWdtZW50cztcbiAgdmFyIGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgY29tcGxldGVkU2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2VnbWVudCA9IGNvbXBsZXRlZFNlZ21lbnRzW2ldO1xuXG4gICAgaWYgKCFmbHVzaFBhcnRpYWxseUNvbXBsZXRlZFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIGJvdW5kYXJ5LCBzZWdtZW50KSkge1xuICAgICAgaSsrO1xuICAgICAgY29tcGxldGVkU2VnbWVudHMuc3BsaWNlKDAsIGkpOyAvLyBPbmx5IHdyaXRlIGFzIG11Y2ggYXMgdGhlIGJ1ZmZlciB3YW50cy4gU29tZXRoaW5nIGhpZ2hlciBwcmlvcml0eVxuICAgICAgLy8gbWlnaHQgd2FudCB0byB3cml0ZSBsYXRlci5cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBsZXRlZFNlZ21lbnRzLnNwbGljZSgwLCBpKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgYm91bmRhcnksIHNlZ21lbnQpIHtcbiAgaWYgKHNlZ21lbnQuc3RhdHVzID09PSBGTFVTSEVEKSB7XG4gICAgLy8gV2UndmUgYWxyZWFkeSBmbHVzaGVkIHRoaXMgaW5saW5lLlxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIHNlZ21lbnRJRCA9IHNlZ21lbnQuaWQ7XG5cbiAgaWYgKHNlZ21lbnRJRCA9PT0gLTEpIHtcbiAgICAvLyBUaGlzIHNlZ21lbnQgd2Fzbid0IHByZXZpb3VzbHkgcmVmZXJyZWQgdG8uIFRoaXMgaGFwcGVucyBhdCB0aGUgcm9vdCBvZlxuICAgIC8vIGEgYm91bmRhcnkuIFdlIG1ha2Uga2luZCBvZiBhIGxlYXAgaGVyZSBhbmQgYXNzdW1lIHRoaXMgaXMgdGhlIHJvb3QuXG4gICAgdmFyIHJvb3RTZWdtZW50SUQgPSBzZWdtZW50LmlkID0gYm91bmRhcnkucm9vdFNlZ21lbnRJRDtcblxuICAgIGlmIChyb290U2VnbWVudElEID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHJvb3Qgc2VnbWVudCBJRCBtdXN0IGhhdmUgYmVlbiBhc3NpZ25lZCBieSBub3cuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZsdXNoU2VnbWVudENvbnRhaW5lcihyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgZmx1c2hTZWdtZW50Q29udGFpbmVyKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KTtcbiAgICByZXR1cm4gd3JpdGVDb21wbGV0ZWRTZWdtZW50SW5zdHJ1Y3Rpb24oZGVzdGluYXRpb24sIHJlcXVlc3QucmVzcG9uc2VTdGF0ZSwgc2VnbWVudElEKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaENvbXBsZXRlZFF1ZXVlcyhyZXF1ZXN0LCBkZXN0aW5hdGlvbikge1xuXG4gIHRyeSB7XG4gICAgLy8gVGhlIHN0cnVjdHVyZSBvZiB0aGlzIGlzIHRvIGdvIHRocm91Z2ggZWFjaCBxdWV1ZSBvbmUgYnkgb25lIGFuZCB3cml0ZVxuICAgIC8vIHVudGlsIHRoZSBzaW5rIHRlbGxzIHVzIHRvIHN0b3AuIFdoZW4gd2Ugc2hvdWxkIHN0b3AsIHdlIHN0aWxsIGZpbmlzaCB3cml0aW5nXG4gICAgLy8gdGhhdCBpdGVtIGZ1bGx5IGFuZCB0aGVuIHlpZWxkLiBBdCB0aGF0IHBvaW50IHdlIHJlbW92ZSB0aGUgYWxyZWFkeSBjb21wbGV0ZWRcbiAgICAvLyBpdGVtcyB1cCB1bnRpbCB0aGUgcG9pbnQgd2UgY29tcGxldGVkIHRoZW0uXG4gICAgLy8gVE9ETzogRW1pdCBwcmVsb2FkaW5nLlxuICAgIC8vIFRPRE86IEl0J3Mga2luZCBvZiB1bmZvcnR1bmF0ZSB0byBrZWVwIGNoZWNraW5nIHRoaXMgYXJyYXkgYWZ0ZXIgd2UndmUgYWxyZWFkeVxuICAgIC8vIGVtaXR0ZWQgdGhlIHJvb3QuXG4gICAgdmFyIGNvbXBsZXRlZFJvb3RTZWdtZW50ID0gcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudDtcblxuICAgIGlmIChjb21wbGV0ZWRSb290U2VnbWVudCAhPT0gbnVsbCAmJiByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MgPT09IDApIHtcbiAgICAgIGZsdXNoU2VnbWVudChyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgY29tcGxldGVkUm9vdFNlZ21lbnQpO1xuICAgICAgcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudCA9IG51bGw7XG4gICAgICB3cml0ZUNvbXBsZXRlZFJvb3QoZGVzdGluYXRpb24sIHJlcXVlc3QucmVzcG9uc2VTdGF0ZSk7XG4gICAgfSAvLyBXZSBlbWl0IGNsaWVudCByZW5kZXJpbmcgaW5zdHJ1Y3Rpb25zIGZvciBhbHJlYWR5IGVtaXR0ZWQgYm91bmRhcmllcyBmaXJzdC5cbiAgICAvLyBUaGlzIGlzIHNvIHRoYXQgd2UgY2FuIHNpZ25hbCB0byB0aGUgY2xpZW50IHRvIHN0YXJ0IGNsaWVudCByZW5kZXJpbmcgdGhlbSBhc1xuICAgIC8vIHNvb24gYXMgcG9zc2libGUuXG5cblxuICAgIHZhciBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMgPSByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcztcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBib3VuZGFyeSA9IGNsaWVudFJlbmRlcmVkQm91bmRhcmllc1tpXTtcblxuICAgICAgaWYgKCFmbHVzaENsaWVudFJlbmRlcmVkQm91bmRhcnkocmVxdWVzdCwgZGVzdGluYXRpb24sIGJvdW5kYXJ5KSkge1xuICAgICAgICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgICAgaSsrO1xuICAgICAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTsgLy8gTmV4dCB3ZSBlbWl0IGFueSBjb21wbGV0ZSBib3VuZGFyaWVzLiBJdCdzIGJldHRlciB0byBmYXZvciBib3VuZGFyaWVzXG4gICAgLy8gdGhhdCBhcmUgY29tcGxldGVseSBkb25lIHNpbmNlIHdlIGNhbiBhY3R1YWxseSBzaG93IHRoZW0sIHRoYW4gaXQgaXMgdG8gZW1pdFxuICAgIC8vIGFueSBpbmRpdmlkdWFsIHNlZ21lbnRzIGZyb20gYSBwYXJ0aWFsbHkgY29tcGxldGUgYm91bmRhcnkuXG5cbiAgICB2YXIgY29tcGxldGVkQm91bmRhcmllcyA9IHJlcXVlc3QuY29tcGxldGVkQm91bmRhcmllcztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb21wbGV0ZWRCb3VuZGFyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX2JvdW5kYXJ5ID0gY29tcGxldGVkQm91bmRhcmllc1tpXTtcblxuICAgICAgaWYgKCFmbHVzaENvbXBsZXRlZEJvdW5kYXJ5KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBfYm91bmRhcnkpKSB7XG4gICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICBpKys7XG4gICAgICAgIGNvbXBsZXRlZEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tcGxldGVkQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7IC8vIEFsbG93IGFueXRoaW5nIHdyaXR0ZW4gc28gZmFyIHRvIGZsdXNoIHRvIHRoZSB1bmRlcmx5aW5nIHNpbmsgYmVmb3JlXG4gICAgLy8gd2UgY29udGludWUgd2l0aCBsb3dlciBwcmlvcml0aWVzLlxuXG4gICAgY29tcGxldGVXcml0aW5nKGRlc3RpbmF0aW9uKTtcbiAgICBiZWdpbldyaXRpbmcoZGVzdGluYXRpb24pOyAvLyBUT0RPOiBIZXJlIHdlJ2xsIGVtaXQgZGF0YSB1c2VkIGJ5IGh5ZHJhdGlvbi5cbiAgICAvLyBOZXh0IHdlIGVtaXQgYW55IHNlZ21lbnRzIG9mIGFueSBib3VuZGFyaWVzIHRoYXQgYXJlIHBhcnRpYWxseSBjb21wbGV0ZVxuICAgIC8vIGJ1dCBub3QgZGVlcGx5IGNvbXBsZXRlLlxuXG4gICAgdmFyIHBhcnRpYWxCb3VuZGFyaWVzID0gcmVxdWVzdC5wYXJ0aWFsQm91bmRhcmllcztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0aWFsQm91bmRhcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9ib3VuZGFyeTIgPSBwYXJ0aWFsQm91bmRhcmllc1tpXTtcblxuICAgICAgaWYgKCFmbHVzaFBhcnRpYWxCb3VuZGFyeShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgX2JvdW5kYXJ5MikpIHtcbiAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgIGkrKztcbiAgICAgICAgcGFydGlhbEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFydGlhbEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpOyAvLyBOZXh0IHdlIGNoZWNrIHRoZSBjb21wbGV0ZWQgYm91bmRhcmllcyBhZ2Fpbi4gVGhpcyBtYXkgaGF2ZSBoYWRcbiAgICAvLyBib3VuZGFyaWVzIGFkZGVkIHRvIGl0IGluIGNhc2UgdGhleSB3ZXJlIHRvbyBsYXJnZWQgdG8gYmUgaW5saW5lZC5cbiAgICAvLyBOZXcgb25lcyBtaWdodCBiZSBhZGRlZCBpbiB0aGlzIGxvb3AuXG5cbiAgICB2YXIgbGFyZ2VCb3VuZGFyaWVzID0gcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxhcmdlQm91bmRhcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9ib3VuZGFyeTMgPSBsYXJnZUJvdW5kYXJpZXNbaV07XG5cbiAgICAgIGlmICghZmx1c2hDb21wbGV0ZWRCb3VuZGFyeShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgX2JvdW5kYXJ5MykpIHtcbiAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgIGkrKztcbiAgICAgICAgbGFyZ2VCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhcmdlQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gIH0gZmluYWxseSB7XG5cbiAgICBpZiAocmVxdWVzdC5hbGxQZW5kaW5nVGFza3MgPT09IDAgJiYgcmVxdWVzdC5waW5nZWRUYXNrcy5sZW5ndGggPT09IDAgJiYgcmVxdWVzdC5jbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMubGVuZ3RoID09PSAwICYmIHJlcXVlc3QuY29tcGxldGVkQm91bmRhcmllcy5sZW5ndGggPT09IDAgLy8gV2UgZG9uJ3QgbmVlZCB0byBjaGVjayBhbnkgcGFydGlhbGx5IGNvbXBsZXRlZCBzZWdtZW50cyBiZWNhdXNlXG4gICAgLy8gZWl0aGVyIHRoZXkgaGF2ZSBwZW5kaW5nIHRhc2sgb3IgdGhleSdyZSBjb21wbGV0ZS5cbiAgICApIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmIChyZXF1ZXN0LmFib3J0YWJsZVRhc2tzLnNpemUgIT09IDApIHtcbiAgICAgICAgICAgIGVycm9yKCdUaGVyZSB3YXMgc3RpbGwgYWJvcnRhYmxlIHRhc2sgYXQgdGhlIHJvb3Qgd2hlbiB3ZSBjbG9zZWQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFdlJ3JlIGRvbmUuXG5cblxuICAgICAgICBjbG9zZShkZXN0aW5hdGlvbik7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRXb3JrKHJlcXVlc3QpIHtcbiAgc2NoZWR1bGVXb3JrKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGVyZm9ybVdvcmsocmVxdWVzdCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gc3RhcnRGbG93aW5nKHJlcXVlc3QsIGRlc3RpbmF0aW9uKSB7XG4gIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gQ0xPU0lORykge1xuICAgIHJlcXVlc3Quc3RhdHVzID0gQ0xPU0VEO1xuICAgIGNsb3NlV2l0aEVycm9yKGRlc3RpbmF0aW9uLCByZXF1ZXN0LmZhdGFsRXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gQ0xPU0VEKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHJlcXVlc3QuZGVzdGluYXRpb24gIT09IG51bGwpIHtcbiAgICAvLyBXZSdyZSBhbHJlYWR5IGZsb3dpbmcuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuXG4gIHRyeSB7XG4gICAgZmx1c2hDb21wbGV0ZWRRdWV1ZXMocmVxdWVzdCwgZGVzdGluYXRpb24pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICAgIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICB9XG59IC8vIFRoaXMgaXMgY2FsbGVkIHRvIGVhcmx5IHRlcm1pbmF0ZSBhIHJlcXVlc3QuIEl0IHB1dHMgYWxsIHBlbmRpbmcgYm91bmRhcmllcyBpbiBjbGllbnQgcmVuZGVyZWQgc3RhdGUuXG5cbmZ1bmN0aW9uIGFib3J0KHJlcXVlc3QsIHJlYXNvbikge1xuICB0cnkge1xuICAgIHZhciBhYm9ydGFibGVUYXNrcyA9IHJlcXVlc3QuYWJvcnRhYmxlVGFza3M7XG4gICAgYWJvcnRhYmxlVGFza3MuZm9yRWFjaChmdW5jdGlvbiAodGFzaykge1xuICAgICAgcmV0dXJuIGFib3J0VGFzayh0YXNrLCByZXF1ZXN0LCByZWFzb24pO1xuICAgIH0pO1xuICAgIGFib3J0YWJsZVRhc2tzLmNsZWFyKCk7XG5cbiAgICBpZiAocmVxdWVzdC5kZXN0aW5hdGlvbiAhPT0gbnVsbCkge1xuICAgICAgZmx1c2hDb21wbGV0ZWRRdWV1ZXMocmVxdWVzdCwgcmVxdWVzdC5kZXN0aW5hdGlvbik7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICAgIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uRXJyb3IoKSB7Ly8gTm9uLWZhdGFsIGVycm9ycyBhcmUgaWdub3JlZC5cbn1cblxuZnVuY3Rpb24gcmVuZGVyVG9TdHJpbmdJbXBsKGNoaWxkcmVuLCBvcHRpb25zLCBnZW5lcmF0ZVN0YXRpY01hcmt1cCwgYWJvcnRSZWFzb24pIHtcbiAgdmFyIGRpZEZhdGFsID0gZmFsc2U7XG4gIHZhciBmYXRhbEVycm9yID0gbnVsbDtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB2YXIgZGVzdGluYXRpb24gPSB7XG4gICAgcHVzaDogZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICBpZiAoY2h1bmsgIT09IG51bGwpIHtcbiAgICAgICAgcmVzdWx0ICs9IGNodW5rO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgZGlkRmF0YWwgPSB0cnVlO1xuICAgICAgZmF0YWxFcnJvciA9IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgdmFyIHJlYWR5VG9TdHJlYW0gPSBmYWxzZTtcblxuICBmdW5jdGlvbiBvblNoZWxsUmVhZHkoKSB7XG4gICAgcmVhZHlUb1N0cmVhbSA9IHRydWU7XG4gIH1cblxuICB2YXIgcmVxdWVzdCA9IGNyZWF0ZVJlcXVlc3QoY2hpbGRyZW4sIGNyZWF0ZVJlc3BvbnNlU3RhdGUkMShnZW5lcmF0ZVN0YXRpY01hcmt1cCwgb3B0aW9ucyA/IG9wdGlvbnMuaWRlbnRpZmllclByZWZpeCA6IHVuZGVmaW5lZCksIGNyZWF0ZVJvb3RGb3JtYXRDb250ZXh0KCksIEluZmluaXR5LCBvbkVycm9yLCB1bmRlZmluZWQsIG9uU2hlbGxSZWFkeSwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICBzdGFydFdvcmsocmVxdWVzdCk7IC8vIElmIGFueXRoaW5nIHN1c3BlbmRlZCBhbmQgaXMgc3RpbGwgcGVuZGluZywgd2UnbGwgYWJvcnQgaXQgYmVmb3JlIHdyaXRpbmcuXG4gIC8vIFRoYXQgd2F5IHdlIHdyaXRlIG9ubHkgY2xpZW50LXJlbmRlcmVkIGJvdW5kYXJpZXMgZnJvbSB0aGUgc3RhcnQuXG5cbiAgYWJvcnQocmVxdWVzdCwgYWJvcnRSZWFzb24pO1xuICBzdGFydEZsb3dpbmcocmVxdWVzdCwgZGVzdGluYXRpb24pO1xuXG4gIGlmIChkaWRGYXRhbCkge1xuICAgIHRocm93IGZhdGFsRXJyb3I7XG4gIH1cblxuICBpZiAoIXJlYWR5VG9TdHJlYW0pIHtcbiAgICAvLyBOb3RlOiBUaGlzIGVycm9yIG1lc3NhZ2UgaXMgdGhlIG9uZSB3ZSB1c2Ugb24gdGhlIGNsaWVudC4gSXQgZG9lc24ndFxuICAgIC8vIHJlYWxseSBtYWtlIHNlbnNlIGhlcmUuIEJ1dCB0aGlzIGlzIHRoZSBsZWdhY3kgc2VydmVyIHJlbmRlcmVyLCBhbnl3YXkuXG4gICAgLy8gV2UncmUgZ29pbmcgdG8gZGVsZXRlIGl0IHNvb24uXG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIGNvbXBvbmVudCBzdXNwZW5kZWQgd2hpbGUgcmVzcG9uZGluZyB0byBzeW5jaHJvbm91cyBpbnB1dC4gVGhpcyAnICsgJ3dpbGwgY2F1c2UgdGhlIFVJIHRvIGJlIHJlcGxhY2VkIHdpdGggYSBsb2FkaW5nIGluZGljYXRvci4gVG8gZml4LCAnICsgJ3VwZGF0ZXMgdGhhdCBzdXNwZW5kIHNob3VsZCBiZSB3cmFwcGVkIHdpdGggc3RhcnRUcmFuc2l0aW9uLicpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuXG52YXIgUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWRhYmxlKSB7XG4gIF9pbmhlcml0c0xvb3NlKFJlYWN0TWFya3VwUmVhZGFibGVTdHJlYW0sIF9SZWFkYWJsZSk7XG5cbiAgZnVuY3Rpb24gUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbSgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICAvLyBDYWxscyB0aGUgc3RyZWFtLlJlYWRhYmxlKG9wdGlvbnMpIGNvbnN0cnVjdG9yLiBDb25zaWRlciBleHBvc2luZyBidWlsdC1pblxuICAgIC8vIGZlYXR1cmVzIGxpa2UgaGlnaFdhdGVyTWFyayBpbiB0aGUgZnV0dXJlLlxuICAgIF90aGlzID0gX1JlYWRhYmxlLmNhbGwodGhpcywge30pIHx8IHRoaXM7XG4gICAgX3RoaXMucmVxdWVzdCA9IG51bGw7XG4gICAgX3RoaXMuc3RhcnRlZEZsb3dpbmcgPSBmYWxzZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9kZXN0cm95ID0gZnVuY3Rpb24gX2Rlc3Ryb3koZXJyLCBjYWxsYmFjaykge1xuICAgIGFib3J0KHRoaXMucmVxdWVzdCk7IC8vICRGbG93Rml4TWU6IFRoZSB0eXBlIGRlZmluaXRpb24gZm9yIHRoZSBjYWxsYmFjayBzaG91bGQgYWxsb3cgdW5kZWZpbmVkIGFuZCBudWxsLlxuXG4gICAgY2FsbGJhY2soZXJyKTtcbiAgfTtcblxuICBfcHJvdG8uX3JlYWQgPSBmdW5jdGlvbiBfcmVhZChzaXplKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRlZEZsb3dpbmcpIHtcbiAgICAgIHN0YXJ0Rmxvd2luZyh0aGlzLnJlcXVlc3QsIHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbTtcbn0oc3RyZWFtLlJlYWRhYmxlKTtcblxuZnVuY3Rpb24gb25FcnJvciQxKCkgey8vIE5vbi1mYXRhbCBlcnJvcnMgYXJlIGlnbm9yZWQuXG59XG5cbmZ1bmN0aW9uIHJlbmRlclRvTm9kZVN0cmVhbUltcGwoY2hpbGRyZW4sIG9wdGlvbnMsIGdlbmVyYXRlU3RhdGljTWFya3VwKSB7XG4gIGZ1bmN0aW9uIG9uQWxsUmVhZHkoKSB7XG4gICAgLy8gV2Ugd2FpdCB1bnRpbCBldmVyeXRoaW5nIGhhcyBsb2FkZWQgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLlxuICAgIC8vIFRoYXQgd2F5IHdlIG9ubHkgZW5kIHVwIHdpdGggZnVsbHkgcmVzb2x2ZWQgSFRNTCBldmVuIGlmIHdlIHN1c3BlbmQuXG4gICAgZGVzdGluYXRpb24uc3RhcnRlZEZsb3dpbmcgPSB0cnVlO1xuICAgIHN0YXJ0Rmxvd2luZyhyZXF1ZXN0LCBkZXN0aW5hdGlvbik7XG4gIH1cblxuICB2YXIgZGVzdGluYXRpb24gPSBuZXcgUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbSgpO1xuICB2YXIgcmVxdWVzdCA9IGNyZWF0ZVJlcXVlc3QoY2hpbGRyZW4sIGNyZWF0ZVJlc3BvbnNlU3RhdGUkMShmYWxzZSwgb3B0aW9ucyA/IG9wdGlvbnMuaWRlbnRpZmllclByZWZpeCA6IHVuZGVmaW5lZCksIGNyZWF0ZVJvb3RGb3JtYXRDb250ZXh0KCksIEluZmluaXR5LCBvbkVycm9yJDEsIG9uQWxsUmVhZHksIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgZGVzdGluYXRpb24ucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIHN0YXJ0V29yayhyZXF1ZXN0KTtcbiAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufVxuXG5mdW5jdGlvbiByZW5kZXJUb05vZGVTdHJlYW0oY2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAge1xuICAgIGVycm9yKCdyZW5kZXJUb05vZGVTdHJlYW0gaXMgZGVwcmVjYXRlZC4gVXNlIHJlbmRlclRvUGlwZWFibGVTdHJlYW0gaW5zdGVhZC4nKTtcbiAgfVxuXG4gIHJldHVybiByZW5kZXJUb05vZGVTdHJlYW1JbXBsKGNoaWxkcmVuLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyVG9TdGF0aWNOb2RlU3RyZWFtKGNoaWxkcmVuLCBvcHRpb25zKSB7XG4gIHJldHVybiByZW5kZXJUb05vZGVTdHJlYW1JbXBsKGNoaWxkcmVuLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyVG9TdHJpbmcoY2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHJlbmRlclRvU3RyaW5nSW1wbChjaGlsZHJlbiwgb3B0aW9ucywgZmFsc2UsICdUaGUgc2VydmVyIHVzZWQgXCJyZW5kZXJUb1N0cmluZ1wiIHdoaWNoIGRvZXMgbm90IHN1cHBvcnQgU3VzcGVuc2UuIElmIHlvdSBpbnRlbmRlZCBmb3IgdGhpcyBTdXNwZW5zZSBib3VuZGFyeSB0byByZW5kZXIgdGhlIGZhbGxiYWNrIGNvbnRlbnQgb24gdGhlIHNlcnZlciBjb25zaWRlciB0aHJvd2luZyBhbiBFcnJvciBzb21ld2hlcmUgd2l0aGluIHRoZSBTdXNwZW5zZSBib3VuZGFyeS4gSWYgeW91IGludGVuZGVkIHRvIGhhdmUgdGhlIHNlcnZlciB3YWl0IGZvciB0aGUgc3VzcGVuZGVkIGNvbXBvbmVudCBwbGVhc2Ugc3dpdGNoIHRvIFwicmVuZGVyVG9QaXBlYWJsZVN0cmVhbVwiIHdoaWNoIHN1cHBvcnRzIFN1c3BlbnNlIG9uIHRoZSBzZXJ2ZXInKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyVG9TdGF0aWNNYXJrdXAoY2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHJlbmRlclRvU3RyaW5nSW1wbChjaGlsZHJlbiwgb3B0aW9ucywgdHJ1ZSwgJ1RoZSBzZXJ2ZXIgdXNlZCBcInJlbmRlclRvU3RhdGljTWFya3VwXCIgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCBTdXNwZW5zZS4gSWYgeW91IGludGVuZGVkIHRvIGhhdmUgdGhlIHNlcnZlciB3YWl0IGZvciB0aGUgc3VzcGVuZGVkIGNvbXBvbmVudCBwbGVhc2Ugc3dpdGNoIHRvIFwicmVuZGVyVG9QaXBlYWJsZVN0cmVhbVwiIHdoaWNoIHN1cHBvcnRzIFN1c3BlbnNlIG9uIHRoZSBzZXJ2ZXInKTtcbn1cblxuZXhwb3J0cy5yZW5kZXJUb05vZGVTdHJlYW0gPSByZW5kZXJUb05vZGVTdHJlYW07XG5leHBvcnRzLnJlbmRlclRvU3RhdGljTWFya3VwID0gcmVuZGVyVG9TdGF0aWNNYXJrdXA7XG5leHBvcnRzLnJlbmRlclRvU3RhdGljTm9kZVN0cmVhbSA9IHJlbmRlclRvU3RhdGljTm9kZVN0cmVhbTtcbmV4cG9ydHMucmVuZGVyVG9TdHJpbmcgPSByZW5kZXJUb1N0cmluZztcbmV4cG9ydHMudmVyc2lvbiA9IFJlYWN0VmVyc2lvbjtcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiUmVhY3QiLCJyZXF1aXJlIiwic3RyZWFtIiwiUmVhY3RWZXJzaW9uIiwiUmVhY3RTaGFyZWRJbnRlcm5hbHMiLCJfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsIndhcm4iLCJmb3JtYXQiLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJncyIsIkFycmF5IiwiX2tleSIsInByaW50V2FybmluZyIsImVycm9yIiwiX2xlbjIiLCJfa2V5MiIsImxldmVsIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSIsInN0YWNrIiwiZ2V0U3RhY2tBZGRlbmR1bSIsImNvbmNhdCIsImFyZ3NXaXRoRm9ybWF0IiwibWFwIiwiaXRlbSIsIlN0cmluZyIsInVuc2hpZnQiLCJGdW5jdGlvbiIsInByb3RvdHlwZSIsImFwcGx5IiwiY2FsbCIsImNvbnNvbGUiLCJzY2hlZHVsZVdvcmsiLCJjYWxsYmFjayIsImJlZ2luV3JpdGluZyIsImRlc3RpbmF0aW9uIiwid3JpdGVDaHVuayIsImNodW5rIiwid3JpdGVDaHVua0FuZFJldHVybiIsInB1c2giLCJjb21wbGV0ZVdyaXRpbmciLCJjbG9zZSIsInN0cmluZ1RvQ2h1bmsiLCJjb250ZW50Iiwic3RyaW5nVG9QcmVjb21wdXRlZENodW5rIiwiY2xvc2VXaXRoRXJyb3IiLCJkZXN0cm95IiwidHlwZU5hbWUiLCJ2YWx1ZSIsImhhc1RvU3RyaW5nVGFnIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ0eXBlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwid2lsbENvZXJjaW9uVGhyb3ciLCJ0ZXN0U3RyaW5nQ29lcmNpb24iLCJlIiwiY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbiIsImF0dHJpYnV0ZU5hbWUiLCJjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24iLCJwcm9wTmFtZSIsImNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uIiwiaGFzT3duUHJvcGVydHkiLCJPYmplY3QiLCJSRVNFUlZFRCIsIlNUUklORyIsIkJPT0xFQU5JU0hfU1RSSU5HIiwiQk9PTEVBTiIsIk9WRVJMT0FERURfQk9PTEVBTiIsIk5VTUVSSUMiLCJQT1NJVElWRV9OVU1FUklDIiwiQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiIsIkFUVFJJQlVURV9OQU1FX0NIQVIiLCJWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCIsIlJlZ0V4cCIsImlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUiLCJ2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUiLCJpc0F0dHJpYnV0ZU5hbWVTYWZlIiwidGVzdCIsInNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nIiwicHJvcGVydHlJbmZvIiwiaXNDdXN0b21Db21wb25lbnRUYWciLCJhY2NlcHRzQm9vbGVhbnMiLCJwcmVmaXgiLCJ0b0xvd2VyQ2FzZSIsInNsaWNlIiwiZ2V0UHJvcGVydHlJbmZvIiwicHJvcGVydGllcyIsIlByb3BlcnR5SW5mb1JlY29yZCIsIm11c3RVc2VQcm9wZXJ0eSIsImF0dHJpYnV0ZU5hbWVzcGFjZSIsInNhbml0aXplVVJMIiwicmVtb3ZlRW1wdHlTdHJpbmciLCJwcm9wZXJ0eU5hbWUiLCJyZXNlcnZlZFByb3BzIiwiZm9yRWFjaCIsIl9yZWYiLCJDQU1FTElaRSIsImNhcGl0YWxpemUiLCJ0b2tlbiIsInRvVXBwZXJDYXNlIiwicmVwbGFjZSIsInhsaW5rSHJlZiIsImlzVW5pdGxlc3NOdW1iZXIiLCJhbmltYXRpb25JdGVyYXRpb25Db3VudCIsImFzcGVjdFJhdGlvIiwiYm9yZGVySW1hZ2VPdXRzZXQiLCJib3JkZXJJbWFnZVNsaWNlIiwiYm9yZGVySW1hZ2VXaWR0aCIsImJveEZsZXgiLCJib3hGbGV4R3JvdXAiLCJib3hPcmRpbmFsR3JvdXAiLCJjb2x1bW5Db3VudCIsImNvbHVtbnMiLCJmbGV4IiwiZmxleEdyb3ciLCJmbGV4UG9zaXRpdmUiLCJmbGV4U2hyaW5rIiwiZmxleE5lZ2F0aXZlIiwiZmxleE9yZGVyIiwiZ3JpZEFyZWEiLCJncmlkUm93IiwiZ3JpZFJvd0VuZCIsImdyaWRSb3dTcGFuIiwiZ3JpZFJvd1N0YXJ0IiwiZ3JpZENvbHVtbiIsImdyaWRDb2x1bW5FbmQiLCJncmlkQ29sdW1uU3BhbiIsImdyaWRDb2x1bW5TdGFydCIsImZvbnRXZWlnaHQiLCJsaW5lQ2xhbXAiLCJsaW5lSGVpZ2h0Iiwib3BhY2l0eSIsIm9yZGVyIiwib3JwaGFucyIsInRhYlNpemUiLCJ3aWRvd3MiLCJ6SW5kZXgiLCJ6b29tIiwiZmlsbE9wYWNpdHkiLCJmbG9vZE9wYWNpdHkiLCJzdG9wT3BhY2l0eSIsInN0cm9rZURhc2hhcnJheSIsInN0cm9rZURhc2hvZmZzZXQiLCJzdHJva2VNaXRlcmxpbWl0Iiwic3Ryb2tlT3BhY2l0eSIsInN0cm9rZVdpZHRoIiwicHJlZml4S2V5Iiwia2V5IiwiY2hhckF0Iiwic3Vic3RyaW5nIiwicHJlZml4ZXMiLCJrZXlzIiwicHJvcCIsImhhc1JlYWRPbmx5VmFsdWUiLCJidXR0b24iLCJjaGVja2JveCIsImltYWdlIiwiaGlkZGVuIiwicmFkaW8iLCJyZXNldCIsInN1Ym1pdCIsImNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMiLCJ0YWdOYW1lIiwicHJvcHMiLCJvbkNoYW5nZSIsIm9uSW5wdXQiLCJyZWFkT25seSIsImRpc2FibGVkIiwiY2hlY2tlZCIsImlzQ3VzdG9tQ29tcG9uZW50IiwiaW5kZXhPZiIsImlzIiwiYXJpYVByb3BlcnRpZXMiLCJ3YXJuZWRQcm9wZXJ0aWVzIiwickFSSUEiLCJyQVJJQUNhbWVsIiwidmFsaWRhdGVQcm9wZXJ0eSIsImFyaWFOYW1lIiwiY29ycmVjdE5hbWUiLCJsb3dlckNhc2VkTmFtZSIsInN0YW5kYXJkTmFtZSIsIndhcm5JbnZhbGlkQVJJQVByb3BzIiwiaW52YWxpZFByb3BzIiwiaXNWYWxpZCIsInVua25vd25Qcm9wU3RyaW5nIiwiam9pbiIsInZhbGlkYXRlUHJvcGVydGllcyIsImRpZFdhcm5WYWx1ZU51bGwiLCJ2YWxpZGF0ZVByb3BlcnRpZXMkMSIsIm11bHRpcGxlIiwicG9zc2libGVTdGFuZGFyZE5hbWVzIiwiYWNjZXB0IiwiYWNjZXB0Y2hhcnNldCIsImFjY2Vzc2tleSIsImFjdGlvbiIsImFsbG93ZnVsbHNjcmVlbiIsImFsdCIsImFzIiwiYXN5bmMiLCJhdXRvY2FwaXRhbGl6ZSIsImF1dG9jb21wbGV0ZSIsImF1dG9jb3JyZWN0IiwiYXV0b2ZvY3VzIiwiYXV0b3BsYXkiLCJhdXRvc2F2ZSIsImNhcHR1cmUiLCJjZWxscGFkZGluZyIsImNlbGxzcGFjaW5nIiwiY2hhbGxlbmdlIiwiY2hhcnNldCIsImNoaWxkcmVuIiwiY2l0ZSIsImNsYXNzIiwiY2xhc3NpZCIsImNsYXNzbmFtZSIsImNvbHMiLCJjb2xzcGFuIiwiY29udGVudGVkaXRhYmxlIiwiY29udGV4dG1lbnUiLCJjb250cm9scyIsImNvbnRyb2xzbGlzdCIsImNvb3JkcyIsImNyb3Nzb3JpZ2luIiwiZGFuZ2Vyb3VzbHlzZXRpbm5lcmh0bWwiLCJkYXRhIiwiZGF0ZXRpbWUiLCJkZWZhdWx0IiwiZGVmYXVsdGNoZWNrZWQiLCJkZWZhdWx0dmFsdWUiLCJkZWZlciIsImRpciIsImRpc2FibGVwaWN0dXJlaW5waWN0dXJlIiwiZGlzYWJsZXJlbW90ZXBsYXliYWNrIiwiZG93bmxvYWQiLCJkcmFnZ2FibGUiLCJlbmN0eXBlIiwiZW50ZXJrZXloaW50IiwiZm9yIiwiZm9ybSIsImZvcm1tZXRob2QiLCJmb3JtYWN0aW9uIiwiZm9ybWVuY3R5cGUiLCJmb3Jtbm92YWxpZGF0ZSIsImZvcm10YXJnZXQiLCJmcmFtZWJvcmRlciIsImhlYWRlcnMiLCJoZWlnaHQiLCJoaWdoIiwiaHJlZiIsImhyZWZsYW5nIiwiaHRtbGZvciIsImh0dHBlcXVpdiIsImljb24iLCJpZCIsImltYWdlc2l6ZXMiLCJpbWFnZXNyY3NldCIsImlubmVyaHRtbCIsImlucHV0bW9kZSIsImludGVncml0eSIsIml0ZW1pZCIsIml0ZW1wcm9wIiwiaXRlbXJlZiIsIml0ZW1zY29wZSIsIml0ZW10eXBlIiwia2V5cGFyYW1zIiwia2V5dHlwZSIsImtpbmQiLCJsYWJlbCIsImxhbmciLCJsaXN0IiwibG9vcCIsImxvdyIsIm1hbmlmZXN0IiwibWFyZ2lud2lkdGgiLCJtYXJnaW5oZWlnaHQiLCJtYXgiLCJtYXhsZW5ndGgiLCJtZWRpYSIsIm1lZGlhZ3JvdXAiLCJtZXRob2QiLCJtaW4iLCJtaW5sZW5ndGgiLCJtdXRlZCIsIm5vbW9kdWxlIiwibm9uY2UiLCJub3ZhbGlkYXRlIiwib3BlbiIsIm9wdGltdW0iLCJwYXR0ZXJuIiwicGxhY2Vob2xkZXIiLCJwbGF5c2lubGluZSIsInBvc3RlciIsInByZWxvYWQiLCJwcm9maWxlIiwicmFkaW9ncm91cCIsInJlYWRvbmx5IiwicmVmZXJyZXJwb2xpY3kiLCJyZWwiLCJyZXF1aXJlZCIsInJldmVyc2VkIiwicm9sZSIsInJvd3MiLCJyb3dzcGFuIiwic2FuZGJveCIsInNjb3BlIiwic2NvcGVkIiwic2Nyb2xsaW5nIiwic2VhbWxlc3MiLCJzZWxlY3RlZCIsInNoYXBlIiwic2l6ZSIsInNpemVzIiwic3BhbiIsInNwZWxsY2hlY2siLCJzcmMiLCJzcmNkb2MiLCJzcmNsYW5nIiwic3Jjc2V0Iiwic3RhcnQiLCJzdGVwIiwic3R5bGUiLCJzdW1tYXJ5IiwidGFiaW5kZXgiLCJ0YXJnZXQiLCJ0aXRsZSIsInVzZW1hcCIsIndpZHRoIiwid21vZGUiLCJ3cmFwIiwiYWJvdXQiLCJhY2NlbnRoZWlnaHQiLCJhY2N1bXVsYXRlIiwiYWRkaXRpdmUiLCJhbGlnbm1lbnRiYXNlbGluZSIsImFsbG93cmVvcmRlciIsImFscGhhYmV0aWMiLCJhbXBsaXR1ZGUiLCJhcmFiaWNmb3JtIiwiYXNjZW50IiwiYXR0cmlidXRlbmFtZSIsImF0dHJpYnV0ZXR5cGUiLCJhdXRvcmV2ZXJzZSIsImF6aW11dGgiLCJiYXNlZnJlcXVlbmN5IiwiYmFzZWxpbmVzaGlmdCIsImJhc2Vwcm9maWxlIiwiYmJveCIsImJlZ2luIiwiYmlhcyIsImJ5IiwiY2FsY21vZGUiLCJjYXBoZWlnaHQiLCJjbGlwIiwiY2xpcHBhdGgiLCJjbGlwcGF0aHVuaXRzIiwiY2xpcHJ1bGUiLCJjb2xvciIsImNvbG9yaW50ZXJwb2xhdGlvbiIsImNvbG9yaW50ZXJwb2xhdGlvbmZpbHRlcnMiLCJjb2xvcnByb2ZpbGUiLCJjb2xvcnJlbmRlcmluZyIsImNvbnRlbnRzY3JpcHR0eXBlIiwiY29udGVudHN0eWxldHlwZSIsImN1cnNvciIsImN4IiwiY3kiLCJkIiwiZGF0YXR5cGUiLCJkZWNlbGVyYXRlIiwiZGVzY2VudCIsImRpZmZ1c2Vjb25zdGFudCIsImRpcmVjdGlvbiIsImRpc3BsYXkiLCJkaXZpc29yIiwiZG9taW5hbnRiYXNlbGluZSIsImR1ciIsImR4IiwiZHkiLCJlZGdlbW9kZSIsImVsZXZhdGlvbiIsImVuYWJsZWJhY2tncm91bmQiLCJlbmQiLCJleHBvbmVudCIsImV4dGVybmFscmVzb3VyY2VzcmVxdWlyZWQiLCJmaWxsIiwiZmlsbG9wYWNpdHkiLCJmaWxscnVsZSIsImZpbHRlciIsImZpbHRlcnJlcyIsImZpbHRlcnVuaXRzIiwiZmxvb2RvcGFjaXR5IiwiZmxvb2Rjb2xvciIsImZvY3VzYWJsZSIsImZvbnRmYW1pbHkiLCJmb250c2l6ZSIsImZvbnRzaXplYWRqdXN0IiwiZm9udHN0cmV0Y2giLCJmb250c3R5bGUiLCJmb250dmFyaWFudCIsImZvbnR3ZWlnaHQiLCJmcm9tIiwiZngiLCJmeSIsImcxIiwiZzIiLCJnbHlwaG5hbWUiLCJnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbCIsImdseXBob3JpZW50YXRpb252ZXJ0aWNhbCIsImdseXBocmVmIiwiZ3JhZGllbnR0cmFuc2Zvcm0iLCJncmFkaWVudHVuaXRzIiwiaGFuZ2luZyIsImhvcml6YWR2eCIsImhvcml6b3JpZ2lueCIsImlkZW9ncmFwaGljIiwiaW1hZ2VyZW5kZXJpbmciLCJpbjIiLCJpbiIsImlubGlzdCIsImludGVyY2VwdCIsImsxIiwiazIiLCJrMyIsIms0IiwiayIsImtlcm5lbG1hdHJpeCIsImtlcm5lbHVuaXRsZW5ndGgiLCJrZXJuaW5nIiwia2V5cG9pbnRzIiwia2V5c3BsaW5lcyIsImtleXRpbWVzIiwibGVuZ3RoYWRqdXN0IiwibGV0dGVyc3BhY2luZyIsImxpZ2h0aW5nY29sb3IiLCJsaW1pdGluZ2NvbmVhbmdsZSIsImxvY2FsIiwibWFya2VyZW5kIiwibWFya2VyaGVpZ2h0IiwibWFya2VybWlkIiwibWFya2Vyc3RhcnQiLCJtYXJrZXJ1bml0cyIsIm1hcmtlcndpZHRoIiwibWFzayIsIm1hc2tjb250ZW50dW5pdHMiLCJtYXNrdW5pdHMiLCJtYXRoZW1hdGljYWwiLCJtb2RlIiwibnVtb2N0YXZlcyIsIm9mZnNldCIsIm9wZXJhdG9yIiwib3JpZW50Iiwib3JpZW50YXRpb24iLCJvcmlnaW4iLCJvdmVyZmxvdyIsIm92ZXJsaW5lcG9zaXRpb24iLCJvdmVybGluZXRoaWNrbmVzcyIsInBhaW50b3JkZXIiLCJwYW5vc2UxIiwicGF0aGxlbmd0aCIsInBhdHRlcm5jb250ZW50dW5pdHMiLCJwYXR0ZXJudHJhbnNmb3JtIiwicGF0dGVybnVuaXRzIiwicG9pbnRlcmV2ZW50cyIsInBvaW50cyIsInBvaW50c2F0eCIsInBvaW50c2F0eSIsInBvaW50c2F0eiIsInByZXNlcnZlYWxwaGEiLCJwcmVzZXJ2ZWFzcGVjdHJhdGlvIiwicHJpbWl0aXZldW5pdHMiLCJwcm9wZXJ0eSIsInIiLCJyYWRpdXMiLCJyZWZ4IiwicmVmeSIsInJlbmRlcmluZ2ludGVudCIsInJlcGVhdGNvdW50IiwicmVwZWF0ZHVyIiwicmVxdWlyZWRleHRlbnNpb25zIiwicmVxdWlyZWRmZWF0dXJlcyIsInJlc291cmNlIiwicmVzdGFydCIsInJlc3VsdCIsInJlc3VsdHMiLCJyb3RhdGUiLCJyeCIsInJ5Iiwic2NhbGUiLCJzZWN1cml0eSIsInNlZWQiLCJzaGFwZXJlbmRlcmluZyIsInNsb3BlIiwic3BhY2luZyIsInNwZWN1bGFyY29uc3RhbnQiLCJzcGVjdWxhcmV4cG9uZW50Iiwic3BlZWQiLCJzcHJlYWRtZXRob2QiLCJzdGFydG9mZnNldCIsInN0ZGRldmlhdGlvbiIsInN0ZW1oIiwic3RlbXYiLCJzdGl0Y2h0aWxlcyIsInN0b3Bjb2xvciIsInN0b3BvcGFjaXR5Iiwic3RyaWtldGhyb3VnaHBvc2l0aW9uIiwic3RyaWtldGhyb3VnaHRoaWNrbmVzcyIsInN0cmluZyIsInN0cm9rZSIsInN0cm9rZWRhc2hhcnJheSIsInN0cm9rZWRhc2hvZmZzZXQiLCJzdHJva2VsaW5lY2FwIiwic3Ryb2tlbGluZWpvaW4iLCJzdHJva2VtaXRlcmxpbWl0Iiwic3Ryb2tld2lkdGgiLCJzdHJva2VvcGFjaXR5Iiwic3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nIiwic3VwcHJlc3NoeWRyYXRpb253YXJuaW5nIiwic3VyZmFjZXNjYWxlIiwic3lzdGVtbGFuZ3VhZ2UiLCJ0YWJsZXZhbHVlcyIsInRhcmdldHgiLCJ0YXJnZXR5IiwidGV4dGFuY2hvciIsInRleHRkZWNvcmF0aW9uIiwidGV4dGxlbmd0aCIsInRleHRyZW5kZXJpbmciLCJ0byIsInRyYW5zZm9ybSIsInR5cGVvZiIsInUxIiwidTIiLCJ1bmRlcmxpbmVwb3NpdGlvbiIsInVuZGVybGluZXRoaWNrbmVzcyIsInVuaWNvZGUiLCJ1bmljb2RlYmlkaSIsInVuaWNvZGVyYW5nZSIsInVuaXRzcGVyZW0iLCJ1bnNlbGVjdGFibGUiLCJ2YWxwaGFiZXRpYyIsInZhbHVlcyIsInZlY3RvcmVmZmVjdCIsInZlcnNpb24iLCJ2ZXJ0YWR2eSIsInZlcnRvcmlnaW54IiwidmVydG9yaWdpbnkiLCJ2aGFuZ2luZyIsInZpZGVvZ3JhcGhpYyIsInZpZXdib3giLCJ2aWV3dGFyZ2V0IiwidmlzaWJpbGl0eSIsInZtYXRoZW1hdGljYWwiLCJ2b2NhYiIsIndpZHRocyIsIndvcmRzcGFjaW5nIiwid3JpdGluZ21vZGUiLCJ4MSIsIngyIiwieCIsInhjaGFubmVsc2VsZWN0b3IiLCJ4aGVpZ2h0IiwieGxpbmthY3R1YXRlIiwieGxpbmthcmNyb2xlIiwieGxpbmtocmVmIiwieGxpbmtyb2xlIiwieGxpbmtzaG93IiwieGxpbmt0aXRsZSIsInhsaW5rdHlwZSIsInhtbGJhc2UiLCJ4bWxsYW5nIiwieG1sbnMiLCJ4bWxuc3hsaW5rIiwieG1sc3BhY2UiLCJ5MSIsInkyIiwieSIsInljaGFubmVsc2VsZWN0b3IiLCJ6Iiwiem9vbWFuZHBhbiIsInZhbGlkYXRlUHJvcGVydHkkMSIsIndhcm5lZFByb3BlcnRpZXMkMSIsIkVWRU5UX05BTUVfUkVHRVgiLCJJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgiLCJyQVJJQSQxIiwickFSSUFDYW1lbCQxIiwiZXZlbnRSZWdpc3RyeSIsInJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMiLCJwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIiwicmVnaXN0cmF0aW9uTmFtZSIsInVuZGVmaW5lZCIsImlzTmFOIiwiaXNSZXNlcnZlZCIsIndhcm5Vbmtub3duUHJvcGVydGllcyIsInVua25vd25Qcm9wcyIsInZhbGlkYXRlUHJvcGVydGllcyQyIiwid2FyblZhbGlkU3R5bGUiLCJiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4iLCJtc1BhdHRlcm4iLCJoeXBoZW5QYXR0ZXJuIiwiYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuIiwid2FybmVkU3R5bGVOYW1lcyIsIndhcm5lZFN0eWxlVmFsdWVzIiwid2FybmVkRm9yTmFOVmFsdWUiLCJ3YXJuZWRGb3JJbmZpbml0eVZhbHVlIiwiY2FtZWxpemUiLCJfIiwiY2hhcmFjdGVyIiwid2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUiLCJ3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUiLCJ3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24iLCJ3YXJuU3R5bGVWYWx1ZUlzTmFOIiwid2FyblN0eWxlVmFsdWVJc0luZmluaXR5IiwiaXNGaW5pdGUiLCJ3YXJuVmFsaWRTdHlsZSQxIiwibWF0Y2hIdG1sUmVnRXhwIiwiZXNjYXBlSHRtbCIsInN0ciIsIm1hdGNoIiwiZXhlYyIsImVzY2FwZSIsImh0bWwiLCJpbmRleCIsImxhc3RJbmRleCIsImNoYXJDb2RlQXQiLCJlc2NhcGVUZXh0Rm9yQnJvd3NlciIsInRleHQiLCJ1cHBlcmNhc2VQYXR0ZXJuIiwibXNQYXR0ZXJuJDEiLCJoeXBoZW5hdGVTdHlsZU5hbWUiLCJpc0phdmFTY3JpcHRQcm90b2NvbCIsImRpZFdhcm4iLCJ1cmwiLCJKU09OIiwic3RyaW5naWZ5IiwiaXNBcnJheUltcGwiLCJpc0FycmF5IiwiYSIsInN0YXJ0SW5saW5lU2NyaXB0IiwiZW5kSW5saW5lU2NyaXB0Iiwic3RhcnRTY3JpcHRTcmMiLCJzdGFydE1vZHVsZVNyYyIsImVuZEFzeW5jU2NyaXB0IiwiZXNjYXBlQm9vdHN0cmFwU2NyaXB0Q29udGVudCIsInNjcmlwdFRleHQiLCJzY3JpcHRSZWdleCIsInNjcmlwdFJlcGxhY2VyIiwicyIsInN1ZmZpeCIsImNyZWF0ZVJlc3BvbnNlU3RhdGUiLCJpZGVudGlmaWVyUHJlZml4IiwiYm9vdHN0cmFwU2NyaXB0Q29udGVudCIsImJvb3RzdHJhcFNjcmlwdHMiLCJib290c3RyYXBNb2R1bGVzIiwiaWRQcmVmaXgiLCJpbmxpbmVTY3JpcHRXaXRoTm9uY2UiLCJib290c3RyYXBDaHVua3MiLCJpIiwiX2kiLCJwbGFjZWhvbGRlclByZWZpeCIsInNlZ21lbnRQcmVmaXgiLCJib3VuZGFyeVByZWZpeCIsIm5leHRTdXNwZW5zZUlEIiwic2VudENvbXBsZXRlU2VnbWVudEZ1bmN0aW9uIiwic2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbiIsInNlbnRDbGllbnRSZW5kZXJGdW5jdGlvbiIsIlJPT1RfSFRNTF9NT0RFIiwiSFRNTF9NT0RFIiwiU1ZHX01PREUiLCJNQVRITUxfTU9ERSIsIkhUTUxfVEFCTEVfTU9ERSIsIkhUTUxfVEFCTEVfQk9EWV9NT0RFIiwiSFRNTF9UQUJMRV9ST1dfTU9ERSIsIkhUTUxfQ09MR1JPVVBfTU9ERSIsImNyZWF0ZUZvcm1hdENvbnRleHQiLCJpbnNlcnRpb25Nb2RlIiwic2VsZWN0ZWRWYWx1ZSIsImdldENoaWxkRm9ybWF0Q29udGV4dCIsInBhcmVudENvbnRleHQiLCJkZWZhdWx0VmFsdWUiLCJVTklOSVRJQUxJWkVEX1NVU1BFTlNFX0JPVU5EQVJZX0lEIiwiYXNzaWduU3VzcGVuc2VCb3VuZGFyeUlEIiwicmVzcG9uc2VTdGF0ZSIsImdlbmVyYXRlZElEIiwidG9TdHJpbmciLCJtYWtlSWQiLCJ0cmVlSWQiLCJsb2NhbElkIiwiZW5jb2RlSFRNTFRleHROb2RlIiwidGV4dFNlcGFyYXRvciIsInB1c2hUZXh0SW5zdGFuY2UiLCJ0ZXh0RW1iZWRkZWQiLCJwdXNoU2VnbWVudEZpbmFsZSIsImxhc3RQdXNoZWRUZXh0Iiwic3R5bGVOYW1lQ2FjaGUiLCJNYXAiLCJwcm9jZXNzU3R5bGVOYW1lIiwic3R5bGVOYW1lIiwiZ2V0Iiwic2V0Iiwic3R5bGVBdHRyaWJ1dGVTdGFydCIsInN0eWxlQXNzaWduIiwic3R5bGVTZXBhcmF0b3IiLCJwdXNoU3R5bGUiLCJFcnJvciIsImlzRmlyc3QiLCJzdHlsZVZhbHVlIiwibmFtZUNodW5rIiwidmFsdWVDaHVuayIsImlzQ3VzdG9tUHJvcGVydHkiLCJ0cmltIiwiYXR0cmlidXRlRW5kIiwiYXR0cmlidXRlU2VwYXJhdG9yIiwiYXR0cmlidXRlQXNzaWduIiwiYXR0cmlidXRlRW1wdHlTdHJpbmciLCJwdXNoQXR0cmlidXRlIiwiYXR0cmlidXRlTmFtZUNodW5rIiwiZW5kT2ZTdGFydFRhZyIsImVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyIsInB1c2hJbm5lckhUTUwiLCJpbm5lckhUTUwiLCJfX2h0bWwiLCJkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUiLCJkaWRXYXJuRGVmYXVsdENoZWNrZWQiLCJkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlIiwiZGlkV2FybkRlZmF1bHRUZXh0YXJlYVZhbHVlIiwiZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiIsImRpZFdhcm5JbnZhbGlkT3B0aW9uSW5uZXJIVE1MIiwiZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24iLCJjaGVja1NlbGVjdFByb3AiLCJhcnJheSIsInB1c2hTdGFydFNlbGVjdCIsInN0YXJ0Q2h1bmtGb3JUYWciLCJwcm9wS2V5IiwicHJvcFZhbHVlIiwiZmxhdHRlbk9wdGlvbkNoaWxkcmVuIiwiQ2hpbGRyZW4iLCJjaGlsZCIsInNlbGVjdGVkTWFya2VyQXR0cmlidXRlIiwicHVzaFN0YXJ0T3B0aW9uIiwiZm9ybWF0Q29udGV4dCIsInN0cmluZ1ZhbHVlIiwidiIsInB1c2hJbnB1dCIsImRlZmF1bHRDaGVja2VkIiwicHVzaFN0YXJ0VGV4dEFyZWEiLCJsZWFkaW5nTmV3bGluZSIsInB1c2hTZWxmQ2xvc2luZyIsInRhZyIsInB1c2hTdGFydE1lbnVJdGVtIiwicHVzaFN0YXJ0VGl0bGUiLCIkJHR5cGVvZiIsInB1c2hTdGFydEdlbmVyaWNFbGVtZW50IiwicHVzaFN0YXJ0Q3VzdG9tRWxlbWVudCIsInB1c2hTdGFydFByZWZvcm1hdHRlZEVsZW1lbnQiLCJWQUxJRF9UQUdfUkVHRVgiLCJ2YWxpZGF0ZWRUYWdDYWNoZSIsInRhZ1N0YXJ0Q2h1bmsiLCJET0NUWVBFIiwicHVzaFN0YXJ0SW5zdGFuY2UiLCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmciLCJjb250ZW50RWRpdGFibGUiLCJlbmRUYWcxIiwiZW5kVGFnMiIsInB1c2hFbmRJbnN0YW5jZSIsIndyaXRlQ29tcGxldGVkUm9vdCIsInBsYWNlaG9sZGVyMSIsInBsYWNlaG9sZGVyMiIsIndyaXRlUGxhY2Vob2xkZXIiLCJmb3JtYXR0ZWRJRCIsInN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSIsInN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkxIiwic3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTIiLCJzdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSIsImVuZFN1c3BlbnNlQm91bmRhcnkiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjEiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWwiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFBIiwiY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQiIsImNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUMiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjIiLCJ3cml0ZVN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSIsIndyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeSIsIndyaXRlU3RhcnRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkiLCJlcnJvckRpZ2VzdCIsImVycm9yTWVzc3NhZ2UiLCJlcnJvckNvbXBvbmVudFN0YWNrIiwid3JpdGVFbmRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5Iiwid3JpdGVFbmRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeSIsIndyaXRlRW5kQ2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5Iiwic3RhcnRTZWdtZW50SFRNTCIsInN0YXJ0U2VnbWVudEhUTUwyIiwiZW5kU2VnbWVudEhUTUwiLCJzdGFydFNlZ21lbnRTVkciLCJzdGFydFNlZ21lbnRTVkcyIiwiZW5kU2VnbWVudFNWRyIsInN0YXJ0U2VnbWVudE1hdGhNTCIsInN0YXJ0U2VnbWVudE1hdGhNTDIiLCJlbmRTZWdtZW50TWF0aE1MIiwic3RhcnRTZWdtZW50VGFibGUiLCJzdGFydFNlZ21lbnRUYWJsZTIiLCJlbmRTZWdtZW50VGFibGUiLCJzdGFydFNlZ21lbnRUYWJsZUJvZHkiLCJzdGFydFNlZ21lbnRUYWJsZUJvZHkyIiwiZW5kU2VnbWVudFRhYmxlQm9keSIsInN0YXJ0U2VnbWVudFRhYmxlUm93Iiwic3RhcnRTZWdtZW50VGFibGVSb3cyIiwiZW5kU2VnbWVudFRhYmxlUm93Iiwic3RhcnRTZWdtZW50Q29sR3JvdXAiLCJzdGFydFNlZ21lbnRDb2xHcm91cDIiLCJlbmRTZWdtZW50Q29sR3JvdXAiLCJ3cml0ZVN0YXJ0U2VnbWVudCIsIndyaXRlRW5kU2VnbWVudCIsImNvbXBsZXRlU2VnbWVudEZ1bmN0aW9uIiwiY29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uIiwiY2xpZW50UmVuZGVyRnVuY3Rpb24iLCJjb21wbGV0ZVNlZ21lbnRTY3JpcHQxRnVsbCIsImNvbXBsZXRlU2VnbWVudFNjcmlwdDFQYXJ0aWFsIiwiY29tcGxldGVTZWdtZW50U2NyaXB0MiIsImNvbXBsZXRlU2VnbWVudFNjcmlwdDMiLCJ3cml0ZUNvbXBsZXRlZFNlZ21lbnRJbnN0cnVjdGlvbiIsImNvbnRlbnRTZWdtZW50SUQiLCJjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MUZ1bGwiLCJjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MVBhcnRpYWwiLCJjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MiIsImNvbXBsZXRlQm91bmRhcnlTY3JpcHQzIiwid3JpdGVDb21wbGV0ZWRCb3VuZGFyeUluc3RydWN0aW9uIiwiYm91bmRhcnlJRCIsImZvcm1hdHRlZENvbnRlbnRJRCIsImNsaWVudFJlbmRlclNjcmlwdDFGdWxsIiwiY2xpZW50UmVuZGVyU2NyaXB0MVBhcnRpYWwiLCJjbGllbnRSZW5kZXJTY3JpcHQxQSIsImNsaWVudFJlbmRlclNjcmlwdDIiLCJjbGllbnRSZW5kZXJFcnJvclNjcmlwdEFyZ0ludGVyc3RpdGlhbCIsIndyaXRlQ2xpZW50UmVuZGVyQm91bmRhcnlJbnN0cnVjdGlvbiIsImVycm9yTWVzc2FnZSIsImVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyIsInJlZ2V4Rm9ySlNTdHJpbmdzSW5TY3JpcHRzIiwiaW5wdXQiLCJlc2NhcGVkIiwiY3JlYXRlUmVzcG9uc2VTdGF0ZSQxIiwiZ2VuZXJhdGVTdGF0aWNNYXJrdXAiLCJjcmVhdGVSb290Rm9ybWF0Q29udGV4dCIsInB1c2hUZXh0SW5zdGFuY2UkMSIsInB1c2hTZWdtZW50RmluYWxlJDEiLCJ3cml0ZVN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSQxIiwid3JpdGVTdGFydENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSQxIiwid3JpdGVFbmRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5JDEiLCJ3cml0ZUVuZENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSQxIiwiYXNzaWduIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUkVBQ1RfU1RSSUNUX01PREVfVFlQRSIsIlJFQUNUX1BST0ZJTEVSX1RZUEUiLCJSRUFDVF9QUk9WSURFUl9UWVBFIiwiUkVBQ1RfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUiLCJSRUFDVF9NRU1PX1RZUEUiLCJSRUFDVF9MQVpZX1RZUEUiLCJSRUFDVF9TQ09QRV9UWVBFIiwiUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUiLCJSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUiLCJSRUFDVF9TRVJWRVJfQ09OVEVYVF9ERUZBVUxUX1ZBTFVFX05PVF9MT0FERUQiLCJNQVlCRV9JVEVSQVRPUl9TWU1CT0wiLCJpdGVyYXRvciIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJtYXliZUl0ZXJhdG9yIiwiZ2V0V3JhcHBlZE5hbWUiLCJvdXRlclR5cGUiLCJpbm5lclR5cGUiLCJ3cmFwcGVyTmFtZSIsImRpc3BsYXlOYW1lIiwiZnVuY3Rpb25OYW1lIiwiZ2V0Q29udGV4dE5hbWUiLCJnZXRDb21wb25lbnROYW1lRnJvbVR5cGUiLCJjb250ZXh0IiwicHJvdmlkZXIiLCJfY29udGV4dCIsInJlbmRlciIsIm91dGVyTmFtZSIsImxhenlDb21wb25lbnQiLCJwYXlsb2FkIiwiX3BheWxvYWQiLCJpbml0IiwiX2luaXQiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsImdyb3VwIiwiZ3JvdXBDb2xsYXBzZWQiLCJncm91cEVuZCIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnRpZXMiLCJyZWVuYWJsZUxvZ3MiLCJSZWFjdEN1cnJlbnREaXNwYXRjaGVyIiwiZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUiLCJzb3VyY2UiLCJvd25lckZuIiwicmVlbnRyeSIsImNvbXBvbmVudEZyYW1lQ2FjaGUiLCJQb3NzaWJseVdlYWtNYXAiLCJXZWFrTWFwIiwiZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSIsImZuIiwiY29uc3RydWN0IiwiZnJhbWUiLCJjb250cm9sIiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsIlJlZmxlY3QiLCJzYW1wbGUiLCJzYW1wbGVMaW5lcyIsInNwbGl0IiwiY29udHJvbExpbmVzIiwiYyIsIl9mcmFtZSIsImluY2x1ZGVzIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUiLCJjdG9yIiwiZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lIiwic2hvdWxkQ29uc3RydWN0IiwiQ29tcG9uZW50IiwiaXNSZWFjdENvbXBvbmVudCIsImRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFViIsImxvZ2dlZFR5cGVGYWlsdXJlcyIsInNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50IiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJ3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQiLCJlbXB0eUNvbnRleHRPYmplY3QiLCJmcmVlemUiLCJnZXRNYXNrZWRDb250ZXh0IiwidW5tYXNrZWRDb250ZXh0IiwiY29udGV4dFR5cGVzIiwicHJvY2Vzc0NoaWxkQ29udGV4dCIsImluc3RhbmNlIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJnZXRDaGlsZENvbnRleHQiLCJjaGlsZENvbnRleHQiLCJjb250ZXh0S2V5IiwicmVuZGVyZXJTaWdpbCIsInJvb3RDb250ZXh0U25hcHNob3QiLCJjdXJyZW50QWN0aXZlU25hcHNob3QiLCJwb3BOb2RlIiwicHJldiIsIl9jdXJyZW50VmFsdWUyIiwicGFyZW50VmFsdWUiLCJwdXNoTm9kZSIsIm5leHQiLCJwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvciIsInBhcmVudFByZXYiLCJwYXJlbnQiLCJwYXJlbnROZXh0IiwicG9wQWxsUHJldmlvdXMiLCJwdXNoQWxsTmV4dCIsInBvcFByZXZpb3VzVG9Db21tb25MZXZlbCIsImRlcHRoIiwicG9wTmV4dFRvQ29tbW9uTGV2ZWwiLCJzd2l0Y2hDb250ZXh0IiwibmV3U25hcHNob3QiLCJwdXNoUHJvdmlkZXIiLCJuZXh0VmFsdWUiLCJwcmV2VmFsdWUiLCJfY3VycmVudFJlbmRlcmVyMiIsInByZXZOb2RlIiwibmV3Tm9kZSIsInBvcFByb3ZpZGVyIiwicHJldlNuYXBzaG90IiwiX3ZhbHVlIiwiX2RlZmF1bHRWYWx1ZSIsImdldEFjdGl2ZUNvbnRleHQiLCJyZWFkQ29udGV4dCIsIl9yZWFjdEludGVybmFscyIsImRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnQiLCJkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50IiwiZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlIiwiZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlIiwiZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSIsImRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSIsIndhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZSIsIndhcm5PbkludmFsaWRDYWxsYmFjayIsImRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlIiwiZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMiLCJkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUiLCJTZXQiLCJkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2siLCJjYWxsZXJOYW1lIiwiYWRkIiwicGFydGlhbFN0YXRlIiwid2Fybk5vb3AiLCJwdWJsaWNJbnN0YW5jZSIsIl9jb25zdHJ1Y3RvciIsIndhcm5pbmdLZXkiLCJjbGFzc0NvbXBvbmVudFVwZGF0ZXIiLCJpc01vdW50ZWQiLCJpbnN0IiwiZW5xdWV1ZVNldFN0YXRlIiwiaW50ZXJuYWxzIiwicXVldWUiLCJlbnF1ZXVlUmVwbGFjZVN0YXRlIiwiZW5xdWV1ZUZvcmNlVXBkYXRlIiwiYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJwcmV2U3RhdGUiLCJuZXh0UHJvcHMiLCJuZXdTdGF0ZSIsImNvbnN0cnVjdENsYXNzSW5zdGFuY2UiLCJtYXNrZWRMZWdhY3lDb250ZXh0IiwiY29udGV4dFR5cGUiLCJhZGRlbmR1bSIsInN0YXRlIiwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUiLCJmb3VuZFdpbGxNb3VudE5hbWUiLCJmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIiwiZm91bmRXaWxsVXBkYXRlTmFtZSIsImNvbXBvbmVudFdpbGxNb3VudCIsIl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmciLCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIiwiX2NvbXBvbmVudE5hbWUiLCJuZXdBcGlOYW1lIiwiY2hlY2tDbGFzc0luc3RhbmNlIiwibmV3UHJvcHMiLCJyZW5kZXJQcmVzZW50IiwiZ2V0SW5pdGlhbFN0YXRlIiwiaXNSZWFjdENsYXNzQXBwcm92ZWQiLCJnZXREZWZhdWx0UHJvcHMiLCJwcm9wVHlwZXMiLCJjb21wb25lbnRTaG91bGRVcGRhdGUiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsImNvbXBvbmVudERpZFVubW91bnQiLCJjb21wb25lbnREaWRSZWNlaXZlUHJvcHMiLCJjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJoYXNNdXRhdGVkUHJvcHMiLCJkZWZhdWx0UHJvcHMiLCJjb21wb25lbnREaWRVcGRhdGUiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJfc3RhdGUiLCJjYWxsQ29tcG9uZW50V2lsbE1vdW50Iiwib2xkU3RhdGUiLCJwcm9jZXNzVXBkYXRlUXVldWUiLCJpbnRlcm5hbEluc3RhbmNlIiwib2xkUXVldWUiLCJvbGRSZXBsYWNlIiwibmV4dFN0YXRlIiwiZG9udE11dGF0ZSIsInBhcnRpYWwiLCJtb3VudENsYXNzSW5zdGFuY2UiLCJpbml0aWFsU3RhdGUiLCJ1cGRhdGVyIiwiZW1wdHlUcmVlQ29udGV4dCIsImdldFRyZWVJZCIsImlkV2l0aExlYWRpbmdCaXQiLCJnZXRMZWFkaW5nQml0IiwicHVzaFRyZWVDb250ZXh0IiwiYmFzZUNvbnRleHQiLCJ0b3RhbENoaWxkcmVuIiwiYmFzZUlkV2l0aExlYWRpbmdCaXQiLCJiYXNlT3ZlcmZsb3ciLCJiYXNlTGVuZ3RoIiwiZ2V0Qml0TGVuZ3RoIiwiYmFzZUlkIiwic2xvdCIsIm51bWJlck9mT3ZlcmZsb3dCaXRzIiwibmV3T3ZlcmZsb3dCaXRzIiwibmV3T3ZlcmZsb3ciLCJyZXN0T2ZCYXNlSWQiLCJyZXN0T2ZCYXNlTGVuZ3RoIiwicmVzdE9mTGVuZ3RoIiwicmVzdE9mTmV3Qml0cyIsIm5ld0JpdHMiLCJfaWQiLCJfb3ZlcmZsb3ciLCJudW1iZXIiLCJjbHozMiIsIk1hdGgiLCJjbHozMkZhbGxiYWNrIiwiTE4yIiwiYXNVaW50Iiwib2JqZWN0SXMiLCJjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQiLCJjdXJyZW50bHlSZW5kZXJpbmdUYXNrIiwiZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2siLCJ3b3JrSW5Qcm9ncmVzc0hvb2siLCJpc1JlUmVuZGVyIiwiZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSIsImxvY2FsSWRDb3VudGVyIiwicmVuZGVyUGhhc2VVcGRhdGVzIiwibnVtYmVyT2ZSZVJlbmRlcnMiLCJSRV9SRU5ERVJfTElNSVQiLCJpc0luSG9va1VzZXJDb2RlSW5EZXYiLCJjdXJyZW50SG9va05hbWVJbkRldiIsInJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQiLCJhcmVIb29rSW5wdXRzRXF1YWwiLCJuZXh0RGVwcyIsInByZXZEZXBzIiwiY3JlYXRlSG9vayIsIm1lbW9pemVkU3RhdGUiLCJjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2siLCJwcmVwYXJlVG9Vc2VIb29rcyIsInRhc2siLCJjb21wb25lbnRJZGVudGl0eSIsImZpbmlzaEhvb2tzIiwicmVmT3JDb250ZXh0IiwicmVzZXRIb29rc1N0YXRlIiwiY2hlY2tEaWRSZW5kZXJJZEhvb2siLCJkaWRSZW5kZXJJZEhvb2siLCJyZWFkQ29udGV4dCQxIiwidXNlQ29udGV4dCIsImJhc2ljU3RhdGVSZWR1Y2VyIiwidXNlU3RhdGUiLCJ1c2VSZWR1Y2VyIiwicmVkdWNlciIsImluaXRpYWxBcmciLCJkaXNwYXRjaCIsImZpcnN0UmVuZGVyUGhhc2VVcGRhdGUiLCJkZWxldGUiLCJ1cGRhdGUiLCJfcXVldWUiLCJsYXN0IiwiX2Rpc3BhdGNoIiwiZGlzcGF0Y2hBY3Rpb24iLCJ1c2VNZW1vIiwibmV4dENyZWF0ZSIsImRlcHMiLCJ1c2VSZWYiLCJpbml0aWFsVmFsdWUiLCJwcmV2aW91c1JlZiIsInJlZiIsInNlYWwiLCJ1c2VMYXlvdXRFZmZlY3QiLCJjcmVhdGUiLCJpbnB1dHMiLCJsYXN0UmVuZGVyUGhhc2VVcGRhdGUiLCJ1c2VDYWxsYmFjayIsInVzZU11dGFibGVTb3VyY2UiLCJnZXRTbmFwc2hvdCIsInN1YnNjcmliZSIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwiZ2V0U2VydmVyU25hcHNob3QiLCJ1c2VEZWZlcnJlZFZhbHVlIiwidW5zdXBwb3J0ZWRTdGFydFRyYW5zaXRpb24iLCJ1c2VUcmFuc2l0aW9uIiwidXNlSWQiLCJ0cmVlQ29udGV4dCIsImN1cnJlbnRSZXNwb25zZVN0YXRlIiwibm9vcCIsIkRpc3BhdGNoZXIiLCJ1c2VJbnNlcnRpb25FZmZlY3QiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwidXNlRWZmZWN0IiwidXNlRGVidWdWYWx1ZSIsInNldEN1cnJlbnRSZXNwb25zZVN0YXRlIiwiZ2V0U3RhY2tCeUNvbXBvbmVudFN0YWNrTm9kZSIsImNvbXBvbmVudFN0YWNrIiwibm9kZSIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSIsIlBFTkRJTkciLCJDT01QTEVURUQiLCJGTFVTSEVEIiwiQUJPUlRFRCIsIkVSUk9SRUQiLCJPUEVOIiwiQ0xPU0lORyIsIkNMT1NFRCIsIkRFRkFVTFRfUFJPR1JFU1NJVkVfQ0hVTktfU0laRSIsImRlZmF1bHRFcnJvckhhbmRsZXIiLCJub29wJDEiLCJjcmVhdGVSZXF1ZXN0Iiwicm9vdEZvcm1hdENvbnRleHQiLCJwcm9ncmVzc2l2ZUNodW5rU2l6ZSIsIm9uRXJyb3IiLCJvbkFsbFJlYWR5Iiwib25TaGVsbFJlYWR5Iiwib25TaGVsbEVycm9yIiwib25GYXRhbEVycm9yIiwicGluZ2VkVGFza3MiLCJhYm9ydFNldCIsInJlcXVlc3QiLCJzdGF0dXMiLCJmYXRhbEVycm9yIiwibmV4dFNlZ21lbnRJZCIsImFsbFBlbmRpbmdUYXNrcyIsInBlbmRpbmdSb290VGFza3MiLCJjb21wbGV0ZWRSb290U2VnbWVudCIsImFib3J0YWJsZVRhc2tzIiwiY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzIiwiY29tcGxldGVkQm91bmRhcmllcyIsInBhcnRpYWxCb3VuZGFyaWVzIiwicm9vdFNlZ21lbnQiLCJjcmVhdGVQZW5kaW5nU2VnbWVudCIsInBhcmVudEZsdXNoZWQiLCJyb290VGFzayIsImNyZWF0ZVRhc2siLCJwaW5nVGFzayIsInBlcmZvcm1Xb3JrIiwiY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSIsImZhbGxiYWNrQWJvcnRhYmxlVGFza3MiLCJyb290U2VnbWVudElEIiwicGVuZGluZ1Rhc2tzIiwiZm9yY2VDbGllbnRSZW5kZXIiLCJjb21wbGV0ZWRTZWdtZW50cyIsImJ5dGVTaXplIiwiYmxvY2tlZEJvdW5kYXJ5IiwiYmxvY2tlZFNlZ21lbnQiLCJsZWdhY3lDb250ZXh0IiwicGluZyIsImJvdW5kYXJ5IiwiY2h1bmtzIiwiY3VycmVudFRhc2tJbkRFViIsImdldEN1cnJlbnRTdGFja0luREVWIiwicHVzaEJ1aWx0SW5Db21wb25lbnRTdGFja0luREVWIiwicHVzaEZ1bmN0aW9uQ29tcG9uZW50U3RhY2tJbkRFViIsInB1c2hDbGFzc0NvbXBvbmVudFN0YWNrSW5ERVYiLCJwb3BDb21wb25lbnRTdGFja0luREVWIiwibGFzdEJvdW5kYXJ5RXJyb3JDb21wb25lbnRTdGFja0RldiIsImNhcHR1cmVCb3VuZGFyeUVycm9yRGV0YWlsc0RldiIsImxvZ1JlY292ZXJhYmxlRXJyb3IiLCJyZW5kZXJTdXNwZW5zZUJvdW5kYXJ5IiwicGFyZW50Qm91bmRhcnkiLCJwYXJlbnRTZWdtZW50IiwiZmFsbGJhY2siLCJmYWxsYmFja0Fib3J0U2V0IiwibmV3Qm91bmRhcnkiLCJpbnNlcnRpb25JbmRleCIsImJvdW5kYXJ5U2VnbWVudCIsImNvbnRlbnRSb290U2VnbWVudCIsInJlbmRlck5vZGUiLCJxdWV1ZUNvbXBsZXRlZFNlZ21lbnQiLCJzdXNwZW5kZWRGYWxsYmFja1Rhc2siLCJyZW5kZXJIb3N0RWxlbWVudCIsInNlZ21lbnQiLCJwcmV2Q29udGV4dCIsInNob3VsZENvbnN0cnVjdCQxIiwicmVuZGVyV2l0aEhvb2tzIiwic2Vjb25kQXJnIiwiZmluaXNoQ2xhc3NDb21wb25lbnQiLCJuZXh0Q2hpbGRyZW4iLCJkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzIiwicHJldmlvdXNDb250ZXh0IiwibWVyZ2VkQ29udGV4dCIsInJlbmRlck5vZGVEZXN0cnVjdGl2ZSIsInJlbmRlckNsYXNzQ29tcG9uZW50IiwibWFza2VkQ29udGV4dCIsImRpZFdhcm5BYm91dEJhZENsYXNzIiwiZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudCIsImRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudCIsImRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnQiLCJkaWRXYXJuQWJvdXRHZW5lcmF0b3JzIiwiZGlkV2FybkFib3V0TWFwcyIsImhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lciIsInJlbmRlckluZGV0ZXJtaW5hdGVDb21wb25lbnQiLCJoYXNJZCIsIl9jb21wb25lbnROYW1lMiIsInZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldiIsInByZXZUcmVlQ29udGV4dCIsIl9jb21wb25lbnROYW1lMyIsIl9jb21wb25lbnROYW1lNCIsInJlc29sdmVEZWZhdWx0UHJvcHMiLCJiYXNlUHJvcHMiLCJyZW5kZXJGb3J3YXJkUmVmIiwicmVuZGVyTWVtbyIsInJlc29sdmVkUHJvcHMiLCJyZW5kZXJFbGVtZW50IiwicmVuZGVyQ29udGV4dENvbnN1bWVyIiwiQ29uc3VtZXIiLCJuZXdWYWx1ZSIsIm5ld0NoaWxkcmVuIiwicmVuZGVyQ29udGV4dFByb3ZpZGVyIiwicmVuZGVyTGF6eUNvbXBvbmVudCIsInZhbGlkYXRlSXRlcmFibGUiLCJpdGVyYWJsZSIsIml0ZXJhdG9yRm4iLCJlbnRyaWVzIiwicmVuZGVyTm9kZURlc3RydWN0aXZlSW1wbCIsInRoZW4iLCJsYXp5Tm9kZSIsInJlc29sdmVkTm9kZSIsInJlbmRlckNoaWxkcmVuQXJyYXkiLCJkb25lIiwiY2hpbGRTdHJpbmciLCJfc2VnbWVudCIsInNwYXduTmV3U3VzcGVuZGVkVGFzayIsIm5ld1NlZ21lbnQiLCJuZXdUYXNrIiwicHJldmlvdXNGb3JtYXRDb250ZXh0IiwicHJldmlvdXNMZWdhY3lDb250ZXh0IiwicHJldmlvdXNDb21wb25lbnRTdGFjayIsImVycm9yZWRUYXNrIiwiYWJvcnRUYXNrU29mdCIsImZpbmlzaGVkVGFzayIsImFib3J0VGFzayIsInJlYXNvbiIsIl9lcnJvciIsImVycm9yUHJlZml4IiwicHJldmlvdXNUYXNrSW5EZXYiLCJmYWxsYmFja1Rhc2siLCJjbGVhciIsImNoaWxkU2VnbWVudCIsInJldHJ5VGFzayIsInByZXZUYXNrSW5ERVYiLCJwcmV2RGlzcGF0Y2hlciIsInByZXZHZXRDdXJyZW50U3RhY2tJbXBsIiwiZ2V0Q3VycmVudFN0YWNrIiwicHJldlJlc3BvbnNlU3RhdGUiLCJzcGxpY2UiLCJmbHVzaENvbXBsZXRlZFF1ZXVlcyIsImZsdXNoU3VidHJlZSIsInNlZ21lbnRJRCIsImNodW5rSWR4IiwiY2hpbGRJZHgiLCJuZXh0Q2hpbGQiLCJmbHVzaFNlZ21lbnQiLCJjb250ZW50U2VnbWVudCIsImZsdXNoQ2xpZW50UmVuZGVyZWRCb3VuZGFyeSIsImZsdXNoU2VnbWVudENvbnRhaW5lciIsImZsdXNoQ29tcGxldGVkQm91bmRhcnkiLCJmbHVzaFBhcnRpYWxseUNvbXBsZXRlZFNlZ21lbnQiLCJmbHVzaFBhcnRpYWxCb3VuZGFyeSIsIl9ib3VuZGFyeSIsIl9ib3VuZGFyeTIiLCJsYXJnZUJvdW5kYXJpZXMiLCJfYm91bmRhcnkzIiwic3RhcnRXb3JrIiwic3RhcnRGbG93aW5nIiwiYWJvcnQiLCJyZW5kZXJUb1N0cmluZ0ltcGwiLCJvcHRpb25zIiwiYWJvcnRSZWFzb24iLCJkaWRGYXRhbCIsInJlYWR5VG9TdHJlYW0iLCJJbmZpbml0eSIsIl9pbmhlcml0c0xvb3NlIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiX19wcm90b19fIiwiUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbSIsIl9SZWFkYWJsZSIsIl90aGlzIiwic3RhcnRlZEZsb3dpbmciLCJfcHJvdG8iLCJfZGVzdHJveSIsIl9yZWFkIiwiUmVhZGFibGUiLCJvbkVycm9yJDEiLCJyZW5kZXJUb05vZGVTdHJlYW1JbXBsIiwicmVuZGVyVG9Ob2RlU3RyZWFtIiwicmVuZGVyVG9TdGF0aWNOb2RlU3RyZWFtIiwicmVuZGVyVG9TdHJpbmciLCJyZW5kZXJUb1N0YXRpY01hcmt1cCIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/cjs/react-dom-server.node.development.js":
/*!******************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/cjs/react-dom-server.node.development.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * @license React\n * react-dom-server.node.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! react */ \"(rsc)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\n        var util = __webpack_require__(/*! util */ \"util\");\n        var ReactVersion = \"18.2.0\";\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        // by calls to these methods by a Babel plugin.\n        //\n        // In PROD (or in packages without access to React internals),\n        // they are left as they are instead.\n        function warn(format) {\n            {\n                {\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    printWarning(\"warn\", format, args);\n                }\n            }\n        }\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        function scheduleWork(callback) {\n            setImmediate(callback);\n        }\n        function flushBuffered(destination) {\n            // If we don't have any more data to send right now.\n            // Flush whatever is in the buffer to the wire.\n            if (typeof destination.flush === \"function\") {\n                // By convention the Zlib streams provide a flush function for this purpose.\n                // For Express, compression middleware adds this method.\n                destination.flush();\n            }\n        }\n        var VIEW_SIZE = 2048;\n        var currentView = null;\n        var writtenBytes = 0;\n        var destinationHasCapacity = true;\n        function beginWriting(destination) {\n            currentView = new Uint8Array(VIEW_SIZE);\n            writtenBytes = 0;\n            destinationHasCapacity = true;\n        }\n        function writeStringChunk(destination, stringChunk) {\n            if (stringChunk.length === 0) {\n                return;\n            } // maximum possible view needed to encode entire string\n            if (stringChunk.length * 3 > VIEW_SIZE) {\n                if (writtenBytes > 0) {\n                    writeToDestination(destination, currentView.subarray(0, writtenBytes));\n                    currentView = new Uint8Array(VIEW_SIZE);\n                    writtenBytes = 0;\n                }\n                writeToDestination(destination, textEncoder.encode(stringChunk));\n                return;\n            }\n            var target = currentView;\n            if (writtenBytes > 0) {\n                target = currentView.subarray(writtenBytes);\n            }\n            var _textEncoder$encodeIn = textEncoder.encodeInto(stringChunk, target), read = _textEncoder$encodeIn.read, written = _textEncoder$encodeIn.written;\n            writtenBytes += written;\n            if (read < stringChunk.length) {\n                writeToDestination(destination, currentView);\n                currentView = new Uint8Array(VIEW_SIZE);\n                writtenBytes = textEncoder.encodeInto(stringChunk.slice(read), currentView).written;\n            }\n            if (writtenBytes === VIEW_SIZE) {\n                writeToDestination(destination, currentView);\n                currentView = new Uint8Array(VIEW_SIZE);\n                writtenBytes = 0;\n            }\n        }\n        function writeViewChunk(destination, chunk) {\n            if (chunk.byteLength === 0) {\n                return;\n            }\n            if (chunk.byteLength > VIEW_SIZE) {\n                // this chunk may overflow a single view which implies it was not\n                // one that is cached by the streaming renderer. We will enqueu\n                // it directly and expect it is not re-used\n                if (writtenBytes > 0) {\n                    writeToDestination(destination, currentView.subarray(0, writtenBytes));\n                    currentView = new Uint8Array(VIEW_SIZE);\n                    writtenBytes = 0;\n                }\n                writeToDestination(destination, chunk);\n                return;\n            }\n            var bytesToWrite = chunk;\n            var allowableBytes = currentView.length - writtenBytes;\n            if (allowableBytes < bytesToWrite.byteLength) {\n                // this chunk would overflow the current view. We enqueue a full view\n                // and start a new view with the remaining chunk\n                if (allowableBytes === 0) {\n                    // the current view is already full, send it\n                    writeToDestination(destination, currentView);\n                } else {\n                    // fill up the current view and apply the remaining chunk bytes\n                    // to a new view.\n                    currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes);\n                    writtenBytes += allowableBytes;\n                    writeToDestination(destination, currentView);\n                    bytesToWrite = bytesToWrite.subarray(allowableBytes);\n                }\n                currentView = new Uint8Array(VIEW_SIZE);\n                writtenBytes = 0;\n            }\n            currentView.set(bytesToWrite, writtenBytes);\n            writtenBytes += bytesToWrite.byteLength;\n            if (writtenBytes === VIEW_SIZE) {\n                writeToDestination(destination, currentView);\n                currentView = new Uint8Array(VIEW_SIZE);\n                writtenBytes = 0;\n            }\n        }\n        function writeChunk(destination, chunk) {\n            if (typeof chunk === \"string\") {\n                writeStringChunk(destination, chunk);\n            } else {\n                writeViewChunk(destination, chunk);\n            }\n        }\n        function writeToDestination(destination, view) {\n            var currentHasCapacity = destination.write(view);\n            destinationHasCapacity = destinationHasCapacity && currentHasCapacity;\n        }\n        function writeChunkAndReturn(destination, chunk) {\n            writeChunk(destination, chunk);\n            return destinationHasCapacity;\n        }\n        function completeWriting(destination) {\n            if (currentView && writtenBytes > 0) {\n                destination.write(currentView.subarray(0, writtenBytes));\n            }\n            currentView = null;\n            writtenBytes = 0;\n            destinationHasCapacity = true;\n        }\n        function close(destination) {\n            destination.end();\n        }\n        var textEncoder = new util.TextEncoder();\n        function stringToChunk(content) {\n            return content;\n        }\n        function stringToPrecomputedChunk(content) {\n            return textEncoder.encode(content);\n        }\n        function closeWithError(destination, error) {\n            // $FlowFixMe: This is an Error object or the destination accepts other types.\n            destination.destroy(error);\n        }\n        /*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\";\n                return type;\n            }\n        } // $FlowFixMe only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkAttributeStringCoercion(value, attributeName) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided `%s` attribute is an unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", attributeName, typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function checkCSSPropertyStringCoercion(value, propName) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided `%s` CSS property is an unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", propName, typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function checkHtmlStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided HTML markup uses a value of unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        // A reserved attribute.\n        // It is handled by React separately and shouldn't be written to the DOM.\n        var RESERVED = 0; // A simple string attribute.\n        // Attributes that aren't in the filter are presumed to have this type.\n        var STRING = 1; // A string attribute that accepts booleans in React. In HTML, these are called\n        // \"enumerated\" attributes with \"true\" and \"false\" as possible values.\n        // When true, it should be set to a \"true\" string.\n        // When false, it should be set to a \"false\" string.\n        var BOOLEANISH_STRING = 2; // A real boolean attribute.\n        // When true, it should be present (set either to an empty string or its name).\n        // When false, it should be omitted.\n        var BOOLEAN = 3; // An attribute that can be used as a flag as well as with a value.\n        // When true, it should be present (set either to an empty string or its name).\n        // When false, it should be omitted.\n        // For any other value, should be present with that value.\n        var OVERLOADED_BOOLEAN = 4; // An attribute that must be numeric or parse as a numeric.\n        // When falsy, it should be removed.\n        var NUMERIC = 5; // An attribute that must be positive numeric or parse as a positive numeric.\n        // When falsy, it should be removed.\n        var POSITIVE_NUMERIC = 6;\n        /* eslint-disable max-len */ var ATTRIBUTE_NAME_START_CHAR = \":A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n        /* eslint-enable max-len */ var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + \"\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\n        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp(\"^[\" + ATTRIBUTE_NAME_START_CHAR + \"][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var illegalAttributeNameCache = {};\n        var validatedAttributeNameCache = {};\n        function isAttributeNameSafe(attributeName) {\n            if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {\n                return true;\n            }\n            if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {\n                return false;\n            }\n            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\n                validatedAttributeNameCache[attributeName] = true;\n                return true;\n            }\n            illegalAttributeNameCache[attributeName] = true;\n            {\n                error(\"Invalid attribute name: `%s`\", attributeName);\n            }\n            return false;\n        }\n        function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {\n            if (propertyInfo !== null && propertyInfo.type === RESERVED) {\n                return false;\n            }\n            switch(typeof value){\n                case \"function\":\n                case \"symbol\":\n                    // eslint-disable-line\n                    return true;\n                case \"boolean\":\n                    {\n                        if (isCustomComponentTag) {\n                            return false;\n                        }\n                        if (propertyInfo !== null) {\n                            return !propertyInfo.acceptsBooleans;\n                        } else {\n                            var prefix = name.toLowerCase().slice(0, 5);\n                            return prefix !== \"data-\" && prefix !== \"aria-\";\n                        }\n                    }\n                default:\n                    return false;\n            }\n        }\n        function getPropertyInfo(name) {\n            return properties.hasOwnProperty(name) ? properties[name] : null;\n        }\n        function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL, removeEmptyString) {\n            this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;\n            this.attributeName = attributeName;\n            this.attributeNamespace = attributeNamespace;\n            this.mustUseProperty = mustUseProperty;\n            this.propertyName = name;\n            this.type = type;\n            this.sanitizeURL = sanitizeURL;\n            this.removeEmptyString = removeEmptyString;\n        } // When adding attributes to this list, be sure to also add them to\n        // the `possibleStandardNames` module to ensure casing and incorrect\n        // name warnings.\n        var properties = {}; // These props are reserved by React. They shouldn't be written to the DOM.\n        var reservedProps = [\n            \"children\",\n            \"dangerouslySetInnerHTML\",\n            // elements (not just inputs). Now that ReactDOMInput assigns to the\n            // defaultValue property -- do we need this?\n            \"defaultValue\",\n            \"defaultChecked\",\n            \"innerHTML\",\n            \"suppressContentEditableWarning\",\n            \"suppressHydrationWarning\",\n            \"style\"\n        ];\n        reservedProps.forEach(function(name) {\n            properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);\n        }); // A few React string attributes have a different name.\n        // This is a mapping from React prop names to the attribute names.\n        [\n            [\n                \"acceptCharset\",\n                \"accept-charset\"\n            ],\n            [\n                \"className\",\n                \"class\"\n            ],\n            [\n                \"htmlFor\",\n                \"for\"\n            ],\n            [\n                \"httpEquiv\",\n                \"http-equiv\"\n            ]\n        ].forEach(function(_ref) {\n            var name = _ref[0], attributeName = _ref[1];\n            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);\n        }); // These are \"enumerated\" HTML attributes that accept \"true\" and \"false\".\n        // In React, we let users pass `true` and `false` even though technically\n        // these aren't boolean attributes (they are coerced to strings).\n        [\n            \"contentEditable\",\n            \"draggable\",\n            \"spellCheck\",\n            \"value\"\n        ].forEach(function(name) {\n            properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);\n        }); // These are \"enumerated\" SVG attributes that accept \"true\" and \"false\".\n        // In React, we let users pass `true` and `false` even though technically\n        // these aren't boolean attributes (they are coerced to strings).\n        // Since these are SVG attributes, their attribute names are case-sensitive.\n        [\n            \"autoReverse\",\n            \"externalResourcesRequired\",\n            \"focusable\",\n            \"preserveAlpha\"\n        ].forEach(function(name) {\n            properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);\n        }); // These are HTML boolean attributes.\n        [\n            \"allowFullScreen\",\n            \"async\",\n            // on the client side because the browsers are inconsistent. Instead we call focus().\n            \"autoFocus\",\n            \"autoPlay\",\n            \"controls\",\n            \"default\",\n            \"defer\",\n            \"disabled\",\n            \"disablePictureInPicture\",\n            \"disableRemotePlayback\",\n            \"formNoValidate\",\n            \"hidden\",\n            \"loop\",\n            \"noModule\",\n            \"noValidate\",\n            \"open\",\n            \"playsInline\",\n            \"readOnly\",\n            \"required\",\n            \"reversed\",\n            \"scoped\",\n            \"seamless\",\n            \"itemScope\"\n        ].forEach(function(name) {\n            properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);\n        }); // These are the few React props that we set as DOM properties\n        // rather than attributes. These are all booleans.\n        [\n            \"checked\",\n            // disabled with `removeAttribute`. We have special logic for handling this.\n            \"multiple\",\n            \"muted\",\n            \"selected\" // NOTE: if you add a camelCased prop to this list,\n        ].forEach(function(name) {\n            properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);\n        }); // These are HTML attributes that are \"overloaded booleans\": they behave like\n        // booleans, but can also accept a string value.\n        [\n            \"capture\",\n            \"download\" // NOTE: if you add a camelCased prop to this list,\n        ].forEach(function(name) {\n            properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);\n        }); // These are HTML attributes that must be positive numbers.\n        [\n            \"cols\",\n            \"rows\",\n            \"size\",\n            \"span\" // NOTE: if you add a camelCased prop to this list,\n        ].forEach(function(name) {\n            properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);\n        }); // These are HTML attributes that must be numbers.\n        [\n            \"rowSpan\",\n            \"start\"\n        ].forEach(function(name) {\n            properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);\n        });\n        var CAMELIZE = /[\\-\\:]([a-z])/g;\n        var capitalize = function(token) {\n            return token[1].toUpperCase();\n        }; // This is a list of all SVG attributes that need special casing, namespacing,\n        // or boolean value assignment. Regular attributes that just accept strings\n        // and have the same names are omitted, just like in the HTML attribute filter.\n        // Some of these attributes can be hard to find. This list was created by\n        // scraping the MDN documentation.\n        [\n            \"accent-height\",\n            \"alignment-baseline\",\n            \"arabic-form\",\n            \"baseline-shift\",\n            \"cap-height\",\n            \"clip-path\",\n            \"clip-rule\",\n            \"color-interpolation\",\n            \"color-interpolation-filters\",\n            \"color-profile\",\n            \"color-rendering\",\n            \"dominant-baseline\",\n            \"enable-background\",\n            \"fill-opacity\",\n            \"fill-rule\",\n            \"flood-color\",\n            \"flood-opacity\",\n            \"font-family\",\n            \"font-size\",\n            \"font-size-adjust\",\n            \"font-stretch\",\n            \"font-style\",\n            \"font-variant\",\n            \"font-weight\",\n            \"glyph-name\",\n            \"glyph-orientation-horizontal\",\n            \"glyph-orientation-vertical\",\n            \"horiz-adv-x\",\n            \"horiz-origin-x\",\n            \"image-rendering\",\n            \"letter-spacing\",\n            \"lighting-color\",\n            \"marker-end\",\n            \"marker-mid\",\n            \"marker-start\",\n            \"overline-position\",\n            \"overline-thickness\",\n            \"paint-order\",\n            \"panose-1\",\n            \"pointer-events\",\n            \"rendering-intent\",\n            \"shape-rendering\",\n            \"stop-color\",\n            \"stop-opacity\",\n            \"strikethrough-position\",\n            \"strikethrough-thickness\",\n            \"stroke-dasharray\",\n            \"stroke-dashoffset\",\n            \"stroke-linecap\",\n            \"stroke-linejoin\",\n            \"stroke-miterlimit\",\n            \"stroke-opacity\",\n            \"stroke-width\",\n            \"text-anchor\",\n            \"text-decoration\",\n            \"text-rendering\",\n            \"underline-position\",\n            \"underline-thickness\",\n            \"unicode-bidi\",\n            \"unicode-range\",\n            \"units-per-em\",\n            \"v-alphabetic\",\n            \"v-hanging\",\n            \"v-ideographic\",\n            \"v-mathematical\",\n            \"vector-effect\",\n            \"vert-adv-y\",\n            \"vert-origin-x\",\n            \"vert-origin-y\",\n            \"word-spacing\",\n            \"writing-mode\",\n            \"xmlns:xlink\",\n            \"x-height\" // NOTE: if you add a camelCased prop to this list,\n        ].forEach(function(attributeName) {\n            var name = attributeName.replace(CAMELIZE, capitalize);\n            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);\n        }); // String SVG attributes with the xlink namespace.\n        [\n            \"xlink:actuate\",\n            \"xlink:arcrole\",\n            \"xlink:role\",\n            \"xlink:show\",\n            \"xlink:title\",\n            \"xlink:type\" // NOTE: if you add a camelCased prop to this list,\n        ].forEach(function(attributeName) {\n            var name = attributeName.replace(CAMELIZE, capitalize);\n            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, \"http://www.w3.org/1999/xlink\", false, false);\n        }); // String SVG attributes with the xml namespace.\n        [\n            \"xml:base\",\n            \"xml:lang\",\n            \"xml:space\" // NOTE: if you add a camelCased prop to this list,\n        ].forEach(function(attributeName) {\n            var name = attributeName.replace(CAMELIZE, capitalize);\n            properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, \"http://www.w3.org/XML/1998/namespace\", false, false);\n        }); // These attribute exists both in HTML and SVG.\n        // The attribute name is case-sensitive in SVG so we can't just use\n        // the React name like we do for attributes that exist only in HTML.\n        [\n            \"tabIndex\",\n            \"crossOrigin\"\n        ].forEach(function(attributeName) {\n            properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);\n        }); // These attributes accept URLs. These must not allow javascript: URLS.\n        // These will also need to accept Trusted Types object in the future.\n        var xlinkHref = \"xlinkHref\";\n        properties[xlinkHref] = new PropertyInfoRecord(\"xlinkHref\", STRING, false, \"xlink:href\", \"http://www.w3.org/1999/xlink\", true, false);\n        [\n            \"src\",\n            \"href\",\n            \"action\",\n            \"formAction\"\n        ].forEach(function(attributeName) {\n            properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);\n        });\n        /**\n * CSS properties which accept numbers but are not in units of \"px\".\n */ var isUnitlessNumber = {\n            animationIterationCount: true,\n            aspectRatio: true,\n            borderImageOutset: true,\n            borderImageSlice: true,\n            borderImageWidth: true,\n            boxFlex: true,\n            boxFlexGroup: true,\n            boxOrdinalGroup: true,\n            columnCount: true,\n            columns: true,\n            flex: true,\n            flexGrow: true,\n            flexPositive: true,\n            flexShrink: true,\n            flexNegative: true,\n            flexOrder: true,\n            gridArea: true,\n            gridRow: true,\n            gridRowEnd: true,\n            gridRowSpan: true,\n            gridRowStart: true,\n            gridColumn: true,\n            gridColumnEnd: true,\n            gridColumnSpan: true,\n            gridColumnStart: true,\n            fontWeight: true,\n            lineClamp: true,\n            lineHeight: true,\n            opacity: true,\n            order: true,\n            orphans: true,\n            tabSize: true,\n            widows: true,\n            zIndex: true,\n            zoom: true,\n            // SVG-related properties\n            fillOpacity: true,\n            floodOpacity: true,\n            stopOpacity: true,\n            strokeDasharray: true,\n            strokeDashoffset: true,\n            strokeMiterlimit: true,\n            strokeOpacity: true,\n            strokeWidth: true\n        };\n        /**\n * @param {string} prefix vendor-specific prefix, eg: Webkit\n * @param {string} key style name, eg: transitionDuration\n * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n * WebkitTransitionDuration\n */ function prefixKey(prefix, key) {\n            return prefix + key.charAt(0).toUpperCase() + key.substring(1);\n        }\n        /**\n * Support style names that may come passed in prefixed by adding permutations\n * of vendor prefixes.\n */ var prefixes = [\n            \"Webkit\",\n            \"ms\",\n            \"Moz\",\n            \"O\"\n        ]; // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n        // infinite loop, because it iterates over the newly added props too.\n        Object.keys(isUnitlessNumber).forEach(function(prop) {\n            prefixes.forEach(function(prefix) {\n                isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];\n            });\n        });\n        var hasReadOnlyValue = {\n            button: true,\n            checkbox: true,\n            image: true,\n            hidden: true,\n            radio: true,\n            reset: true,\n            submit: true\n        };\n        function checkControlledValueProps(tagName, props) {\n            {\n                if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {\n                    error(\"You provided a `value` prop to a form field without an \" + \"`onChange` handler. This will render a read-only field. If \" + \"the field should be mutable use `defaultValue`. Otherwise, \" + \"set either `onChange` or `readOnly`.\");\n                }\n                if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {\n                    error(\"You provided a `checked` prop to a form field without an \" + \"`onChange` handler. This will render a read-only field. If \" + \"the field should be mutable use `defaultChecked`. Otherwise, \" + \"set either `onChange` or `readOnly`.\");\n                }\n            }\n        }\n        function isCustomComponent(tagName, props) {\n            if (tagName.indexOf(\"-\") === -1) {\n                return typeof props.is === \"string\";\n            }\n            switch(tagName){\n                // These are reserved SVG and MathML elements.\n                // We don't mind this list too much because we expect it to never grow.\n                // The alternative is to track the namespace in a few places which is convoluted.\n                // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n                case \"annotation-xml\":\n                case \"color-profile\":\n                case \"font-face\":\n                case \"font-face-src\":\n                case \"font-face-uri\":\n                case \"font-face-format\":\n                case \"font-face-name\":\n                case \"missing-glyph\":\n                    return false;\n                default:\n                    return true;\n            }\n        }\n        var ariaProperties = {\n            \"aria-current\": 0,\n            // state\n            \"aria-description\": 0,\n            \"aria-details\": 0,\n            \"aria-disabled\": 0,\n            // state\n            \"aria-hidden\": 0,\n            // state\n            \"aria-invalid\": 0,\n            // state\n            \"aria-keyshortcuts\": 0,\n            \"aria-label\": 0,\n            \"aria-roledescription\": 0,\n            // Widget Attributes\n            \"aria-autocomplete\": 0,\n            \"aria-checked\": 0,\n            \"aria-expanded\": 0,\n            \"aria-haspopup\": 0,\n            \"aria-level\": 0,\n            \"aria-modal\": 0,\n            \"aria-multiline\": 0,\n            \"aria-multiselectable\": 0,\n            \"aria-orientation\": 0,\n            \"aria-placeholder\": 0,\n            \"aria-pressed\": 0,\n            \"aria-readonly\": 0,\n            \"aria-required\": 0,\n            \"aria-selected\": 0,\n            \"aria-sort\": 0,\n            \"aria-valuemax\": 0,\n            \"aria-valuemin\": 0,\n            \"aria-valuenow\": 0,\n            \"aria-valuetext\": 0,\n            // Live Region Attributes\n            \"aria-atomic\": 0,\n            \"aria-busy\": 0,\n            \"aria-live\": 0,\n            \"aria-relevant\": 0,\n            // Drag-and-Drop Attributes\n            \"aria-dropeffect\": 0,\n            \"aria-grabbed\": 0,\n            // Relationship Attributes\n            \"aria-activedescendant\": 0,\n            \"aria-colcount\": 0,\n            \"aria-colindex\": 0,\n            \"aria-colspan\": 0,\n            \"aria-controls\": 0,\n            \"aria-describedby\": 0,\n            \"aria-errormessage\": 0,\n            \"aria-flowto\": 0,\n            \"aria-labelledby\": 0,\n            \"aria-owns\": 0,\n            \"aria-posinset\": 0,\n            \"aria-rowcount\": 0,\n            \"aria-rowindex\": 0,\n            \"aria-rowspan\": 0,\n            \"aria-setsize\": 0\n        };\n        var warnedProperties = {};\n        var rARIA = new RegExp(\"^(aria)-[\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var rARIACamel = new RegExp(\"^(aria)[A-Z][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        function validateProperty(tagName, name) {\n            {\n                if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {\n                    return true;\n                }\n                if (rARIACamel.test(name)) {\n                    var ariaName = \"aria-\" + name.slice(4).toLowerCase();\n                    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null; // If this is an aria-* attribute, but is not listed in the known DOM\n                    // DOM properties, then it is an invalid aria-* attribute.\n                    if (correctName == null) {\n                        error(\"Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.\", name);\n                        warnedProperties[name] = true;\n                        return true;\n                    } // aria-* attributes should be lowercase; suggest the lowercase version.\n                    if (name !== correctName) {\n                        error(\"Invalid ARIA attribute `%s`. Did you mean `%s`?\", name, correctName);\n                        warnedProperties[name] = true;\n                        return true;\n                    }\n                }\n                if (rARIA.test(name)) {\n                    var lowerCasedName = name.toLowerCase();\n                    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null; // If this is an aria-* attribute, but is not listed in the known DOM\n                    // DOM properties, then it is an invalid aria-* attribute.\n                    if (standardName == null) {\n                        warnedProperties[name] = true;\n                        return false;\n                    } // aria-* attributes should be lowercase; suggest the lowercase version.\n                    if (name !== standardName) {\n                        error(\"Unknown ARIA attribute `%s`. Did you mean `%s`?\", name, standardName);\n                        warnedProperties[name] = true;\n                        return true;\n                    }\n                }\n            }\n            return true;\n        }\n        function warnInvalidARIAProps(type, props) {\n            {\n                var invalidProps = [];\n                for(var key in props){\n                    var isValid = validateProperty(type, key);\n                    if (!isValid) {\n                        invalidProps.push(key);\n                    }\n                }\n                var unknownPropString = invalidProps.map(function(prop) {\n                    return \"`\" + prop + \"`\";\n                }).join(\", \");\n                if (invalidProps.length === 1) {\n                    error(\"Invalid aria prop %s on <%s> tag. \" + \"For details, see https://reactjs.org/link/invalid-aria-props\", unknownPropString, type);\n                } else if (invalidProps.length > 1) {\n                    error(\"Invalid aria props %s on <%s> tag. \" + \"For details, see https://reactjs.org/link/invalid-aria-props\", unknownPropString, type);\n                }\n            }\n        }\n        function validateProperties(type, props) {\n            if (isCustomComponent(type, props)) {\n                return;\n            }\n            warnInvalidARIAProps(type, props);\n        }\n        var didWarnValueNull = false;\n        function validateProperties$1(type, props) {\n            {\n                if (type !== \"input\" && type !== \"textarea\" && type !== \"select\") {\n                    return;\n                }\n                if (props != null && props.value === null && !didWarnValueNull) {\n                    didWarnValueNull = true;\n                    if (type === \"select\" && props.multiple) {\n                        error(\"`value` prop on `%s` should not be null. \" + \"Consider using an empty array when `multiple` is set to `true` \" + \"to clear the component or `undefined` for uncontrolled components.\", type);\n                    } else {\n                        error(\"`value` prop on `%s` should not be null. \" + \"Consider using an empty string to clear the component or `undefined` \" + \"for uncontrolled components.\", type);\n                    }\n                }\n            }\n        }\n        // When adding attributes to the HTML or SVG allowed attribute list, be sure to\n        // also add them to this module to ensure casing and incorrect name\n        // warnings.\n        var possibleStandardNames = {\n            // HTML\n            accept: \"accept\",\n            acceptcharset: \"acceptCharset\",\n            \"accept-charset\": \"acceptCharset\",\n            accesskey: \"accessKey\",\n            action: \"action\",\n            allowfullscreen: \"allowFullScreen\",\n            alt: \"alt\",\n            as: \"as\",\n            async: \"async\",\n            autocapitalize: \"autoCapitalize\",\n            autocomplete: \"autoComplete\",\n            autocorrect: \"autoCorrect\",\n            autofocus: \"autoFocus\",\n            autoplay: \"autoPlay\",\n            autosave: \"autoSave\",\n            capture: \"capture\",\n            cellpadding: \"cellPadding\",\n            cellspacing: \"cellSpacing\",\n            challenge: \"challenge\",\n            charset: \"charSet\",\n            checked: \"checked\",\n            children: \"children\",\n            cite: \"cite\",\n            class: \"className\",\n            classid: \"classID\",\n            classname: \"className\",\n            cols: \"cols\",\n            colspan: \"colSpan\",\n            content: \"content\",\n            contenteditable: \"contentEditable\",\n            contextmenu: \"contextMenu\",\n            controls: \"controls\",\n            controlslist: \"controlsList\",\n            coords: \"coords\",\n            crossorigin: \"crossOrigin\",\n            dangerouslysetinnerhtml: \"dangerouslySetInnerHTML\",\n            data: \"data\",\n            datetime: \"dateTime\",\n            default: \"default\",\n            defaultchecked: \"defaultChecked\",\n            defaultvalue: \"defaultValue\",\n            defer: \"defer\",\n            dir: \"dir\",\n            disabled: \"disabled\",\n            disablepictureinpicture: \"disablePictureInPicture\",\n            disableremoteplayback: \"disableRemotePlayback\",\n            download: \"download\",\n            draggable: \"draggable\",\n            enctype: \"encType\",\n            enterkeyhint: \"enterKeyHint\",\n            for: \"htmlFor\",\n            form: \"form\",\n            formmethod: \"formMethod\",\n            formaction: \"formAction\",\n            formenctype: \"formEncType\",\n            formnovalidate: \"formNoValidate\",\n            formtarget: \"formTarget\",\n            frameborder: \"frameBorder\",\n            headers: \"headers\",\n            height: \"height\",\n            hidden: \"hidden\",\n            high: \"high\",\n            href: \"href\",\n            hreflang: \"hrefLang\",\n            htmlfor: \"htmlFor\",\n            httpequiv: \"httpEquiv\",\n            \"http-equiv\": \"httpEquiv\",\n            icon: \"icon\",\n            id: \"id\",\n            imagesizes: \"imageSizes\",\n            imagesrcset: \"imageSrcSet\",\n            innerhtml: \"innerHTML\",\n            inputmode: \"inputMode\",\n            integrity: \"integrity\",\n            is: \"is\",\n            itemid: \"itemID\",\n            itemprop: \"itemProp\",\n            itemref: \"itemRef\",\n            itemscope: \"itemScope\",\n            itemtype: \"itemType\",\n            keyparams: \"keyParams\",\n            keytype: \"keyType\",\n            kind: \"kind\",\n            label: \"label\",\n            lang: \"lang\",\n            list: \"list\",\n            loop: \"loop\",\n            low: \"low\",\n            manifest: \"manifest\",\n            marginwidth: \"marginWidth\",\n            marginheight: \"marginHeight\",\n            max: \"max\",\n            maxlength: \"maxLength\",\n            media: \"media\",\n            mediagroup: \"mediaGroup\",\n            method: \"method\",\n            min: \"min\",\n            minlength: \"minLength\",\n            multiple: \"multiple\",\n            muted: \"muted\",\n            name: \"name\",\n            nomodule: \"noModule\",\n            nonce: \"nonce\",\n            novalidate: \"noValidate\",\n            open: \"open\",\n            optimum: \"optimum\",\n            pattern: \"pattern\",\n            placeholder: \"placeholder\",\n            playsinline: \"playsInline\",\n            poster: \"poster\",\n            preload: \"preload\",\n            profile: \"profile\",\n            radiogroup: \"radioGroup\",\n            readonly: \"readOnly\",\n            referrerpolicy: \"referrerPolicy\",\n            rel: \"rel\",\n            required: \"required\",\n            reversed: \"reversed\",\n            role: \"role\",\n            rows: \"rows\",\n            rowspan: \"rowSpan\",\n            sandbox: \"sandbox\",\n            scope: \"scope\",\n            scoped: \"scoped\",\n            scrolling: \"scrolling\",\n            seamless: \"seamless\",\n            selected: \"selected\",\n            shape: \"shape\",\n            size: \"size\",\n            sizes: \"sizes\",\n            span: \"span\",\n            spellcheck: \"spellCheck\",\n            src: \"src\",\n            srcdoc: \"srcDoc\",\n            srclang: \"srcLang\",\n            srcset: \"srcSet\",\n            start: \"start\",\n            step: \"step\",\n            style: \"style\",\n            summary: \"summary\",\n            tabindex: \"tabIndex\",\n            target: \"target\",\n            title: \"title\",\n            type: \"type\",\n            usemap: \"useMap\",\n            value: \"value\",\n            width: \"width\",\n            wmode: \"wmode\",\n            wrap: \"wrap\",\n            // SVG\n            about: \"about\",\n            accentheight: \"accentHeight\",\n            \"accent-height\": \"accentHeight\",\n            accumulate: \"accumulate\",\n            additive: \"additive\",\n            alignmentbaseline: \"alignmentBaseline\",\n            \"alignment-baseline\": \"alignmentBaseline\",\n            allowreorder: \"allowReorder\",\n            alphabetic: \"alphabetic\",\n            amplitude: \"amplitude\",\n            arabicform: \"arabicForm\",\n            \"arabic-form\": \"arabicForm\",\n            ascent: \"ascent\",\n            attributename: \"attributeName\",\n            attributetype: \"attributeType\",\n            autoreverse: \"autoReverse\",\n            azimuth: \"azimuth\",\n            basefrequency: \"baseFrequency\",\n            baselineshift: \"baselineShift\",\n            \"baseline-shift\": \"baselineShift\",\n            baseprofile: \"baseProfile\",\n            bbox: \"bbox\",\n            begin: \"begin\",\n            bias: \"bias\",\n            by: \"by\",\n            calcmode: \"calcMode\",\n            capheight: \"capHeight\",\n            \"cap-height\": \"capHeight\",\n            clip: \"clip\",\n            clippath: \"clipPath\",\n            \"clip-path\": \"clipPath\",\n            clippathunits: \"clipPathUnits\",\n            cliprule: \"clipRule\",\n            \"clip-rule\": \"clipRule\",\n            color: \"color\",\n            colorinterpolation: \"colorInterpolation\",\n            \"color-interpolation\": \"colorInterpolation\",\n            colorinterpolationfilters: \"colorInterpolationFilters\",\n            \"color-interpolation-filters\": \"colorInterpolationFilters\",\n            colorprofile: \"colorProfile\",\n            \"color-profile\": \"colorProfile\",\n            colorrendering: \"colorRendering\",\n            \"color-rendering\": \"colorRendering\",\n            contentscripttype: \"contentScriptType\",\n            contentstyletype: \"contentStyleType\",\n            cursor: \"cursor\",\n            cx: \"cx\",\n            cy: \"cy\",\n            d: \"d\",\n            datatype: \"datatype\",\n            decelerate: \"decelerate\",\n            descent: \"descent\",\n            diffuseconstant: \"diffuseConstant\",\n            direction: \"direction\",\n            display: \"display\",\n            divisor: \"divisor\",\n            dominantbaseline: \"dominantBaseline\",\n            \"dominant-baseline\": \"dominantBaseline\",\n            dur: \"dur\",\n            dx: \"dx\",\n            dy: \"dy\",\n            edgemode: \"edgeMode\",\n            elevation: \"elevation\",\n            enablebackground: \"enableBackground\",\n            \"enable-background\": \"enableBackground\",\n            end: \"end\",\n            exponent: \"exponent\",\n            externalresourcesrequired: \"externalResourcesRequired\",\n            fill: \"fill\",\n            fillopacity: \"fillOpacity\",\n            \"fill-opacity\": \"fillOpacity\",\n            fillrule: \"fillRule\",\n            \"fill-rule\": \"fillRule\",\n            filter: \"filter\",\n            filterres: \"filterRes\",\n            filterunits: \"filterUnits\",\n            floodopacity: \"floodOpacity\",\n            \"flood-opacity\": \"floodOpacity\",\n            floodcolor: \"floodColor\",\n            \"flood-color\": \"floodColor\",\n            focusable: \"focusable\",\n            fontfamily: \"fontFamily\",\n            \"font-family\": \"fontFamily\",\n            fontsize: \"fontSize\",\n            \"font-size\": \"fontSize\",\n            fontsizeadjust: \"fontSizeAdjust\",\n            \"font-size-adjust\": \"fontSizeAdjust\",\n            fontstretch: \"fontStretch\",\n            \"font-stretch\": \"fontStretch\",\n            fontstyle: \"fontStyle\",\n            \"font-style\": \"fontStyle\",\n            fontvariant: \"fontVariant\",\n            \"font-variant\": \"fontVariant\",\n            fontweight: \"fontWeight\",\n            \"font-weight\": \"fontWeight\",\n            format: \"format\",\n            from: \"from\",\n            fx: \"fx\",\n            fy: \"fy\",\n            g1: \"g1\",\n            g2: \"g2\",\n            glyphname: \"glyphName\",\n            \"glyph-name\": \"glyphName\",\n            glyphorientationhorizontal: \"glyphOrientationHorizontal\",\n            \"glyph-orientation-horizontal\": \"glyphOrientationHorizontal\",\n            glyphorientationvertical: \"glyphOrientationVertical\",\n            \"glyph-orientation-vertical\": \"glyphOrientationVertical\",\n            glyphref: \"glyphRef\",\n            gradienttransform: \"gradientTransform\",\n            gradientunits: \"gradientUnits\",\n            hanging: \"hanging\",\n            horizadvx: \"horizAdvX\",\n            \"horiz-adv-x\": \"horizAdvX\",\n            horizoriginx: \"horizOriginX\",\n            \"horiz-origin-x\": \"horizOriginX\",\n            ideographic: \"ideographic\",\n            imagerendering: \"imageRendering\",\n            \"image-rendering\": \"imageRendering\",\n            in2: \"in2\",\n            in: \"in\",\n            inlist: \"inlist\",\n            intercept: \"intercept\",\n            k1: \"k1\",\n            k2: \"k2\",\n            k3: \"k3\",\n            k4: \"k4\",\n            k: \"k\",\n            kernelmatrix: \"kernelMatrix\",\n            kernelunitlength: \"kernelUnitLength\",\n            kerning: \"kerning\",\n            keypoints: \"keyPoints\",\n            keysplines: \"keySplines\",\n            keytimes: \"keyTimes\",\n            lengthadjust: \"lengthAdjust\",\n            letterspacing: \"letterSpacing\",\n            \"letter-spacing\": \"letterSpacing\",\n            lightingcolor: \"lightingColor\",\n            \"lighting-color\": \"lightingColor\",\n            limitingconeangle: \"limitingConeAngle\",\n            local: \"local\",\n            markerend: \"markerEnd\",\n            \"marker-end\": \"markerEnd\",\n            markerheight: \"markerHeight\",\n            markermid: \"markerMid\",\n            \"marker-mid\": \"markerMid\",\n            markerstart: \"markerStart\",\n            \"marker-start\": \"markerStart\",\n            markerunits: \"markerUnits\",\n            markerwidth: \"markerWidth\",\n            mask: \"mask\",\n            maskcontentunits: \"maskContentUnits\",\n            maskunits: \"maskUnits\",\n            mathematical: \"mathematical\",\n            mode: \"mode\",\n            numoctaves: \"numOctaves\",\n            offset: \"offset\",\n            opacity: \"opacity\",\n            operator: \"operator\",\n            order: \"order\",\n            orient: \"orient\",\n            orientation: \"orientation\",\n            origin: \"origin\",\n            overflow: \"overflow\",\n            overlineposition: \"overlinePosition\",\n            \"overline-position\": \"overlinePosition\",\n            overlinethickness: \"overlineThickness\",\n            \"overline-thickness\": \"overlineThickness\",\n            paintorder: \"paintOrder\",\n            \"paint-order\": \"paintOrder\",\n            panose1: \"panose1\",\n            \"panose-1\": \"panose1\",\n            pathlength: \"pathLength\",\n            patterncontentunits: \"patternContentUnits\",\n            patterntransform: \"patternTransform\",\n            patternunits: \"patternUnits\",\n            pointerevents: \"pointerEvents\",\n            \"pointer-events\": \"pointerEvents\",\n            points: \"points\",\n            pointsatx: \"pointsAtX\",\n            pointsaty: \"pointsAtY\",\n            pointsatz: \"pointsAtZ\",\n            prefix: \"prefix\",\n            preservealpha: \"preserveAlpha\",\n            preserveaspectratio: \"preserveAspectRatio\",\n            primitiveunits: \"primitiveUnits\",\n            property: \"property\",\n            r: \"r\",\n            radius: \"radius\",\n            refx: \"refX\",\n            refy: \"refY\",\n            renderingintent: \"renderingIntent\",\n            \"rendering-intent\": \"renderingIntent\",\n            repeatcount: \"repeatCount\",\n            repeatdur: \"repeatDur\",\n            requiredextensions: \"requiredExtensions\",\n            requiredfeatures: \"requiredFeatures\",\n            resource: \"resource\",\n            restart: \"restart\",\n            result: \"result\",\n            results: \"results\",\n            rotate: \"rotate\",\n            rx: \"rx\",\n            ry: \"ry\",\n            scale: \"scale\",\n            security: \"security\",\n            seed: \"seed\",\n            shaperendering: \"shapeRendering\",\n            \"shape-rendering\": \"shapeRendering\",\n            slope: \"slope\",\n            spacing: \"spacing\",\n            specularconstant: \"specularConstant\",\n            specularexponent: \"specularExponent\",\n            speed: \"speed\",\n            spreadmethod: \"spreadMethod\",\n            startoffset: \"startOffset\",\n            stddeviation: \"stdDeviation\",\n            stemh: \"stemh\",\n            stemv: \"stemv\",\n            stitchtiles: \"stitchTiles\",\n            stopcolor: \"stopColor\",\n            \"stop-color\": \"stopColor\",\n            stopopacity: \"stopOpacity\",\n            \"stop-opacity\": \"stopOpacity\",\n            strikethroughposition: \"strikethroughPosition\",\n            \"strikethrough-position\": \"strikethroughPosition\",\n            strikethroughthickness: \"strikethroughThickness\",\n            \"strikethrough-thickness\": \"strikethroughThickness\",\n            string: \"string\",\n            stroke: \"stroke\",\n            strokedasharray: \"strokeDasharray\",\n            \"stroke-dasharray\": \"strokeDasharray\",\n            strokedashoffset: \"strokeDashoffset\",\n            \"stroke-dashoffset\": \"strokeDashoffset\",\n            strokelinecap: \"strokeLinecap\",\n            \"stroke-linecap\": \"strokeLinecap\",\n            strokelinejoin: \"strokeLinejoin\",\n            \"stroke-linejoin\": \"strokeLinejoin\",\n            strokemiterlimit: \"strokeMiterlimit\",\n            \"stroke-miterlimit\": \"strokeMiterlimit\",\n            strokewidth: \"strokeWidth\",\n            \"stroke-width\": \"strokeWidth\",\n            strokeopacity: \"strokeOpacity\",\n            \"stroke-opacity\": \"strokeOpacity\",\n            suppresscontenteditablewarning: \"suppressContentEditableWarning\",\n            suppresshydrationwarning: \"suppressHydrationWarning\",\n            surfacescale: \"surfaceScale\",\n            systemlanguage: \"systemLanguage\",\n            tablevalues: \"tableValues\",\n            targetx: \"targetX\",\n            targety: \"targetY\",\n            textanchor: \"textAnchor\",\n            \"text-anchor\": \"textAnchor\",\n            textdecoration: \"textDecoration\",\n            \"text-decoration\": \"textDecoration\",\n            textlength: \"textLength\",\n            textrendering: \"textRendering\",\n            \"text-rendering\": \"textRendering\",\n            to: \"to\",\n            transform: \"transform\",\n            typeof: \"typeof\",\n            u1: \"u1\",\n            u2: \"u2\",\n            underlineposition: \"underlinePosition\",\n            \"underline-position\": \"underlinePosition\",\n            underlinethickness: \"underlineThickness\",\n            \"underline-thickness\": \"underlineThickness\",\n            unicode: \"unicode\",\n            unicodebidi: \"unicodeBidi\",\n            \"unicode-bidi\": \"unicodeBidi\",\n            unicoderange: \"unicodeRange\",\n            \"unicode-range\": \"unicodeRange\",\n            unitsperem: \"unitsPerEm\",\n            \"units-per-em\": \"unitsPerEm\",\n            unselectable: \"unselectable\",\n            valphabetic: \"vAlphabetic\",\n            \"v-alphabetic\": \"vAlphabetic\",\n            values: \"values\",\n            vectoreffect: \"vectorEffect\",\n            \"vector-effect\": \"vectorEffect\",\n            version: \"version\",\n            vertadvy: \"vertAdvY\",\n            \"vert-adv-y\": \"vertAdvY\",\n            vertoriginx: \"vertOriginX\",\n            \"vert-origin-x\": \"vertOriginX\",\n            vertoriginy: \"vertOriginY\",\n            \"vert-origin-y\": \"vertOriginY\",\n            vhanging: \"vHanging\",\n            \"v-hanging\": \"vHanging\",\n            videographic: \"vIdeographic\",\n            \"v-ideographic\": \"vIdeographic\",\n            viewbox: \"viewBox\",\n            viewtarget: \"viewTarget\",\n            visibility: \"visibility\",\n            vmathematical: \"vMathematical\",\n            \"v-mathematical\": \"vMathematical\",\n            vocab: \"vocab\",\n            widths: \"widths\",\n            wordspacing: \"wordSpacing\",\n            \"word-spacing\": \"wordSpacing\",\n            writingmode: \"writingMode\",\n            \"writing-mode\": \"writingMode\",\n            x1: \"x1\",\n            x2: \"x2\",\n            x: \"x\",\n            xchannelselector: \"xChannelSelector\",\n            xheight: \"xHeight\",\n            \"x-height\": \"xHeight\",\n            xlinkactuate: \"xlinkActuate\",\n            \"xlink:actuate\": \"xlinkActuate\",\n            xlinkarcrole: \"xlinkArcrole\",\n            \"xlink:arcrole\": \"xlinkArcrole\",\n            xlinkhref: \"xlinkHref\",\n            \"xlink:href\": \"xlinkHref\",\n            xlinkrole: \"xlinkRole\",\n            \"xlink:role\": \"xlinkRole\",\n            xlinkshow: \"xlinkShow\",\n            \"xlink:show\": \"xlinkShow\",\n            xlinktitle: \"xlinkTitle\",\n            \"xlink:title\": \"xlinkTitle\",\n            xlinktype: \"xlinkType\",\n            \"xlink:type\": \"xlinkType\",\n            xmlbase: \"xmlBase\",\n            \"xml:base\": \"xmlBase\",\n            xmllang: \"xmlLang\",\n            \"xml:lang\": \"xmlLang\",\n            xmlns: \"xmlns\",\n            \"xml:space\": \"xmlSpace\",\n            xmlnsxlink: \"xmlnsXlink\",\n            \"xmlns:xlink\": \"xmlnsXlink\",\n            xmlspace: \"xmlSpace\",\n            y1: \"y1\",\n            y2: \"y2\",\n            y: \"y\",\n            ychannelselector: \"yChannelSelector\",\n            z: \"z\",\n            zoomandpan: \"zoomAndPan\"\n        };\n        var validateProperty$1 = function() {};\n        {\n            var warnedProperties$1 = {};\n            var EVENT_NAME_REGEX = /^on./;\n            var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;\n            var rARIA$1 = new RegExp(\"^(aria)-[\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n            var rARIACamel$1 = new RegExp(\"^(aria)[A-Z][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n            validateProperty$1 = function(tagName, name, value, eventRegistry) {\n                if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {\n                    return true;\n                }\n                var lowerCasedName = name.toLowerCase();\n                if (lowerCasedName === \"onfocusin\" || lowerCasedName === \"onfocusout\") {\n                    error(\"React uses onFocus and onBlur instead of onFocusIn and onFocusOut. \" + \"All React events are normalized to bubble, so onFocusIn and onFocusOut \" + \"are not needed/supported by React.\");\n                    warnedProperties$1[name] = true;\n                    return true;\n                } // We can't rely on the event system being injected on the server.\n                if (eventRegistry != null) {\n                    var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;\n                    if (registrationNameDependencies.hasOwnProperty(name)) {\n                        return true;\n                    }\n                    var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;\n                    if (registrationName != null) {\n                        error(\"Invalid event handler property `%s`. Did you mean `%s`?\", name, registrationName);\n                        warnedProperties$1[name] = true;\n                        return true;\n                    }\n                    if (EVENT_NAME_REGEX.test(name)) {\n                        error(\"Unknown event handler property `%s`. It will be ignored.\", name);\n                        warnedProperties$1[name] = true;\n                        return true;\n                    }\n                } else if (EVENT_NAME_REGEX.test(name)) {\n                    // If no event plugins have been injected, we are in a server environment.\n                    // So we can't tell if the event name is correct for sure, but we can filter\n                    // out known bad ones like `onclick`. We can't suggest a specific replacement though.\n                    if (INVALID_EVENT_NAME_REGEX.test(name)) {\n                        error(\"Invalid event handler property `%s`. \" + \"React events use the camelCase naming convention, for example `onClick`.\", name);\n                    }\n                    warnedProperties$1[name] = true;\n                    return true;\n                } // Let the ARIA attribute hook validate ARIA attributes\n                if (rARIA$1.test(name) || rARIACamel$1.test(name)) {\n                    return true;\n                }\n                if (lowerCasedName === \"innerhtml\") {\n                    error(\"Directly setting property `innerHTML` is not permitted. \" + \"For more information, lookup documentation on `dangerouslySetInnerHTML`.\");\n                    warnedProperties$1[name] = true;\n                    return true;\n                }\n                if (lowerCasedName === \"aria\") {\n                    error(\"The `aria` attribute is reserved for future use in React. \" + \"Pass individual `aria-` attributes instead.\");\n                    warnedProperties$1[name] = true;\n                    return true;\n                }\n                if (lowerCasedName === \"is\" && value !== null && value !== undefined && typeof value !== \"string\") {\n                    error(\"Received a `%s` for a string attribute `is`. If this is expected, cast \" + \"the value to a string.\", typeof value);\n                    warnedProperties$1[name] = true;\n                    return true;\n                }\n                if (typeof value === \"number\" && isNaN(value)) {\n                    error(\"Received NaN for the `%s` attribute. If this is expected, cast \" + \"the value to a string.\", name);\n                    warnedProperties$1[name] = true;\n                    return true;\n                }\n                var propertyInfo = getPropertyInfo(name);\n                var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED; // Known attributes should match the casing specified in the property config.\n                if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n                    var standardName = possibleStandardNames[lowerCasedName];\n                    if (standardName !== name) {\n                        error(\"Invalid DOM property `%s`. Did you mean `%s`?\", name, standardName);\n                        warnedProperties$1[name] = true;\n                        return true;\n                    }\n                } else if (!isReserved && name !== lowerCasedName) {\n                    // Unknown attributes should have lowercase casing since that's how they\n                    // will be cased anyway with server rendering.\n                    error(\"React does not recognize the `%s` prop on a DOM element. If you \" + \"intentionally want it to appear in the DOM as a custom \" + \"attribute, spell it as lowercase `%s` instead. \" + \"If you accidentally passed it from a parent component, remove \" + \"it from the DOM element.\", name, lowerCasedName);\n                    warnedProperties$1[name] = true;\n                    return true;\n                }\n                if (typeof value === \"boolean\" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {\n                    if (value) {\n                        error(\"Received `%s` for a non-boolean attribute `%s`.\\n\\n\" + \"If you want to write it to the DOM, pass a string instead: \" + '%s=\"%s\" or %s={value.toString()}.', value, name, name, value, name);\n                    } else {\n                        error(\"Received `%s` for a non-boolean attribute `%s`.\\n\\n\" + \"If you want to write it to the DOM, pass a string instead: \" + '%s=\"%s\" or %s={value.toString()}.\\n\\n' + \"If you used to conditionally omit it with %s={condition && value}, \" + \"pass %s={condition ? value : undefined} instead.\", value, name, name, value, name, name, name);\n                    }\n                    warnedProperties$1[name] = true;\n                    return true;\n                } // Now that we've validated casing, do not validate\n                // data types for reserved props\n                if (isReserved) {\n                    return true;\n                } // Warn when a known attribute is a bad type\n                if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {\n                    warnedProperties$1[name] = true;\n                    return false;\n                } // Warn when passing the strings 'false' or 'true' into a boolean prop\n                if ((value === \"false\" || value === \"true\") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {\n                    error(\"Received the string `%s` for the boolean attribute `%s`. \" + \"%s \" + \"Did you mean %s={%s}?\", value, name, value === \"false\" ? \"The browser will interpret it as a truthy value.\" : 'Although this works, it will not work as expected if you pass the string \"false\".', name, value);\n                    warnedProperties$1[name] = true;\n                    return true;\n                }\n                return true;\n            };\n        }\n        var warnUnknownProperties = function(type, props, eventRegistry) {\n            {\n                var unknownProps = [];\n                for(var key in props){\n                    var isValid = validateProperty$1(type, key, props[key], eventRegistry);\n                    if (!isValid) {\n                        unknownProps.push(key);\n                    }\n                }\n                var unknownPropString = unknownProps.map(function(prop) {\n                    return \"`\" + prop + \"`\";\n                }).join(\", \");\n                if (unknownProps.length === 1) {\n                    error(\"Invalid value for prop %s on <%s> tag. Either remove it from the element, \" + \"or pass a string or number value to keep it in the DOM. \" + \"For details, see https://reactjs.org/link/attribute-behavior \", unknownPropString, type);\n                } else if (unknownProps.length > 1) {\n                    error(\"Invalid values for props %s on <%s> tag. Either remove them from the element, \" + \"or pass a string or number value to keep them in the DOM. \" + \"For details, see https://reactjs.org/link/attribute-behavior \", unknownPropString, type);\n                }\n            }\n        };\n        function validateProperties$2(type, props, eventRegistry) {\n            if (isCustomComponent(type, props)) {\n                return;\n            }\n            warnUnknownProperties(type, props, eventRegistry);\n        }\n        var warnValidStyle = function() {};\n        {\n            // 'msTransform' is correct, but the other prefixes should be capitalized\n            var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;\n            var msPattern = /^-ms-/;\n            var hyphenPattern = /-(.)/g; // style values shouldn't contain a semicolon\n            var badStyleValueWithSemicolonPattern = /;\\s*$/;\n            var warnedStyleNames = {};\n            var warnedStyleValues = {};\n            var warnedForNaNValue = false;\n            var warnedForInfinityValue = false;\n            var camelize = function(string) {\n                return string.replace(hyphenPattern, function(_, character) {\n                    return character.toUpperCase();\n                });\n            };\n            var warnHyphenatedStyleName = function(name) {\n                if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n                    return;\n                }\n                warnedStyleNames[name] = true;\n                error(\"Unsupported style property %s. Did you mean %s?\", name, // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n                // is converted to lowercase `ms`.\n                camelize(name.replace(msPattern, \"ms-\")));\n            };\n            var warnBadVendoredStyleName = function(name) {\n                if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n                    return;\n                }\n                warnedStyleNames[name] = true;\n                error(\"Unsupported vendor-prefixed style property %s. Did you mean %s?\", name, name.charAt(0).toUpperCase() + name.slice(1));\n            };\n            var warnStyleValueWithSemicolon = function(name, value) {\n                if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\n                    return;\n                }\n                warnedStyleValues[value] = true;\n                error(\"Style property values shouldn't contain a semicolon. \" + 'Try \"%s: %s\" instead.', name, value.replace(badStyleValueWithSemicolonPattern, \"\"));\n            };\n            var warnStyleValueIsNaN = function(name, value) {\n                if (warnedForNaNValue) {\n                    return;\n                }\n                warnedForNaNValue = true;\n                error(\"`NaN` is an invalid value for the `%s` css style property.\", name);\n            };\n            var warnStyleValueIsInfinity = function(name, value) {\n                if (warnedForInfinityValue) {\n                    return;\n                }\n                warnedForInfinityValue = true;\n                error(\"`Infinity` is an invalid value for the `%s` css style property.\", name);\n            };\n            warnValidStyle = function(name, value) {\n                if (name.indexOf(\"-\") > -1) {\n                    warnHyphenatedStyleName(name);\n                } else if (badVendoredStyleNamePattern.test(name)) {\n                    warnBadVendoredStyleName(name);\n                } else if (badStyleValueWithSemicolonPattern.test(value)) {\n                    warnStyleValueWithSemicolon(name, value);\n                }\n                if (typeof value === \"number\") {\n                    if (isNaN(value)) {\n                        warnStyleValueIsNaN(name, value);\n                    } else if (!isFinite(value)) {\n                        warnStyleValueIsInfinity(name, value);\n                    }\n                }\n            };\n        }\n        var warnValidStyle$1 = warnValidStyle;\n        // code copied and modified from escape-html\n        var matchHtmlRegExp = /[\"'&<>]/;\n        /**\n * Escapes special characters and HTML entities in a given html string.\n *\n * @param  {string} string HTML string to escape for later insertion\n * @return {string}\n * @public\n */ function escapeHtml(string) {\n            {\n                checkHtmlStringCoercion(string);\n            }\n            var str = \"\" + string;\n            var match = matchHtmlRegExp.exec(str);\n            if (!match) {\n                return str;\n            }\n            var escape;\n            var html = \"\";\n            var index;\n            var lastIndex = 0;\n            for(index = match.index; index < str.length; index++){\n                switch(str.charCodeAt(index)){\n                    case 34:\n                        // \"\n                        escape = \"&quot;\";\n                        break;\n                    case 38:\n                        // &\n                        escape = \"&amp;\";\n                        break;\n                    case 39:\n                        // '\n                        escape = \"&#x27;\"; // modified from escape-html; used to be '&#39'\n                        break;\n                    case 60:\n                        // <\n                        escape = \"&lt;\";\n                        break;\n                    case 62:\n                        // >\n                        escape = \"&gt;\";\n                        break;\n                    default:\n                        continue;\n                }\n                if (lastIndex !== index) {\n                    html += str.substring(lastIndex, index);\n                }\n                lastIndex = index + 1;\n                html += escape;\n            }\n            return lastIndex !== index ? html + str.substring(lastIndex, index) : html;\n        } // end code copied and modified from escape-html\n        /**\n * Escapes text to prevent scripting attacks.\n *\n * @param {*} text Text value to escape.\n * @return {string} An escaped string.\n */ function escapeTextForBrowser(text) {\n            if (typeof text === \"boolean\" || typeof text === \"number\") {\n                // this shortcircuit helps perf for types that we know will never have\n                // special characters, especially given that this function is used often\n                // for numeric dom ids.\n                return \"\" + text;\n            }\n            return escapeHtml(text);\n        }\n        var uppercasePattern = /([A-Z])/g;\n        var msPattern$1 = /^ms-/;\n        /**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n */ function hyphenateStyleName(name) {\n            return name.replace(uppercasePattern, \"-$1\").toLowerCase().replace(msPattern$1, \"-ms-\");\n        }\n        // and any newline or tab are filtered out as if they're not part of the URL.\n        // https://url.spec.whatwg.org/#url-parsing\n        // Tab or newline are defined as \\r\\n\\t:\n        // https://infra.spec.whatwg.org/#ascii-tab-or-newline\n        // A C0 control is a code point in the range \\u0000 NULL to \\u001F\n        // INFORMATION SEPARATOR ONE, inclusive:\n        // https://infra.spec.whatwg.org/#c0-control-or-space\n        /* eslint-disable max-len */ var isJavaScriptProtocol = /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*\\:/i;\n        var didWarn = false;\n        function sanitizeURL(url) {\n            {\n                if (!didWarn && isJavaScriptProtocol.test(url)) {\n                    didWarn = true;\n                    error(\"A future version of React will block javascript: URLs as a security precaution. \" + \"Use event handlers instead if you can. If you need to generate unsafe HTML try \" + \"using dangerouslySetInnerHTML instead. React was passed %s.\", JSON.stringify(url));\n                }\n            }\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        var startInlineScript = stringToPrecomputedChunk(\"<script>\");\n        var endInlineScript = stringToPrecomputedChunk(\"</script>\");\n        var startScriptSrc = stringToPrecomputedChunk('<script src=\"');\n        var startModuleSrc = stringToPrecomputedChunk('<script type=\"module\" src=\"');\n        var endAsyncScript = stringToPrecomputedChunk('\" async=\"\"></script>');\n        /**\n * This escaping function is designed to work with bootstrapScriptContent only.\n * because we know we are escaping the entire script. We can avoid for instance\n * escaping html comment string sequences that are valid javascript as well because\n * if there are no sebsequent <script sequences the html parser will never enter\n * script data double escaped state (see: https://www.w3.org/TR/html53/syntax.html#script-data-double-escaped-state)\n *\n * While untrusted script content should be made safe before using this api it will\n * ensure that the script cannot be early terminated or never terminated state\n */ function escapeBootstrapScriptContent(scriptText) {\n            {\n                checkHtmlStringCoercion(scriptText);\n            }\n            return (\"\" + scriptText).replace(scriptRegex, scriptReplacer);\n        }\n        var scriptRegex = /(<\\/|<)(s)(cript)/gi;\n        var scriptReplacer = function(match, prefix, s, suffix) {\n            return \"\" + prefix + (s === \"s\" ? \"\\\\u0073\" : \"\\\\u0053\") + suffix;\n        }; // Allows us to keep track of what we've already written so we can refer back to it.\n        function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {\n            var idPrefix = identifierPrefix === undefined ? \"\" : identifierPrefix;\n            var inlineScriptWithNonce = nonce === undefined ? startInlineScript : stringToPrecomputedChunk('<script nonce=\"' + escapeTextForBrowser(nonce) + '\">');\n            var bootstrapChunks = [];\n            if (bootstrapScriptContent !== undefined) {\n                bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);\n            }\n            if (bootstrapScripts !== undefined) {\n                for(var i = 0; i < bootstrapScripts.length; i++){\n                    bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(bootstrapScripts[i])), endAsyncScript);\n                }\n            }\n            if (bootstrapModules !== undefined) {\n                for(var _i = 0; _i < bootstrapModules.length; _i++){\n                    bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(bootstrapModules[_i])), endAsyncScript);\n                }\n            }\n            return {\n                bootstrapChunks: bootstrapChunks,\n                startInlineScript: inlineScriptWithNonce,\n                placeholderPrefix: stringToPrecomputedChunk(idPrefix + \"P:\"),\n                segmentPrefix: stringToPrecomputedChunk(idPrefix + \"S:\"),\n                boundaryPrefix: idPrefix + \"B:\",\n                idPrefix: idPrefix,\n                nextSuspenseID: 0,\n                sentCompleteSegmentFunction: false,\n                sentCompleteBoundaryFunction: false,\n                sentClientRenderFunction: false\n            };\n        } // Constants for the insertion mode we're currently writing in. We don't encode all HTML5 insertion\n        // modes. We only include the variants as they matter for the sake of our purposes.\n        // We don't actually provide the namespace therefore we use constants instead of the string.\n        var ROOT_HTML_MODE = 0; // Used for the root most element tag.\n        var HTML_MODE = 1;\n        var SVG_MODE = 2;\n        var MATHML_MODE = 3;\n        var HTML_TABLE_MODE = 4;\n        var HTML_TABLE_BODY_MODE = 5;\n        var HTML_TABLE_ROW_MODE = 6;\n        var HTML_COLGROUP_MODE = 7; // We have a greater than HTML_TABLE_MODE check elsewhere. If you add more cases here, make sure it\n        // still makes sense\n        function createFormatContext(insertionMode, selectedValue) {\n            return {\n                insertionMode: insertionMode,\n                selectedValue: selectedValue\n            };\n        }\n        function createRootFormatContext(namespaceURI) {\n            var insertionMode = namespaceURI === \"http://www.w3.org/2000/svg\" ? SVG_MODE : namespaceURI === \"http://www.w3.org/1998/Math/MathML\" ? MATHML_MODE : ROOT_HTML_MODE;\n            return createFormatContext(insertionMode, null);\n        }\n        function getChildFormatContext(parentContext, type, props) {\n            switch(type){\n                case \"select\":\n                    return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);\n                case \"svg\":\n                    return createFormatContext(SVG_MODE, null);\n                case \"math\":\n                    return createFormatContext(MATHML_MODE, null);\n                case \"foreignObject\":\n                    return createFormatContext(HTML_MODE, null);\n                // Table parents are special in that their children can only be created at all if they're\n                // wrapped in a table parent. So we need to encode that we're entering this mode.\n                case \"table\":\n                    return createFormatContext(HTML_TABLE_MODE, null);\n                case \"thead\":\n                case \"tbody\":\n                case \"tfoot\":\n                    return createFormatContext(HTML_TABLE_BODY_MODE, null);\n                case \"colgroup\":\n                    return createFormatContext(HTML_COLGROUP_MODE, null);\n                case \"tr\":\n                    return createFormatContext(HTML_TABLE_ROW_MODE, null);\n            }\n            if (parentContext.insertionMode >= HTML_TABLE_MODE) {\n                // Whatever tag this was, it wasn't a table parent or other special parent, so we must have\n                // entered plain HTML again.\n                return createFormatContext(HTML_MODE, null);\n            }\n            if (parentContext.insertionMode === ROOT_HTML_MODE) {\n                // We've emitted the root and is now in plain HTML mode.\n                return createFormatContext(HTML_MODE, null);\n            }\n            return parentContext;\n        }\n        var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;\n        function assignSuspenseBoundaryID(responseState) {\n            var generatedID = responseState.nextSuspenseID++;\n            return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));\n        }\n        function makeId(responseState, treeId, localId) {\n            var idPrefix = responseState.idPrefix;\n            var id = \":\" + idPrefix + \"R\" + treeId; // Unless this is the first id at this level, append a number at the end\n            // that represents the position of this useId hook among all the useId\n            // hooks for this fiber.\n            if (localId > 0) {\n                id += \"H\" + localId.toString(32);\n            }\n            return id + \":\";\n        }\n        function encodeHTMLTextNode(text) {\n            return escapeTextForBrowser(text);\n        }\n        var textSeparator = stringToPrecomputedChunk(\"<!-- -->\");\n        function pushTextInstance(target, text, responseState, textEmbedded) {\n            if (text === \"\") {\n                // Empty text doesn't have a DOM node representation and the hydration is aware of this.\n                return textEmbedded;\n            }\n            if (textEmbedded) {\n                target.push(textSeparator);\n            }\n            target.push(stringToChunk(encodeHTMLTextNode(text)));\n            return true;\n        } // Called when Fizz is done with a Segment. Currently the only purpose is to conditionally\n        // emit a text separator when we don't know for sure it is safe to omit\n        function pushSegmentFinale(target, responseState, lastPushedText, textEmbedded) {\n            if (lastPushedText && textEmbedded) {\n                target.push(textSeparator);\n            }\n        }\n        var styleNameCache = new Map();\n        function processStyleName(styleName) {\n            var chunk = styleNameCache.get(styleName);\n            if (chunk !== undefined) {\n                return chunk;\n            }\n            var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));\n            styleNameCache.set(styleName, result);\n            return result;\n        }\n        var styleAttributeStart = stringToPrecomputedChunk(' style=\"');\n        var styleAssign = stringToPrecomputedChunk(\":\");\n        var styleSeparator = stringToPrecomputedChunk(\";\");\n        function pushStyle(target, responseState, style) {\n            if (typeof style !== \"object\") {\n                throw new Error(\"The `style` prop expects a mapping from style properties to values, \" + \"not a string. For example, style={{marginRight: spacing + 'em'}} when \" + \"using JSX.\");\n            }\n            var isFirst = true;\n            for(var styleName in style){\n                if (!hasOwnProperty.call(style, styleName)) {\n                    continue;\n                } // If you provide unsafe user data here they can inject arbitrary CSS\n                // which may be problematic (I couldn't repro this):\n                // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n                // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n                // This is not an XSS hole but instead a potential CSS injection issue\n                // which has lead to a greater discussion about how we're going to\n                // trust URLs moving forward. See #2115901\n                var styleValue = style[styleName];\n                if (styleValue == null || typeof styleValue === \"boolean\" || styleValue === \"\") {\n                    continue;\n                }\n                var nameChunk = void 0;\n                var valueChunk = void 0;\n                var isCustomProperty = styleName.indexOf(\"--\") === 0;\n                if (isCustomProperty) {\n                    nameChunk = stringToChunk(escapeTextForBrowser(styleName));\n                    {\n                        checkCSSPropertyStringCoercion(styleValue, styleName);\n                    }\n                    valueChunk = stringToChunk(escapeTextForBrowser((\"\" + styleValue).trim()));\n                } else {\n                    {\n                        warnValidStyle$1(styleName, styleValue);\n                    }\n                    nameChunk = processStyleName(styleName);\n                    if (typeof styleValue === \"number\") {\n                        if (styleValue !== 0 && !hasOwnProperty.call(isUnitlessNumber, styleName)) {\n                            valueChunk = stringToChunk(styleValue + \"px\"); // Presumes implicit 'px' suffix for unitless numbers\n                        } else {\n                            valueChunk = stringToChunk(\"\" + styleValue);\n                        }\n                    } else {\n                        {\n                            checkCSSPropertyStringCoercion(styleValue, styleName);\n                        }\n                        valueChunk = stringToChunk(escapeTextForBrowser((\"\" + styleValue).trim()));\n                    }\n                }\n                if (isFirst) {\n                    isFirst = false; // If it's first, we don't need any separators prefixed.\n                    target.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);\n                } else {\n                    target.push(styleSeparator, nameChunk, styleAssign, valueChunk);\n                }\n            }\n            if (!isFirst) {\n                target.push(attributeEnd);\n            }\n        }\n        var attributeSeparator = stringToPrecomputedChunk(\" \");\n        var attributeAssign = stringToPrecomputedChunk('=\"');\n        var attributeEnd = stringToPrecomputedChunk('\"');\n        var attributeEmptyString = stringToPrecomputedChunk('=\"\"');\n        function pushAttribute(target, responseState, name, value) {\n            switch(name){\n                case \"style\":\n                    {\n                        pushStyle(target, responseState, value);\n                        return;\n                    }\n                case \"defaultValue\":\n                case \"defaultChecked\":\n                case \"innerHTML\":\n                case \"suppressContentEditableWarning\":\n                case \"suppressHydrationWarning\":\n                    // Ignored. These are built-in to React on the client.\n                    return;\n            }\n            if (// We have already filtered out null/undefined and reserved words.\n            name.length > 2 && (name[0] === \"o\" || name[0] === \"O\") && (name[1] === \"n\" || name[1] === \"N\")) {\n                return;\n            }\n            var propertyInfo = getPropertyInfo(name);\n            if (propertyInfo !== null) {\n                // shouldRemoveAttribute\n                switch(typeof value){\n                    case \"function\":\n                    case \"symbol\":\n                        // eslint-disable-line\n                        return;\n                    case \"boolean\":\n                        {\n                            if (!propertyInfo.acceptsBooleans) {\n                                return;\n                            }\n                        }\n                }\n                var attributeName = propertyInfo.attributeName;\n                var attributeNameChunk = stringToChunk(attributeName); // TODO: If it's known we can cache the chunk.\n                switch(propertyInfo.type){\n                    case BOOLEAN:\n                        if (value) {\n                            target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);\n                        }\n                        return;\n                    case OVERLOADED_BOOLEAN:\n                        if (value === true) {\n                            target.push(attributeSeparator, attributeNameChunk, attributeEmptyString);\n                        } else if (value === false) ;\n                        else {\n                            target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        return;\n                    case NUMERIC:\n                        if (!isNaN(value)) {\n                            target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        break;\n                    case POSITIVE_NUMERIC:\n                        if (!isNaN(value) && value >= 1) {\n                            target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                        }\n                        break;\n                    default:\n                        if (propertyInfo.sanitizeURL) {\n                            {\n                                checkAttributeStringCoercion(value, attributeName);\n                            }\n                            value = \"\" + value;\n                            sanitizeURL(value);\n                        }\n                        target.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n                }\n            } else if (isAttributeNameSafe(name)) {\n                // shouldRemoveAttribute\n                switch(typeof value){\n                    case \"function\":\n                    case \"symbol\":\n                        // eslint-disable-line\n                        return;\n                    case \"boolean\":\n                        {\n                            var prefix = name.toLowerCase().slice(0, 5);\n                            if (prefix !== \"data-\" && prefix !== \"aria-\") {\n                                return;\n                            }\n                        }\n                }\n                target.push(attributeSeparator, stringToChunk(name), attributeAssign, stringToChunk(escapeTextForBrowser(value)), attributeEnd);\n            }\n        }\n        var endOfStartTag = stringToPrecomputedChunk(\">\");\n        var endOfStartTagSelfClosing = stringToPrecomputedChunk(\"/>\");\n        function pushInnerHTML(target, innerHTML, children) {\n            if (innerHTML != null) {\n                if (children != null) {\n                    throw new Error(\"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\");\n                }\n                if (typeof innerHTML !== \"object\" || !(\"__html\" in innerHTML)) {\n                    throw new Error(\"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. \" + \"Please visit https://reactjs.org/link/dangerously-set-inner-html \" + \"for more information.\");\n                }\n                var html = innerHTML.__html;\n                if (html !== null && html !== undefined) {\n                    {\n                        checkHtmlStringCoercion(html);\n                    }\n                    target.push(stringToChunk(\"\" + html));\n                }\n            }\n        } // TODO: Move these to ResponseState so that we warn for every request.\n        // It would help debugging in stateful servers (e.g. service worker).\n        var didWarnDefaultInputValue = false;\n        var didWarnDefaultChecked = false;\n        var didWarnDefaultSelectValue = false;\n        var didWarnDefaultTextareaValue = false;\n        var didWarnInvalidOptionChildren = false;\n        var didWarnInvalidOptionInnerHTML = false;\n        var didWarnSelectedSetOnOption = false;\n        function checkSelectProp(props, propName) {\n            {\n                var value = props[propName];\n                if (value != null) {\n                    var array = isArray(value);\n                    if (props.multiple && !array) {\n                        error(\"The `%s` prop supplied to <select> must be an array if \" + \"`multiple` is true.\", propName);\n                    } else if (!props.multiple && array) {\n                        error(\"The `%s` prop supplied to <select> must be a scalar \" + \"value if `multiple` is false.\", propName);\n                    }\n                }\n            }\n        }\n        function pushStartSelect(target, props, responseState) {\n            {\n                checkControlledValueProps(\"select\", props);\n                checkSelectProp(props, \"value\");\n                checkSelectProp(props, \"defaultValue\");\n                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultSelectValue) {\n                    error(\"Select elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled select \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\");\n                    didWarnDefaultSelectValue = true;\n                }\n            }\n            target.push(startChunkForTag(\"select\"));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            // TODO: This doesn't really make sense for select since it can't use the controlled\n                            // value in the innerHTML.\n                            innerHTML = propValue;\n                            break;\n                        case \"defaultValue\":\n                        case \"value\":\n                            break;\n                        default:\n                            pushAttribute(target, responseState, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            return children;\n        }\n        function flattenOptionChildren(children) {\n            var content = \"\"; // Flatten children and warn if they aren't strings or numbers;\n            // invalid types are ignored.\n            React.Children.forEach(children, function(child) {\n                if (child == null) {\n                    return;\n                }\n                content += child;\n                {\n                    if (!didWarnInvalidOptionChildren && typeof child !== \"string\" && typeof child !== \"number\") {\n                        didWarnInvalidOptionChildren = true;\n                        error(\"Cannot infer the option value of complex children. \" + \"Pass a `value` prop or use a plain string as children to <option>.\");\n                    }\n                }\n            });\n            return content;\n        }\n        var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=\"\"');\n        function pushStartOption(target, props, responseState, formatContext) {\n            var selectedValue = formatContext.selectedValue;\n            target.push(startChunkForTag(\"option\"));\n            var children = null;\n            var value = null;\n            var selected = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"selected\":\n                            // ignore\n                            selected = propValue;\n                            {\n                                // TODO: Remove support for `selected` in <option>.\n                                if (!didWarnSelectedSetOnOption) {\n                                    error(\"Use the `defaultValue` or `value` props on <select> instead of \" + \"setting `selected` on <option>.\");\n                                    didWarnSelectedSetOnOption = true;\n                                }\n                            }\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        // eslint-disable-next-line-no-fallthrough\n                        case \"value\":\n                            value = propValue;\n                        // We intentionally fallthrough to also set the attribute on the node.\n                        // eslint-disable-next-line-no-fallthrough\n                        default:\n                            pushAttribute(target, responseState, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            if (selectedValue != null) {\n                var stringValue;\n                if (value !== null) {\n                    {\n                        checkAttributeStringCoercion(value, \"value\");\n                    }\n                    stringValue = \"\" + value;\n                } else {\n                    {\n                        if (innerHTML !== null) {\n                            if (!didWarnInvalidOptionInnerHTML) {\n                                didWarnInvalidOptionInnerHTML = true;\n                                error(\"Pass a `value` prop if you set dangerouslyInnerHTML so React knows \" + \"which value should be selected.\");\n                            }\n                        }\n                    }\n                    stringValue = flattenOptionChildren(children);\n                }\n                if (isArray(selectedValue)) {\n                    // multiple\n                    for(var i = 0; i < selectedValue.length; i++){\n                        {\n                            checkAttributeStringCoercion(selectedValue[i], \"value\");\n                        }\n                        var v = \"\" + selectedValue[i];\n                        if (v === stringValue) {\n                            target.push(selectedMarkerAttribute);\n                            break;\n                        }\n                    }\n                } else {\n                    {\n                        checkAttributeStringCoercion(selectedValue, \"select.value\");\n                    }\n                    if (\"\" + selectedValue === stringValue) {\n                        target.push(selectedMarkerAttribute);\n                    }\n                }\n            } else if (selected) {\n                target.push(selectedMarkerAttribute);\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            return children;\n        }\n        function pushInput(target, props, responseState) {\n            {\n                checkControlledValueProps(\"input\", props);\n                if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnDefaultChecked) {\n                    error(\"%s contains an input of type %s with both checked and defaultChecked props. \" + \"Input elements must be either controlled or uncontrolled \" + \"(specify either the checked prop, or the defaultChecked prop, but not \" + \"both). Decide between using a controlled or uncontrolled input \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\", \"A component\", props.type);\n                    didWarnDefaultChecked = true;\n                }\n                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultInputValue) {\n                    error(\"%s contains an input of type %s with both value and defaultValue props. \" + \"Input elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled input \" + \"element and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\", \"A component\", props.type);\n                    didWarnDefaultInputValue = true;\n                }\n            }\n            target.push(startChunkForTag(\"input\"));\n            var value = null;\n            var defaultValue = null;\n            var checked = null;\n            var defaultChecked = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"input\" + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        // eslint-disable-next-line-no-fallthrough\n                        case \"defaultChecked\":\n                            defaultChecked = propValue;\n                            break;\n                        case \"defaultValue\":\n                            defaultValue = propValue;\n                            break;\n                        case \"checked\":\n                            checked = propValue;\n                            break;\n                        case \"value\":\n                            value = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, responseState, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            if (checked !== null) {\n                pushAttribute(target, responseState, \"checked\", checked);\n            } else if (defaultChecked !== null) {\n                pushAttribute(target, responseState, \"checked\", defaultChecked);\n            }\n            if (value !== null) {\n                pushAttribute(target, responseState, \"value\", value);\n            } else if (defaultValue !== null) {\n                pushAttribute(target, responseState, \"value\", defaultValue);\n            }\n            target.push(endOfStartTagSelfClosing);\n            return null;\n        }\n        function pushStartTextArea(target, props, responseState) {\n            {\n                checkControlledValueProps(\"textarea\", props);\n                if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultTextareaValue) {\n                    error(\"Textarea elements must be either controlled or uncontrolled \" + \"(specify either the value prop, or the defaultValue prop, but not \" + \"both). Decide between using a controlled or uncontrolled textarea \" + \"and remove one of these props. More info: \" + \"https://reactjs.org/link/controlled-components\");\n                    didWarnDefaultTextareaValue = true;\n                }\n            }\n            target.push(startChunkForTag(\"textarea\"));\n            var value = null;\n            var defaultValue = null;\n            var children = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"value\":\n                            value = propValue;\n                            break;\n                        case \"defaultValue\":\n                            defaultValue = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"`dangerouslySetInnerHTML` does not make sense on <textarea>.\");\n                        // eslint-disable-next-line-no-fallthrough\n                        default:\n                            pushAttribute(target, responseState, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            if (value === null && defaultValue !== null) {\n                value = defaultValue;\n            }\n            target.push(endOfStartTag); // TODO (yungsters): Remove support for children content in <textarea>.\n            if (children != null) {\n                {\n                    error(\"Use the `defaultValue` or `value` props instead of setting \" + \"children on <textarea>.\");\n                }\n                if (value != null) {\n                    throw new Error(\"If you supply `defaultValue` on a <textarea>, do not pass children.\");\n                }\n                if (isArray(children)) {\n                    if (children.length > 1) {\n                        throw new Error(\"<textarea> can only have at most one child.\");\n                    } // TODO: remove the coercion and the DEV check below because it will\n                    // always be overwritten by the coercion several lines below it. #22309\n                    {\n                        checkHtmlStringCoercion(children[0]);\n                    }\n                    value = \"\" + children[0];\n                }\n                {\n                    checkHtmlStringCoercion(children);\n                }\n                value = \"\" + children;\n            }\n            if (typeof value === \"string\" && value[0] === \"\\n\") {\n                // text/html ignores the first character in these tags if it's a newline\n                // Prefer to break application/xml over text/html (for now) by adding\n                // a newline specifically to get eaten by the parser. (Alternately for\n                // textareas, replacing \"^\\n\" with \"\\r\\n\" doesn't get eaten, and the first\n                // \\r is normalized out by HTMLTextAreaElement#value.)\n                // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>\n                // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>\n                // See: <http://www.w3.org/TR/html5/syntax.html#newlines>\n                // See: Parsing of \"textarea\" \"listing\" and \"pre\" elements\n                //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>\n                target.push(leadingNewline);\n            } // ToString and push directly instead of recurse over children.\n            // We don't really support complex children in the value anyway.\n            // This also currently avoids a trailing comment node which breaks textarea.\n            if (value !== null) {\n                {\n                    checkAttributeStringCoercion(value, \"value\");\n                }\n                target.push(stringToChunk(encodeHTMLTextNode(\"\" + value)));\n            }\n            return null;\n        }\n        function pushSelfClosing(target, props, tag, responseState) {\n            target.push(startChunkForTag(tag));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(tag + \" is a self-closing tag and must neither have `children` nor \" + \"use `dangerouslySetInnerHTML`.\");\n                        // eslint-disable-next-line-no-fallthrough\n                        default:\n                            pushAttribute(target, responseState, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTagSelfClosing);\n            return null;\n        }\n        function pushStartMenuItem(target, props, responseState) {\n            target.push(startChunkForTag(\"menuitem\"));\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"menuitems cannot have `children` nor `dangerouslySetInnerHTML`.\");\n                        // eslint-disable-next-line-no-fallthrough\n                        default:\n                            pushAttribute(target, responseState, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            return null;\n        }\n        function pushStartTitle(target, props, responseState) {\n            target.push(startChunkForTag(\"title\"));\n            var children = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            throw new Error(\"`dangerouslySetInnerHTML` does not make sense on <title>.\");\n                        // eslint-disable-next-line-no-fallthrough\n                        default:\n                            pushAttribute(target, responseState, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            {\n                var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;\n                if (Array.isArray(children) && children.length > 1) {\n                    error(\"A title element received an array with more than 1 element as children. \" + \"In browsers title Elements can only have Text Nodes as children. If \" + \"the children being rendered output more than a single text node in aggregate the browser \" + \"will display markup and comments as text in the title and hydration will likely fail and \" + \"fall back to client rendering\");\n                } else if (child != null && child.$$typeof != null) {\n                    error(\"A title element received a React element for children. \" + \"In the browser title Elements can only have Text Nodes as children. If \" + \"the children being rendered output more than a single text node in aggregate the browser \" + \"will display markup and comments as text in the title and hydration will likely fail and \" + \"fall back to client rendering\");\n                } else if (child != null && typeof child !== \"string\" && typeof child !== \"number\") {\n                    error(\"A title element received a value that was not a string or number for children. \" + \"In the browser title Elements can only have Text Nodes as children. If \" + \"the children being rendered output more than a single text node in aggregate the browser \" + \"will display markup and comments as text in the title and hydration will likely fail and \" + \"fall back to client rendering\");\n                }\n            }\n            return children;\n        }\n        function pushStartGenericElement(target, props, tag, responseState) {\n            target.push(startChunkForTag(tag));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, responseState, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            if (typeof children === \"string\") {\n                // Special case children as a string to avoid the unnecessary comment.\n                // TODO: Remove this special case after the general optimization is in place.\n                target.push(stringToChunk(encodeHTMLTextNode(children)));\n                return null;\n            }\n            return children;\n        }\n        function pushStartCustomElement(target, props, tag, responseState) {\n            target.push(startChunkForTag(tag));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        case \"style\":\n                            pushStyle(target, responseState, propValue);\n                            break;\n                        case \"suppressContentEditableWarning\":\n                        case \"suppressHydrationWarning\":\n                            break;\n                        default:\n                            if (isAttributeNameSafe(propKey) && typeof propValue !== \"function\" && typeof propValue !== \"symbol\") {\n                                target.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);\n                            }\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag);\n            pushInnerHTML(target, innerHTML, children);\n            return children;\n        }\n        var leadingNewline = stringToPrecomputedChunk(\"\\n\");\n        function pushStartPreformattedElement(target, props, tag, responseState) {\n            target.push(startChunkForTag(tag));\n            var children = null;\n            var innerHTML = null;\n            for(var propKey in props){\n                if (hasOwnProperty.call(props, propKey)) {\n                    var propValue = props[propKey];\n                    if (propValue == null) {\n                        continue;\n                    }\n                    switch(propKey){\n                        case \"children\":\n                            children = propValue;\n                            break;\n                        case \"dangerouslySetInnerHTML\":\n                            innerHTML = propValue;\n                            break;\n                        default:\n                            pushAttribute(target, responseState, propKey, propValue);\n                            break;\n                    }\n                }\n            }\n            target.push(endOfStartTag); // text/html ignores the first character in these tags if it's a newline\n            // Prefer to break application/xml over text/html (for now) by adding\n            // a newline specifically to get eaten by the parser. (Alternately for\n            // textareas, replacing \"^\\n\" with \"\\r\\n\" doesn't get eaten, and the first\n            // \\r is normalized out by HTMLTextAreaElement#value.)\n            // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>\n            // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>\n            // See: <http://www.w3.org/TR/html5/syntax.html#newlines>\n            // See: Parsing of \"textarea\" \"listing\" and \"pre\" elements\n            //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>\n            // TODO: This doesn't deal with the case where the child is an array\n            // or component that returns a string.\n            if (innerHTML != null) {\n                if (children != null) {\n                    throw new Error(\"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\");\n                }\n                if (typeof innerHTML !== \"object\" || !(\"__html\" in innerHTML)) {\n                    throw new Error(\"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. \" + \"Please visit https://reactjs.org/link/dangerously-set-inner-html \" + \"for more information.\");\n                }\n                var html = innerHTML.__html;\n                if (html !== null && html !== undefined) {\n                    if (typeof html === \"string\" && html.length > 0 && html[0] === \"\\n\") {\n                        target.push(leadingNewline, stringToChunk(html));\n                    } else {\n                        {\n                            checkHtmlStringCoercion(html);\n                        }\n                        target.push(stringToChunk(\"\" + html));\n                    }\n                }\n            }\n            if (typeof children === \"string\" && children[0] === \"\\n\") {\n                target.push(leadingNewline);\n            }\n            return children;\n        } // We accept any tag to be rendered but since this gets injected into arbitrary\n        // HTML, we want to make sure that it's a safe tag.\n        // http://www.w3.org/TR/REC-xml/#NT-Name\n        var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\\.\\-\\d]*$/; // Simplified subset\n        var validatedTagCache = new Map();\n        function startChunkForTag(tag) {\n            var tagStartChunk = validatedTagCache.get(tag);\n            if (tagStartChunk === undefined) {\n                if (!VALID_TAG_REGEX.test(tag)) {\n                    throw new Error(\"Invalid tag: \" + tag);\n                }\n                tagStartChunk = stringToPrecomputedChunk(\"<\" + tag);\n                validatedTagCache.set(tag, tagStartChunk);\n            }\n            return tagStartChunk;\n        }\n        var DOCTYPE = stringToPrecomputedChunk(\"<!DOCTYPE html>\");\n        function pushStartInstance(target, type, props, responseState, formatContext) {\n            {\n                validateProperties(type, props);\n                validateProperties$1(type, props);\n                validateProperties$2(type, props, null);\n                if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {\n                    error(\"A component is `contentEditable` and contains `children` managed by \" + \"React. It is now your responsibility to guarantee that none of \" + \"those nodes are unexpectedly modified or duplicated. This is \" + \"probably not intentional.\");\n                }\n                if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {\n                    if (type.indexOf(\"-\") === -1 && typeof props.is !== \"string\" && type.toLowerCase() !== type) {\n                        error(\"<%s /> is using incorrect casing. \" + \"Use PascalCase for React components, \" + \"or lowercase for HTML elements.\", type);\n                    }\n                }\n            }\n            switch(type){\n                // Special tags\n                case \"select\":\n                    return pushStartSelect(target, props, responseState);\n                case \"option\":\n                    return pushStartOption(target, props, responseState, formatContext);\n                case \"textarea\":\n                    return pushStartTextArea(target, props, responseState);\n                case \"input\":\n                    return pushInput(target, props, responseState);\n                case \"menuitem\":\n                    return pushStartMenuItem(target, props, responseState);\n                case \"title\":\n                    return pushStartTitle(target, props, responseState);\n                // Newline eating tags\n                case \"listing\":\n                case \"pre\":\n                    {\n                        return pushStartPreformattedElement(target, props, type, responseState);\n                    }\n                // Omitted close tags\n                case \"area\":\n                case \"base\":\n                case \"br\":\n                case \"col\":\n                case \"embed\":\n                case \"hr\":\n                case \"img\":\n                case \"keygen\":\n                case \"link\":\n                case \"meta\":\n                case \"param\":\n                case \"source\":\n                case \"track\":\n                case \"wbr\":\n                    {\n                        return pushSelfClosing(target, props, type, responseState);\n                    }\n                // These are reserved SVG and MathML elements, that are never custom elements.\n                // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n                case \"annotation-xml\":\n                case \"color-profile\":\n                case \"font-face\":\n                case \"font-face-src\":\n                case \"font-face-uri\":\n                case \"font-face-format\":\n                case \"font-face-name\":\n                case \"missing-glyph\":\n                    {\n                        return pushStartGenericElement(target, props, type, responseState);\n                    }\n                case \"html\":\n                    {\n                        if (formatContext.insertionMode === ROOT_HTML_MODE) {\n                            // If we're rendering the html tag and we're at the root (i.e. not in foreignObject)\n                            // then we also emit the DOCTYPE as part of the root content as a convenience for\n                            // rendering the whole document.\n                            target.push(DOCTYPE);\n                        }\n                        return pushStartGenericElement(target, props, type, responseState);\n                    }\n                default:\n                    {\n                        if (type.indexOf(\"-\") === -1 && typeof props.is !== \"string\") {\n                            // Generic element\n                            return pushStartGenericElement(target, props, type, responseState);\n                        } else {\n                            // Custom element\n                            return pushStartCustomElement(target, props, type, responseState);\n                        }\n                    }\n            }\n        }\n        var endTag1 = stringToPrecomputedChunk(\"</\");\n        var endTag2 = stringToPrecomputedChunk(\">\");\n        function pushEndInstance(target, type, props) {\n            switch(type){\n                // Omitted close tags\n                // TODO: Instead of repeating this switch we could try to pass a flag from above.\n                // That would require returning a tuple. Which might be ok if it gets inlined.\n                case \"area\":\n                case \"base\":\n                case \"br\":\n                case \"col\":\n                case \"embed\":\n                case \"hr\":\n                case \"img\":\n                case \"input\":\n                case \"keygen\":\n                case \"link\":\n                case \"meta\":\n                case \"param\":\n                case \"source\":\n                case \"track\":\n                case \"wbr\":\n                    {\n                        break;\n                    }\n                default:\n                    {\n                        target.push(endTag1, stringToChunk(type), endTag2);\n                    }\n            }\n        }\n        function writeCompletedRoot(destination, responseState) {\n            var bootstrapChunks = responseState.bootstrapChunks;\n            var i = 0;\n            for(; i < bootstrapChunks.length - 1; i++){\n                writeChunk(destination, bootstrapChunks[i]);\n            }\n            if (i < bootstrapChunks.length) {\n                return writeChunkAndReturn(destination, bootstrapChunks[i]);\n            }\n            return true;\n        } // Structural Nodes\n        // A placeholder is a node inside a hidden partial tree that can be filled in later, but before\n        // display. It's never visible to users. We use the template tag because it can be used in every\n        // type of parent. <script> tags also work in every other tag except <colgroup>.\n        var placeholder1 = stringToPrecomputedChunk('<template id=\"');\n        var placeholder2 = stringToPrecomputedChunk('\"></template>');\n        function writePlaceholder(destination, responseState, id) {\n            writeChunk(destination, placeholder1);\n            writeChunk(destination, responseState.placeholderPrefix);\n            var formattedID = stringToChunk(id.toString(16));\n            writeChunk(destination, formattedID);\n            return writeChunkAndReturn(destination, placeholder2);\n        } // Suspense boundaries are encoded as comments.\n        var startCompletedSuspenseBoundary = stringToPrecomputedChunk(\"<!--$-->\");\n        var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id=\"');\n        var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('\"></template>');\n        var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk(\"<!--$!-->\");\n        var endSuspenseBoundary = stringToPrecomputedChunk(\"<!--/$-->\");\n        var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk(\"<template\");\n        var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('\"');\n        var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst=\"');\n        var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg=\"');\n        var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck=\"');\n        var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk(\"></template>\");\n        function writeStartCompletedSuspenseBoundary(destination, responseState) {\n            return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);\n        }\n        function writeStartPendingSuspenseBoundary(destination, responseState, id) {\n            writeChunk(destination, startPendingSuspenseBoundary1);\n            if (id === null) {\n                throw new Error(\"An ID must have been assigned before we can complete the boundary.\");\n            }\n            writeChunk(destination, id);\n            return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);\n        }\n        function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {\n            var result;\n            result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);\n            writeChunk(destination, clientRenderedSuspenseBoundaryError1);\n            if (errorDigest) {\n                writeChunk(destination, clientRenderedSuspenseBoundaryError1A);\n                writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));\n                writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);\n            }\n            {\n                if (errorMesssage) {\n                    writeChunk(destination, clientRenderedSuspenseBoundaryError1B);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));\n                    writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);\n                }\n                if (errorComponentStack) {\n                    writeChunk(destination, clientRenderedSuspenseBoundaryError1C);\n                    writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));\n                    writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);\n                }\n            }\n            result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);\n            return result;\n        }\n        function writeEndCompletedSuspenseBoundary(destination, responseState) {\n            return writeChunkAndReturn(destination, endSuspenseBoundary);\n        }\n        function writeEndPendingSuspenseBoundary(destination, responseState) {\n            return writeChunkAndReturn(destination, endSuspenseBoundary);\n        }\n        function writeEndClientRenderedSuspenseBoundary(destination, responseState) {\n            return writeChunkAndReturn(destination, endSuspenseBoundary);\n        }\n        var startSegmentHTML = stringToPrecomputedChunk('<div hidden id=\"');\n        var startSegmentHTML2 = stringToPrecomputedChunk('\">');\n        var endSegmentHTML = stringToPrecomputedChunk(\"</div>\");\n        var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden=\"true\" style=\"display:none\" id=\"');\n        var startSegmentSVG2 = stringToPrecomputedChunk('\">');\n        var endSegmentSVG = stringToPrecomputedChunk(\"</svg>\");\n        var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden=\"true\" style=\"display:none\" id=\"');\n        var startSegmentMathML2 = stringToPrecomputedChunk('\">');\n        var endSegmentMathML = stringToPrecomputedChunk(\"</math>\");\n        var startSegmentTable = stringToPrecomputedChunk('<table hidden id=\"');\n        var startSegmentTable2 = stringToPrecomputedChunk('\">');\n        var endSegmentTable = stringToPrecomputedChunk(\"</table>\");\n        var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id=\"');\n        var startSegmentTableBody2 = stringToPrecomputedChunk('\">');\n        var endSegmentTableBody = stringToPrecomputedChunk(\"</tbody></table>\");\n        var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id=\"');\n        var startSegmentTableRow2 = stringToPrecomputedChunk('\">');\n        var endSegmentTableRow = stringToPrecomputedChunk(\"</tr></table>\");\n        var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id=\"');\n        var startSegmentColGroup2 = stringToPrecomputedChunk('\">');\n        var endSegmentColGroup = stringToPrecomputedChunk(\"</colgroup></table>\");\n        function writeStartSegment(destination, responseState, formatContext, id) {\n            switch(formatContext.insertionMode){\n                case ROOT_HTML_MODE:\n                case HTML_MODE:\n                    {\n                        writeChunk(destination, startSegmentHTML);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentHTML2);\n                    }\n                case SVG_MODE:\n                    {\n                        writeChunk(destination, startSegmentSVG);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentSVG2);\n                    }\n                case MATHML_MODE:\n                    {\n                        writeChunk(destination, startSegmentMathML);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentMathML2);\n                    }\n                case HTML_TABLE_MODE:\n                    {\n                        writeChunk(destination, startSegmentTable);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentTable2);\n                    }\n                // TODO: For the rest of these, there will be extra wrapper nodes that never\n                // get deleted from the document. We need to delete the table too as part\n                // of the injected scripts. They are invisible though so it's not too terrible\n                // and it's kind of an edge case to suspend in a table. Totally supported though.\n                case HTML_TABLE_BODY_MODE:\n                    {\n                        writeChunk(destination, startSegmentTableBody);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentTableBody2);\n                    }\n                case HTML_TABLE_ROW_MODE:\n                    {\n                        writeChunk(destination, startSegmentTableRow);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentTableRow2);\n                    }\n                case HTML_COLGROUP_MODE:\n                    {\n                        writeChunk(destination, startSegmentColGroup);\n                        writeChunk(destination, responseState.segmentPrefix);\n                        writeChunk(destination, stringToChunk(id.toString(16)));\n                        return writeChunkAndReturn(destination, startSegmentColGroup2);\n                    }\n                default:\n                    {\n                        throw new Error(\"Unknown insertion mode. This is a bug in React.\");\n                    }\n            }\n        }\n        function writeEndSegment(destination, formatContext) {\n            switch(formatContext.insertionMode){\n                case ROOT_HTML_MODE:\n                case HTML_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentHTML);\n                    }\n                case SVG_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentSVG);\n                    }\n                case MATHML_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentMathML);\n                    }\n                case HTML_TABLE_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentTable);\n                    }\n                case HTML_TABLE_BODY_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentTableBody);\n                    }\n                case HTML_TABLE_ROW_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentTableRow);\n                    }\n                case HTML_COLGROUP_MODE:\n                    {\n                        return writeChunkAndReturn(destination, endSegmentColGroup);\n                    }\n                default:\n                    {\n                        throw new Error(\"Unknown insertion mode. This is a bug in React.\");\n                    }\n            }\n        } // Instruction Set\n        // The following code is the source scripts that we then minify and inline below,\n        // with renamed function names that we hope don't collide:\n        // const COMMENT_NODE = 8;\n        // const SUSPENSE_START_DATA = '$';\n        // const SUSPENSE_END_DATA = '/$';\n        // const SUSPENSE_PENDING_START_DATA = '$?';\n        // const SUSPENSE_FALLBACK_START_DATA = '$!';\n        //\n        // function clientRenderBoundary(suspenseBoundaryID, errorDigest, errorMsg, errorComponentStack) {\n        //   // Find the fallback's first element.\n        //   const suspenseIdNode = document.getElementById(suspenseBoundaryID);\n        //   if (!suspenseIdNode) {\n        //     // The user must have already navigated away from this tree.\n        //     // E.g. because the parent was hydrated.\n        //     return;\n        //   }\n        //   // Find the boundary around the fallback. This is always the previous node.\n        //   const suspenseNode = suspenseIdNode.previousSibling;\n        //   // Tag it to be client rendered.\n        //   suspenseNode.data = SUSPENSE_FALLBACK_START_DATA;\n        //   // assign error metadata to first sibling\n        //   let dataset = suspenseIdNode.dataset;\n        //   if (errorDigest) dataset.dgst = errorDigest;\n        //   if (errorMsg) dataset.msg = errorMsg;\n        //   if (errorComponentStack) dataset.stck = errorComponentStack;\n        //   // Tell React to retry it if the parent already hydrated.\n        //   if (suspenseNode._reactRetry) {\n        //     suspenseNode._reactRetry();\n        //   }\n        // }\n        //\n        // function completeBoundary(suspenseBoundaryID, contentID) {\n        //   // Find the fallback's first element.\n        //   const suspenseIdNode = document.getElementById(suspenseBoundaryID);\n        //   const contentNode = document.getElementById(contentID);\n        //   // We'll detach the content node so that regardless of what happens next we don't leave in the tree.\n        //   // This might also help by not causing recalcing each time we move a child from here to the target.\n        //   contentNode.parentNode.removeChild(contentNode);\n        //   if (!suspenseIdNode) {\n        //     // The user must have already navigated away from this tree.\n        //     // E.g. because the parent was hydrated. That's fine there's nothing to do\n        //     // but we have to make sure that we already deleted the container node.\n        //     return;\n        //   }\n        //   // Find the boundary around the fallback. This is always the previous node.\n        //   const suspenseNode = suspenseIdNode.previousSibling;\n        //\n        //   // Clear all the existing children. This is complicated because\n        //   // there can be embedded Suspense boundaries in the fallback.\n        //   // This is similar to clearSuspenseBoundary in ReactDOMHostConfig.\n        //   // TODO: We could avoid this if we never emitted suspense boundaries in fallback trees.\n        //   // They never hydrate anyway. However, currently we support incrementally loading the fallback.\n        //   const parentInstance = suspenseNode.parentNode;\n        //   let node = suspenseNode.nextSibling;\n        //   let depth = 0;\n        //   do {\n        //     if (node && node.nodeType === COMMENT_NODE) {\n        //       const data = node.data;\n        //       if (data === SUSPENSE_END_DATA) {\n        //         if (depth === 0) {\n        //           break;\n        //         } else {\n        //           depth--;\n        //         }\n        //       } else if (\n        //         data === SUSPENSE_START_DATA ||\n        //         data === SUSPENSE_PENDING_START_DATA ||\n        //         data === SUSPENSE_FALLBACK_START_DATA\n        //       ) {\n        //         depth++;\n        //       }\n        //     }\n        //\n        //     const nextNode = node.nextSibling;\n        //     parentInstance.removeChild(node);\n        //     node = nextNode;\n        //   } while (node);\n        //\n        //   const endOfBoundary = node;\n        //\n        //   // Insert all the children from the contentNode between the start and end of suspense boundary.\n        //   while (contentNode.firstChild) {\n        //     parentInstance.insertBefore(contentNode.firstChild, endOfBoundary);\n        //   }\n        //   suspenseNode.data = SUSPENSE_START_DATA;\n        //   if (suspenseNode._reactRetry) {\n        //     suspenseNode._reactRetry();\n        //   }\n        // }\n        //\n        // function completeSegment(containerID, placeholderID) {\n        //   const segmentContainer = document.getElementById(containerID);\n        //   const placeholderNode = document.getElementById(placeholderID);\n        //   // We always expect both nodes to exist here because, while we might\n        //   // have navigated away from the main tree, we still expect the detached\n        //   // tree to exist.\n        //   segmentContainer.parentNode.removeChild(segmentContainer);\n        //   while (segmentContainer.firstChild) {\n        //     placeholderNode.parentNode.insertBefore(\n        //       segmentContainer.firstChild,\n        //       placeholderNode,\n        //     );\n        //   }\n        //   placeholderNode.parentNode.removeChild(placeholderNode);\n        // }\n        var completeSegmentFunction = \"function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}\";\n        var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if(\"/$\"===d)if(0===e)break;else e--;else\"$\"!==d&&\"$?\"!==d&&\"$!\"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data=\"$\";a._reactRetry&&a._reactRetry()}}';\n        var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data=\"$!\",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';\n        var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS(\"');\n        var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS(\"');\n        var completeSegmentScript2 = stringToPrecomputedChunk('\",\"');\n        var completeSegmentScript3 = stringToPrecomputedChunk('\")</script>');\n        function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {\n            writeChunk(destination, responseState.startInlineScript);\n            if (!responseState.sentCompleteSegmentFunction) {\n                // The first time we write this, we'll need to include the full implementation.\n                responseState.sentCompleteSegmentFunction = true;\n                writeChunk(destination, completeSegmentScript1Full);\n            } else {\n                // Future calls can just reuse the same function.\n                writeChunk(destination, completeSegmentScript1Partial);\n            }\n            writeChunk(destination, responseState.segmentPrefix);\n            var formattedID = stringToChunk(contentSegmentID.toString(16));\n            writeChunk(destination, formattedID);\n            writeChunk(destination, completeSegmentScript2);\n            writeChunk(destination, responseState.placeholderPrefix);\n            writeChunk(destination, formattedID);\n            return writeChunkAndReturn(destination, completeSegmentScript3);\n        }\n        var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC(\"');\n        var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC(\"');\n        var completeBoundaryScript2 = stringToPrecomputedChunk('\",\"');\n        var completeBoundaryScript3 = stringToPrecomputedChunk('\")</script>');\n        function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {\n            writeChunk(destination, responseState.startInlineScript);\n            if (!responseState.sentCompleteBoundaryFunction) {\n                // The first time we write this, we'll need to include the full implementation.\n                responseState.sentCompleteBoundaryFunction = true;\n                writeChunk(destination, completeBoundaryScript1Full);\n            } else {\n                // Future calls can just reuse the same function.\n                writeChunk(destination, completeBoundaryScript1Partial);\n            }\n            if (boundaryID === null) {\n                throw new Error(\"An ID must have been assigned before we can complete the boundary.\");\n            }\n            var formattedContentID = stringToChunk(contentSegmentID.toString(16));\n            writeChunk(destination, boundaryID);\n            writeChunk(destination, completeBoundaryScript2);\n            writeChunk(destination, responseState.segmentPrefix);\n            writeChunk(destination, formattedContentID);\n            return writeChunkAndReturn(destination, completeBoundaryScript3);\n        }\n        var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX(\"');\n        var clientRenderScript1Partial = stringToPrecomputedChunk('$RX(\"');\n        var clientRenderScript1A = stringToPrecomputedChunk('\"');\n        var clientRenderScript2 = stringToPrecomputedChunk(\")</script>\");\n        var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(\",\");\n        function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {\n            writeChunk(destination, responseState.startInlineScript);\n            if (!responseState.sentClientRenderFunction) {\n                // The first time we write this, we'll need to include the full implementation.\n                responseState.sentClientRenderFunction = true;\n                writeChunk(destination, clientRenderScript1Full);\n            } else {\n                // Future calls can just reuse the same function.\n                writeChunk(destination, clientRenderScript1Partial);\n            }\n            if (boundaryID === null) {\n                throw new Error(\"An ID must have been assigned before we can complete the boundary.\");\n            }\n            writeChunk(destination, boundaryID);\n            writeChunk(destination, clientRenderScript1A);\n            if (errorDigest || errorMessage || errorComponentStack) {\n                writeChunk(destination, clientRenderErrorScriptArgInterstitial);\n                writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || \"\")));\n            }\n            if (errorMessage || errorComponentStack) {\n                writeChunk(destination, clientRenderErrorScriptArgInterstitial);\n                writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || \"\")));\n            }\n            if (errorComponentStack) {\n                writeChunk(destination, clientRenderErrorScriptArgInterstitial);\n                writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));\n            }\n            return writeChunkAndReturn(destination, clientRenderScript2);\n        }\n        var regexForJSStringsInScripts = /[<\\u2028\\u2029]/g;\n        function escapeJSStringsForInstructionScripts(input) {\n            var escaped = JSON.stringify(input);\n            return escaped.replace(regexForJSStringsInScripts, function(match) {\n                switch(match){\n                    // santizing breaking out of strings and script tags\n                    case \"<\":\n                        return \"\\\\u003c\";\n                    case \"\\u2028\":\n                        return \"\\\\u2028\";\n                    case \"\\u2029\":\n                        return \"\\\\u2029\";\n                    default:\n                        {\n                            // eslint-disable-next-line react-internal/prod-error-codes\n                            throw new Error(\"escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React\");\n                        }\n                }\n            });\n        }\n        var assign = Object.assign;\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_SCOPE_TYPE = Symbol.for(\"react.scope\");\n        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for(\"react.debug_trace_mode\");\n        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for(\"react.legacy_hidden\");\n        var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for(\"react.default_value\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            {\n                if (typeof type.tag === \"number\") {\n                    error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                }\n            }\n            if (typeof type === \"function\") {\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            var control;\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            try {\n                // This should throw.\n                if (construct) {\n                    // Something should be setting the props in the constructor.\n                    var Fake = function() {\n                        throw Error();\n                    }; // $FlowFixMe\n                    Object.defineProperty(Fake.prototype, \"props\", {\n                        set: function() {\n                            // We use a throwing setter instead of frozen or non-writable props\n                            // because that won't throw in a non-strict mode function.\n                            throw Error();\n                        }\n                    });\n                    if (typeof Reflect === \"object\" && Reflect.construct) {\n                        // We construct a different control for this case to include any extra\n                        // frames added by the construct call.\n                        try {\n                            Reflect.construct(Fake, []);\n                        } catch (x) {\n                            control = x;\n                        }\n                        Reflect.construct(fn, [], Fake);\n                    } else {\n                        try {\n                            Fake.call();\n                        } catch (x) {\n                            control = x;\n                        }\n                        fn.call(Fake.prototype);\n                    }\n                } else {\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        control = x;\n                    }\n                    fn();\n                }\n            } catch (sample) {\n                // This is inlined manually because closure doesn't do it for us.\n                if (sample && control && typeof sample.stack === \"string\") {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sample.stack.split(\"\\n\");\n                    var controlLines = control.stack.split(\"\\n\");\n                    var s = sampleLines.length - 1;\n                    var c = controlLines.length - 1;\n                    while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                        // We expect at least one stack frame to be shared.\n                        // Typically this will be the root most one. However, stack frames may be\n                        // cut off due to maximum stack limits. In this case, one maybe cut off\n                        // earlier than the other. We assume that the sample is longer or the same\n                        // and there for cut off earlier. So we should find the root most frame in\n                        // the sample somewhere in the control.\n                        c--;\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        }\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeClassComponentFrame(ctor, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(ctor, true);\n            }\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement(null);\n                        }\n                    }\n                }\n            }\n        }\n        var warnedAboutMissingGetChildContext;\n        {\n            warnedAboutMissingGetChildContext = {};\n        }\n        var emptyContextObject = {};\n        {\n            Object.freeze(emptyContextObject);\n        }\n        function getMaskedContext(type, unmaskedContext) {\n            {\n                var contextTypes = type.contextTypes;\n                if (!contextTypes) {\n                    return emptyContextObject;\n                }\n                var context = {};\n                for(var key in contextTypes){\n                    context[key] = unmaskedContext[key];\n                }\n                {\n                    var name = getComponentNameFromType(type) || \"Unknown\";\n                    checkPropTypes(contextTypes, context, \"context\", name);\n                }\n                return context;\n            }\n        }\n        function processChildContext(instance, type, parentContext, childContextTypes) {\n            {\n                // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n                // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n                if (typeof instance.getChildContext !== \"function\") {\n                    {\n                        var componentName = getComponentNameFromType(type) || \"Unknown\";\n                        if (!warnedAboutMissingGetChildContext[componentName]) {\n                            warnedAboutMissingGetChildContext[componentName] = true;\n                            error(\"%s.childContextTypes is specified but there is no getChildContext() method \" + \"on the instance. You can either define getChildContext() on %s or remove \" + \"childContextTypes from it.\", componentName, componentName);\n                        }\n                    }\n                    return parentContext;\n                }\n                var childContext = instance.getChildContext();\n                for(var contextKey in childContext){\n                    if (!(contextKey in childContextTypes)) {\n                        throw new Error((getComponentNameFromType(type) || \"Unknown\") + '.getChildContext(): key \"' + contextKey + '\" is not defined in childContextTypes.');\n                    }\n                }\n                {\n                    var name = getComponentNameFromType(type) || \"Unknown\";\n                    checkPropTypes(childContextTypes, childContext, \"child context\", name);\n                }\n                return assign({}, parentContext, childContext);\n            }\n        }\n        var rendererSigil;\n        {\n            // Use this to detect multiple renderers using the same context\n            rendererSigil = {};\n        }\n        // Forming a reverse tree.\n        var rootContextSnapshot = null; // We assume that this runtime owns the \"current\" field on all ReactContext instances.\n        // This global (actually thread local) state represents what state all those \"current\",\n        // fields are currently in.\n        var currentActiveSnapshot = null;\n        function popNode(prev) {\n            {\n                prev.context._currentValue = prev.parentValue;\n            }\n        }\n        function pushNode(next) {\n            {\n                next.context._currentValue = next.value;\n            }\n        }\n        function popToNearestCommonAncestor(prev, next) {\n            if (prev === next) ;\n            else {\n                popNode(prev);\n                var parentPrev = prev.parent;\n                var parentNext = next.parent;\n                if (parentPrev === null) {\n                    if (parentNext !== null) {\n                        throw new Error(\"The stacks must reach the root at the same time. This is a bug in React.\");\n                    }\n                } else {\n                    if (parentNext === null) {\n                        throw new Error(\"The stacks must reach the root at the same time. This is a bug in React.\");\n                    }\n                    popToNearestCommonAncestor(parentPrev, parentNext);\n                } // On the way back, we push the new ones that weren't common.\n                pushNode(next);\n            }\n        }\n        function popAllPrevious(prev) {\n            popNode(prev);\n            var parentPrev = prev.parent;\n            if (parentPrev !== null) {\n                popAllPrevious(parentPrev);\n            }\n        }\n        function pushAllNext(next) {\n            var parentNext = next.parent;\n            if (parentNext !== null) {\n                pushAllNext(parentNext);\n            }\n            pushNode(next);\n        }\n        function popPreviousToCommonLevel(prev, next) {\n            popNode(prev);\n            var parentPrev = prev.parent;\n            if (parentPrev === null) {\n                throw new Error(\"The depth must equal at least at zero before reaching the root. This is a bug in React.\");\n            }\n            if (parentPrev.depth === next.depth) {\n                // We found the same level. Now we just need to find a shared ancestor.\n                popToNearestCommonAncestor(parentPrev, next);\n            } else {\n                // We must still be deeper.\n                popPreviousToCommonLevel(parentPrev, next);\n            }\n        }\n        function popNextToCommonLevel(prev, next) {\n            var parentNext = next.parent;\n            if (parentNext === null) {\n                throw new Error(\"The depth must equal at least at zero before reaching the root. This is a bug in React.\");\n            }\n            if (prev.depth === parentNext.depth) {\n                // We found the same level. Now we just need to find a shared ancestor.\n                popToNearestCommonAncestor(prev, parentNext);\n            } else {\n                // We must still be deeper.\n                popNextToCommonLevel(prev, parentNext);\n            }\n            pushNode(next);\n        } // Perform context switching to the new snapshot.\n        // To make it cheap to read many contexts, while not suspending, we make the switch eagerly by\n        // updating all the context's current values. That way reads, always just read the current value.\n        // At the cost of updating contexts even if they're never read by this subtree.\n        function switchContext(newSnapshot) {\n            // The basic algorithm we need to do is to pop back any contexts that are no longer on the stack.\n            // We also need to update any new contexts that are now on the stack with the deepest value.\n            // The easiest way to update new contexts is to just reapply them in reverse order from the\n            // perspective of the backpointers. To avoid allocating a lot when switching, we use the stack\n            // for that. Therefore this algorithm is recursive.\n            // 1) First we pop which ever snapshot tree was deepest. Popping old contexts as we go.\n            // 2) Then we find the nearest common ancestor from there. Popping old contexts as we go.\n            // 3) Then we reapply new contexts on the way back up the stack.\n            var prev = currentActiveSnapshot;\n            var next = newSnapshot;\n            if (prev !== next) {\n                if (prev === null) {\n                    // $FlowFixMe: This has to be non-null since it's not equal to prev.\n                    pushAllNext(next);\n                } else if (next === null) {\n                    popAllPrevious(prev);\n                } else if (prev.depth === next.depth) {\n                    popToNearestCommonAncestor(prev, next);\n                } else if (prev.depth > next.depth) {\n                    popPreviousToCommonLevel(prev, next);\n                } else {\n                    popNextToCommonLevel(prev, next);\n                }\n                currentActiveSnapshot = next;\n            }\n        }\n        function pushProvider(context, nextValue) {\n            var prevValue;\n            {\n                prevValue = context._currentValue;\n                context._currentValue = nextValue;\n                {\n                    if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {\n                        error(\"Detected multiple renderers concurrently rendering the \" + \"same context provider. This is currently unsupported.\");\n                    }\n                    context._currentRenderer = rendererSigil;\n                }\n            }\n            var prevNode = currentActiveSnapshot;\n            var newNode = {\n                parent: prevNode,\n                depth: prevNode === null ? 0 : prevNode.depth + 1,\n                context: context,\n                parentValue: prevValue,\n                value: nextValue\n            };\n            currentActiveSnapshot = newNode;\n            return newNode;\n        }\n        function popProvider(context) {\n            var prevSnapshot = currentActiveSnapshot;\n            if (prevSnapshot === null) {\n                throw new Error(\"Tried to pop a Context at the root of the app. This is a bug in React.\");\n            }\n            {\n                if (prevSnapshot.context !== context) {\n                    error(\"The parent context is not the expected context. This is probably a bug in React.\");\n                }\n            }\n            {\n                var value = prevSnapshot.parentValue;\n                if (value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {\n                    prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue;\n                } else {\n                    prevSnapshot.context._currentValue = value;\n                }\n                {\n                    if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {\n                        error(\"Detected multiple renderers concurrently rendering the \" + \"same context provider. This is currently unsupported.\");\n                    }\n                    context._currentRenderer = rendererSigil;\n                }\n            }\n            return currentActiveSnapshot = prevSnapshot.parent;\n        }\n        function getActiveContext() {\n            return currentActiveSnapshot;\n        }\n        function readContext(context) {\n            var value = context._currentValue;\n            return value;\n        }\n        /**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */ function get(key) {\n            return key._reactInternals;\n        }\n        function set(key, value) {\n            key._reactInternals = value;\n        }\n        var didWarnAboutNoopUpdateForComponent = {};\n        var didWarnAboutDeprecatedWillMount = {};\n        var didWarnAboutUninitializedState;\n        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\n        var didWarnAboutLegacyLifecyclesAndDerivedState;\n        var didWarnAboutUndefinedDerivedState;\n        var warnOnUndefinedDerivedState;\n        var warnOnInvalidCallback;\n        var didWarnAboutDirectlyAssigningPropsToState;\n        var didWarnAboutContextTypeAndContextTypes;\n        var didWarnAboutInvalidateContextType;\n        {\n            didWarnAboutUninitializedState = new Set();\n            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n            didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n            didWarnAboutDirectlyAssigningPropsToState = new Set();\n            didWarnAboutUndefinedDerivedState = new Set();\n            didWarnAboutContextTypeAndContextTypes = new Set();\n            didWarnAboutInvalidateContextType = new Set();\n            var didWarnOnInvalidCallback = new Set();\n            warnOnInvalidCallback = function(callback, callerName) {\n                if (callback === null || typeof callback === \"function\") {\n                    return;\n                }\n                var key = callerName + \"_\" + callback;\n                if (!didWarnOnInvalidCallback.has(key)) {\n                    didWarnOnInvalidCallback.add(key);\n                    error(\"%s(...): Expected the last optional `callback` argument to be a \" + \"function. Instead received: %s.\", callerName, callback);\n                }\n            };\n            warnOnUndefinedDerivedState = function(type, partialState) {\n                if (partialState === undefined) {\n                    var componentName = getComponentNameFromType(type) || \"Component\";\n                    if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n                        didWarnAboutUndefinedDerivedState.add(componentName);\n                        error(\"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. \" + \"You have returned undefined.\", componentName);\n                    }\n                }\n            };\n        }\n        function warnNoop(publicInstance, callerName) {\n            {\n                var _constructor = publicInstance.constructor;\n                var componentName = _constructor && getComponentNameFromType(_constructor) || \"ReactClass\";\n                var warningKey = componentName + \".\" + callerName;\n                if (didWarnAboutNoopUpdateForComponent[warningKey]) {\n                    return;\n                }\n                error(\"%s(...): Can only update a mounting component. \" + \"This usually means you called %s() outside componentWillMount() on the server. \" + \"This is a no-op.\\n\\nPlease check the code for the %s component.\", callerName, callerName, componentName);\n                didWarnAboutNoopUpdateForComponent[warningKey] = true;\n            }\n        }\n        var classComponentUpdater = {\n            isMounted: function(inst) {\n                return false;\n            },\n            enqueueSetState: function(inst, payload, callback) {\n                var internals = get(inst);\n                if (internals.queue === null) {\n                    warnNoop(inst, \"setState\");\n                } else {\n                    internals.queue.push(payload);\n                    {\n                        if (callback !== undefined && callback !== null) {\n                            warnOnInvalidCallback(callback, \"setState\");\n                        }\n                    }\n                }\n            },\n            enqueueReplaceState: function(inst, payload, callback) {\n                var internals = get(inst);\n                internals.replace = true;\n                internals.queue = [\n                    payload\n                ];\n                {\n                    if (callback !== undefined && callback !== null) {\n                        warnOnInvalidCallback(callback, \"setState\");\n                    }\n                }\n            },\n            enqueueForceUpdate: function(inst, callback) {\n                var internals = get(inst);\n                if (internals.queue === null) {\n                    warnNoop(inst, \"forceUpdate\");\n                } else {\n                    {\n                        if (callback !== undefined && callback !== null) {\n                            warnOnInvalidCallback(callback, \"setState\");\n                        }\n                    }\n                }\n            }\n        };\n        function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {\n            var partialState = getDerivedStateFromProps(nextProps, prevState);\n            {\n                warnOnUndefinedDerivedState(ctor, partialState);\n            }\n            var newState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);\n            return newState;\n        }\n        function constructClassInstance(ctor, props, maskedLegacyContext) {\n            var context = emptyContextObject;\n            var contextType = ctor.contextType;\n            {\n                if (\"contextType\" in ctor) {\n                    var isValid = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>\n                    if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n                        didWarnAboutInvalidateContextType.add(ctor);\n                        var addendum = \"\";\n                        if (contextType === undefined) {\n                            addendum = \" However, it is set to undefined. \" + \"This can be caused by a typo or by mixing up named and default imports. \" + \"This can also happen due to a circular dependency, so \" + \"try moving the createContext() call to a separate file.\";\n                        } else if (typeof contextType !== \"object\") {\n                            addendum = \" However, it is set to a \" + typeof contextType + \".\";\n                        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n                            addendum = \" Did you accidentally pass the Context.Provider instead?\";\n                        } else if (contextType._context !== undefined) {\n                            // <Context.Consumer>\n                            addendum = \" Did you accidentally pass the Context.Consumer instead?\";\n                        } else {\n                            addendum = \" However, it is set to an object with keys {\" + Object.keys(contextType).join(\", \") + \"}.\";\n                        }\n                        error(\"%s defines an invalid contextType. \" + \"contextType should point to the Context object returned by React.createContext().%s\", getComponentNameFromType(ctor) || \"Component\", addendum);\n                    }\n                }\n            }\n            if (typeof contextType === \"object\" && contextType !== null) {\n                context = readContext(contextType);\n            } else {\n                context = maskedLegacyContext;\n            }\n            var instance = new ctor(props, context);\n            {\n                if (typeof ctor.getDerivedStateFromProps === \"function\" && (instance.state === null || instance.state === undefined)) {\n                    var componentName = getComponentNameFromType(ctor) || \"Component\";\n                    if (!didWarnAboutUninitializedState.has(componentName)) {\n                        didWarnAboutUninitializedState.add(componentName);\n                        error(\"`%s` uses `getDerivedStateFromProps` but its initial state is \" + \"%s. This is not recommended. Instead, define the initial state by \" + \"assigning an object to `this.state` in the constructor of `%s`. \" + \"This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\", componentName, instance.state === null ? \"null\" : \"undefined\", componentName);\n                    }\n                } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n                // Warn about these lifecycles if they are present.\n                // Don't warn about react-lifecycles-compat polyfilled methods though.\n                if (typeof ctor.getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\") {\n                    var foundWillMountName = null;\n                    var foundWillReceivePropsName = null;\n                    var foundWillUpdateName = null;\n                    if (typeof instance.componentWillMount === \"function\" && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                        foundWillMountName = \"componentWillMount\";\n                    } else if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                        foundWillMountName = \"UNSAFE_componentWillMount\";\n                    }\n                    if (typeof instance.componentWillReceiveProps === \"function\" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n                        foundWillReceivePropsName = \"componentWillReceiveProps\";\n                    } else if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n                        foundWillReceivePropsName = \"UNSAFE_componentWillReceiveProps\";\n                    }\n                    if (typeof instance.componentWillUpdate === \"function\" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n                        foundWillUpdateName = \"componentWillUpdate\";\n                    } else if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n                        foundWillUpdateName = \"UNSAFE_componentWillUpdate\";\n                    }\n                    if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n                        var _componentName = getComponentNameFromType(ctor) || \"Component\";\n                        var newApiName = typeof ctor.getDerivedStateFromProps === \"function\" ? \"getDerivedStateFromProps()\" : \"getSnapshotBeforeUpdate()\";\n                        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n                            didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n                            error(\"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n\" + \"%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n\" + \"The above lifecycles should be removed. Learn more about this warning here:\\n\" + \"https://reactjs.org/link/unsafe-component-lifecycles\", _componentName, newApiName, foundWillMountName !== null ? \"\\n  \" + foundWillMountName : \"\", foundWillReceivePropsName !== null ? \"\\n  \" + foundWillReceivePropsName : \"\", foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : \"\");\n                        }\n                    }\n                }\n            }\n            return instance;\n        }\n        function checkClassInstance(instance, ctor, newProps) {\n            {\n                var name = getComponentNameFromType(ctor) || \"Component\";\n                var renderPresent = instance.render;\n                if (!renderPresent) {\n                    if (ctor.prototype && typeof ctor.prototype.render === \"function\") {\n                        error(\"%s(...): No `render` method found on the returned component \" + \"instance: did you accidentally return an object from the constructor?\", name);\n                    } else {\n                        error(\"%s(...): No `render` method found on the returned component \" + \"instance: you may have forgotten to define `render`.\", name);\n                    }\n                }\n                if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {\n                    error(\"getInitialState was defined on %s, a plain JavaScript class. \" + \"This is only supported for classes created using React.createClass. \" + \"Did you mean to define a state property instead?\", name);\n                }\n                if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps was defined on %s, a plain JavaScript class. \" + \"This is only supported for classes created using React.createClass. \" + \"Use a static property to define defaultProps instead.\", name);\n                }\n                if (instance.propTypes) {\n                    error(\"propTypes was defined as an instance property on %s. Use a static \" + \"property to define propTypes instead.\", name);\n                }\n                if (instance.contextType) {\n                    error(\"contextType was defined as an instance property on %s. Use a static \" + \"property to define contextType instead.\", name);\n                }\n                {\n                    if (instance.contextTypes) {\n                        error(\"contextTypes was defined as an instance property on %s. Use a static \" + \"property to define contextTypes instead.\", name);\n                    }\n                    if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {\n                        didWarnAboutContextTypeAndContextTypes.add(ctor);\n                        error(\"%s declares both contextTypes and contextType static properties. \" + \"The legacy contextTypes property will be ignored.\", name);\n                    }\n                }\n                if (typeof instance.componentShouldUpdate === \"function\") {\n                    error(\"%s has a method called \" + \"componentShouldUpdate(). Did you mean shouldComponentUpdate()? \" + \"The name is phrased as a question because the function is \" + \"expected to return a value.\", name);\n                }\n                if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== \"undefined\") {\n                    error(\"%s has a method called shouldComponentUpdate(). \" + \"shouldComponentUpdate should not be used when extending React.PureComponent. \" + \"Please extend React.Component if shouldComponentUpdate is used.\", getComponentNameFromType(ctor) || \"A pure component\");\n                }\n                if (typeof instance.componentDidUnmount === \"function\") {\n                    error(\"%s has a method called \" + \"componentDidUnmount(). But there is no such lifecycle method. \" + \"Did you mean componentWillUnmount()?\", name);\n                }\n                if (typeof instance.componentDidReceiveProps === \"function\") {\n                    error(\"%s has a method called \" + \"componentDidReceiveProps(). But there is no such lifecycle method. \" + \"If you meant to update the state in response to changing props, \" + \"use componentWillReceiveProps(). If you meant to fetch data or \" + \"run side-effects or mutations after React has updated the UI, use componentDidUpdate().\", name);\n                }\n                if (typeof instance.componentWillRecieveProps === \"function\") {\n                    error(\"%s has a method called \" + \"componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\", name);\n                }\n                if (typeof instance.UNSAFE_componentWillRecieveProps === \"function\") {\n                    error(\"%s has a method called \" + \"UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\", name);\n                }\n                var hasMutatedProps = instance.props !== newProps;\n                if (instance.props !== undefined && hasMutatedProps) {\n                    error(\"%s(...): When calling super() in `%s`, make sure to pass \" + \"up the same props that your component's constructor was passed.\", name, name);\n                }\n                if (instance.defaultProps) {\n                    error(\"Setting defaultProps as an instance property on %s is not supported and will be ignored.\" + \" Instead, define defaultProps as a static property on %s.\", name, name);\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === \"function\" && typeof instance.componentDidUpdate !== \"function\" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n                    didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n                    error(\"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). \" + \"This component defines getSnapshotBeforeUpdate() only.\", getComponentNameFromType(ctor));\n                }\n                if (typeof instance.getDerivedStateFromProps === \"function\") {\n                    error(\"%s: getDerivedStateFromProps() is defined as an instance method \" + \"and will be ignored. Instead, declare it as a static method.\", name);\n                }\n                if (typeof instance.getDerivedStateFromError === \"function\") {\n                    error(\"%s: getDerivedStateFromError() is defined as an instance method \" + \"and will be ignored. Instead, declare it as a static method.\", name);\n                }\n                if (typeof ctor.getSnapshotBeforeUpdate === \"function\") {\n                    error(\"%s: getSnapshotBeforeUpdate() is defined as a static method \" + \"and will be ignored. Instead, declare it as an instance method.\", name);\n                }\n                var _state = instance.state;\n                if (_state && (typeof _state !== \"object\" || isArray(_state))) {\n                    error(\"%s.state: must be set to an object or null\", name);\n                }\n                if (typeof instance.getChildContext === \"function\" && typeof ctor.childContextTypes !== \"object\") {\n                    error(\"%s.getChildContext(): childContextTypes must be defined in order to \" + \"use getChildContext().\", name);\n                }\n            }\n        }\n        function callComponentWillMount(type, instance) {\n            var oldState = instance.state;\n            if (typeof instance.componentWillMount === \"function\") {\n                {\n                    if (instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                        var componentName = getComponentNameFromType(type) || \"Unknown\";\n                        if (!didWarnAboutDeprecatedWillMount[componentName]) {\n                            warn(\"componentWillMount has been renamed, and is not recommended for use. \" + \"See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n\" + \"* Move code from componentWillMount to componentDidMount (preferred in most cases) \" + \"or the constructor.\\n\" + \"\\nPlease update the following components: %s\", componentName);\n                            didWarnAboutDeprecatedWillMount[componentName] = true;\n                        }\n                    }\n                }\n                instance.componentWillMount();\n            }\n            if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                instance.UNSAFE_componentWillMount();\n            }\n            if (oldState !== instance.state) {\n                {\n                    error(\"%s.componentWillMount(): Assigning directly to this.state is \" + \"deprecated (except inside a component's \" + \"constructor). Use setState instead.\", getComponentNameFromType(type) || \"Component\");\n                }\n                classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n            }\n        }\n        function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {\n            if (internalInstance.queue !== null && internalInstance.queue.length > 0) {\n                var oldQueue = internalInstance.queue;\n                var oldReplace = internalInstance.replace;\n                internalInstance.queue = null;\n                internalInstance.replace = false;\n                if (oldReplace && oldQueue.length === 1) {\n                    inst.state = oldQueue[0];\n                } else {\n                    var nextState = oldReplace ? oldQueue[0] : inst.state;\n                    var dontMutate = true;\n                    for(var i = oldReplace ? 1 : 0; i < oldQueue.length; i++){\n                        var partial = oldQueue[i];\n                        var partialState = typeof partial === \"function\" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;\n                        if (partialState != null) {\n                            if (dontMutate) {\n                                dontMutate = false;\n                                nextState = assign({}, nextState, partialState);\n                            } else {\n                                assign(nextState, partialState);\n                            }\n                        }\n                    }\n                    inst.state = nextState;\n                }\n            } else {\n                internalInstance.queue = null;\n            }\n        } // Invokes the mount life-cycles on a previously never rendered instance.\n        function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {\n            {\n                checkClassInstance(instance, ctor, newProps);\n            }\n            var initialState = instance.state !== undefined ? instance.state : null;\n            instance.updater = classComponentUpdater;\n            instance.props = newProps;\n            instance.state = initialState; // We don't bother initializing the refs object on the server, since we're not going to resolve them anyway.\n            // The internal instance will be used to manage updates that happen during this mount.\n            var internalInstance = {\n                queue: [],\n                replace: false\n            };\n            set(instance, internalInstance);\n            var contextType = ctor.contextType;\n            if (typeof contextType === \"object\" && contextType !== null) {\n                instance.context = readContext(contextType);\n            } else {\n                instance.context = maskedLegacyContext;\n            }\n            {\n                if (instance.state === newProps) {\n                    var componentName = getComponentNameFromType(ctor) || \"Component\";\n                    if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n                        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n                        error(\"%s: It is not recommended to assign props directly to state \" + \"because updates to props won't be reflected in state. \" + \"In most cases, it is better to use props directly.\", componentName);\n                    }\n                }\n            }\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            if (typeof getDerivedStateFromProps === \"function\") {\n                instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);\n            } // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (typeof ctor.getDerivedStateFromProps !== \"function\" && typeof instance.getSnapshotBeforeUpdate !== \"function\" && (typeof instance.UNSAFE_componentWillMount === \"function\" || typeof instance.componentWillMount === \"function\")) {\n                callComponentWillMount(ctor, instance); // If we had additional state updates during this life-cycle, let's\n                // process them now.\n                processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);\n            }\n        }\n        // Ids are base 32 strings whose binary representation corresponds to the\n        // position of a node in a tree.\n        // Every time the tree forks into multiple children, we add additional bits to\n        // the left of the sequence that represent the position of the child within the\n        // current level of children.\n        //\n        //      00101       00010001011010101\n        //             \n        //   Fork 5 of 20       Parent id\n        //\n        // The leading 0s are important. In the above example, you only need 3 bits to\n        // represent slot 5. However, you need 5 bits to represent all the forks at\n        // the current level, so we must account for the empty bits at the end.\n        //\n        // For this same reason, slots are 1-indexed instead of 0-indexed. Otherwise,\n        // the zeroth id at a level would be indistinguishable from its parent.\n        //\n        // If a node has only one child, and does not materialize an id (i.e. does not\n        // contain a useId hook), then we don't need to allocate any space in the\n        // sequence. It's treated as a transparent indirection. For example, these two\n        // trees produce the same ids:\n        //\n        // <>                          <>\n        //   <Indirection>               <A />\n        //     <A />                     <B />\n        //   </Indirection>            </>\n        //   <B />\n        // </>\n        //\n        // However, we cannot skip any node that materializes an id. Otherwise, a parent\n        // id that does not fork would be indistinguishable from its child id. For\n        // example, this tree does not fork, but the parent and child must have\n        // different ids.\n        //\n        // <Parent>\n        //   <Child />\n        // </Parent>\n        //\n        // To handle this scenario, every time we materialize an id, we allocate a\n        // new level with a single slot. You can think of this as a fork with only one\n        // prong, or an array of children with length 1.\n        //\n        // It's possible for the size of the sequence to exceed 32 bits, the max\n        // size for bitwise operations. When this happens, we make more room by\n        // converting the right part of the id to a string and storing it in an overflow\n        // variable. We use a base 32 string representation, because 32 is the largest\n        // power of 2 that is supported by toString(). We want the base to be large so\n        // that the resulting ids are compact, and we want the base to be a power of 2\n        // because every log2(base) bits corresponds to a single character, i.e. every\n        // log2(32) = 5 bits. That means we can lop bits off the end 5 at a time without\n        // affecting the final result.\n        var emptyTreeContext = {\n            id: 1,\n            overflow: \"\"\n        };\n        function getTreeId(context) {\n            var overflow = context.overflow;\n            var idWithLeadingBit = context.id;\n            var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\n            return id.toString(32) + overflow;\n        }\n        function pushTreeContext(baseContext, totalChildren, index) {\n            var baseIdWithLeadingBit = baseContext.id;\n            var baseOverflow = baseContext.overflow; // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n            // of the id; we use it to account for leading 0s.\n            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;\n            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);\n            var slot = index + 1;\n            var length = getBitLength(totalChildren) + baseLength; // 30 is the max length we can store without overflowing, taking into\n            // consideration the leading 1 we use to mark the end of the sequence.\n            if (length > 30) {\n                // We overflowed the bitwise-safe range. Fall back to slower algorithm.\n                // This branch assumes the length of the base id is greater than 5; it won't\n                // work for smaller ids, because you need 5 bits per character.\n                //\n                // We encode the id in multiple steps: first the base id, then the\n                // remaining digits.\n                //\n                // Each 5 bit sequence corresponds to a single base 32 character. So for\n                // example, if the current id is 23 bits long, we can convert 20 of those\n                // bits into a string of 4 characters, with 3 bits left over.\n                //\n                // First calculate how many bits in the base id represent a complete\n                // sequence of characters.\n                var numberOfOverflowBits = baseLength - baseLength % 5; // Then create a bitmask that selects only those bits.\n                var newOverflowBits = (1 << numberOfOverflowBits) - 1; // Select the bits, and convert them to a base 32 string.\n                var newOverflow = (baseId & newOverflowBits).toString(32); // Now we can remove those bits from the base id.\n                var restOfBaseId = baseId >> numberOfOverflowBits;\n                var restOfBaseLength = baseLength - numberOfOverflowBits; // Finally, encode the rest of the bits using the normal algorithm. Because\n                // we made more room, this time it won't overflow.\n                var restOfLength = getBitLength(totalChildren) + restOfBaseLength;\n                var restOfNewBits = slot << restOfBaseLength;\n                var id = restOfNewBits | restOfBaseId;\n                var overflow = newOverflow + baseOverflow;\n                return {\n                    id: 1 << restOfLength | id,\n                    overflow: overflow\n                };\n            } else {\n                // Normal path\n                var newBits = slot << baseLength;\n                var _id = newBits | baseId;\n                var _overflow = baseOverflow;\n                return {\n                    id: 1 << length | _id,\n                    overflow: _overflow\n                };\n            }\n        }\n        function getBitLength(number) {\n            return 32 - clz32(number);\n        }\n        function getLeadingBit(id) {\n            return 1 << getBitLength(id) - 1;\n        } // TODO: Math.clz32 is supported in Node 12+. Maybe we can drop the fallback.\n        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros.\n        // Based on:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n        var log = Math.log;\n        var LN2 = Math.LN2;\n        function clz32Fallback(x) {\n            var asUint = x >>> 0;\n            if (asUint === 0) {\n                return 32;\n            }\n            return 31 - (log(asUint) / LN2 | 0) | 0;\n        }\n        /**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */ function is(x, y) {\n            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n            ;\n        }\n        var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n        var currentlyRenderingComponent = null;\n        var currentlyRenderingTask = null;\n        var firstWorkInProgressHook = null;\n        var workInProgressHook = null; // Whether the work-in-progress hook is a re-rendered hook\n        var isReRender = false; // Whether an update was scheduled during the currently executing render pass.\n        var didScheduleRenderPhaseUpdate = false; // Counts the number of useId hooks in this component\n        var localIdCounter = 0; // Lazily created map of render-phase updates\n        var renderPhaseUpdates = null; // Counter to prevent infinite loops.\n        var numberOfReRenders = 0;\n        var RE_RENDER_LIMIT = 25;\n        var isInHookUserCodeInDev = false; // In DEV, this is the name of the currently executing primitive hook\n        var currentHookNameInDev;\n        function resolveCurrentlyRenderingComponent() {\n            if (currentlyRenderingComponent === null) {\n                throw new Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for\" + \" one of the following reasons:\\n\" + \"1. You might have mismatching versions of React and the renderer (such as React DOM)\\n\" + \"2. You might be breaking the Rules of Hooks\\n\" + \"3. You might have more than one copy of React in the same app\\n\" + \"See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n            }\n            {\n                if (isInHookUserCodeInDev) {\n                    error(\"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. \" + \"You can only call Hooks at the top level of your React function. \" + \"For more information, see \" + \"https://reactjs.org/link/rules-of-hooks\");\n                }\n            }\n            return currentlyRenderingComponent;\n        }\n        function areHookInputsEqual(nextDeps, prevDeps) {\n            if (prevDeps === null) {\n                {\n                    error(\"%s received a final argument during this render, but not during \" + \"the previous render. Even though the final argument is optional, \" + \"its type cannot change between renders.\", currentHookNameInDev);\n                }\n                return false;\n            }\n            {\n                // Don't bother comparing lengths in prod because these arrays should be\n                // passed inline.\n                if (nextDeps.length !== prevDeps.length) {\n                    error(\"The final argument passed to %s changed size between renders. The \" + \"order and size of this array must remain constant.\\n\\n\" + \"Previous: %s\\n\" + \"Incoming: %s\", currentHookNameInDev, \"[\" + nextDeps.join(\", \") + \"]\", \"[\" + prevDeps.join(\", \") + \"]\");\n                }\n            }\n            for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++){\n                if (objectIs(nextDeps[i], prevDeps[i])) {\n                    continue;\n                }\n                return false;\n            }\n            return true;\n        }\n        function createHook() {\n            if (numberOfReRenders > 0) {\n                throw new Error(\"Rendered more hooks than during the previous render\");\n            }\n            return {\n                memoizedState: null,\n                queue: null,\n                next: null\n            };\n        }\n        function createWorkInProgressHook() {\n            if (workInProgressHook === null) {\n                // This is the first hook in the list\n                if (firstWorkInProgressHook === null) {\n                    isReRender = false;\n                    firstWorkInProgressHook = workInProgressHook = createHook();\n                } else {\n                    // There's already a work-in-progress. Reuse it.\n                    isReRender = true;\n                    workInProgressHook = firstWorkInProgressHook;\n                }\n            } else {\n                if (workInProgressHook.next === null) {\n                    isReRender = false; // Append to the end of the list\n                    workInProgressHook = workInProgressHook.next = createHook();\n                } else {\n                    // There's already a work-in-progress. Reuse it.\n                    isReRender = true;\n                    workInProgressHook = workInProgressHook.next;\n                }\n            }\n            return workInProgressHook;\n        }\n        function prepareToUseHooks(task, componentIdentity) {\n            currentlyRenderingComponent = componentIdentity;\n            currentlyRenderingTask = task;\n            {\n                isInHookUserCodeInDev = false;\n            }\n            // didScheduleRenderPhaseUpdate = false;\n            // localIdCounter = 0;\n            // firstWorkInProgressHook = null;\n            // numberOfReRenders = 0;\n            // renderPhaseUpdates = null;\n            // workInProgressHook = null;\n            localIdCounter = 0;\n        }\n        function finishHooks(Component, props, children, refOrContext) {\n            // This must be called after every function component to prevent hooks from\n            // being used in classes.\n            while(didScheduleRenderPhaseUpdate){\n                // Updates were scheduled during the render phase. They are stored in\n                // the `renderPhaseUpdates` map. Call the component again, reusing the\n                // work-in-progress hooks and applying the additional updates on top. Keep\n                // restarting until no more updates are scheduled.\n                didScheduleRenderPhaseUpdate = false;\n                localIdCounter = 0;\n                numberOfReRenders += 1; // Start over from the beginning of the list\n                workInProgressHook = null;\n                children = Component(props, refOrContext);\n            }\n            resetHooksState();\n            return children;\n        }\n        function checkDidRenderIdHook() {\n            // This should be called immediately after every finishHooks call.\n            // Conceptually, it's part of the return value of finishHooks; it's only a\n            // separate function to avoid using an array tuple.\n            var didRenderIdHook = localIdCounter !== 0;\n            return didRenderIdHook;\n        } // Reset the internal hooks state if an error occurs while rendering a component\n        function resetHooksState() {\n            {\n                isInHookUserCodeInDev = false;\n            }\n            currentlyRenderingComponent = null;\n            currentlyRenderingTask = null;\n            didScheduleRenderPhaseUpdate = false;\n            firstWorkInProgressHook = null;\n            numberOfReRenders = 0;\n            renderPhaseUpdates = null;\n            workInProgressHook = null;\n        }\n        function readContext$1(context) {\n            {\n                if (isInHookUserCodeInDev) {\n                    error(\"Context can only be read while React is rendering. \" + \"In classes, you can read it in the render method or getDerivedStateFromProps. \" + \"In function components, you can read it directly in the function body, but not \" + \"inside Hooks like useReducer() or useMemo().\");\n                }\n            }\n            return readContext(context);\n        }\n        function useContext(context) {\n            {\n                currentHookNameInDev = \"useContext\";\n            }\n            resolveCurrentlyRenderingComponent();\n            return readContext(context);\n        }\n        function basicStateReducer(state, action) {\n            // $FlowFixMe: Flow doesn't like mixed types\n            return typeof action === \"function\" ? action(state) : action;\n        }\n        function useState(initialState) {\n            {\n                currentHookNameInDev = \"useState\";\n            }\n            return useReducer(basicStateReducer, initialState);\n        }\n        function useReducer(reducer, initialArg, init) {\n            {\n                if (reducer !== basicStateReducer) {\n                    currentHookNameInDev = \"useReducer\";\n                }\n            }\n            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n            workInProgressHook = createWorkInProgressHook();\n            if (isReRender) {\n                // This is a re-render. Apply the new render phase updates to the previous\n                // current hook.\n                var queue = workInProgressHook.queue;\n                var dispatch = queue.dispatch;\n                if (renderPhaseUpdates !== null) {\n                    // Render phase updates are stored in a map of queue -> linked list\n                    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n                    if (firstRenderPhaseUpdate !== undefined) {\n                        renderPhaseUpdates.delete(queue);\n                        var newState = workInProgressHook.memoizedState;\n                        var update = firstRenderPhaseUpdate;\n                        do {\n                            // Process this render phase update. We don't have to check the\n                            // priority because it will always be the same as the current\n                            // render's.\n                            var action = update.action;\n                            {\n                                isInHookUserCodeInDev = true;\n                            }\n                            newState = reducer(newState, action);\n                            {\n                                isInHookUserCodeInDev = false;\n                            }\n                            update = update.next;\n                        }while (update !== null);\n                        workInProgressHook.memoizedState = newState;\n                        return [\n                            newState,\n                            dispatch\n                        ];\n                    }\n                }\n                return [\n                    workInProgressHook.memoizedState,\n                    dispatch\n                ];\n            } else {\n                {\n                    isInHookUserCodeInDev = true;\n                }\n                var initialState;\n                if (reducer === basicStateReducer) {\n                    // Special case for `useState`.\n                    initialState = typeof initialArg === \"function\" ? initialArg() : initialArg;\n                } else {\n                    initialState = init !== undefined ? init(initialArg) : initialArg;\n                }\n                {\n                    isInHookUserCodeInDev = false;\n                }\n                workInProgressHook.memoizedState = initialState;\n                var _queue = workInProgressHook.queue = {\n                    last: null,\n                    dispatch: null\n                };\n                var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);\n                return [\n                    workInProgressHook.memoizedState,\n                    _dispatch\n                ];\n            }\n        }\n        function useMemo(nextCreate, deps) {\n            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n            workInProgressHook = createWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            if (workInProgressHook !== null) {\n                var prevState = workInProgressHook.memoizedState;\n                if (prevState !== null) {\n                    if (nextDeps !== null) {\n                        var prevDeps = prevState[1];\n                        if (areHookInputsEqual(nextDeps, prevDeps)) {\n                            return prevState[0];\n                        }\n                    }\n                }\n            }\n            {\n                isInHookUserCodeInDev = true;\n            }\n            var nextValue = nextCreate();\n            {\n                isInHookUserCodeInDev = false;\n            }\n            workInProgressHook.memoizedState = [\n                nextValue,\n                nextDeps\n            ];\n            return nextValue;\n        }\n        function useRef(initialValue) {\n            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();\n            workInProgressHook = createWorkInProgressHook();\n            var previousRef = workInProgressHook.memoizedState;\n            if (previousRef === null) {\n                var ref = {\n                    current: initialValue\n                };\n                {\n                    Object.seal(ref);\n                }\n                workInProgressHook.memoizedState = ref;\n                return ref;\n            } else {\n                return previousRef;\n            }\n        }\n        function useLayoutEffect(create, inputs) {\n            {\n                currentHookNameInDev = \"useLayoutEffect\";\n                error(\"useLayoutEffect does nothing on the server, because its effect cannot \" + \"be encoded into the server renderer's output format. This will lead \" + \"to a mismatch between the initial, non-hydrated UI and the intended \" + \"UI. To avoid this, useLayoutEffect should only be used in \" + \"components that render exclusively on the client. \" + \"See https://reactjs.org/link/uselayouteffect-ssr for common fixes.\");\n            }\n        }\n        function dispatchAction(componentIdentity, queue, action) {\n            if (numberOfReRenders >= RE_RENDER_LIMIT) {\n                throw new Error(\"Too many re-renders. React limits the number of renders to prevent \" + \"an infinite loop.\");\n            }\n            if (componentIdentity === currentlyRenderingComponent) {\n                // This is a render phase update. Stash it in a lazily-created map of\n                // queue -> linked list of updates. After this render pass, we'll restart\n                // and apply the stashed updates on top of the work-in-progress hook.\n                didScheduleRenderPhaseUpdate = true;\n                var update = {\n                    action: action,\n                    next: null\n                };\n                if (renderPhaseUpdates === null) {\n                    renderPhaseUpdates = new Map();\n                }\n                var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);\n                if (firstRenderPhaseUpdate === undefined) {\n                    renderPhaseUpdates.set(queue, update);\n                } else {\n                    // Append the update to the end of the list.\n                    var lastRenderPhaseUpdate = firstRenderPhaseUpdate;\n                    while(lastRenderPhaseUpdate.next !== null){\n                        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n                    }\n                    lastRenderPhaseUpdate.next = update;\n                }\n            }\n        }\n        function useCallback(callback, deps) {\n            return useMemo(function() {\n                return callback;\n            }, deps);\n        } // TODO Decide on how to implement this hook for server rendering.\n        // If a mutation occurs during render, consider triggering a Suspense boundary\n        // and falling back to client rendering.\n        function useMutableSource(source, getSnapshot, subscribe) {\n            resolveCurrentlyRenderingComponent();\n            return getSnapshot(source._source);\n        }\n        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n            if (getServerSnapshot === undefined) {\n                throw new Error(\"Missing getServerSnapshot, which is required for \" + \"server-rendered content. Will revert to client rendering.\");\n            }\n            return getServerSnapshot();\n        }\n        function useDeferredValue(value) {\n            resolveCurrentlyRenderingComponent();\n            return value;\n        }\n        function unsupportedStartTransition() {\n            throw new Error(\"startTransition cannot be called during server rendering.\");\n        }\n        function useTransition() {\n            resolveCurrentlyRenderingComponent();\n            return [\n                false,\n                unsupportedStartTransition\n            ];\n        }\n        function useId() {\n            var task = currentlyRenderingTask;\n            var treeId = getTreeId(task.treeContext);\n            var responseState = currentResponseState;\n            if (responseState === null) {\n                throw new Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component.\");\n            }\n            var localId = localIdCounter++;\n            return makeId(responseState, treeId, localId);\n        }\n        function noop() {}\n        var Dispatcher = {\n            readContext: readContext$1,\n            useContext: useContext,\n            useMemo: useMemo,\n            useReducer: useReducer,\n            useRef: useRef,\n            useState: useState,\n            useInsertionEffect: noop,\n            useLayoutEffect: useLayoutEffect,\n            useCallback: useCallback,\n            // useImperativeHandle is not run in the server environment\n            useImperativeHandle: noop,\n            // Effects are not run in the server environment.\n            useEffect: noop,\n            // Debugging effect\n            useDebugValue: noop,\n            useDeferredValue: useDeferredValue,\n            useTransition: useTransition,\n            useId: useId,\n            // Subscriptions are not setup in a server environment.\n            useMutableSource: useMutableSource,\n            useSyncExternalStore: useSyncExternalStore\n        };\n        var currentResponseState = null;\n        function setCurrentResponseState(responseState) {\n            currentResponseState = responseState;\n        }\n        function getStackByComponentStackNode(componentStack) {\n            try {\n                var info = \"\";\n                var node = componentStack;\n                do {\n                    switch(node.tag){\n                        case 0:\n                            info += describeBuiltInComponentFrame(node.type, null, null);\n                            break;\n                        case 1:\n                            info += describeFunctionComponentFrame(node.type, null, null);\n                            break;\n                        case 2:\n                            info += describeClassComponentFrame(node.type, null, null);\n                            break;\n                    }\n                    node = node.parent;\n                }while (node);\n                return info;\n            } catch (x) {\n                return \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n            }\n        }\n        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        var PENDING = 0;\n        var COMPLETED = 1;\n        var FLUSHED = 2;\n        var ABORTED = 3;\n        var ERRORED = 4;\n        var OPEN = 0;\n        var CLOSING = 1;\n        var CLOSED = 2;\n        // This is a default heuristic for how to split up the HTML content into progressive\n        // loading. Our goal is to be able to display additional new content about every 500ms.\n        // Faster than that is unnecessary and should be throttled on the client. It also\n        // adds unnecessary overhead to do more splits. We don't know if it's a higher or lower\n        // end device but higher end suffer less from the overhead than lower end does from\n        // not getting small enough pieces. We error on the side of low end.\n        // We base this on low end 3G speeds which is about 500kbits per second. We assume\n        // that there can be a reasonable drop off from max bandwidth which leaves you with\n        // as little as 80%. We can receive half of that each 500ms - at best. In practice,\n        // a little bandwidth is lost to processing and contention - e.g. CSS and images that\n        // are downloaded along with the main content. So we estimate about half of that to be\n        // the lower end throughput. In other words, we expect that you can at least show\n        // about 12.5kb of content per 500ms. Not counting starting latency for the first\n        // paint.\n        // 500 * 1024 / 8 * .8 * 0.5 / 2\n        var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;\n        function defaultErrorHandler(error) {\n            console[\"error\"](error); // Don't transform to our wrapper\n            return null;\n        }\n        function noop$1() {}\n        function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError) {\n            var pingedTasks = [];\n            var abortSet = new Set();\n            var request = {\n                destination: null,\n                responseState: responseState,\n                progressiveChunkSize: progressiveChunkSize === undefined ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,\n                status: OPEN,\n                fatalError: null,\n                nextSegmentId: 0,\n                allPendingTasks: 0,\n                pendingRootTasks: 0,\n                completedRootSegment: null,\n                abortableTasks: abortSet,\n                pingedTasks: pingedTasks,\n                clientRenderedBoundaries: [],\n                completedBoundaries: [],\n                partialBoundaries: [],\n                onError: onError === undefined ? defaultErrorHandler : onError,\n                onAllReady: onAllReady === undefined ? noop$1 : onAllReady,\n                onShellReady: onShellReady === undefined ? noop$1 : onShellReady,\n                onShellError: onShellError === undefined ? noop$1 : onShellError,\n                onFatalError: onFatalError === undefined ? noop$1 : onFatalError\n            }; // This segment represents the root fallback.\n            var rootSegment = createPendingSegment(request, 0, null, rootFormatContext, false, false); // There is no parent so conceptually, we're unblocked to flush this segment.\n            rootSegment.parentFlushed = true;\n            var rootTask = createTask(request, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);\n            pingedTasks.push(rootTask);\n            return request;\n        }\n        function pingTask(request, task) {\n            var pingedTasks = request.pingedTasks;\n            pingedTasks.push(task);\n            if (pingedTasks.length === 1) {\n                scheduleWork(function() {\n                    return performWork(request);\n                });\n            }\n        }\n        function createSuspenseBoundary(request, fallbackAbortableTasks) {\n            return {\n                id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,\n                rootSegmentID: -1,\n                parentFlushed: false,\n                pendingTasks: 0,\n                forceClientRender: false,\n                completedSegments: [],\n                byteSize: 0,\n                fallbackAbortableTasks: fallbackAbortableTasks,\n                errorDigest: null\n            };\n        }\n        function createTask(request, node, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {\n            request.allPendingTasks++;\n            if (blockedBoundary === null) {\n                request.pendingRootTasks++;\n            } else {\n                blockedBoundary.pendingTasks++;\n            }\n            var task = {\n                node: node,\n                ping: function() {\n                    return pingTask(request, task);\n                },\n                blockedBoundary: blockedBoundary,\n                blockedSegment: blockedSegment,\n                abortSet: abortSet,\n                legacyContext: legacyContext,\n                context: context,\n                treeContext: treeContext\n            };\n            {\n                task.componentStack = null;\n            }\n            abortSet.add(task);\n            return task;\n        }\n        function createPendingSegment(request, index, boundary, formatContext, lastPushedText, textEmbedded) {\n            return {\n                status: PENDING,\n                id: -1,\n                // lazily assigned later\n                index: index,\n                parentFlushed: false,\n                chunks: [],\n                children: [],\n                formatContext: formatContext,\n                boundary: boundary,\n                lastPushedText: lastPushedText,\n                textEmbedded: textEmbedded\n            };\n        } // DEV-only global reference to the currently executing task\n        var currentTaskInDEV = null;\n        function getCurrentStackInDEV() {\n            {\n                if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {\n                    return \"\";\n                }\n                return getStackByComponentStackNode(currentTaskInDEV.componentStack);\n            }\n        }\n        function pushBuiltInComponentStackInDEV(task, type) {\n            {\n                task.componentStack = {\n                    tag: 0,\n                    parent: task.componentStack,\n                    type: type\n                };\n            }\n        }\n        function pushFunctionComponentStackInDEV(task, type) {\n            {\n                task.componentStack = {\n                    tag: 1,\n                    parent: task.componentStack,\n                    type: type\n                };\n            }\n        }\n        function pushClassComponentStackInDEV(task, type) {\n            {\n                task.componentStack = {\n                    tag: 2,\n                    parent: task.componentStack,\n                    type: type\n                };\n            }\n        }\n        function popComponentStackInDEV(task) {\n            {\n                if (task.componentStack === null) {\n                    error(\"Unexpectedly popped too many stack frames. This is a bug in React.\");\n                } else {\n                    task.componentStack = task.componentStack.parent;\n                }\n            }\n        } // stash the component stack of an unwinding error until it is processed\n        var lastBoundaryErrorComponentStackDev = null;\n        function captureBoundaryErrorDetailsDev(boundary, error) {\n            {\n                var errorMessage;\n                if (typeof error === \"string\") {\n                    errorMessage = error;\n                } else if (error && typeof error.message === \"string\") {\n                    errorMessage = error.message;\n                } else {\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    errorMessage = String(error);\n                }\n                var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();\n                lastBoundaryErrorComponentStackDev = null;\n                boundary.errorMessage = errorMessage;\n                boundary.errorComponentStack = errorComponentStack;\n            }\n        }\n        function logRecoverableError(request, error) {\n            // If this callback errors, we intentionally let that error bubble up to become a fatal error\n            // so that someone fixes the error reporting instead of hiding it.\n            var errorDigest = request.onError(error);\n            if (errorDigest != null && typeof errorDigest !== \"string\") {\n                // eslint-disable-next-line react-internal/prod-error-codes\n                throw new Error('onError returned something with a type other than \"string\". onError should return a string and may return null or undefined but must not return anything else. It received something of type \"' + typeof errorDigest + '\" instead');\n            }\n            return errorDigest;\n        }\n        function fatalError(request, error) {\n            // This is called outside error handling code such as if the root errors outside\n            // a suspense boundary or if the root suspense boundary's fallback errors.\n            // It's also called if React itself or its host configs errors.\n            var onShellError = request.onShellError;\n            onShellError(error);\n            var onFatalError = request.onFatalError;\n            onFatalError(error);\n            if (request.destination !== null) {\n                request.status = CLOSED;\n                closeWithError(request.destination, error);\n            } else {\n                request.status = CLOSING;\n                request.fatalError = error;\n            }\n        }\n        function renderSuspenseBoundary(request, task, props) {\n            pushBuiltInComponentStackInDEV(task, \"Suspense\");\n            var parentBoundary = task.blockedBoundary;\n            var parentSegment = task.blockedSegment; // Each time we enter a suspense boundary, we split out into a new segment for\n            // the fallback so that we can later replace that segment with the content.\n            // This also lets us split out the main content even if it doesn't suspend,\n            // in case it ends up generating a large subtree of content.\n            var fallback = props.fallback;\n            var content = props.children;\n            var fallbackAbortSet = new Set();\n            var newBoundary = createSuspenseBoundary(request, fallbackAbortSet);\n            var insertionIndex = parentSegment.chunks.length; // The children of the boundary segment is actually the fallback.\n            var boundarySegment = createPendingSegment(request, insertionIndex, newBoundary, parentSegment.formatContext, false, false);\n            parentSegment.children.push(boundarySegment); // The parentSegment has a child Segment at this index so we reset the lastPushedText marker on the parent\n            parentSegment.lastPushedText = false; // This segment is the actual child content. We can start rendering that immediately.\n            var contentRootSegment = createPendingSegment(request, 0, null, parentSegment.formatContext, false, false); // We mark the root segment as having its parent flushed. It's not really flushed but there is\n            // no parent segment so there's nothing to wait on.\n            contentRootSegment.parentFlushed = true; // Currently this is running synchronously. We could instead schedule this to pingedTasks.\n            // I suspect that there might be some efficiency benefits from not creating the suspended task\n            // and instead just using the stack if possible.\n            // TODO: Call this directly instead of messing with saving and restoring contexts.\n            // We can reuse the current context and task to render the content immediately without\n            // context switching. We just need to temporarily switch which boundary and which segment\n            // we're writing to. If something suspends, it'll spawn new suspended task with that context.\n            task.blockedBoundary = newBoundary;\n            task.blockedSegment = contentRootSegment;\n            try {\n                // We use the safe form because we don't handle suspending here. Only error handling.\n                renderNode(request, task, content);\n                pushSegmentFinale(contentRootSegment.chunks, request.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);\n                contentRootSegment.status = COMPLETED;\n                queueCompletedSegment(newBoundary, contentRootSegment);\n                if (newBoundary.pendingTasks === 0) {\n                    // This must have been the last segment we were waiting on. This boundary is now complete.\n                    // Therefore we won't need the fallback. We early return so that we don't have to create\n                    // the fallback.\n                    popComponentStackInDEV(task);\n                    return;\n                }\n            } catch (error) {\n                contentRootSegment.status = ERRORED;\n                newBoundary.forceClientRender = true;\n                newBoundary.errorDigest = logRecoverableError(request, error);\n                {\n                    captureBoundaryErrorDetailsDev(newBoundary, error);\n                }\n            // We don't need to schedule any task because we know the parent has written yet.\n            // We do need to fallthrough to create the fallback though.\n            } finally{\n                task.blockedBoundary = parentBoundary;\n                task.blockedSegment = parentSegment;\n            } // We create suspended task for the fallback because we don't want to actually work\n            // on it yet in case we finish the main content, so we queue for later.\n            var suspendedFallbackTask = createTask(request, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);\n            {\n                suspendedFallbackTask.componentStack = task.componentStack;\n            }\n            // on preparing fallbacks if we don't have any more main content to task on.\n            request.pingedTasks.push(suspendedFallbackTask);\n            popComponentStackInDEV(task);\n        }\n        function renderHostElement(request, task, type, props) {\n            pushBuiltInComponentStackInDEV(task, type);\n            var segment = task.blockedSegment;\n            var children = pushStartInstance(segment.chunks, type, props, request.responseState, segment.formatContext);\n            segment.lastPushedText = false;\n            var prevContext = segment.formatContext;\n            segment.formatContext = getChildFormatContext(prevContext, type, props); // We use the non-destructive form because if something suspends, we still\n            // need to pop back up and finish this subtree of HTML.\n            renderNode(request, task, children); // We expect that errors will fatal the whole task and that we don't need\n            // the correct context. Therefore this is not in a finally.\n            segment.formatContext = prevContext;\n            pushEndInstance(segment.chunks, type);\n            segment.lastPushedText = false;\n            popComponentStackInDEV(task);\n        }\n        function shouldConstruct$1(Component) {\n            return Component.prototype && Component.prototype.isReactComponent;\n        }\n        function renderWithHooks(request, task, Component, props, secondArg) {\n            var componentIdentity = {};\n            prepareToUseHooks(task, componentIdentity);\n            var result = Component(props, secondArg);\n            return finishHooks(Component, props, result, secondArg);\n        }\n        function finishClassComponent(request, task, instance, Component, props) {\n            var nextChildren = instance.render();\n            {\n                if (instance.props !== props) {\n                    if (!didWarnAboutReassigningProps) {\n                        error(\"It looks like %s is reassigning its own `this.props` while rendering. \" + \"This is not supported and can lead to confusing bugs.\", getComponentNameFromType(Component) || \"a component\");\n                    }\n                    didWarnAboutReassigningProps = true;\n                }\n            }\n            {\n                var childContextTypes = Component.childContextTypes;\n                if (childContextTypes !== null && childContextTypes !== undefined) {\n                    var previousContext = task.legacyContext;\n                    var mergedContext = processChildContext(instance, Component, previousContext, childContextTypes);\n                    task.legacyContext = mergedContext;\n                    renderNodeDestructive(request, task, nextChildren);\n                    task.legacyContext = previousContext;\n                    return;\n                }\n            }\n            renderNodeDestructive(request, task, nextChildren);\n        }\n        function renderClassComponent(request, task, Component, props) {\n            pushClassComponentStackInDEV(task, Component);\n            var maskedContext = getMaskedContext(Component, task.legacyContext);\n            var instance = constructClassInstance(Component, props, maskedContext);\n            mountClassInstance(instance, Component, props, maskedContext);\n            finishClassComponent(request, task, instance, Component, props);\n            popComponentStackInDEV(task);\n        }\n        var didWarnAboutBadClass = {};\n        var didWarnAboutModulePatternComponent = {};\n        var didWarnAboutContextTypeOnFunctionComponent = {};\n        var didWarnAboutGetDerivedStateOnFunctionComponent = {};\n        var didWarnAboutReassigningProps = false;\n        var didWarnAboutGenerators = false;\n        var didWarnAboutMaps = false;\n        var hasWarnedAboutUsingContextAsConsumer = false; // This would typically be a function component but we still support module pattern\n        // components for some reason.\n        function renderIndeterminateComponent(request, task, Component, props) {\n            var legacyContext;\n            {\n                legacyContext = getMaskedContext(Component, task.legacyContext);\n            }\n            pushFunctionComponentStackInDEV(task, Component);\n            {\n                if (Component.prototype && typeof Component.prototype.render === \"function\") {\n                    var componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutBadClass[componentName]) {\n                        error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + \"This is likely to cause errors. Change %s to extend React.Component instead.\", componentName, componentName);\n                        didWarnAboutBadClass[componentName] = true;\n                    }\n                }\n            }\n            var value = renderWithHooks(request, task, Component, props, legacyContext);\n            var hasId = checkDidRenderIdHook();\n            {\n                // Support for module components is deprecated and is removed behind a flag.\n                // Whether or not it would crash later, we want to show a good message in DEV first.\n                if (typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === undefined) {\n                    var _componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutModulePatternComponent[_componentName]) {\n                        error(\"The <%s /> component appears to be a function component that returns a class instance. \" + \"Change %s to a class that extends React.Component instead. \" + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + \"cannot be called with `new` by React.\", _componentName, _componentName, _componentName);\n                        didWarnAboutModulePatternComponent[_componentName] = true;\n                    }\n                }\n            }\n            if (// Eventually we'll delete this branch altogether.\n            typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === undefined) {\n                {\n                    var _componentName2 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutModulePatternComponent[_componentName2]) {\n                        error(\"The <%s /> component appears to be a function component that returns a class instance. \" + \"Change %s to a class that extends React.Component instead. \" + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + \"cannot be called with `new` by React.\", _componentName2, _componentName2, _componentName2);\n                        didWarnAboutModulePatternComponent[_componentName2] = true;\n                    }\n                }\n                mountClassInstance(value, Component, props, legacyContext);\n                finishClassComponent(request, task, value, Component, props);\n            } else {\n                {\n                    validateFunctionComponentInDev(Component);\n                }\n                // the previous task every again, so we can use the destructive recursive form.\n                if (hasId) {\n                    // This component materialized an id. We treat this as its own level, with\n                    // a single \"child\" slot.\n                    var prevTreeContext = task.treeContext;\n                    var totalChildren = 1;\n                    var index = 0;\n                    task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);\n                    try {\n                        renderNodeDestructive(request, task, value);\n                    } finally{\n                        task.treeContext = prevTreeContext;\n                    }\n                } else {\n                    renderNodeDestructive(request, task, value);\n                }\n            }\n            popComponentStackInDEV(task);\n        }\n        function validateFunctionComponentInDev(Component) {\n            {\n                if (Component) {\n                    if (Component.childContextTypes) {\n                        error(\"%s(...): childContextTypes cannot be defined on a function component.\", Component.displayName || Component.name || \"Component\");\n                    }\n                }\n                if (typeof Component.getDerivedStateFromProps === \"function\") {\n                    var _componentName3 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {\n                        error(\"%s: Function components do not support getDerivedStateFromProps.\", _componentName3);\n                        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;\n                    }\n                }\n                if (typeof Component.contextType === \"object\" && Component.contextType !== null) {\n                    var _componentName4 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {\n                        error(\"%s: Function components do not support contextType.\", _componentName4);\n                        didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;\n                    }\n                }\n            }\n        }\n        function resolveDefaultProps(Component, baseProps) {\n            if (Component && Component.defaultProps) {\n                // Resolve default props. Taken from ReactElement\n                var props = assign({}, baseProps);\n                var defaultProps = Component.defaultProps;\n                for(var propName in defaultProps){\n                    if (props[propName] === undefined) {\n                        props[propName] = defaultProps[propName];\n                    }\n                }\n                return props;\n            }\n            return baseProps;\n        }\n        function renderForwardRef(request, task, type, props, ref) {\n            pushFunctionComponentStackInDEV(task, type.render);\n            var children = renderWithHooks(request, task, type.render, props, ref);\n            var hasId = checkDidRenderIdHook();\n            if (hasId) {\n                // This component materialized an id. We treat this as its own level, with\n                // a single \"child\" slot.\n                var prevTreeContext = task.treeContext;\n                var totalChildren = 1;\n                var index = 0;\n                task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index);\n                try {\n                    renderNodeDestructive(request, task, children);\n                } finally{\n                    task.treeContext = prevTreeContext;\n                }\n            } else {\n                renderNodeDestructive(request, task, children);\n            }\n            popComponentStackInDEV(task);\n        }\n        function renderMemo(request, task, type, props, ref) {\n            var innerType = type.type;\n            var resolvedProps = resolveDefaultProps(innerType, props);\n            renderElement(request, task, innerType, resolvedProps, ref);\n        }\n        function renderContextConsumer(request, task, context, props) {\n            // The logic below for Context differs depending on PROD or DEV mode. In\n            // DEV mode, we create a separate object for Context.Consumer that acts\n            // like a proxy to Context. This proxy object adds unnecessary code in PROD\n            // so we use the old behaviour (Context.Consumer references Context) to\n            // reduce size and overhead. The separate object references context via\n            // a property called \"_context\", which also gives us the ability to check\n            // in DEV mode if this property exists or not and warn if it does not.\n            {\n                if (context._context === undefined) {\n                    // This may be because it's a Context (rather than a Consumer).\n                    // Or it may be because it's older React where they're the same thing.\n                    // We only want to warn if we're sure it's a new React.\n                    if (context !== context.Consumer) {\n                        if (!hasWarnedAboutUsingContextAsConsumer) {\n                            hasWarnedAboutUsingContextAsConsumer = true;\n                            error(\"Rendering <Context> directly is not supported and will be removed in \" + \"a future major release. Did you mean to render <Context.Consumer> instead?\");\n                        }\n                    }\n                } else {\n                    context = context._context;\n                }\n            }\n            var render = props.children;\n            {\n                if (typeof render !== \"function\") {\n                    error(\"A context consumer was rendered with multiple children, or a child \" + \"that isn't a function. A context consumer expects a single child \" + \"that is a function. If you did pass a function, make sure there \" + \"is no trailing or leading whitespace around it.\");\n                }\n            }\n            var newValue = readContext(context);\n            var newChildren = render(newValue);\n            renderNodeDestructive(request, task, newChildren);\n        }\n        function renderContextProvider(request, task, type, props) {\n            var context = type._context;\n            var value = props.value;\n            var children = props.children;\n            var prevSnapshot;\n            {\n                prevSnapshot = task.context;\n            }\n            task.context = pushProvider(context, value);\n            renderNodeDestructive(request, task, children);\n            task.context = popProvider(context);\n            {\n                if (prevSnapshot !== task.context) {\n                    error(\"Popping the context provider did not return back to the original snapshot. This is a bug in React.\");\n                }\n            }\n        }\n        function renderLazyComponent(request, task, lazyComponent, props, ref) {\n            pushBuiltInComponentStackInDEV(task, \"Lazy\");\n            var payload = lazyComponent._payload;\n            var init = lazyComponent._init;\n            var Component = init(payload);\n            var resolvedProps = resolveDefaultProps(Component, props);\n            renderElement(request, task, Component, resolvedProps, ref);\n            popComponentStackInDEV(task);\n        }\n        function renderElement(request, task, type, props, ref) {\n            if (typeof type === \"function\") {\n                if (shouldConstruct$1(type)) {\n                    renderClassComponent(request, task, type, props);\n                    return;\n                } else {\n                    renderIndeterminateComponent(request, task, type, props);\n                    return;\n                }\n            }\n            if (typeof type === \"string\") {\n                renderHostElement(request, task, type, props);\n                return;\n            }\n            switch(type){\n                // TODO: LegacyHidden acts the same as a fragment. This only works\n                // because we currently assume that every instance of LegacyHidden is\n                // accompanied by a host component wrapper. In the hidden mode, the host\n                // component is given a `hidden` attribute, which ensures that the\n                // initial HTML is not visible. To support the use of LegacyHidden as a\n                // true fragment, without an extra DOM node, we would have to hide the\n                // initial HTML in some other way.\n                // TODO: Add REACT_OFFSCREEN_TYPE here too with the same capability.\n                case REACT_LEGACY_HIDDEN_TYPE:\n                case REACT_DEBUG_TRACING_MODE_TYPE:\n                case REACT_STRICT_MODE_TYPE:\n                case REACT_PROFILER_TYPE:\n                case REACT_FRAGMENT_TYPE:\n                    {\n                        renderNodeDestructive(request, task, props.children);\n                        return;\n                    }\n                case REACT_SUSPENSE_LIST_TYPE:\n                    {\n                        pushBuiltInComponentStackInDEV(task, \"SuspenseList\"); // TODO: SuspenseList should control the boundaries.\n                        renderNodeDestructive(request, task, props.children);\n                        popComponentStackInDEV(task);\n                        return;\n                    }\n                case REACT_SCOPE_TYPE:\n                    {\n                        throw new Error(\"ReactDOMServer does not yet support scope components.\");\n                    }\n                // eslint-disable-next-line-no-fallthrough\n                case REACT_SUSPENSE_TYPE:\n                    {\n                        {\n                            renderSuspenseBoundary(request, task, props);\n                        }\n                        return;\n                    }\n            }\n            if (typeof type === \"object\" && type !== null) {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        {\n                            renderForwardRef(request, task, type, props, ref);\n                            return;\n                        }\n                    case REACT_MEMO_TYPE:\n                        {\n                            renderMemo(request, task, type, props, ref);\n                            return;\n                        }\n                    case REACT_PROVIDER_TYPE:\n                        {\n                            renderContextProvider(request, task, type, props);\n                            return;\n                        }\n                    case REACT_CONTEXT_TYPE:\n                        {\n                            renderContextConsumer(request, task, type, props);\n                            return;\n                        }\n                    case REACT_LAZY_TYPE:\n                        {\n                            renderLazyComponent(request, task, type, props);\n                            return;\n                        }\n                }\n            }\n            var info = \"\";\n            {\n                if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                    info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and \" + \"named imports.\";\n                }\n            }\n            throw new Error(\"Element type is invalid: expected a string (for built-in \" + \"components) or a class/function (for composite components) \" + (\"but got: \" + (type == null ? type : typeof type) + \".\" + info));\n        }\n        function validateIterable(iterable, iteratorFn) {\n            {\n                // We don't support rendering Generators because it's a mutation.\n                // See https://github.com/facebook/react/issues/12995\n                if (typeof Symbol === \"function\" && // $FlowFixMe Flow doesn't know about toStringTag\n                iterable[Symbol.toStringTag] === \"Generator\") {\n                    if (!didWarnAboutGenerators) {\n                        error(\"Using Generators as children is unsupported and will likely yield \" + \"unexpected results because enumerating a generator mutates it. \" + \"You may convert it to an array with `Array.from()` or the \" + \"`[...spread]` operator before rendering. Keep in mind \" + \"you might need to polyfill these features for older browsers.\");\n                    }\n                    didWarnAboutGenerators = true;\n                } // Warn about using Maps as children\n                if (iterable.entries === iteratorFn) {\n                    if (!didWarnAboutMaps) {\n                        error(\"Using Maps as children is not supported. \" + \"Use an array of keyed ReactElements instead.\");\n                    }\n                    didWarnAboutMaps = true;\n                }\n            }\n        }\n        function renderNodeDestructive(request, task, node) {\n            {\n                // In Dev we wrap renderNodeDestructiveImpl in a try / catch so we can capture\n                // a component stack at the right place in the tree. We don't do this in renderNode\n                // becuase it is not called at every layer of the tree and we may lose frames\n                try {\n                    return renderNodeDestructiveImpl(request, task, node);\n                } catch (x) {\n                    if (typeof x === \"object\" && x !== null && typeof x.then === \"function\") ;\n                    else {\n                        // This is an error, stash the component stack if it is null.\n                        lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();\n                    } // rethrow so normal suspense logic can handle thrown value accordingly\n                    throw x;\n                }\n            }\n        } // This function by it self renders a node and consumes the task by mutating it\n        // to update the current execution state.\n        function renderNodeDestructiveImpl(request, task, node) {\n            // Stash the node we're working on. We'll pick up from this task in case\n            // something suspends.\n            task.node = node; // Handle object types\n            if (typeof node === \"object\" && node !== null) {\n                switch(node.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        {\n                            var element = node;\n                            var type = element.type;\n                            var props = element.props;\n                            var ref = element.ref;\n                            renderElement(request, task, type, props, ref);\n                            return;\n                        }\n                    case REACT_PORTAL_TYPE:\n                        throw new Error(\"Portals are not currently supported by the server renderer. \" + \"Render them conditionally so that they only appear on the client render.\");\n                    // eslint-disable-next-line-no-fallthrough\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyNode = node;\n                            var payload = lazyNode._payload;\n                            var init = lazyNode._init;\n                            var resolvedNode;\n                            {\n                                try {\n                                    resolvedNode = init(payload);\n                                } catch (x) {\n                                    if (typeof x === \"object\" && x !== null && typeof x.then === \"function\") {\n                                        // this Lazy initializer is suspending. push a temporary frame onto the stack so it can be\n                                        // popped off in spawnNewSuspendedTask. This aligns stack behavior between Lazy in element position\n                                        // vs Component position. We do not want the frame for Errors so we exclusively do this in\n                                        // the wakeable branch\n                                        pushBuiltInComponentStackInDEV(task, \"Lazy\");\n                                    }\n                                    throw x;\n                                }\n                            }\n                            renderNodeDestructive(request, task, resolvedNode);\n                            return;\n                        }\n                }\n                if (isArray(node)) {\n                    renderChildrenArray(request, task, node);\n                    return;\n                }\n                var iteratorFn = getIteratorFn(node);\n                if (iteratorFn) {\n                    {\n                        validateIterable(node, iteratorFn);\n                    }\n                    var iterator = iteratorFn.call(node);\n                    if (iterator) {\n                        // We need to know how many total children are in this set, so that we\n                        // can allocate enough id slots to acommodate them. So we must exhaust\n                        // the iterator before we start recursively rendering the children.\n                        // TODO: This is not great but I think it's inherent to the id\n                        // generation algorithm.\n                        var step = iterator.next(); // If there are not entries, we need to push an empty so we start by checking that.\n                        if (!step.done) {\n                            var children = [];\n                            do {\n                                children.push(step.value);\n                                step = iterator.next();\n                            }while (!step.done);\n                            renderChildrenArray(request, task, children);\n                            return;\n                        }\n                        return;\n                    }\n                }\n                var childString = Object.prototype.toString.call(node);\n                throw new Error(\"Objects are not valid as a React child (found: \" + (childString === \"[object Object]\" ? \"object with keys {\" + Object.keys(node).join(\", \") + \"}\" : childString) + \"). \" + \"If you meant to render a collection of children, use an array \" + \"instead.\");\n            }\n            if (typeof node === \"string\") {\n                var segment = task.blockedSegment;\n                segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, node, request.responseState, segment.lastPushedText);\n                return;\n            }\n            if (typeof node === \"number\") {\n                var _segment = task.blockedSegment;\n                _segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, \"\" + node, request.responseState, _segment.lastPushedText);\n                return;\n            }\n            {\n                if (typeof node === \"function\") {\n                    error(\"Functions are not valid as a React child. This may happen if \" + \"you return a Component instead of <Component /> from render. \" + \"Or maybe you meant to call this function rather than return it.\");\n                }\n            }\n        }\n        function renderChildrenArray(request, task, children) {\n            var totalChildren = children.length;\n            for(var i = 0; i < totalChildren; i++){\n                var prevTreeContext = task.treeContext;\n                task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i);\n                try {\n                    // We need to use the non-destructive form so that we can safely pop back\n                    // up and render the sibling if something suspends.\n                    renderNode(request, task, children[i]);\n                } finally{\n                    task.treeContext = prevTreeContext;\n                }\n            }\n        }\n        function spawnNewSuspendedTask(request, task, x) {\n            // Something suspended, we'll need to create a new segment and resolve it later.\n            var segment = task.blockedSegment;\n            var insertionIndex = segment.chunks.length;\n            var newSegment = createPendingSegment(request, insertionIndex, null, segment.formatContext, segment.lastPushedText, true);\n            segment.children.push(newSegment); // Reset lastPushedText for current Segment since the new Segment \"consumed\" it\n            segment.lastPushedText = false;\n            var newTask = createTask(request, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);\n            {\n                if (task.componentStack !== null) {\n                    // We pop one task off the stack because the node that suspended will be tried again,\n                    // which will add it back onto the stack.\n                    newTask.componentStack = task.componentStack.parent;\n                }\n            }\n            var ping = newTask.ping;\n            x.then(ping, ping);\n        } // This is a non-destructive form of rendering a node. If it suspends it spawns\n        // a new task and restores the context of this task to what it was before.\n        function renderNode(request, task, node) {\n            // TODO: Store segment.children.length here and reset it in case something\n            // suspended partially through writing something.\n            // Snapshot the current context in case something throws to interrupt the\n            // process.\n            var previousFormatContext = task.blockedSegment.formatContext;\n            var previousLegacyContext = task.legacyContext;\n            var previousContext = task.context;\n            var previousComponentStack = null;\n            {\n                previousComponentStack = task.componentStack;\n            }\n            try {\n                return renderNodeDestructive(request, task, node);\n            } catch (x) {\n                resetHooksState();\n                if (typeof x === \"object\" && x !== null && typeof x.then === \"function\") {\n                    spawnNewSuspendedTask(request, task, x); // Restore the context. We assume that this will be restored by the inner\n                    // functions in case nothing throws so we don't use \"finally\" here.\n                    task.blockedSegment.formatContext = previousFormatContext;\n                    task.legacyContext = previousLegacyContext;\n                    task.context = previousContext; // Restore all active ReactContexts to what they were before.\n                    switchContext(previousContext);\n                    {\n                        task.componentStack = previousComponentStack;\n                    }\n                    return;\n                } else {\n                    // Restore the context. We assume that this will be restored by the inner\n                    // functions in case nothing throws so we don't use \"finally\" here.\n                    task.blockedSegment.formatContext = previousFormatContext;\n                    task.legacyContext = previousLegacyContext;\n                    task.context = previousContext; // Restore all active ReactContexts to what they were before.\n                    switchContext(previousContext);\n                    {\n                        task.componentStack = previousComponentStack;\n                    }\n                    // Let's terminate the rest of the tree and don't render any siblings.\n                    throw x;\n                }\n            }\n        }\n        function erroredTask(request, boundary, segment, error) {\n            // Report the error to a global handler.\n            var errorDigest = logRecoverableError(request, error);\n            if (boundary === null) {\n                fatalError(request, error);\n            } else {\n                boundary.pendingTasks--;\n                if (!boundary.forceClientRender) {\n                    boundary.forceClientRender = true;\n                    boundary.errorDigest = errorDigest;\n                    {\n                        captureBoundaryErrorDetailsDev(boundary, error);\n                    }\n                    // so we can flush it, if the parent already flushed.\n                    if (boundary.parentFlushed) {\n                        // We don't have a preference where in the queue this goes since it's likely\n                        // to error on the client anyway. However, intentionally client-rendered\n                        // boundaries should be flushed earlier so that they can start on the client.\n                        // We reuse the same queue for errors.\n                        request.clientRenderedBoundaries.push(boundary);\n                    }\n                }\n            }\n            request.allPendingTasks--;\n            if (request.allPendingTasks === 0) {\n                var onAllReady = request.onAllReady;\n                onAllReady();\n            }\n        }\n        function abortTaskSoft(task) {\n            // This aborts task without aborting the parent boundary that it blocks.\n            // It's used for when we didn't need this task to complete the tree.\n            // If task was needed, then it should use abortTask instead.\n            var request = this;\n            var boundary = task.blockedBoundary;\n            var segment = task.blockedSegment;\n            segment.status = ABORTED;\n            finishedTask(request, boundary, segment);\n        }\n        function abortTask(task, request, reason) {\n            // This aborts the task and aborts the parent that it blocks, putting it into\n            // client rendered mode.\n            var boundary = task.blockedBoundary;\n            var segment = task.blockedSegment;\n            segment.status = ABORTED;\n            if (boundary === null) {\n                request.allPendingTasks--; // We didn't complete the root so we have nothing to show. We can close\n                // the request;\n                if (request.status !== CLOSED) {\n                    request.status = CLOSED;\n                    if (request.destination !== null) {\n                        close(request.destination);\n                    }\n                }\n            } else {\n                boundary.pendingTasks--;\n                if (!boundary.forceClientRender) {\n                    boundary.forceClientRender = true;\n                    var _error = reason === undefined ? new Error(\"The render was aborted by the server without a reason.\") : reason;\n                    boundary.errorDigest = request.onError(_error);\n                    {\n                        var errorPrefix = \"The server did not finish this Suspense boundary: \";\n                        if (_error && typeof _error.message === \"string\") {\n                            _error = errorPrefix + _error.message;\n                        } else {\n                            // eslint-disable-next-line react-internal/safe-string-coercion\n                            _error = errorPrefix + String(_error);\n                        }\n                        var previousTaskInDev = currentTaskInDEV;\n                        currentTaskInDEV = task;\n                        try {\n                            captureBoundaryErrorDetailsDev(boundary, _error);\n                        } finally{\n                            currentTaskInDEV = previousTaskInDev;\n                        }\n                    }\n                    if (boundary.parentFlushed) {\n                        request.clientRenderedBoundaries.push(boundary);\n                    }\n                } // If this boundary was still pending then we haven't already cancelled its fallbacks.\n                // We'll need to abort the fallbacks, which will also error that parent boundary.\n                boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {\n                    return abortTask(fallbackTask, request, reason);\n                });\n                boundary.fallbackAbortableTasks.clear();\n                request.allPendingTasks--;\n                if (request.allPendingTasks === 0) {\n                    var onAllReady = request.onAllReady;\n                    onAllReady();\n                }\n            }\n        }\n        function queueCompletedSegment(boundary, segment) {\n            if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {\n                // This is an empty segment. There's nothing to write, so we can instead transfer the ID\n                // to the child. That way any existing references point to the child.\n                var childSegment = segment.children[0];\n                childSegment.id = segment.id;\n                childSegment.parentFlushed = true;\n                if (childSegment.status === COMPLETED) {\n                    queueCompletedSegment(boundary, childSegment);\n                }\n            } else {\n                var completedSegments = boundary.completedSegments;\n                completedSegments.push(segment);\n            }\n        }\n        function finishedTask(request, boundary, segment) {\n            if (boundary === null) {\n                if (segment.parentFlushed) {\n                    if (request.completedRootSegment !== null) {\n                        throw new Error(\"There can only be one root segment. This is a bug in React.\");\n                    }\n                    request.completedRootSegment = segment;\n                }\n                request.pendingRootTasks--;\n                if (request.pendingRootTasks === 0) {\n                    // We have completed the shell so the shell can't error anymore.\n                    request.onShellError = noop$1;\n                    var onShellReady = request.onShellReady;\n                    onShellReady();\n                }\n            } else {\n                boundary.pendingTasks--;\n                if (boundary.forceClientRender) ;\n                else if (boundary.pendingTasks === 0) {\n                    // This must have been the last segment we were waiting on. This boundary is now complete.\n                    if (segment.parentFlushed) {\n                        // Our parent segment already flushed, so we need to schedule this segment to be emitted.\n                        // If it is a segment that was aborted, we'll write other content instead so we don't need\n                        // to emit it.\n                        if (segment.status === COMPLETED) {\n                            queueCompletedSegment(boundary, segment);\n                        }\n                    }\n                    if (boundary.parentFlushed) {\n                        // The segment might be part of a segment that didn't flush yet, but if the boundary's\n                        // parent flushed, we need to schedule the boundary to be emitted.\n                        request.completedBoundaries.push(boundary);\n                    } // We can now cancel any pending task on the fallback since we won't need to show it anymore.\n                    // This needs to happen after we read the parentFlushed flags because aborting can finish\n                    // work which can trigger user code, which can start flushing, which can change those flags.\n                    boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request);\n                    boundary.fallbackAbortableTasks.clear();\n                } else {\n                    if (segment.parentFlushed) {\n                        // Our parent already flushed, so we need to schedule this segment to be emitted.\n                        // If it is a segment that was aborted, we'll write other content instead so we don't need\n                        // to emit it.\n                        if (segment.status === COMPLETED) {\n                            queueCompletedSegment(boundary, segment);\n                            var completedSegments = boundary.completedSegments;\n                            if (completedSegments.length === 1) {\n                                // This is the first time since we last flushed that we completed anything.\n                                // We can schedule this boundary to emit its partially completed segments early\n                                // in case the parent has already been flushed.\n                                if (boundary.parentFlushed) {\n                                    request.partialBoundaries.push(boundary);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            request.allPendingTasks--;\n            if (request.allPendingTasks === 0) {\n                // This needs to be called at the very end so that we can synchronously write the result\n                // in the callback if needed.\n                var onAllReady = request.onAllReady;\n                onAllReady();\n            }\n        }\n        function retryTask(request, task) {\n            var segment = task.blockedSegment;\n            if (segment.status !== PENDING) {\n                // We completed this by other means before we had a chance to retry it.\n                return;\n            } // We restore the context to what it was when we suspended.\n            // We don't restore it after we leave because it's likely that we'll end up\n            // needing a very similar context soon again.\n            switchContext(task.context);\n            var prevTaskInDEV = null;\n            {\n                prevTaskInDEV = currentTaskInDEV;\n                currentTaskInDEV = task;\n            }\n            try {\n                // We call the destructive form that mutates this task. That way if something\n                // suspends again, we can reuse the same task instead of spawning a new one.\n                renderNodeDestructive(request, task, task.node);\n                pushSegmentFinale(segment.chunks, request.responseState, segment.lastPushedText, segment.textEmbedded);\n                task.abortSet.delete(task);\n                segment.status = COMPLETED;\n                finishedTask(request, task.blockedBoundary, segment);\n            } catch (x) {\n                resetHooksState();\n                if (typeof x === \"object\" && x !== null && typeof x.then === \"function\") {\n                    // Something suspended again, let's pick it back up later.\n                    var ping = task.ping;\n                    x.then(ping, ping);\n                } else {\n                    task.abortSet.delete(task);\n                    segment.status = ERRORED;\n                    erroredTask(request, task.blockedBoundary, segment, x);\n                }\n            } finally{\n                {\n                    currentTaskInDEV = prevTaskInDEV;\n                }\n            }\n        }\n        function performWork(request) {\n            if (request.status === CLOSED) {\n                return;\n            }\n            var prevContext = getActiveContext();\n            var prevDispatcher = ReactCurrentDispatcher$1.current;\n            ReactCurrentDispatcher$1.current = Dispatcher;\n            var prevGetCurrentStackImpl;\n            {\n                prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;\n                ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;\n            }\n            var prevResponseState = currentResponseState;\n            setCurrentResponseState(request.responseState);\n            try {\n                var pingedTasks = request.pingedTasks;\n                var i;\n                for(i = 0; i < pingedTasks.length; i++){\n                    var task = pingedTasks[i];\n                    retryTask(request, task);\n                }\n                pingedTasks.splice(0, i);\n                if (request.destination !== null) {\n                    flushCompletedQueues(request, request.destination);\n                }\n            } catch (error) {\n                logRecoverableError(request, error);\n                fatalError(request, error);\n            } finally{\n                setCurrentResponseState(prevResponseState);\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n                {\n                    ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;\n                }\n                if (prevDispatcher === Dispatcher) {\n                    // This means that we were in a reentrant work loop. This could happen\n                    // in a renderer that supports synchronous work like renderToString,\n                    // when it's called from within another renderer.\n                    // Normally we don't bother switching the contexts to their root/default\n                    // values when leaving because we'll likely need the same or similar\n                    // context again. However, when we're inside a synchronous loop like this\n                    // we'll to restore the context to what it was before returning.\n                    switchContext(prevContext);\n                }\n            }\n        }\n        function flushSubtree(request, destination, segment) {\n            segment.parentFlushed = true;\n            switch(segment.status){\n                case PENDING:\n                    {\n                        // We're emitting a placeholder for this segment to be filled in later.\n                        // Therefore we'll need to assign it an ID - to refer to it by.\n                        var segmentID = segment.id = request.nextSegmentId++; // When this segment finally completes it won't be embedded in text since it will flush separately\n                        segment.lastPushedText = false;\n                        segment.textEmbedded = false;\n                        return writePlaceholder(destination, request.responseState, segmentID);\n                    }\n                case COMPLETED:\n                    {\n                        segment.status = FLUSHED;\n                        var r = true;\n                        var chunks = segment.chunks;\n                        var chunkIdx = 0;\n                        var children = segment.children;\n                        for(var childIdx = 0; childIdx < children.length; childIdx++){\n                            var nextChild = children[childIdx]; // Write all the chunks up until the next child.\n                            for(; chunkIdx < nextChild.index; chunkIdx++){\n                                writeChunk(destination, chunks[chunkIdx]);\n                            }\n                            r = flushSegment(request, destination, nextChild);\n                        } // Finally just write all the remaining chunks\n                        for(; chunkIdx < chunks.length - 1; chunkIdx++){\n                            writeChunk(destination, chunks[chunkIdx]);\n                        }\n                        if (chunkIdx < chunks.length) {\n                            r = writeChunkAndReturn(destination, chunks[chunkIdx]);\n                        }\n                        return r;\n                    }\n                default:\n                    {\n                        throw new Error(\"Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.\");\n                    }\n            }\n        }\n        function flushSegment(request, destination, segment) {\n            var boundary = segment.boundary;\n            if (boundary === null) {\n                // Not a suspense boundary.\n                return flushSubtree(request, destination, segment);\n            }\n            boundary.parentFlushed = true; // This segment is a Suspense boundary. We need to decide whether to\n            // emit the content or the fallback now.\n            if (boundary.forceClientRender) {\n                // Emit a client rendered suspense boundary wrapper.\n                // We never queue the inner boundary so we'll never emit its content or partial segments.\n                writeStartClientRenderedSuspenseBoundary(destination, request.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack); // Flush the fallback.\n                flushSubtree(request, destination, segment);\n                return writeEndClientRenderedSuspenseBoundary(destination, request.responseState);\n            } else if (boundary.pendingTasks > 0) {\n                // This boundary is still loading. Emit a pending suspense boundary wrapper.\n                // Assign an ID to refer to the future content by.\n                boundary.rootSegmentID = request.nextSegmentId++;\n                if (boundary.completedSegments.length > 0) {\n                    // If this is at least partially complete, we can queue it to be partially emitted early.\n                    request.partialBoundaries.push(boundary);\n                } /// This is the first time we should have referenced this ID.\n                var id = boundary.id = assignSuspenseBoundaryID(request.responseState);\n                writeStartPendingSuspenseBoundary(destination, request.responseState, id); // Flush the fallback.\n                flushSubtree(request, destination, segment);\n                return writeEndPendingSuspenseBoundary(destination, request.responseState);\n            } else if (boundary.byteSize > request.progressiveChunkSize) {\n                // This boundary is large and will be emitted separately so that we can progressively show\n                // other content. We add it to the queue during the flush because we have to ensure that\n                // the parent flushes first so that there's something to inject it into.\n                // We also have to make sure that it's emitted into the queue in a deterministic slot.\n                // I.e. we can't insert it here when it completes.\n                // Assign an ID to refer to the future content by.\n                boundary.rootSegmentID = request.nextSegmentId++;\n                request.completedBoundaries.push(boundary); // Emit a pending rendered suspense boundary wrapper.\n                writeStartPendingSuspenseBoundary(destination, request.responseState, boundary.id); // Flush the fallback.\n                flushSubtree(request, destination, segment);\n                return writeEndPendingSuspenseBoundary(destination, request.responseState);\n            } else {\n                // We can inline this boundary's content as a complete boundary.\n                writeStartCompletedSuspenseBoundary(destination, request.responseState);\n                var completedSegments = boundary.completedSegments;\n                if (completedSegments.length !== 1) {\n                    throw new Error(\"A previously unvisited boundary must have exactly one root segment. This is a bug in React.\");\n                }\n                var contentSegment = completedSegments[0];\n                flushSegment(request, destination, contentSegment);\n                return writeEndCompletedSuspenseBoundary(destination, request.responseState);\n            }\n        }\n        function flushClientRenderedBoundary(request, destination, boundary) {\n            return writeClientRenderBoundaryInstruction(destination, request.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);\n        }\n        function flushSegmentContainer(request, destination, segment) {\n            writeStartSegment(destination, request.responseState, segment.formatContext, segment.id);\n            flushSegment(request, destination, segment);\n            return writeEndSegment(destination, segment.formatContext);\n        }\n        function flushCompletedBoundary(request, destination, boundary) {\n            var completedSegments = boundary.completedSegments;\n            var i = 0;\n            for(; i < completedSegments.length; i++){\n                var segment = completedSegments[i];\n                flushPartiallyCompletedSegment(request, destination, boundary, segment);\n            }\n            completedSegments.length = 0;\n            return writeCompletedBoundaryInstruction(destination, request.responseState, boundary.id, boundary.rootSegmentID);\n        }\n        function flushPartialBoundary(request, destination, boundary) {\n            var completedSegments = boundary.completedSegments;\n            var i = 0;\n            for(; i < completedSegments.length; i++){\n                var segment = completedSegments[i];\n                if (!flushPartiallyCompletedSegment(request, destination, boundary, segment)) {\n                    i++;\n                    completedSegments.splice(0, i); // Only write as much as the buffer wants. Something higher priority\n                    // might want to write later.\n                    return false;\n                }\n            }\n            completedSegments.splice(0, i);\n            return true;\n        }\n        function flushPartiallyCompletedSegment(request, destination, boundary, segment) {\n            if (segment.status === FLUSHED) {\n                // We've already flushed this inline.\n                return true;\n            }\n            var segmentID = segment.id;\n            if (segmentID === -1) {\n                // This segment wasn't previously referred to. This happens at the root of\n                // a boundary. We make kind of a leap here and assume this is the root.\n                var rootSegmentID = segment.id = boundary.rootSegmentID;\n                if (rootSegmentID === -1) {\n                    throw new Error(\"A root segment ID must have been assigned by now. This is a bug in React.\");\n                }\n                return flushSegmentContainer(request, destination, segment);\n            } else {\n                flushSegmentContainer(request, destination, segment);\n                return writeCompletedSegmentInstruction(destination, request.responseState, segmentID);\n            }\n        }\n        function flushCompletedQueues(request, destination) {\n            beginWriting();\n            try {\n                // The structure of this is to go through each queue one by one and write\n                // until the sink tells us to stop. When we should stop, we still finish writing\n                // that item fully and then yield. At that point we remove the already completed\n                // items up until the point we completed them.\n                // TODO: Emit preloading.\n                // TODO: It's kind of unfortunate to keep checking this array after we've already\n                // emitted the root.\n                var completedRootSegment = request.completedRootSegment;\n                if (completedRootSegment !== null && request.pendingRootTasks === 0) {\n                    flushSegment(request, destination, completedRootSegment);\n                    request.completedRootSegment = null;\n                    writeCompletedRoot(destination, request.responseState);\n                } // We emit client rendering instructions for already emitted boundaries first.\n                // This is so that we can signal to the client to start client rendering them as\n                // soon as possible.\n                var clientRenderedBoundaries = request.clientRenderedBoundaries;\n                var i;\n                for(i = 0; i < clientRenderedBoundaries.length; i++){\n                    var boundary = clientRenderedBoundaries[i];\n                    if (!flushClientRenderedBoundary(request, destination, boundary)) {\n                        request.destination = null;\n                        i++;\n                        clientRenderedBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                clientRenderedBoundaries.splice(0, i); // Next we emit any complete boundaries. It's better to favor boundaries\n                // that are completely done since we can actually show them, than it is to emit\n                // any individual segments from a partially complete boundary.\n                var completedBoundaries = request.completedBoundaries;\n                for(i = 0; i < completedBoundaries.length; i++){\n                    var _boundary = completedBoundaries[i];\n                    if (!flushCompletedBoundary(request, destination, _boundary)) {\n                        request.destination = null;\n                        i++;\n                        completedBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                completedBoundaries.splice(0, i); // Allow anything written so far to flush to the underlying sink before\n                // we continue with lower priorities.\n                completeWriting(destination);\n                beginWriting(destination); // TODO: Here we'll emit data used by hydration.\n                // Next we emit any segments of any boundaries that are partially complete\n                // but not deeply complete.\n                var partialBoundaries = request.partialBoundaries;\n                for(i = 0; i < partialBoundaries.length; i++){\n                    var _boundary2 = partialBoundaries[i];\n                    if (!flushPartialBoundary(request, destination, _boundary2)) {\n                        request.destination = null;\n                        i++;\n                        partialBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                partialBoundaries.splice(0, i); // Next we check the completed boundaries again. This may have had\n                // boundaries added to it in case they were too larged to be inlined.\n                // New ones might be added in this loop.\n                var largeBoundaries = request.completedBoundaries;\n                for(i = 0; i < largeBoundaries.length; i++){\n                    var _boundary3 = largeBoundaries[i];\n                    if (!flushCompletedBoundary(request, destination, _boundary3)) {\n                        request.destination = null;\n                        i++;\n                        largeBoundaries.splice(0, i);\n                        return;\n                    }\n                }\n                largeBoundaries.splice(0, i);\n            } finally{\n                completeWriting(destination);\n                flushBuffered(destination);\n                if (request.allPendingTasks === 0 && request.pingedTasks.length === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0 // We don't need to check any partially completed segments because\n                ) {\n                    {\n                        if (request.abortableTasks.size !== 0) {\n                            error(\"There was still abortable task at the root when we closed. This is a bug in React.\");\n                        }\n                    }\n                    close(destination);\n                }\n            }\n        }\n        function startWork(request) {\n            scheduleWork(function() {\n                return performWork(request);\n            });\n        }\n        function startFlowing(request, destination) {\n            if (request.status === CLOSING) {\n                request.status = CLOSED;\n                closeWithError(destination, request.fatalError);\n                return;\n            }\n            if (request.status === CLOSED) {\n                return;\n            }\n            if (request.destination !== null) {\n                // We're already flowing.\n                return;\n            }\n            request.destination = destination;\n            try {\n                flushCompletedQueues(request, destination);\n            } catch (error) {\n                logRecoverableError(request, error);\n                fatalError(request, error);\n            }\n        } // This is called to early terminate a request. It puts all pending boundaries in client rendered state.\n        function abort(request, reason) {\n            try {\n                var abortableTasks = request.abortableTasks;\n                abortableTasks.forEach(function(task) {\n                    return abortTask(task, request, reason);\n                });\n                abortableTasks.clear();\n                if (request.destination !== null) {\n                    flushCompletedQueues(request, request.destination);\n                }\n            } catch (error) {\n                logRecoverableError(request, error);\n                fatalError(request, error);\n            }\n        }\n        function createDrainHandler(destination, request) {\n            return function() {\n                return startFlowing(request, destination);\n            };\n        }\n        function createAbortHandler(request, reason) {\n            return function() {\n                return abort(request, reason);\n            };\n        }\n        function createRequestImpl(children, options) {\n            return createRequest(children, createResponseState(options ? options.identifierPrefix : undefined, options ? options.nonce : undefined, options ? options.bootstrapScriptContent : undefined, options ? options.bootstrapScripts : undefined, options ? options.bootstrapModules : undefined), createRootFormatContext(options ? options.namespaceURI : undefined), options ? options.progressiveChunkSize : undefined, options ? options.onError : undefined, options ? options.onAllReady : undefined, options ? options.onShellReady : undefined, options ? options.onShellError : undefined, undefined);\n        }\n        function renderToPipeableStream(children, options) {\n            var request = createRequestImpl(children, options);\n            var hasStartedFlowing = false;\n            startWork(request);\n            return {\n                pipe: function(destination) {\n                    if (hasStartedFlowing) {\n                        throw new Error(\"React currently only supports piping to one writable stream.\");\n                    }\n                    hasStartedFlowing = true;\n                    startFlowing(request, destination);\n                    destination.on(\"drain\", createDrainHandler(destination, request));\n                    destination.on(\"error\", createAbortHandler(request, new Error(\"The destination stream errored while writing data.\")));\n                    destination.on(\"close\", createAbortHandler(request, new Error(\"The destination stream closed early.\")));\n                    return destination;\n                },\n                abort: function(reason) {\n                    abort(request, reason);\n                }\n            };\n        }\n        exports.renderToPipeableStream = renderToPipeableStream;\n        exports.version = ReactVersion;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS1zZXJ2ZXIubm9kZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUM7UUFDcEIsSUFBSUMsT0FBT0QsbUJBQU9BLENBQUM7UUFFbkIsSUFBSUUsZUFBZTtRQUVuQixJQUFJQyx1QkFBdUJKLE1BQU1LLGtEQUFrRDtRQUVuRiwrQ0FBK0M7UUFDL0MsRUFBRTtRQUNGLDhEQUE4RDtRQUM5RCxxQ0FBcUM7UUFFckMsU0FBU0MsS0FBS0MsTUFBTTtZQUNsQjtnQkFDRTtvQkFDRSxJQUFLLElBQUlDLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSixPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJSyxPQUFPLEdBQUdBLE9BQU9MLE1BQU1LLE9BQVE7d0JBQzFHRixJQUFJLENBQUNFLE9BQU8sRUFBRSxHQUFHSixTQUFTLENBQUNJLEtBQUs7b0JBQ2xDO29CQUVBQyxhQUFhLFFBQVFQLFFBQVFJO2dCQUMvQjtZQUNGO1FBQ0Y7UUFDQSxTQUFTSSxNQUFNUixNQUFNO1lBQ25CO2dCQUNFO29CQUNFLElBQUssSUFBSVMsUUFBUVAsVUFBVUMsTUFBTSxFQUFFQyxPQUFPLElBQUlDLE1BQU1JLFFBQVEsSUFBSUEsUUFBUSxJQUFJLElBQUlDLFFBQVEsR0FBR0EsUUFBUUQsT0FBT0MsUUFBUzt3QkFDakhOLElBQUksQ0FBQ00sUUFBUSxFQUFFLEdBQUdSLFNBQVMsQ0FBQ1EsTUFBTTtvQkFDcEM7b0JBRUFILGFBQWEsU0FBU1AsUUFBUUk7Z0JBQ2hDO1lBQ0Y7UUFDRjtRQUVBLFNBQVNHLGFBQWFJLEtBQUssRUFBRVgsTUFBTSxFQUFF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LEdBQUd6bUIsV0FBV0E7UUFDbmtCO1FBRUEsU0FBU3F3Qix1QkFBdUI3bkMsUUFBUSxFQUFFNG5DLE9BQU87WUFDL0MsSUFBSXZKLFVBQVVzSixrQkFBa0IzbkMsVUFBVTRuQztZQUMxQyxJQUFJRSxvQkFBb0I7WUFDeEJSLFVBQVVqSjtZQUNWLE9BQU87Z0JBQ0wwSixNQUFNLFNBQVU1MEMsV0FBVztvQkFDekIsSUFBSTIwQyxtQkFBbUI7d0JBQ3JCLE1BQU0sSUFBSW5wQixNQUFNO29CQUNsQjtvQkFFQW1wQixvQkFBb0I7b0JBQ3BCUCxhQUFhbEosU0FBU2xyQztvQkFDdEJBLFlBQVk2MEMsRUFBRSxDQUFDLFNBQVNQLG1CQUFtQnQwQyxhQUFha3JDO29CQUN4RGxyQyxZQUFZNjBDLEVBQUUsQ0FBQyxTQUFTTixtQkFBbUJySixTQUMzQyxJQUFJMWYsTUFBTTtvQkFDVnhyQixZQUFZNjBDLEVBQUUsQ0FBQyxTQUFTTixtQkFBbUJySixTQUMzQyxJQUFJMWYsTUFBTTtvQkFDVixPQUFPeHJCO2dCQUNUO2dCQUNBcTBDLE9BQU8sU0FBVWpDLE1BQU07b0JBQ3JCaUMsTUFBTW5KLFNBQVNrSDtnQkFDakI7WUFDRjtRQUNGO1FBRUEwQyw4QkFBOEIsR0FBR0o7UUFDakNJLGVBQWUsR0FBR2gzQztJQUNoQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGlyZXIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS1zZXJ2ZXIubm9kZS5kZXZlbG9wbWVudC5qcz9lODdiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWRvbS1zZXJ2ZXIubm9kZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIFJlYWN0VmVyc2lvbiA9ICcxOC4yLjAnO1xuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuLy8gYnkgY2FsbHMgdG8gdGhlc2UgbWV0aG9kcyBieSBhIEJhYmVsIHBsdWdpbi5cbi8vXG4vLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuLy8gdGhleSBhcmUgbGVmdCBhcyB0aGV5IGFyZSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiB3YXJuKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCd3YXJuJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVXb3JrKGNhbGxiYWNrKSB7XG4gIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBmbHVzaEJ1ZmZlcmVkKGRlc3RpbmF0aW9uKSB7XG4gIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZGF0YSB0byBzZW5kIHJpZ2h0IG5vdy5cbiAgLy8gRmx1c2ggd2hhdGV2ZXIgaXMgaW4gdGhlIGJ1ZmZlciB0byB0aGUgd2lyZS5cbiAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbi5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEJ5IGNvbnZlbnRpb24gdGhlIFpsaWIgc3RyZWFtcyBwcm92aWRlIGEgZmx1c2ggZnVuY3Rpb24gZm9yIHRoaXMgcHVycG9zZS5cbiAgICAvLyBGb3IgRXhwcmVzcywgY29tcHJlc3Npb24gbWlkZGxld2FyZSBhZGRzIHRoaXMgbWV0aG9kLlxuICAgIGRlc3RpbmF0aW9uLmZsdXNoKCk7XG4gIH1cbn1cbnZhciBWSUVXX1NJWkUgPSAyMDQ4O1xudmFyIGN1cnJlbnRWaWV3ID0gbnVsbDtcbnZhciB3cml0dGVuQnl0ZXMgPSAwO1xudmFyIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkgPSB0cnVlO1xuZnVuY3Rpb24gYmVnaW5Xcml0aW5nKGRlc3RpbmF0aW9uKSB7XG4gIGN1cnJlbnRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoVklFV19TSVpFKTtcbiAgd3JpdHRlbkJ5dGVzID0gMDtcbiAgZGVzdGluYXRpb25IYXNDYXBhY2l0eSA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHdyaXRlU3RyaW5nQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ0NodW5rKSB7XG4gIGlmIChzdHJpbmdDaHVuay5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH0gLy8gbWF4aW11bSBwb3NzaWJsZSB2aWV3IG5lZWRlZCB0byBlbmNvZGUgZW50aXJlIHN0cmluZ1xuXG5cbiAgaWYgKHN0cmluZ0NodW5rLmxlbmd0aCAqIDMgPiBWSUVXX1NJWkUpIHtcbiAgICBpZiAod3JpdHRlbkJ5dGVzID4gMCkge1xuICAgICAgd3JpdGVUb0Rlc3RpbmF0aW9uKGRlc3RpbmF0aW9uLCBjdXJyZW50Vmlldy5zdWJhcnJheSgwLCB3cml0dGVuQnl0ZXMpKTtcbiAgICAgIGN1cnJlbnRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoVklFV19TSVpFKTtcbiAgICAgIHdyaXR0ZW5CeXRlcyA9IDA7XG4gICAgfVxuXG4gICAgd3JpdGVUb0Rlc3RpbmF0aW9uKGRlc3RpbmF0aW9uLCB0ZXh0RW5jb2Rlci5lbmNvZGUoc3RyaW5nQ2h1bmspKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdGFyZ2V0ID0gY3VycmVudFZpZXc7XG5cbiAgaWYgKHdyaXR0ZW5CeXRlcyA+IDApIHtcbiAgICB0YXJnZXQgPSBjdXJyZW50Vmlldy5zdWJhcnJheSh3cml0dGVuQnl0ZXMpO1xuICB9XG5cbiAgdmFyIF90ZXh0RW5jb2RlciRlbmNvZGVJbiA9IHRleHRFbmNvZGVyLmVuY29kZUludG8oc3RyaW5nQ2h1bmssIHRhcmdldCksXG4gICAgICByZWFkID0gX3RleHRFbmNvZGVyJGVuY29kZUluLnJlYWQsXG4gICAgICB3cml0dGVuID0gX3RleHRFbmNvZGVyJGVuY29kZUluLndyaXR0ZW47XG5cbiAgd3JpdHRlbkJ5dGVzICs9IHdyaXR0ZW47XG5cbiAgaWYgKHJlYWQgPCBzdHJpbmdDaHVuay5sZW5ndGgpIHtcbiAgICB3cml0ZVRvRGVzdGluYXRpb24oZGVzdGluYXRpb24sIGN1cnJlbnRWaWV3KTtcbiAgICBjdXJyZW50VmlldyA9IG5ldyBVaW50OEFycmF5KFZJRVdfU0laRSk7XG4gICAgd3JpdHRlbkJ5dGVzID0gdGV4dEVuY29kZXIuZW5jb2RlSW50byhzdHJpbmdDaHVuay5zbGljZShyZWFkKSwgY3VycmVudFZpZXcpLndyaXR0ZW47XG4gIH1cblxuICBpZiAod3JpdHRlbkJ5dGVzID09PSBWSUVXX1NJWkUpIHtcbiAgICB3cml0ZVRvRGVzdGluYXRpb24oZGVzdGluYXRpb24sIGN1cnJlbnRWaWV3KTtcbiAgICBjdXJyZW50VmlldyA9IG5ldyBVaW50OEFycmF5KFZJRVdfU0laRSk7XG4gICAgd3JpdHRlbkJ5dGVzID0gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiB3cml0ZVZpZXdDaHVuayhkZXN0aW5hdGlvbiwgY2h1bmspIHtcbiAgaWYgKGNodW5rLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY2h1bmsuYnl0ZUxlbmd0aCA+IFZJRVdfU0laRSkge1xuICAgIC8vIHRoaXMgY2h1bmsgbWF5IG92ZXJmbG93IGEgc2luZ2xlIHZpZXcgd2hpY2ggaW1wbGllcyBpdCB3YXMgbm90XG4gICAgLy8gb25lIHRoYXQgaXMgY2FjaGVkIGJ5IHRoZSBzdHJlYW1pbmcgcmVuZGVyZXIuIFdlIHdpbGwgZW5xdWV1XG4gICAgLy8gaXQgZGlyZWN0bHkgYW5kIGV4cGVjdCBpdCBpcyBub3QgcmUtdXNlZFxuICAgIGlmICh3cml0dGVuQnl0ZXMgPiAwKSB7XG4gICAgICB3cml0ZVRvRGVzdGluYXRpb24oZGVzdGluYXRpb24sIGN1cnJlbnRWaWV3LnN1YmFycmF5KDAsIHdyaXR0ZW5CeXRlcykpO1xuICAgICAgY3VycmVudFZpZXcgPSBuZXcgVWludDhBcnJheShWSUVXX1NJWkUpO1xuICAgICAgd3JpdHRlbkJ5dGVzID0gMDtcbiAgICB9XG5cbiAgICB3cml0ZVRvRGVzdGluYXRpb24oZGVzdGluYXRpb24sIGNodW5rKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYnl0ZXNUb1dyaXRlID0gY2h1bms7XG4gIHZhciBhbGxvd2FibGVCeXRlcyA9IGN1cnJlbnRWaWV3Lmxlbmd0aCAtIHdyaXR0ZW5CeXRlcztcblxuICBpZiAoYWxsb3dhYmxlQnl0ZXMgPCBieXRlc1RvV3JpdGUuYnl0ZUxlbmd0aCkge1xuICAgIC8vIHRoaXMgY2h1bmsgd291bGQgb3ZlcmZsb3cgdGhlIGN1cnJlbnQgdmlldy4gV2UgZW5xdWV1ZSBhIGZ1bGwgdmlld1xuICAgIC8vIGFuZCBzdGFydCBhIG5ldyB2aWV3IHdpdGggdGhlIHJlbWFpbmluZyBjaHVua1xuICAgIGlmIChhbGxvd2FibGVCeXRlcyA9PT0gMCkge1xuICAgICAgLy8gdGhlIGN1cnJlbnQgdmlldyBpcyBhbHJlYWR5IGZ1bGwsIHNlbmQgaXRcbiAgICAgIHdyaXRlVG9EZXN0aW5hdGlvbihkZXN0aW5hdGlvbiwgY3VycmVudFZpZXcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmaWxsIHVwIHRoZSBjdXJyZW50IHZpZXcgYW5kIGFwcGx5IHRoZSByZW1haW5pbmcgY2h1bmsgYnl0ZXNcbiAgICAgIC8vIHRvIGEgbmV3IHZpZXcuXG4gICAgICBjdXJyZW50Vmlldy5zZXQoYnl0ZXNUb1dyaXRlLnN1YmFycmF5KDAsIGFsbG93YWJsZUJ5dGVzKSwgd3JpdHRlbkJ5dGVzKTtcbiAgICAgIHdyaXR0ZW5CeXRlcyArPSBhbGxvd2FibGVCeXRlcztcbiAgICAgIHdyaXRlVG9EZXN0aW5hdGlvbihkZXN0aW5hdGlvbiwgY3VycmVudFZpZXcpO1xuICAgICAgYnl0ZXNUb1dyaXRlID0gYnl0ZXNUb1dyaXRlLnN1YmFycmF5KGFsbG93YWJsZUJ5dGVzKTtcbiAgICB9XG5cbiAgICBjdXJyZW50VmlldyA9IG5ldyBVaW50OEFycmF5KFZJRVdfU0laRSk7XG4gICAgd3JpdHRlbkJ5dGVzID0gMDtcbiAgfVxuXG4gIGN1cnJlbnRWaWV3LnNldChieXRlc1RvV3JpdGUsIHdyaXR0ZW5CeXRlcyk7XG4gIHdyaXR0ZW5CeXRlcyArPSBieXRlc1RvV3JpdGUuYnl0ZUxlbmd0aDtcblxuICBpZiAod3JpdHRlbkJ5dGVzID09PSBWSUVXX1NJWkUpIHtcbiAgICB3cml0ZVRvRGVzdGluYXRpb24oZGVzdGluYXRpb24sIGN1cnJlbnRWaWV3KTtcbiAgICBjdXJyZW50VmlldyA9IG5ldyBVaW50OEFycmF5KFZJRVdfU0laRSk7XG4gICAgd3JpdHRlbkJ5dGVzID0gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjaHVuaykge1xuICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIHdyaXRlU3RyaW5nQ2h1bmsoZGVzdGluYXRpb24sIGNodW5rKTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZVZpZXdDaHVuayhkZXN0aW5hdGlvbiwgY2h1bmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlVG9EZXN0aW5hdGlvbihkZXN0aW5hdGlvbiwgdmlldykge1xuICB2YXIgY3VycmVudEhhc0NhcGFjaXR5ID0gZGVzdGluYXRpb24ud3JpdGUodmlldyk7XG4gIGRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkgPSBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5ICYmIGN1cnJlbnRIYXNDYXBhY2l0eTtcbn1cblxuZnVuY3Rpb24gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY2h1bmspIHtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2h1bmspO1xuICByZXR1cm4gZGVzdGluYXRpb25IYXNDYXBhY2l0eTtcbn1cbmZ1bmN0aW9uIGNvbXBsZXRlV3JpdGluZyhkZXN0aW5hdGlvbikge1xuICBpZiAoY3VycmVudFZpZXcgJiYgd3JpdHRlbkJ5dGVzID4gMCkge1xuICAgIGRlc3RpbmF0aW9uLndyaXRlKGN1cnJlbnRWaWV3LnN1YmFycmF5KDAsIHdyaXR0ZW5CeXRlcykpO1xuICB9XG5cbiAgY3VycmVudFZpZXcgPSBudWxsO1xuICB3cml0dGVuQnl0ZXMgPSAwO1xuICBkZXN0aW5hdGlvbkhhc0NhcGFjaXR5ID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNsb3NlKGRlc3RpbmF0aW9uKSB7XG4gIGRlc3RpbmF0aW9uLmVuZCgpO1xufVxudmFyIHRleHRFbmNvZGVyID0gbmV3IHV0aWwuVGV4dEVuY29kZXIoKTtcbmZ1bmN0aW9uIHN0cmluZ1RvQ2h1bmsoY29udGVudCkge1xuICByZXR1cm4gY29udGVudDtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhjb250ZW50KSB7XG4gIHJldHVybiB0ZXh0RW5jb2Rlci5lbmNvZGUoY29udGVudCk7XG59XG5mdW5jdGlvbiBjbG9zZVdpdGhFcnJvcihkZXN0aW5hdGlvbiwgZXJyb3IpIHtcbiAgLy8gJEZsb3dGaXhNZTogVGhpcyBpcyBhbiBFcnJvciBvYmplY3Qgb3IgdGhlIGRlc3RpbmF0aW9uIGFjY2VwdHMgb3RoZXIgdHlwZXMuXG4gIGRlc3RpbmF0aW9uLmRlc3Ryb3koZXJyb3IpO1xufVxuXG4vKlxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAqL1xuLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gIHtcbiAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XG4gICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGAlc2AgYXR0cmlidXRlIGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIGF0dHJpYnV0ZU5hbWUsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tDU1NQcm9wZXJ0eVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBwcm9wTmFtZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBgJXNgIENTUyBwcm9wZXJ0eSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCBwcm9wTmFtZSwgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBIVE1MIG1hcmt1cCB1c2VzIGEgdmFsdWUgb2YgdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8vIEEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuLy8gSXQgaXMgaGFuZGxlZCBieSBSZWFjdCBzZXBhcmF0ZWx5IGFuZCBzaG91bGRuJ3QgYmUgd3JpdHRlbiB0byB0aGUgRE9NLlxudmFyIFJFU0VSVkVEID0gMDsgLy8gQSBzaW1wbGUgc3RyaW5nIGF0dHJpYnV0ZS5cbi8vIEF0dHJpYnV0ZXMgdGhhdCBhcmVuJ3QgaW4gdGhlIGZpbHRlciBhcmUgcHJlc3VtZWQgdG8gaGF2ZSB0aGlzIHR5cGUuXG5cbnZhciBTVFJJTkcgPSAxOyAvLyBBIHN0cmluZyBhdHRyaWJ1dGUgdGhhdCBhY2NlcHRzIGJvb2xlYW5zIGluIFJlYWN0LiBJbiBIVE1MLCB0aGVzZSBhcmUgY2FsbGVkXG4vLyBcImVudW1lcmF0ZWRcIiBhdHRyaWJ1dGVzIHdpdGggXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIiBhcyBwb3NzaWJsZSB2YWx1ZXMuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBzZXQgdG8gYSBcInRydWVcIiBzdHJpbmcuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgc2V0IHRvIGEgXCJmYWxzZVwiIHN0cmluZy5cblxudmFyIEJPT0xFQU5JU0hfU1RSSU5HID0gMjsgLy8gQSByZWFsIGJvb2xlYW4gYXR0cmlidXRlLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgcHJlc2VudCAoc2V0IGVpdGhlciB0byBhbiBlbXB0eSBzdHJpbmcgb3IgaXRzIG5hbWUpLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIG9taXR0ZWQuXG5cbnZhciBCT09MRUFOID0gMzsgLy8gQW4gYXR0cmlidXRlIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgcHJlc2VudCAoc2V0IGVpdGhlciB0byBhbiBlbXB0eSBzdHJpbmcgb3IgaXRzIG5hbWUpLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIG9taXR0ZWQuXG4vLyBGb3IgYW55IG90aGVyIHZhbHVlLCBzaG91bGQgYmUgcHJlc2VudCB3aXRoIHRoYXQgdmFsdWUuXG5cbnZhciBPVkVSTE9BREVEX0JPT0xFQU4gPSA0OyAvLyBBbiBhdHRyaWJ1dGUgdGhhdCBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljLlxuLy8gV2hlbiBmYWxzeSwgaXQgc2hvdWxkIGJlIHJlbW92ZWQuXG5cbnZhciBOVU1FUklDID0gNTsgLy8gQW4gYXR0cmlidXRlIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgcG9zaXRpdmUgbnVtZXJpYy5cbi8vIFdoZW4gZmFsc3ksIGl0IHNob3VsZCBiZSByZW1vdmVkLlxuXG52YXIgUE9TSVRJVkVfTlVNRVJJQyA9IDY7XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbnZhciBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSID0gXCI6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXCI7XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxudmFyIEFUVFJJQlVURV9OQU1FX0NIQVIgPSBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgXCJcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MFwiO1xudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICddWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbnZhciB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzQXR0cmlidXRlTmFtZVNhZmUoYXR0cmlidXRlTmFtZSkge1xuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuXG4gIHtcbiAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogYCVzYCcsIGF0dHJpYnV0ZU5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCAmJiBwcm9wZXJ0eUluZm8udHlwZSA9PT0gUkVTRVJWRUQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzogLy8gJEZsb3dJc3N1ZSBzeW1ib2wgaXMgcGVyZmVjdGx5IHZhbGlkIGhlcmVcblxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAge1xuICAgICAgICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICFwcm9wZXJ0eUluZm8uYWNjZXB0c0Jvb2xlYW5zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeCAhPT0gJ2RhdGEtJyAmJiBwcmVmaXggIT09ICdhcmlhLSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFByb3BlcnR5SW5mbyhuYW1lKSB7XG4gIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gcHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCB0eXBlLCBtdXN0VXNlUHJvcGVydHksIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZU5hbWVzcGFjZSwgc2FuaXRpemVVUkwsIHJlbW92ZUVtcHR5U3RyaW5nKSB7XG4gIHRoaXMuYWNjZXB0c0Jvb2xlYW5zID0gdHlwZSA9PT0gQk9PTEVBTklTSF9TVFJJTkcgfHwgdHlwZSA9PT0gQk9PTEVBTiB8fCB0eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU47XG4gIHRoaXMuYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gIHRoaXMuYXR0cmlidXRlTmFtZXNwYWNlID0gYXR0cmlidXRlTmFtZXNwYWNlO1xuICB0aGlzLm11c3RVc2VQcm9wZXJ0eSA9IG11c3RVc2VQcm9wZXJ0eTtcbiAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBuYW1lO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnNhbml0aXplVVJMID0gc2FuaXRpemVVUkw7XG4gIHRoaXMucmVtb3ZlRW1wdHlTdHJpbmcgPSByZW1vdmVFbXB0eVN0cmluZztcbn0gLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGlzIGxpc3QsIGJlIHN1cmUgdG8gYWxzbyBhZGQgdGhlbSB0b1xuLy8gdGhlIGBwb3NzaWJsZVN0YW5kYXJkTmFtZXNgIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3Rcbi8vIG5hbWUgd2FybmluZ3MuXG5cblxudmFyIHByb3BlcnRpZXMgPSB7fTsgLy8gVGhlc2UgcHJvcHMgYXJlIHJlc2VydmVkIGJ5IFJlYWN0LiBUaGV5IHNob3VsZG4ndCBiZSB3cml0dGVuIHRvIHRoZSBET00uXG5cbnZhciByZXNlcnZlZFByb3BzID0gWydjaGlsZHJlbicsICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsIC8vIFRPRE86IFRoaXMgcHJldmVudHMgdGhlIGFzc2lnbm1lbnQgb2YgZGVmYXVsdFZhbHVlIHRvIHJlZ3VsYXJcbi8vIGVsZW1lbnRzIChub3QganVzdCBpbnB1dHMpLiBOb3cgdGhhdCBSZWFjdERPTUlucHV0IGFzc2lnbnMgdG8gdGhlXG4vLyBkZWZhdWx0VmFsdWUgcHJvcGVydHkgLS0gZG8gd2UgbmVlZCB0aGlzP1xuJ2RlZmF1bHRWYWx1ZScsICdkZWZhdWx0Q2hlY2tlZCcsICdpbm5lckhUTUwnLCAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJywgJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsICdzdHlsZSddO1xuXG5yZXNlcnZlZFByb3BzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgUkVTRVJWRUQsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBBIGZldyBSZWFjdCBzdHJpbmcgYXR0cmlidXRlcyBoYXZlIGEgZGlmZmVyZW50IG5hbWUuXG4vLyBUaGlzIGlzIGEgbWFwcGluZyBmcm9tIFJlYWN0IHByb3AgbmFtZXMgdG8gdGhlIGF0dHJpYnV0ZSBuYW1lcy5cblxuW1snYWNjZXB0Q2hhcnNldCcsICdhY2NlcHQtY2hhcnNldCddLCBbJ2NsYXNzTmFtZScsICdjbGFzcyddLCBbJ2h0bWxGb3InLCAnZm9yJ10sIFsnaHR0cEVxdWl2JywgJ2h0dHAtZXF1aXYnXV0uZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgbmFtZSA9IF9yZWZbMF0sXG4gICAgICBhdHRyaWJ1dGVOYW1lID0gX3JlZlsxXTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIFwiZW51bWVyYXRlZFwiIEhUTUwgYXR0cmlidXRlcyB0aGF0IGFjY2VwdCBcInRydWVcIiBhbmQgXCJmYWxzZVwiLlxuLy8gSW4gUmVhY3QsIHdlIGxldCB1c2VycyBwYXNzIGB0cnVlYCBhbmQgYGZhbHNlYCBldmVuIHRob3VnaCB0ZWNobmljYWxseVxuLy8gdGhlc2UgYXJlbid0IGJvb2xlYW4gYXR0cmlidXRlcyAodGhleSBhcmUgY29lcmNlZCB0byBzdHJpbmdzKS5cblxuWydjb250ZW50RWRpdGFibGUnLCAnZHJhZ2dhYmxlJywgJ3NwZWxsQ2hlY2snLCAndmFsdWUnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU5JU0hfU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgXCJlbnVtZXJhdGVkXCIgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBhY2NlcHQgXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIi5cbi8vIEluIFJlYWN0LCB3ZSBsZXQgdXNlcnMgcGFzcyBgdHJ1ZWAgYW5kIGBmYWxzZWAgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHlcbi8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG4vLyBTaW5jZSB0aGVzZSBhcmUgU1ZHIGF0dHJpYnV0ZXMsIHRoZWlyIGF0dHJpYnV0ZSBuYW1lcyBhcmUgY2FzZS1zZW5zaXRpdmUuXG5cblsnYXV0b1JldmVyc2UnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdmb2N1c2FibGUnLCAncHJlc2VydmVBbHBoYSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTklTSF9TVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgSFRNTCBib29sZWFuIGF0dHJpYnV0ZXMuXG5cblsnYWxsb3dGdWxsU2NyZWVuJywgJ2FzeW5jJywgLy8gTm90ZTogdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBwcmV2ZW50cyBpdCBmcm9tIGJlaW5nIHdyaXR0ZW4gdG8gdGhlIERPTVxuLy8gb24gdGhlIGNsaWVudCBzaWRlIGJlY2F1c2UgdGhlIGJyb3dzZXJzIGFyZSBpbmNvbnNpc3RlbnQuIEluc3RlYWQgd2UgY2FsbCBmb2N1cygpLlxuJ2F1dG9Gb2N1cycsICdhdXRvUGxheScsICdjb250cm9scycsICdkZWZhdWx0JywgJ2RlZmVyJywgJ2Rpc2FibGVkJywgJ2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJywgJ2Rpc2FibGVSZW1vdGVQbGF5YmFjaycsICdmb3JtTm9WYWxpZGF0ZScsICdoaWRkZW4nLCAnbG9vcCcsICdub01vZHVsZScsICdub1ZhbGlkYXRlJywgJ29wZW4nLCAncGxheXNJbmxpbmUnLCAncmVhZE9ubHknLCAncmVxdWlyZWQnLCAncmV2ZXJzZWQnLCAnc2NvcGVkJywgJ3NlYW1sZXNzJywgLy8gTWljcm9kYXRhXG4naXRlbVNjb3BlJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgdGhlIGZldyBSZWFjdCBwcm9wcyB0aGF0IHdlIHNldCBhcyBET00gcHJvcGVydGllc1xuLy8gcmF0aGVyIHRoYW4gYXR0cmlidXRlcy4gVGhlc2UgYXJlIGFsbCBib29sZWFucy5cblxuWydjaGVja2VkJywgLy8gTm90ZTogYG9wdGlvbi5zZWxlY3RlZGAgaXMgbm90IHVwZGF0ZWQgaWYgYHNlbGVjdC5tdWx0aXBsZWAgaXNcbi8vIGRpc2FibGVkIHdpdGggYHJlbW92ZUF0dHJpYnV0ZWAuIFdlIGhhdmUgc3BlY2lhbCBsb2dpYyBmb3IgaGFuZGxpbmcgdGhpcy5cbidtdWx0aXBsZScsICdtdXRlZCcsICdzZWxlY3RlZCcgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTiwgdHJ1ZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IGFyZSBcIm92ZXJsb2FkZWQgYm9vbGVhbnNcIjogdGhleSBiZWhhdmUgbGlrZVxuLy8gYm9vbGVhbnMsIGJ1dCBjYW4gYWxzbyBhY2NlcHQgYSBzdHJpbmcgdmFsdWUuXG5cblsnY2FwdHVyZScsICdkb3dubG9hZCcgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgT1ZFUkxPQURFRF9CT09MRUFOLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtYmVycy5cblxuWydjb2xzJywgJ3Jvd3MnLCAnc2l6ZScsICdzcGFuJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBQT1NJVElWRV9OVU1FUklDLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IG11c3QgYmUgbnVtYmVycy5cblxuWydyb3dTcGFuJywgJ3N0YXJ0J10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBOVU1FUklDLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pO1xudmFyIENBTUVMSVpFID0gL1tcXC1cXDpdKFthLXpdKS9nO1xuXG52YXIgY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICByZXR1cm4gdG9rZW5bMV0udG9VcHBlckNhc2UoKTtcbn07IC8vIFRoaXMgaXMgYSBsaXN0IG9mIGFsbCBTVkcgYXR0cmlidXRlcyB0aGF0IG5lZWQgc3BlY2lhbCBjYXNpbmcsIG5hbWVzcGFjaW5nLFxuLy8gb3IgYm9vbGVhbiB2YWx1ZSBhc3NpZ25tZW50LiBSZWd1bGFyIGF0dHJpYnV0ZXMgdGhhdCBqdXN0IGFjY2VwdCBzdHJpbmdzXG4vLyBhbmQgaGF2ZSB0aGUgc2FtZSBuYW1lcyBhcmUgb21pdHRlZCwganVzdCBsaWtlIGluIHRoZSBIVE1MIGF0dHJpYnV0ZSBmaWx0ZXIuXG4vLyBTb21lIG9mIHRoZXNlIGF0dHJpYnV0ZXMgY2FuIGJlIGhhcmQgdG8gZmluZC4gVGhpcyBsaXN0IHdhcyBjcmVhdGVkIGJ5XG4vLyBzY3JhcGluZyB0aGUgTUROIGRvY3VtZW50YXRpb24uXG5cblxuWydhY2NlbnQtaGVpZ2h0JywgJ2FsaWdubWVudC1iYXNlbGluZScsICdhcmFiaWMtZm9ybScsICdiYXNlbGluZS1zaGlmdCcsICdjYXAtaGVpZ2h0JywgJ2NsaXAtcGF0aCcsICdjbGlwLXJ1bGUnLCAnY29sb3ItaW50ZXJwb2xhdGlvbicsICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnY29sb3ItcHJvZmlsZScsICdjb2xvci1yZW5kZXJpbmcnLCAnZG9taW5hbnQtYmFzZWxpbmUnLCAnZW5hYmxlLWJhY2tncm91bmQnLCAnZmlsbC1vcGFjaXR5JywgJ2ZpbGwtcnVsZScsICdmbG9vZC1jb2xvcicsICdmbG9vZC1vcGFjaXR5JywgJ2ZvbnQtZmFtaWx5JywgJ2ZvbnQtc2l6ZScsICdmb250LXNpemUtYWRqdXN0JywgJ2ZvbnQtc3RyZXRjaCcsICdmb250LXN0eWxlJywgJ2ZvbnQtdmFyaWFudCcsICdmb250LXdlaWdodCcsICdnbHlwaC1uYW1lJywgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnLCAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnLCAnaG9yaXotYWR2LXgnLCAnaG9yaXotb3JpZ2luLXgnLCAnaW1hZ2UtcmVuZGVyaW5nJywgJ2xldHRlci1zcGFjaW5nJywgJ2xpZ2h0aW5nLWNvbG9yJywgJ21hcmtlci1lbmQnLCAnbWFya2VyLW1pZCcsICdtYXJrZXItc3RhcnQnLCAnb3ZlcmxpbmUtcG9zaXRpb24nLCAnb3ZlcmxpbmUtdGhpY2tuZXNzJywgJ3BhaW50LW9yZGVyJywgJ3Bhbm9zZS0xJywgJ3BvaW50ZXItZXZlbnRzJywgJ3JlbmRlcmluZy1pbnRlbnQnLCAnc2hhcGUtcmVuZGVyaW5nJywgJ3N0b3AtY29sb3InLCAnc3RvcC1vcGFjaXR5JywgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nLCAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnLCAnc3Ryb2tlLWRhc2hhcnJheScsICdzdHJva2UtZGFzaG9mZnNldCcsICdzdHJva2UtbGluZWNhcCcsICdzdHJva2UtbGluZWpvaW4nLCAnc3Ryb2tlLW1pdGVybGltaXQnLCAnc3Ryb2tlLW9wYWNpdHknLCAnc3Ryb2tlLXdpZHRoJywgJ3RleHQtYW5jaG9yJywgJ3RleHQtZGVjb3JhdGlvbicsICd0ZXh0LXJlbmRlcmluZycsICd1bmRlcmxpbmUtcG9zaXRpb24nLCAndW5kZXJsaW5lLXRoaWNrbmVzcycsICd1bmljb2RlLWJpZGknLCAndW5pY29kZS1yYW5nZScsICd1bml0cy1wZXItZW0nLCAndi1hbHBoYWJldGljJywgJ3YtaGFuZ2luZycsICd2LWlkZW9ncmFwaGljJywgJ3YtbWF0aGVtYXRpY2FsJywgJ3ZlY3Rvci1lZmZlY3QnLCAndmVydC1hZHYteScsICd2ZXJ0LW9yaWdpbi14JywgJ3ZlcnQtb3JpZ2luLXknLCAnd29yZC1zcGFjaW5nJywgJ3dyaXRpbmctbW9kZScsICd4bWxuczp4bGluaycsICd4LWhlaWdodCcgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gU3RyaW5nIFNWRyBhdHRyaWJ1dGVzIHdpdGggdGhlIHhsaW5rIG5hbWVzcGFjZS5cblxuWyd4bGluazphY3R1YXRlJywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6cm9sZScsICd4bGluazpzaG93JywgJ3hsaW5rOnRpdGxlJywgJ3hsaW5rOnR5cGUnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBTdHJpbmcgU1ZHIGF0dHJpYnV0ZXMgd2l0aCB0aGUgeG1sIG5hbWVzcGFjZS5cblxuWyd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnLCBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGF0dHJpYnV0ZSBleGlzdHMgYm90aCBpbiBIVE1MIGFuZCBTVkcuXG4vLyBUaGUgYXR0cmlidXRlIG5hbWUgaXMgY2FzZS1zZW5zaXRpdmUgaW4gU1ZHIHNvIHdlIGNhbid0IGp1c3QgdXNlXG4vLyB0aGUgUmVhY3QgbmFtZSBsaWtlIHdlIGRvIGZvciBhdHRyaWJ1dGVzIHRoYXQgZXhpc3Qgb25seSBpbiBIVE1MLlxuXG5bJ3RhYkluZGV4JywgJ2Nyb3NzT3JpZ2luJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICBwcm9wZXJ0aWVzW2F0dHJpYnV0ZU5hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChhdHRyaWJ1dGVOYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGF0dHJpYnV0ZXMgYWNjZXB0IFVSTHMuIFRoZXNlIG11c3Qgbm90IGFsbG93IGphdmFzY3JpcHQ6IFVSTFMuXG4vLyBUaGVzZSB3aWxsIGFsc28gbmVlZCB0byBhY2NlcHQgVHJ1c3RlZCBUeXBlcyBvYmplY3QgaW4gdGhlIGZ1dHVyZS5cblxudmFyIHhsaW5rSHJlZiA9ICd4bGlua0hyZWYnO1xucHJvcGVydGllc1t4bGlua0hyZWZdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZCgneGxpbmtIcmVmJywgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4neGxpbms6aHJlZicsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgdHJ1ZSwgLy8gc2FuaXRpemVVUkxcbmZhbHNlKTtcblsnc3JjJywgJ2hyZWYnLCAnYWN0aW9uJywgJ2Zvcm1BY3Rpb24nXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHByb3BlcnRpZXNbYXR0cmlidXRlTmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKGF0dHJpYnV0ZU5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIHRydWUsIC8vIHNhbml0aXplVVJMXG4gIHRydWUpO1xufSk7XG5cbi8qKlxuICogQ1NTIHByb3BlcnRpZXMgd2hpY2ggYWNjZXB0IG51bWJlcnMgYnV0IGFyZSBub3QgaW4gdW5pdHMgb2YgXCJweFwiLlxuICovXG52YXIgaXNVbml0bGVzc051bWJlciA9IHtcbiAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHRydWUsXG4gIGFzcGVjdFJhdGlvOiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBjb2x1bW5zOiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZEFyZWE6IHRydWUsXG4gIGdyaWRSb3c6IHRydWUsXG4gIGdyaWRSb3dFbmQ6IHRydWUsXG4gIGdyaWRSb3dTcGFuOiB0cnVlLFxuICBncmlkUm93U3RhcnQ6IHRydWUsXG4gIGdyaWRDb2x1bW46IHRydWUsXG4gIGdyaWRDb2x1bW5FbmQ6IHRydWUsXG4gIGdyaWRDb2x1bW5TcGFuOiB0cnVlLFxuICBncmlkQ29sdW1uU3RhcnQ6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIGZpbGxPcGFjaXR5OiB0cnVlLFxuICBmbG9vZE9wYWNpdHk6IHRydWUsXG4gIHN0b3BPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VEYXNoYXJyYXk6IHRydWUsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IHRydWUsXG4gIHN0cm9rZU1pdGVybGltaXQ6IHRydWUsXG4gIHN0cm9rZU9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZVdpZHRoOiB0cnVlXG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBzdHlsZSBuYW1lIHByZWZpeGVkIHdpdGggYHByZWZpeGAsIHByb3Blcmx5IGNhbWVsQ2FzZWQsIGVnOlxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXG4gKi9cblxuZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCwga2V5KSB7XG4gIHJldHVybiBwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xufVxuLyoqXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcbiAqIG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xuXG5cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107IC8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuXG5PYmplY3Qua2V5cyhpc1VuaXRsZXNzTnVtYmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxudmFyIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gIGJ1dHRvbjogdHJ1ZSxcbiAgY2hlY2tib3g6IHRydWUsXG4gIGltYWdlOiB0cnVlLFxuICBoaWRkZW46IHRydWUsXG4gIHJhZGlvOiB0cnVlLFxuICByZXNldDogdHJ1ZSxcbiAgc3VibWl0OiB0cnVlXG59O1xuZnVuY3Rpb24gY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyh0YWdOYW1lLCBwcm9wcykge1xuICB7XG4gICAgaWYgKCEoaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5vbklucHV0IHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkIHx8IHByb3BzLnZhbHVlID09IG51bGwpKSB7XG4gICAgICBlcnJvcignWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIShwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy5jaGVja2VkID09IG51bGwpKSB7XG4gICAgICBlcnJvcignWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzQ3VzdG9tQ29tcG9uZW50KHRhZ05hbWUsIHByb3BzKSB7XG4gIGlmICh0YWdOYW1lLmluZGV4T2YoJy0nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByb3BzLmlzID09PSAnc3RyaW5nJztcbiAgfVxuXG4gIHN3aXRjaCAodGFnTmFtZSkge1xuICAgIC8vIFRoZXNlIGFyZSByZXNlcnZlZCBTVkcgYW5kIE1hdGhNTCBlbGVtZW50cy5cbiAgICAvLyBXZSBkb24ndCBtaW5kIHRoaXMgbGlzdCB0b28gbXVjaCBiZWNhdXNlIHdlIGV4cGVjdCBpdCB0byBuZXZlciBncm93LlxuICAgIC8vIFRoZSBhbHRlcm5hdGl2ZSBpcyB0byB0cmFjayB0aGUgbmFtZXNwYWNlIGluIGEgZmV3IHBsYWNlcyB3aGljaCBpcyBjb252b2x1dGVkLlxuICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvY3VzdG9tLyNjdXN0b20tZWxlbWVudHMtY29yZS1jb25jZXB0c1xuICAgIGNhc2UgJ2Fubm90YXRpb24teG1sJzpcbiAgICBjYXNlICdjb2xvci1wcm9maWxlJzpcbiAgICBjYXNlICdmb250LWZhY2UnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1zcmMnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS11cmknOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1mb3JtYXQnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1uYW1lJzpcbiAgICBjYXNlICdtaXNzaW5nLWdseXBoJzpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG52YXIgYXJpYVByb3BlcnRpZXMgPSB7XG4gICdhcmlhLWN1cnJlbnQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1kZXNjcmlwdGlvbic6IDAsXG4gICdhcmlhLWRldGFpbHMnOiAwLFxuICAnYXJpYS1kaXNhYmxlZCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWhpZGRlbic6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWludmFsaWQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1rZXlzaG9ydGN1dHMnOiAwLFxuICAnYXJpYS1sYWJlbCc6IDAsXG4gICdhcmlhLXJvbGVkZXNjcmlwdGlvbic6IDAsXG4gIC8vIFdpZGdldCBBdHRyaWJ1dGVzXG4gICdhcmlhLWF1dG9jb21wbGV0ZSc6IDAsXG4gICdhcmlhLWNoZWNrZWQnOiAwLFxuICAnYXJpYS1leHBhbmRlZCc6IDAsXG4gICdhcmlhLWhhc3BvcHVwJzogMCxcbiAgJ2FyaWEtbGV2ZWwnOiAwLFxuICAnYXJpYS1tb2RhbCc6IDAsXG4gICdhcmlhLW11bHRpbGluZSc6IDAsXG4gICdhcmlhLW11bHRpc2VsZWN0YWJsZSc6IDAsXG4gICdhcmlhLW9yaWVudGF0aW9uJzogMCxcbiAgJ2FyaWEtcGxhY2Vob2xkZXInOiAwLFxuICAnYXJpYS1wcmVzc2VkJzogMCxcbiAgJ2FyaWEtcmVhZG9ubHknOiAwLFxuICAnYXJpYS1yZXF1aXJlZCc6IDAsXG4gICdhcmlhLXNlbGVjdGVkJzogMCxcbiAgJ2FyaWEtc29ydCc6IDAsXG4gICdhcmlhLXZhbHVlbWF4JzogMCxcbiAgJ2FyaWEtdmFsdWVtaW4nOiAwLFxuICAnYXJpYS12YWx1ZW5vdyc6IDAsXG4gICdhcmlhLXZhbHVldGV4dCc6IDAsXG4gIC8vIExpdmUgUmVnaW9uIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXRvbWljJzogMCxcbiAgJ2FyaWEtYnVzeSc6IDAsXG4gICdhcmlhLWxpdmUnOiAwLFxuICAnYXJpYS1yZWxldmFudCc6IDAsXG4gIC8vIERyYWctYW5kLURyb3AgQXR0cmlidXRlc1xuICAnYXJpYS1kcm9wZWZmZWN0JzogMCxcbiAgJ2FyaWEtZ3JhYmJlZCc6IDAsXG4gIC8vIFJlbGF0aW9uc2hpcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiAwLFxuICAnYXJpYS1jb2xjb3VudCc6IDAsXG4gICdhcmlhLWNvbGluZGV4JzogMCxcbiAgJ2FyaWEtY29sc3Bhbic6IDAsXG4gICdhcmlhLWNvbnRyb2xzJzogMCxcbiAgJ2FyaWEtZGVzY3JpYmVkYnknOiAwLFxuICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiAwLFxuICAnYXJpYS1mbG93dG8nOiAwLFxuICAnYXJpYS1sYWJlbGxlZGJ5JzogMCxcbiAgJ2FyaWEtb3ducyc6IDAsXG4gICdhcmlhLXBvc2luc2V0JzogMCxcbiAgJ2FyaWEtcm93Y291bnQnOiAwLFxuICAnYXJpYS1yb3dpbmRleCc6IDAsXG4gICdhcmlhLXJvd3NwYW4nOiAwLFxuICAnYXJpYS1zZXRzaXplJzogMFxufTtcblxudmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcbnZhciByQVJJQSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIHJBUklBQ2FtZWwgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkodGFnTmFtZSwgbmFtZSkge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcywgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHJBUklBQ2FtZWwudGVzdChuYW1lKSkge1xuICAgICAgdmFyIGFyaWFOYW1lID0gJ2FyaWEtJyArIG5hbWUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBjb3JyZWN0TmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGFyaWFOYW1lKSA/IGFyaWFOYW1lIDogbnVsbDsgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG5cbiAgICAgIGlmIChjb3JyZWN0TmFtZSA9PSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIEFSSUEgYXR0cmlidXRlcyBmb2xsb3cgdGhlIHBhdHRlcm4gYXJpYS0qIGFuZCBtdXN0IGJlIGxvd2VyY2FzZS4nLCBuYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuXG5cbiAgICAgIGlmIChuYW1lICE9PSBjb3JyZWN0TmFtZSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBjb3JyZWN0TmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyQVJJQS50ZXN0KG5hbWUpKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBudWxsOyAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cblxuICAgICAgaWYgKHN0YW5kYXJkTmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuXG5cbiAgICAgIGlmIChuYW1lICE9PSBzdGFuZGFyZE5hbWUpIHtcbiAgICAgICAgZXJyb3IoJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKSB7XG4gIHtcbiAgICB2YXIgaW52YWxpZFByb3BzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSh0eXBlLCBrZXkpO1xuXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgaW52YWxpZFByb3BzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSBpbnZhbGlkUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgICB9KS5qb2luKCcsICcpO1xuXG4gICAgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWFyaWEtcHJvcHMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfSBlbHNlIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID4gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWFyaWEtcHJvcHMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcykge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpO1xufVxuXG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpIHtcbiAge1xuICAgIGlmICh0eXBlICE9PSAnaW5wdXQnICYmIHR5cGUgIT09ICd0ZXh0YXJlYScgJiYgdHlwZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMgIT0gbnVsbCAmJiBwcm9wcy52YWx1ZSA9PT0gbnVsbCAmJiAhZGlkV2FyblZhbHVlTnVsbCkge1xuICAgICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlID09PSAnc2VsZWN0JyAmJiBwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgICBlcnJvcignYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgICcgKyAndG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJywgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IHN0cmluZyB0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgICcgKyAnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLicsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoZSBIVE1MIG9yIFNWRyBhbGxvd2VkIGF0dHJpYnV0ZSBsaXN0LCBiZSBzdXJlIHRvXG4vLyBhbHNvIGFkZCB0aGVtIHRvIHRoaXMgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdCBuYW1lXG4vLyB3YXJuaW5ncy5cbnZhciBwb3NzaWJsZVN0YW5kYXJkTmFtZXMgPSB7XG4gIC8vIEhUTUxcbiAgYWNjZXB0OiAnYWNjZXB0JyxcbiAgYWNjZXB0Y2hhcnNldDogJ2FjY2VwdENoYXJzZXQnLFxuICAnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG4gIGFjY2Vzc2tleTogJ2FjY2Vzc0tleScsXG4gIGFjdGlvbjogJ2FjdGlvbicsXG4gIGFsbG93ZnVsbHNjcmVlbjogJ2FsbG93RnVsbFNjcmVlbicsXG4gIGFsdDogJ2FsdCcsXG4gIGFzOiAnYXMnLFxuICBhc3luYzogJ2FzeW5jJyxcbiAgYXV0b2NhcGl0YWxpemU6ICdhdXRvQ2FwaXRhbGl6ZScsXG4gIGF1dG9jb21wbGV0ZTogJ2F1dG9Db21wbGV0ZScsXG4gIGF1dG9jb3JyZWN0OiAnYXV0b0NvcnJlY3QnLFxuICBhdXRvZm9jdXM6ICdhdXRvRm9jdXMnLFxuICBhdXRvcGxheTogJ2F1dG9QbGF5JyxcbiAgYXV0b3NhdmU6ICdhdXRvU2F2ZScsXG4gIGNhcHR1cmU6ICdjYXB0dXJlJyxcbiAgY2VsbHBhZGRpbmc6ICdjZWxsUGFkZGluZycsXG4gIGNlbGxzcGFjaW5nOiAnY2VsbFNwYWNpbmcnLFxuICBjaGFsbGVuZ2U6ICdjaGFsbGVuZ2UnLFxuICBjaGFyc2V0OiAnY2hhclNldCcsXG4gIGNoZWNrZWQ6ICdjaGVja2VkJyxcbiAgY2hpbGRyZW46ICdjaGlsZHJlbicsXG4gIGNpdGU6ICdjaXRlJyxcbiAgY2xhc3M6ICdjbGFzc05hbWUnLFxuICBjbGFzc2lkOiAnY2xhc3NJRCcsXG4gIGNsYXNzbmFtZTogJ2NsYXNzTmFtZScsXG4gIGNvbHM6ICdjb2xzJyxcbiAgY29sc3BhbjogJ2NvbFNwYW4nLFxuICBjb250ZW50OiAnY29udGVudCcsXG4gIGNvbnRlbnRlZGl0YWJsZTogJ2NvbnRlbnRFZGl0YWJsZScsXG4gIGNvbnRleHRtZW51OiAnY29udGV4dE1lbnUnLFxuICBjb250cm9sczogJ2NvbnRyb2xzJyxcbiAgY29udHJvbHNsaXN0OiAnY29udHJvbHNMaXN0JyxcbiAgY29vcmRzOiAnY29vcmRzJyxcbiAgY3Jvc3NvcmlnaW46ICdjcm9zc09yaWdpbicsXG4gIGRhbmdlcm91c2x5c2V0aW5uZXJodG1sOiAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLFxuICBkYXRhOiAnZGF0YScsXG4gIGRhdGV0aW1lOiAnZGF0ZVRpbWUnLFxuICBkZWZhdWx0OiAnZGVmYXVsdCcsXG4gIGRlZmF1bHRjaGVja2VkOiAnZGVmYXVsdENoZWNrZWQnLFxuICBkZWZhdWx0dmFsdWU6ICdkZWZhdWx0VmFsdWUnLFxuICBkZWZlcjogJ2RlZmVyJyxcbiAgZGlyOiAnZGlyJyxcbiAgZGlzYWJsZWQ6ICdkaXNhYmxlZCcsXG4gIGRpc2FibGVwaWN0dXJlaW5waWN0dXJlOiAnZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUnLFxuICBkaXNhYmxlcmVtb3RlcGxheWJhY2s6ICdkaXNhYmxlUmVtb3RlUGxheWJhY2snLFxuICBkb3dubG9hZDogJ2Rvd25sb2FkJyxcbiAgZHJhZ2dhYmxlOiAnZHJhZ2dhYmxlJyxcbiAgZW5jdHlwZTogJ2VuY1R5cGUnLFxuICBlbnRlcmtleWhpbnQ6ICdlbnRlcktleUhpbnQnLFxuICBmb3I6ICdodG1sRm9yJyxcbiAgZm9ybTogJ2Zvcm0nLFxuICBmb3JtbWV0aG9kOiAnZm9ybU1ldGhvZCcsXG4gIGZvcm1hY3Rpb246ICdmb3JtQWN0aW9uJyxcbiAgZm9ybWVuY3R5cGU6ICdmb3JtRW5jVHlwZScsXG4gIGZvcm1ub3ZhbGlkYXRlOiAnZm9ybU5vVmFsaWRhdGUnLFxuICBmb3JtdGFyZ2V0OiAnZm9ybVRhcmdldCcsXG4gIGZyYW1lYm9yZGVyOiAnZnJhbWVCb3JkZXInLFxuICBoZWFkZXJzOiAnaGVhZGVycycsXG4gIGhlaWdodDogJ2hlaWdodCcsXG4gIGhpZGRlbjogJ2hpZGRlbicsXG4gIGhpZ2g6ICdoaWdoJyxcbiAgaHJlZjogJ2hyZWYnLFxuICBocmVmbGFuZzogJ2hyZWZMYW5nJyxcbiAgaHRtbGZvcjogJ2h0bWxGb3InLFxuICBodHRwZXF1aXY6ICdodHRwRXF1aXYnLFxuICAnaHR0cC1lcXVpdic6ICdodHRwRXF1aXYnLFxuICBpY29uOiAnaWNvbicsXG4gIGlkOiAnaWQnLFxuICBpbWFnZXNpemVzOiAnaW1hZ2VTaXplcycsXG4gIGltYWdlc3Jjc2V0OiAnaW1hZ2VTcmNTZXQnLFxuICBpbm5lcmh0bWw6ICdpbm5lckhUTUwnLFxuICBpbnB1dG1vZGU6ICdpbnB1dE1vZGUnLFxuICBpbnRlZ3JpdHk6ICdpbnRlZ3JpdHknLFxuICBpczogJ2lzJyxcbiAgaXRlbWlkOiAnaXRlbUlEJyxcbiAgaXRlbXByb3A6ICdpdGVtUHJvcCcsXG4gIGl0ZW1yZWY6ICdpdGVtUmVmJyxcbiAgaXRlbXNjb3BlOiAnaXRlbVNjb3BlJyxcbiAgaXRlbXR5cGU6ICdpdGVtVHlwZScsXG4gIGtleXBhcmFtczogJ2tleVBhcmFtcycsXG4gIGtleXR5cGU6ICdrZXlUeXBlJyxcbiAga2luZDogJ2tpbmQnLFxuICBsYWJlbDogJ2xhYmVsJyxcbiAgbGFuZzogJ2xhbmcnLFxuICBsaXN0OiAnbGlzdCcsXG4gIGxvb3A6ICdsb29wJyxcbiAgbG93OiAnbG93JyxcbiAgbWFuaWZlc3Q6ICdtYW5pZmVzdCcsXG4gIG1hcmdpbndpZHRoOiAnbWFyZ2luV2lkdGgnLFxuICBtYXJnaW5oZWlnaHQ6ICdtYXJnaW5IZWlnaHQnLFxuICBtYXg6ICdtYXgnLFxuICBtYXhsZW5ndGg6ICdtYXhMZW5ndGgnLFxuICBtZWRpYTogJ21lZGlhJyxcbiAgbWVkaWFncm91cDogJ21lZGlhR3JvdXAnLFxuICBtZXRob2Q6ICdtZXRob2QnLFxuICBtaW46ICdtaW4nLFxuICBtaW5sZW5ndGg6ICdtaW5MZW5ndGgnLFxuICBtdWx0aXBsZTogJ211bHRpcGxlJyxcbiAgbXV0ZWQ6ICdtdXRlZCcsXG4gIG5hbWU6ICduYW1lJyxcbiAgbm9tb2R1bGU6ICdub01vZHVsZScsXG4gIG5vbmNlOiAnbm9uY2UnLFxuICBub3ZhbGlkYXRlOiAnbm9WYWxpZGF0ZScsXG4gIG9wZW46ICdvcGVuJyxcbiAgb3B0aW11bTogJ29wdGltdW0nLFxuICBwYXR0ZXJuOiAncGF0dGVybicsXG4gIHBsYWNlaG9sZGVyOiAncGxhY2Vob2xkZXInLFxuICBwbGF5c2lubGluZTogJ3BsYXlzSW5saW5lJyxcbiAgcG9zdGVyOiAncG9zdGVyJyxcbiAgcHJlbG9hZDogJ3ByZWxvYWQnLFxuICBwcm9maWxlOiAncHJvZmlsZScsXG4gIHJhZGlvZ3JvdXA6ICdyYWRpb0dyb3VwJyxcbiAgcmVhZG9ubHk6ICdyZWFkT25seScsXG4gIHJlZmVycmVycG9saWN5OiAncmVmZXJyZXJQb2xpY3knLFxuICByZWw6ICdyZWwnLFxuICByZXF1aXJlZDogJ3JlcXVpcmVkJyxcbiAgcmV2ZXJzZWQ6ICdyZXZlcnNlZCcsXG4gIHJvbGU6ICdyb2xlJyxcbiAgcm93czogJ3Jvd3MnLFxuICByb3dzcGFuOiAncm93U3BhbicsXG4gIHNhbmRib3g6ICdzYW5kYm94JyxcbiAgc2NvcGU6ICdzY29wZScsXG4gIHNjb3BlZDogJ3Njb3BlZCcsXG4gIHNjcm9sbGluZzogJ3Njcm9sbGluZycsXG4gIHNlYW1sZXNzOiAnc2VhbWxlc3MnLFxuICBzZWxlY3RlZDogJ3NlbGVjdGVkJyxcbiAgc2hhcGU6ICdzaGFwZScsXG4gIHNpemU6ICdzaXplJyxcbiAgc2l6ZXM6ICdzaXplcycsXG4gIHNwYW46ICdzcGFuJyxcbiAgc3BlbGxjaGVjazogJ3NwZWxsQ2hlY2snLFxuICBzcmM6ICdzcmMnLFxuICBzcmNkb2M6ICdzcmNEb2MnLFxuICBzcmNsYW5nOiAnc3JjTGFuZycsXG4gIHNyY3NldDogJ3NyY1NldCcsXG4gIHN0YXJ0OiAnc3RhcnQnLFxuICBzdGVwOiAnc3RlcCcsXG4gIHN0eWxlOiAnc3R5bGUnLFxuICBzdW1tYXJ5OiAnc3VtbWFyeScsXG4gIHRhYmluZGV4OiAndGFiSW5kZXgnLFxuICB0YXJnZXQ6ICd0YXJnZXQnLFxuICB0aXRsZTogJ3RpdGxlJyxcbiAgdHlwZTogJ3R5cGUnLFxuICB1c2VtYXA6ICd1c2VNYXAnLFxuICB2YWx1ZTogJ3ZhbHVlJyxcbiAgd2lkdGg6ICd3aWR0aCcsXG4gIHdtb2RlOiAnd21vZGUnLFxuICB3cmFwOiAnd3JhcCcsXG4gIC8vIFNWR1xuICBhYm91dDogJ2Fib3V0JyxcbiAgYWNjZW50aGVpZ2h0OiAnYWNjZW50SGVpZ2h0JyxcbiAgJ2FjY2VudC1oZWlnaHQnOiAnYWNjZW50SGVpZ2h0JyxcbiAgYWNjdW11bGF0ZTogJ2FjY3VtdWxhdGUnLFxuICBhZGRpdGl2ZTogJ2FkZGl0aXZlJyxcbiAgYWxpZ25tZW50YmFzZWxpbmU6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gICdhbGlnbm1lbnQtYmFzZWxpbmUnOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICBhbGxvd3Jlb3JkZXI6ICdhbGxvd1Jlb3JkZXInLFxuICBhbHBoYWJldGljOiAnYWxwaGFiZXRpYycsXG4gIGFtcGxpdHVkZTogJ2FtcGxpdHVkZScsXG4gIGFyYWJpY2Zvcm06ICdhcmFiaWNGb3JtJyxcbiAgJ2FyYWJpYy1mb3JtJzogJ2FyYWJpY0Zvcm0nLFxuICBhc2NlbnQ6ICdhc2NlbnQnLFxuICBhdHRyaWJ1dGVuYW1lOiAnYXR0cmlidXRlTmFtZScsXG4gIGF0dHJpYnV0ZXR5cGU6ICdhdHRyaWJ1dGVUeXBlJyxcbiAgYXV0b3JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gIGF6aW11dGg6ICdhemltdXRoJyxcbiAgYmFzZWZyZXF1ZW5jeTogJ2Jhc2VGcmVxdWVuY3knLFxuICBiYXNlbGluZXNoaWZ0OiAnYmFzZWxpbmVTaGlmdCcsXG4gICdiYXNlbGluZS1zaGlmdCc6ICdiYXNlbGluZVNoaWZ0JyxcbiAgYmFzZXByb2ZpbGU6ICdiYXNlUHJvZmlsZScsXG4gIGJib3g6ICdiYm94JyxcbiAgYmVnaW46ICdiZWdpbicsXG4gIGJpYXM6ICdiaWFzJyxcbiAgYnk6ICdieScsXG4gIGNhbGNtb2RlOiAnY2FsY01vZGUnLFxuICBjYXBoZWlnaHQ6ICdjYXBIZWlnaHQnLFxuICAnY2FwLWhlaWdodCc6ICdjYXBIZWlnaHQnLFxuICBjbGlwOiAnY2xpcCcsXG4gIGNsaXBwYXRoOiAnY2xpcFBhdGgnLFxuICAnY2xpcC1wYXRoJzogJ2NsaXBQYXRoJyxcbiAgY2xpcHBhdGh1bml0czogJ2NsaXBQYXRoVW5pdHMnLFxuICBjbGlwcnVsZTogJ2NsaXBSdWxlJyxcbiAgJ2NsaXAtcnVsZSc6ICdjbGlwUnVsZScsXG4gIGNvbG9yOiAnY29sb3InLFxuICBjb2xvcmludGVycG9sYXRpb246ICdjb2xvckludGVycG9sYXRpb24nLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbic6ICdjb2xvckludGVycG9sYXRpb24nLFxuICBjb2xvcmludGVycG9sYXRpb25maWx0ZXJzOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gIGNvbG9ycHJvZmlsZTogJ2NvbG9yUHJvZmlsZScsXG4gICdjb2xvci1wcm9maWxlJzogJ2NvbG9yUHJvZmlsZScsXG4gIGNvbG9ycmVuZGVyaW5nOiAnY29sb3JSZW5kZXJpbmcnLFxuICAnY29sb3ItcmVuZGVyaW5nJzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgY29udGVudHNjcmlwdHR5cGU6ICdjb250ZW50U2NyaXB0VHlwZScsXG4gIGNvbnRlbnRzdHlsZXR5cGU6ICdjb250ZW50U3R5bGVUeXBlJyxcbiAgY3Vyc29yOiAnY3Vyc29yJyxcbiAgY3g6ICdjeCcsXG4gIGN5OiAnY3knLFxuICBkOiAnZCcsXG4gIGRhdGF0eXBlOiAnZGF0YXR5cGUnLFxuICBkZWNlbGVyYXRlOiAnZGVjZWxlcmF0ZScsXG4gIGRlc2NlbnQ6ICdkZXNjZW50JyxcbiAgZGlmZnVzZWNvbnN0YW50OiAnZGlmZnVzZUNvbnN0YW50JyxcbiAgZGlyZWN0aW9uOiAnZGlyZWN0aW9uJyxcbiAgZGlzcGxheTogJ2Rpc3BsYXknLFxuICBkaXZpc29yOiAnZGl2aXNvcicsXG4gIGRvbWluYW50YmFzZWxpbmU6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgJ2RvbWluYW50LWJhc2VsaW5lJzogJ2RvbWluYW50QmFzZWxpbmUnLFxuICBkdXI6ICdkdXInLFxuICBkeDogJ2R4JyxcbiAgZHk6ICdkeScsXG4gIGVkZ2Vtb2RlOiAnZWRnZU1vZGUnLFxuICBlbGV2YXRpb246ICdlbGV2YXRpb24nLFxuICBlbmFibGViYWNrZ3JvdW5kOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gICdlbmFibGUtYmFja2dyb3VuZCc6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgZW5kOiAnZW5kJyxcbiAgZXhwb25lbnQ6ICdleHBvbmVudCcsXG4gIGV4dGVybmFscmVzb3VyY2VzcmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgZmlsbDogJ2ZpbGwnLFxuICBmaWxsb3BhY2l0eTogJ2ZpbGxPcGFjaXR5JyxcbiAgJ2ZpbGwtb3BhY2l0eSc6ICdmaWxsT3BhY2l0eScsXG4gIGZpbGxydWxlOiAnZmlsbFJ1bGUnLFxuICAnZmlsbC1ydWxlJzogJ2ZpbGxSdWxlJyxcbiAgZmlsdGVyOiAnZmlsdGVyJyxcbiAgZmlsdGVycmVzOiAnZmlsdGVyUmVzJyxcbiAgZmlsdGVydW5pdHM6ICdmaWx0ZXJVbml0cycsXG4gIGZsb29kb3BhY2l0eTogJ2Zsb29kT3BhY2l0eScsXG4gICdmbG9vZC1vcGFjaXR5JzogJ2Zsb29kT3BhY2l0eScsXG4gIGZsb29kY29sb3I6ICdmbG9vZENvbG9yJyxcbiAgJ2Zsb29kLWNvbG9yJzogJ2Zsb29kQ29sb3InLFxuICBmb2N1c2FibGU6ICdmb2N1c2FibGUnLFxuICBmb250ZmFtaWx5OiAnZm9udEZhbWlseScsXG4gICdmb250LWZhbWlseSc6ICdmb250RmFtaWx5JyxcbiAgZm9udHNpemU6ICdmb250U2l6ZScsXG4gICdmb250LXNpemUnOiAnZm9udFNpemUnLFxuICBmb250c2l6ZWFkanVzdDogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgJ2ZvbnQtc2l6ZS1hZGp1c3QnOiAnZm9udFNpemVBZGp1c3QnLFxuICBmb250c3RyZXRjaDogJ2ZvbnRTdHJldGNoJyxcbiAgJ2ZvbnQtc3RyZXRjaCc6ICdmb250U3RyZXRjaCcsXG4gIGZvbnRzdHlsZTogJ2ZvbnRTdHlsZScsXG4gICdmb250LXN0eWxlJzogJ2ZvbnRTdHlsZScsXG4gIGZvbnR2YXJpYW50OiAnZm9udFZhcmlhbnQnLFxuICAnZm9udC12YXJpYW50JzogJ2ZvbnRWYXJpYW50JyxcbiAgZm9udHdlaWdodDogJ2ZvbnRXZWlnaHQnLFxuICAnZm9udC13ZWlnaHQnOiAnZm9udFdlaWdodCcsXG4gIGZvcm1hdDogJ2Zvcm1hdCcsXG4gIGZyb206ICdmcm9tJyxcbiAgZng6ICdmeCcsXG4gIGZ5OiAnZnknLFxuICBnMTogJ2cxJyxcbiAgZzI6ICdnMicsXG4gIGdseXBobmFtZTogJ2dseXBoTmFtZScsXG4gICdnbHlwaC1uYW1lJzogJ2dseXBoTmFtZScsXG4gIGdseXBob3JpZW50YXRpb25ob3Jpem9udGFsOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCc6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gIGdseXBob3JpZW50YXRpb252ZXJ0aWNhbDogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCc6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICBnbHlwaHJlZjogJ2dseXBoUmVmJyxcbiAgZ3JhZGllbnR0cmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gIGdyYWRpZW50dW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgaGFuZ2luZzogJ2hhbmdpbmcnLFxuICBob3JpemFkdng6ICdob3JpekFkdlgnLFxuICAnaG9yaXotYWR2LXgnOiAnaG9yaXpBZHZYJyxcbiAgaG9yaXpvcmlnaW54OiAnaG9yaXpPcmlnaW5YJyxcbiAgJ2hvcml6LW9yaWdpbi14JzogJ2hvcml6T3JpZ2luWCcsXG4gIGlkZW9ncmFwaGljOiAnaWRlb2dyYXBoaWMnLFxuICBpbWFnZXJlbmRlcmluZzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgJ2ltYWdlLXJlbmRlcmluZyc6ICdpbWFnZVJlbmRlcmluZycsXG4gIGluMjogJ2luMicsXG4gIGluOiAnaW4nLFxuICBpbmxpc3Q6ICdpbmxpc3QnLFxuICBpbnRlcmNlcHQ6ICdpbnRlcmNlcHQnLFxuICBrMTogJ2sxJyxcbiAgazI6ICdrMicsXG4gIGszOiAnazMnLFxuICBrNDogJ2s0JyxcbiAgazogJ2snLFxuICBrZXJuZWxtYXRyaXg6ICdrZXJuZWxNYXRyaXgnLFxuICBrZXJuZWx1bml0bGVuZ3RoOiAna2VybmVsVW5pdExlbmd0aCcsXG4gIGtlcm5pbmc6ICdrZXJuaW5nJyxcbiAga2V5cG9pbnRzOiAna2V5UG9pbnRzJyxcbiAga2V5c3BsaW5lczogJ2tleVNwbGluZXMnLFxuICBrZXl0aW1lczogJ2tleVRpbWVzJyxcbiAgbGVuZ3RoYWRqdXN0OiAnbGVuZ3RoQWRqdXN0JyxcbiAgbGV0dGVyc3BhY2luZzogJ2xldHRlclNwYWNpbmcnLFxuICAnbGV0dGVyLXNwYWNpbmcnOiAnbGV0dGVyU3BhY2luZycsXG4gIGxpZ2h0aW5nY29sb3I6ICdsaWdodGluZ0NvbG9yJyxcbiAgJ2xpZ2h0aW5nLWNvbG9yJzogJ2xpZ2h0aW5nQ29sb3InLFxuICBsaW1pdGluZ2NvbmVhbmdsZTogJ2xpbWl0aW5nQ29uZUFuZ2xlJyxcbiAgbG9jYWw6ICdsb2NhbCcsXG4gIG1hcmtlcmVuZDogJ21hcmtlckVuZCcsXG4gICdtYXJrZXItZW5kJzogJ21hcmtlckVuZCcsXG4gIG1hcmtlcmhlaWdodDogJ21hcmtlckhlaWdodCcsXG4gIG1hcmtlcm1pZDogJ21hcmtlck1pZCcsXG4gICdtYXJrZXItbWlkJzogJ21hcmtlck1pZCcsXG4gIG1hcmtlcnN0YXJ0OiAnbWFya2VyU3RhcnQnLFxuICAnbWFya2VyLXN0YXJ0JzogJ21hcmtlclN0YXJ0JyxcbiAgbWFya2VydW5pdHM6ICdtYXJrZXJVbml0cycsXG4gIG1hcmtlcndpZHRoOiAnbWFya2VyV2lkdGgnLFxuICBtYXNrOiAnbWFzaycsXG4gIG1hc2tjb250ZW50dW5pdHM6ICdtYXNrQ29udGVudFVuaXRzJyxcbiAgbWFza3VuaXRzOiAnbWFza1VuaXRzJyxcbiAgbWF0aGVtYXRpY2FsOiAnbWF0aGVtYXRpY2FsJyxcbiAgbW9kZTogJ21vZGUnLFxuICBudW1vY3RhdmVzOiAnbnVtT2N0YXZlcycsXG4gIG9mZnNldDogJ29mZnNldCcsXG4gIG9wYWNpdHk6ICdvcGFjaXR5JyxcbiAgb3BlcmF0b3I6ICdvcGVyYXRvcicsXG4gIG9yZGVyOiAnb3JkZXInLFxuICBvcmllbnQ6ICdvcmllbnQnLFxuICBvcmllbnRhdGlvbjogJ29yaWVudGF0aW9uJyxcbiAgb3JpZ2luOiAnb3JpZ2luJyxcbiAgb3ZlcmZsb3c6ICdvdmVyZmxvdycsXG4gIG92ZXJsaW5lcG9zaXRpb246ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgJ292ZXJsaW5lLXBvc2l0aW9uJzogJ292ZXJsaW5lUG9zaXRpb24nLFxuICBvdmVybGluZXRoaWNrbmVzczogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ292ZXJsaW5lLXRoaWNrbmVzcyc6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gIHBhaW50b3JkZXI6ICdwYWludE9yZGVyJyxcbiAgJ3BhaW50LW9yZGVyJzogJ3BhaW50T3JkZXInLFxuICBwYW5vc2UxOiAncGFub3NlMScsXG4gICdwYW5vc2UtMSc6ICdwYW5vc2UxJyxcbiAgcGF0aGxlbmd0aDogJ3BhdGhMZW5ndGgnLFxuICBwYXR0ZXJuY29udGVudHVuaXRzOiAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gIHBhdHRlcm50cmFuc2Zvcm06ICdwYXR0ZXJuVHJhbnNmb3JtJyxcbiAgcGF0dGVybnVuaXRzOiAncGF0dGVyblVuaXRzJyxcbiAgcG9pbnRlcmV2ZW50czogJ3BvaW50ZXJFdmVudHMnLFxuICAncG9pbnRlci1ldmVudHMnOiAncG9pbnRlckV2ZW50cycsXG4gIHBvaW50czogJ3BvaW50cycsXG4gIHBvaW50c2F0eDogJ3BvaW50c0F0WCcsXG4gIHBvaW50c2F0eTogJ3BvaW50c0F0WScsXG4gIHBvaW50c2F0ejogJ3BvaW50c0F0WicsXG4gIHByZWZpeDogJ3ByZWZpeCcsXG4gIHByZXNlcnZlYWxwaGE6ICdwcmVzZXJ2ZUFscGhhJyxcbiAgcHJlc2VydmVhc3BlY3RyYXRpbzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICBwcmltaXRpdmV1bml0czogJ3ByaW1pdGl2ZVVuaXRzJyxcbiAgcHJvcGVydHk6ICdwcm9wZXJ0eScsXG4gIHI6ICdyJyxcbiAgcmFkaXVzOiAncmFkaXVzJyxcbiAgcmVmeDogJ3JlZlgnLFxuICByZWZ5OiAncmVmWScsXG4gIHJlbmRlcmluZ2ludGVudDogJ3JlbmRlcmluZ0ludGVudCcsXG4gICdyZW5kZXJpbmctaW50ZW50JzogJ3JlbmRlcmluZ0ludGVudCcsXG4gIHJlcGVhdGNvdW50OiAncmVwZWF0Q291bnQnLFxuICByZXBlYXRkdXI6ICdyZXBlYXREdXInLFxuICByZXF1aXJlZGV4dGVuc2lvbnM6ICdyZXF1aXJlZEV4dGVuc2lvbnMnLFxuICByZXF1aXJlZGZlYXR1cmVzOiAncmVxdWlyZWRGZWF0dXJlcycsXG4gIHJlc291cmNlOiAncmVzb3VyY2UnLFxuICByZXN0YXJ0OiAncmVzdGFydCcsXG4gIHJlc3VsdDogJ3Jlc3VsdCcsXG4gIHJlc3VsdHM6ICdyZXN1bHRzJyxcbiAgcm90YXRlOiAncm90YXRlJyxcbiAgcng6ICdyeCcsXG4gIHJ5OiAncnknLFxuICBzY2FsZTogJ3NjYWxlJyxcbiAgc2VjdXJpdHk6ICdzZWN1cml0eScsXG4gIHNlZWQ6ICdzZWVkJyxcbiAgc2hhcGVyZW5kZXJpbmc6ICdzaGFwZVJlbmRlcmluZycsXG4gICdzaGFwZS1yZW5kZXJpbmcnOiAnc2hhcGVSZW5kZXJpbmcnLFxuICBzbG9wZTogJ3Nsb3BlJyxcbiAgc3BhY2luZzogJ3NwYWNpbmcnLFxuICBzcGVjdWxhcmNvbnN0YW50OiAnc3BlY3VsYXJDb25zdGFudCcsXG4gIHNwZWN1bGFyZXhwb25lbnQ6ICdzcGVjdWxhckV4cG9uZW50JyxcbiAgc3BlZWQ6ICdzcGVlZCcsXG4gIHNwcmVhZG1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gIHN0YXJ0b2Zmc2V0OiAnc3RhcnRPZmZzZXQnLFxuICBzdGRkZXZpYXRpb246ICdzdGREZXZpYXRpb24nLFxuICBzdGVtaDogJ3N0ZW1oJyxcbiAgc3RlbXY6ICdzdGVtdicsXG4gIHN0aXRjaHRpbGVzOiAnc3RpdGNoVGlsZXMnLFxuICBzdG9wY29sb3I6ICdzdG9wQ29sb3InLFxuICAnc3RvcC1jb2xvcic6ICdzdG9wQ29sb3InLFxuICBzdG9wb3BhY2l0eTogJ3N0b3BPcGFjaXR5JyxcbiAgJ3N0b3Atb3BhY2l0eSc6ICdzdG9wT3BhY2l0eScsXG4gIHN0cmlrZXRocm91Z2hwb3NpdGlvbjogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJzogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gIHN0cmlrZXRocm91Z2h0aGlja25lc3M6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJzogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICBzdHJpbmc6ICdzdHJpbmcnLFxuICBzdHJva2U6ICdzdHJva2UnLFxuICBzdHJva2VkYXNoYXJyYXk6ICdzdHJva2VEYXNoYXJyYXknLFxuICAnc3Ryb2tlLWRhc2hhcnJheSc6ICdzdHJva2VEYXNoYXJyYXknLFxuICBzdHJva2VkYXNob2Zmc2V0OiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gICdzdHJva2UtZGFzaG9mZnNldCc6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgc3Ryb2tlbGluZWNhcDogJ3N0cm9rZUxpbmVjYXAnLFxuICAnc3Ryb2tlLWxpbmVjYXAnOiAnc3Ryb2tlTGluZWNhcCcsXG4gIHN0cm9rZWxpbmVqb2luOiAnc3Ryb2tlTGluZWpvaW4nLFxuICAnc3Ryb2tlLWxpbmVqb2luJzogJ3N0cm9rZUxpbmVqb2luJyxcbiAgc3Ryb2tlbWl0ZXJsaW1pdDogJ3N0cm9rZU1pdGVybGltaXQnLFxuICAnc3Ryb2tlLW1pdGVybGltaXQnOiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gIHN0cm9rZXdpZHRoOiAnc3Ryb2tlV2lkdGgnLFxuICAnc3Ryb2tlLXdpZHRoJzogJ3N0cm9rZVdpZHRoJyxcbiAgc3Ryb2tlb3BhY2l0eTogJ3N0cm9rZU9wYWNpdHknLFxuICAnc3Ryb2tlLW9wYWNpdHknOiAnc3Ryb2tlT3BhY2l0eScsXG4gIHN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZzogJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZycsXG4gIHN1cHByZXNzaHlkcmF0aW9ud2FybmluZzogJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsXG4gIHN1cmZhY2VzY2FsZTogJ3N1cmZhY2VTY2FsZScsXG4gIHN5c3RlbWxhbmd1YWdlOiAnc3lzdGVtTGFuZ3VhZ2UnLFxuICB0YWJsZXZhbHVlczogJ3RhYmxlVmFsdWVzJyxcbiAgdGFyZ2V0eDogJ3RhcmdldFgnLFxuICB0YXJnZXR5OiAndGFyZ2V0WScsXG4gIHRleHRhbmNob3I6ICd0ZXh0QW5jaG9yJyxcbiAgJ3RleHQtYW5jaG9yJzogJ3RleHRBbmNob3InLFxuICB0ZXh0ZGVjb3JhdGlvbjogJ3RleHREZWNvcmF0aW9uJyxcbiAgJ3RleHQtZGVjb3JhdGlvbic6ICd0ZXh0RGVjb3JhdGlvbicsXG4gIHRleHRsZW5ndGg6ICd0ZXh0TGVuZ3RoJyxcbiAgdGV4dHJlbmRlcmluZzogJ3RleHRSZW5kZXJpbmcnLFxuICAndGV4dC1yZW5kZXJpbmcnOiAndGV4dFJlbmRlcmluZycsXG4gIHRvOiAndG8nLFxuICB0cmFuc2Zvcm06ICd0cmFuc2Zvcm0nLFxuICB0eXBlb2Y6ICd0eXBlb2YnLFxuICB1MTogJ3UxJyxcbiAgdTI6ICd1MicsXG4gIHVuZGVybGluZXBvc2l0aW9uOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICAndW5kZXJsaW5lLXBvc2l0aW9uJzogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgdW5kZXJsaW5ldGhpY2tuZXNzOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ3VuZGVybGluZS10aGlja25lc3MnOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgdW5pY29kZTogJ3VuaWNvZGUnLFxuICB1bmljb2RlYmlkaTogJ3VuaWNvZGVCaWRpJyxcbiAgJ3VuaWNvZGUtYmlkaSc6ICd1bmljb2RlQmlkaScsXG4gIHVuaWNvZGVyYW5nZTogJ3VuaWNvZGVSYW5nZScsXG4gICd1bmljb2RlLXJhbmdlJzogJ3VuaWNvZGVSYW5nZScsXG4gIHVuaXRzcGVyZW06ICd1bml0c1BlckVtJyxcbiAgJ3VuaXRzLXBlci1lbSc6ICd1bml0c1BlckVtJyxcbiAgdW5zZWxlY3RhYmxlOiAndW5zZWxlY3RhYmxlJyxcbiAgdmFscGhhYmV0aWM6ICd2QWxwaGFiZXRpYycsXG4gICd2LWFscGhhYmV0aWMnOiAndkFscGhhYmV0aWMnLFxuICB2YWx1ZXM6ICd2YWx1ZXMnLFxuICB2ZWN0b3JlZmZlY3Q6ICd2ZWN0b3JFZmZlY3QnLFxuICAndmVjdG9yLWVmZmVjdCc6ICd2ZWN0b3JFZmZlY3QnLFxuICB2ZXJzaW9uOiAndmVyc2lvbicsXG4gIHZlcnRhZHZ5OiAndmVydEFkdlknLFxuICAndmVydC1hZHYteSc6ICd2ZXJ0QWR2WScsXG4gIHZlcnRvcmlnaW54OiAndmVydE9yaWdpblgnLFxuICAndmVydC1vcmlnaW4teCc6ICd2ZXJ0T3JpZ2luWCcsXG4gIHZlcnRvcmlnaW55OiAndmVydE9yaWdpblknLFxuICAndmVydC1vcmlnaW4teSc6ICd2ZXJ0T3JpZ2luWScsXG4gIHZoYW5naW5nOiAndkhhbmdpbmcnLFxuICAndi1oYW5naW5nJzogJ3ZIYW5naW5nJyxcbiAgdmlkZW9ncmFwaGljOiAndklkZW9ncmFwaGljJyxcbiAgJ3YtaWRlb2dyYXBoaWMnOiAndklkZW9ncmFwaGljJyxcbiAgdmlld2JveDogJ3ZpZXdCb3gnLFxuICB2aWV3dGFyZ2V0OiAndmlld1RhcmdldCcsXG4gIHZpc2liaWxpdHk6ICd2aXNpYmlsaXR5JyxcbiAgdm1hdGhlbWF0aWNhbDogJ3ZNYXRoZW1hdGljYWwnLFxuICAndi1tYXRoZW1hdGljYWwnOiAndk1hdGhlbWF0aWNhbCcsXG4gIHZvY2FiOiAndm9jYWInLFxuICB3aWR0aHM6ICd3aWR0aHMnLFxuICB3b3Jkc3BhY2luZzogJ3dvcmRTcGFjaW5nJyxcbiAgJ3dvcmQtc3BhY2luZyc6ICd3b3JkU3BhY2luZycsXG4gIHdyaXRpbmdtb2RlOiAnd3JpdGluZ01vZGUnLFxuICAnd3JpdGluZy1tb2RlJzogJ3dyaXRpbmdNb2RlJyxcbiAgeDE6ICd4MScsXG4gIHgyOiAneDInLFxuICB4OiAneCcsXG4gIHhjaGFubmVsc2VsZWN0b3I6ICd4Q2hhbm5lbFNlbGVjdG9yJyxcbiAgeGhlaWdodDogJ3hIZWlnaHQnLFxuICAneC1oZWlnaHQnOiAneEhlaWdodCcsXG4gIHhsaW5rYWN0dWF0ZTogJ3hsaW5rQWN0dWF0ZScsXG4gICd4bGluazphY3R1YXRlJzogJ3hsaW5rQWN0dWF0ZScsXG4gIHhsaW5rYXJjcm9sZTogJ3hsaW5rQXJjcm9sZScsXG4gICd4bGluazphcmNyb2xlJzogJ3hsaW5rQXJjcm9sZScsXG4gIHhsaW5raHJlZjogJ3hsaW5rSHJlZicsXG4gICd4bGluazpocmVmJzogJ3hsaW5rSHJlZicsXG4gIHhsaW5rcm9sZTogJ3hsaW5rUm9sZScsXG4gICd4bGluazpyb2xlJzogJ3hsaW5rUm9sZScsXG4gIHhsaW5rc2hvdzogJ3hsaW5rU2hvdycsXG4gICd4bGluazpzaG93JzogJ3hsaW5rU2hvdycsXG4gIHhsaW5rdGl0bGU6ICd4bGlua1RpdGxlJyxcbiAgJ3hsaW5rOnRpdGxlJzogJ3hsaW5rVGl0bGUnLFxuICB4bGlua3R5cGU6ICd4bGlua1R5cGUnLFxuICAneGxpbms6dHlwZSc6ICd4bGlua1R5cGUnLFxuICB4bWxiYXNlOiAneG1sQmFzZScsXG4gICd4bWw6YmFzZSc6ICd4bWxCYXNlJyxcbiAgeG1sbGFuZzogJ3htbExhbmcnLFxuICAneG1sOmxhbmcnOiAneG1sTGFuZycsXG4gIHhtbG5zOiAneG1sbnMnLFxuICAneG1sOnNwYWNlJzogJ3htbFNwYWNlJyxcbiAgeG1sbnN4bGluazogJ3htbG5zWGxpbmsnLFxuICAneG1sbnM6eGxpbmsnOiAneG1sbnNYbGluaycsXG4gIHhtbHNwYWNlOiAneG1sU3BhY2UnLFxuICB5MTogJ3kxJyxcbiAgeTI6ICd5MicsXG4gIHk6ICd5JyxcbiAgeWNoYW5uZWxzZWxlY3RvcjogJ3lDaGFubmVsU2VsZWN0b3InLFxuICB6OiAneicsXG4gIHpvb21hbmRwYW46ICd6b29tQW5kUGFuJ1xufTtcblxudmFyIHZhbGlkYXRlUHJvcGVydHkkMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciB3YXJuZWRQcm9wZXJ0aWVzJDEgPSB7fTtcbiAgdmFyIEVWRU5UX05BTUVfUkVHRVggPSAvXm9uLi87XG4gIHZhciBJTlZBTElEX0VWRU5UX05BTUVfUkVHRVggPSAvXm9uW15BLVpdLztcbiAgdmFyIHJBUklBJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbiAgdmFyIHJBUklBQ2FtZWwkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuICB2YWxpZGF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAodGFnTmFtZSwgbmFtZSwgdmFsdWUsIGV2ZW50UmVnaXN0cnkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzJDEsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c2luJyB8fCBsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNvdXQnKSB7XG4gICAgICBlcnJvcignUmVhY3QgdXNlcyBvbkZvY3VzIGFuZCBvbkJsdXIgaW5zdGVhZCBvZiBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQuICcgKyAnQWxsIFJlYWN0IGV2ZW50cyBhcmUgbm9ybWFsaXplZCB0byBidWJibGUsIHNvIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dCAnICsgJ2FyZSBub3QgbmVlZGVkL3N1cHBvcnRlZCBieSBSZWFjdC4nKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gV2UgY2FuJ3QgcmVseSBvbiB0aGUgZXZlbnQgc3lzdGVtIGJlaW5nIGluamVjdGVkIG9uIHRoZSBzZXJ2ZXIuXG5cblxuICAgIGlmIChldmVudFJlZ2lzdHJ5ICE9IG51bGwpIHtcbiAgICAgIHZhciByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzID0gZXZlbnRSZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLFxuICAgICAgICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSBldmVudFJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM7XG5cbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuXG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgcmVnaXN0cmF0aW9uTmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgICAgZXJyb3IoJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBJdCB3aWxsIGJlIGlnbm9yZWQuJywgbmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIElmIG5vIGV2ZW50IHBsdWdpbnMgaGF2ZSBiZWVuIGluamVjdGVkLCB3ZSBhcmUgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG4gICAgICAvLyBTbyB3ZSBjYW4ndCB0ZWxsIGlmIHRoZSBldmVudCBuYW1lIGlzIGNvcnJlY3QgZm9yIHN1cmUsIGJ1dCB3ZSBjYW4gZmlsdGVyXG4gICAgICAvLyBvdXQga25vd24gYmFkIG9uZXMgbGlrZSBgb25jbGlja2AuIFdlIGNhbid0IHN1Z2dlc3QgYSBzcGVjaWZpYyByZXBsYWNlbWVudCB0aG91Z2guXG4gICAgICBpZiAoSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiAnICsgJ1JlYWN0IGV2ZW50cyB1c2UgdGhlIGNhbWVsQ2FzZSBuYW1pbmcgY29udmVudGlvbiwgZm9yIGV4YW1wbGUgYG9uQ2xpY2tgLicsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBMZXQgdGhlIEFSSUEgYXR0cmlidXRlIGhvb2sgdmFsaWRhdGUgQVJJQSBhdHRyaWJ1dGVzXG5cblxuICAgIGlmIChyQVJJQSQxLnRlc3QobmFtZSkgfHwgckFSSUFDYW1lbCQxLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lubmVyaHRtbCcpIHtcbiAgICAgIGVycm9yKCdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdhcmlhJykge1xuICAgICAgZXJyb3IoJ1RoZSBgYXJpYWAgYXR0cmlidXRlIGlzIHJlc2VydmVkIGZvciBmdXR1cmUgdXNlIGluIFJlYWN0LiAnICsgJ1Bhc3MgaW5kaXZpZHVhbCBgYXJpYS1gIGF0dHJpYnV0ZXMgaW5zdGVhZC4nKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lzJyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhIGAlc2AgZm9yIGEgc3RyaW5nIGF0dHJpYnV0ZSBgaXNgLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgKyAndGhlIHZhbHVlIHRvIGEgc3RyaW5nLicsIHR5cGVvZiB2YWx1ZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4nLCBuYW1lKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gICAgdmFyIGlzUmVzZXJ2ZWQgPSBwcm9wZXJ0eUluZm8gIT09IG51bGwgJiYgcHJvcGVydHlJbmZvLnR5cGUgPT09IFJFU0VSVkVEOyAvLyBLbm93biBhdHRyaWJ1dGVzIHNob3VsZCBtYXRjaCB0aGUgY2FzaW5nIHNwZWNpZmllZCBpbiB0aGUgcHJvcGVydHkgY29uZmlnLlxuXG4gICAgaWYgKHBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBwb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdO1xuXG4gICAgICBpZiAoc3RhbmRhcmROYW1lICE9PSBuYW1lKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIERPTSBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBzdGFuZGFyZE5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQgJiYgbmFtZSAhPT0gbG93ZXJDYXNlZE5hbWUpIHtcbiAgICAgIC8vIFVua25vd24gYXR0cmlidXRlcyBzaG91bGQgaGF2ZSBsb3dlcmNhc2UgY2FzaW5nIHNpbmNlIHRoYXQncyBob3cgdGhleVxuICAgICAgLy8gd2lsbCBiZSBjYXNlZCBhbnl3YXkgd2l0aCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgICAgZXJyb3IoJ1JlYWN0IGRvZXMgbm90IHJlY29nbml6ZSB0aGUgYCVzYCBwcm9wIG9uIGEgRE9NIGVsZW1lbnQuIElmIHlvdSAnICsgJ2ludGVudGlvbmFsbHkgd2FudCBpdCB0byBhcHBlYXIgaW4gdGhlIERPTSBhcyBhIGN1c3RvbSAnICsgJ2F0dHJpYnV0ZSwgc3BlbGwgaXQgYXMgbG93ZXJjYXNlIGAlc2AgaW5zdGVhZC4gJyArICdJZiB5b3UgYWNjaWRlbnRhbGx5IHBhc3NlZCBpdCBmcm9tIGEgcGFyZW50IGNvbXBvbmVudCwgcmVtb3ZlICcgKyAnaXQgZnJvbSB0aGUgRE9NIGVsZW1lbnQuJywgbmFtZSwgbG93ZXJDYXNlZE5hbWUpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nICYmIHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVycm9yKCdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4nLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUsIG5hbWUsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBOb3cgdGhhdCB3ZSd2ZSB2YWxpZGF0ZWQgY2FzaW5nLCBkbyBub3QgdmFsaWRhdGVcbiAgICAvLyBkYXRhIHR5cGVzIGZvciByZXNlcnZlZCBwcm9wc1xuXG5cbiAgICBpZiAoaXNSZXNlcnZlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBXYXJuIHdoZW4gYSBrbm93biBhdHRyaWJ1dGUgaXMgYSBiYWQgdHlwZVxuXG5cbiAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gV2FybiB3aGVuIHBhc3NpbmcgdGhlIHN0cmluZ3MgJ2ZhbHNlJyBvciAndHJ1ZScgaW50byBhIGJvb2xlYW4gcHJvcFxuXG5cbiAgICBpZiAoKHZhbHVlID09PSAnZmFsc2UnIHx8IHZhbHVlID09PSAndHJ1ZScpICYmIHByb3BlcnR5SW5mbyAhPT0gbnVsbCAmJiBwcm9wZXJ0eUluZm8udHlwZSA9PT0gQk9PTEVBTikge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIHRoZSBzdHJpbmcgYCVzYCBmb3IgdGhlIGJvb2xlYW4gYXR0cmlidXRlIGAlc2AuICcgKyAnJXMgJyArICdEaWQgeW91IG1lYW4gJXM9eyVzfT8nLCB2YWx1ZSwgbmFtZSwgdmFsdWUgPT09ICdmYWxzZScgPyAnVGhlIGJyb3dzZXIgd2lsbCBpbnRlcnByZXQgaXQgYXMgYSB0cnV0aHkgdmFsdWUuJyA6ICdBbHRob3VnaCB0aGlzIHdvcmtzLCBpdCB3aWxsIG5vdCB3b3JrIGFzIGV4cGVjdGVkIGlmIHlvdSBwYXNzIHRoZSBzdHJpbmcgXCJmYWxzZVwiLicsIG5hbWUsIHZhbHVlKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG52YXIgd2FyblVua25vd25Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KSB7XG4gIHtcbiAgICB2YXIgdW5rbm93blByb3BzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSQxKHR5cGUsIGtleSwgcHJvcHNba2V5XSwgZXZlbnRSZWdpc3RyeSk7XG5cbiAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICB1bmtub3duUHJvcHMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmtub3duUHJvcFN0cmluZyA9IHVua25vd25Qcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICAgIH0pLmpvaW4oJywgJyk7XG5cbiAgICBpZiAodW5rbm93blByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIHByb3AgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgaXQgZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIGl0IGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yICcsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9IGVsc2UgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgICBlcnJvcignSW52YWxpZCB2YWx1ZXMgZm9yIHByb3BzICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIHRoZW0gaW4gdGhlIERPTS4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9hdHRyaWJ1dGUtYmVoYXZpb3IgJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpIHtcbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHdhcm5Vbmtub3duUHJvcGVydGllcyh0eXBlLCBwcm9wcywgZXZlbnRSZWdpc3RyeSk7XG59XG5cbnZhciB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIC8vICdtc1RyYW5zZm9ybScgaXMgY29ycmVjdCwgYnV0IHRoZSBvdGhlciBwcmVmaXhlcyBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcbiAgdmFyIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLztcbiAgdmFyIG1zUGF0dGVybiA9IC9eLW1zLS87XG4gIHZhciBoeXBoZW5QYXR0ZXJuID0gLy0oLikvZzsgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG5cbiAgdmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcbiAgdmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XG4gIHZhciB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gZmFsc2U7XG5cbiAgdmFyIGNhbWVsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShoeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignVW5zdXBwb3J0ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCAvLyBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gICAgLy8gKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICAgIC8vIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbiAgICBjYW1lbGl6ZShuYW1lLnJlcGxhY2UobXNQYXR0ZXJuLCAnbXMtJykpKTtcbiAgfTtcblxuICB2YXIgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG5cbiAgICBlcnJvcihcIlN0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvbi4gXCIgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc05hTiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRGb3JOYU5WYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZEZvck5hTlZhbHVlID0gdHJ1ZTtcblxuICAgIGVycm9yKCdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJywgbmFtZSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRGb3JJbmZpbml0eVZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IHRydWU7XG5cbiAgICBlcnJvcignYEluZmluaXR5YCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJywgbmFtZSk7XG4gIH07XG5cbiAgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4udGVzdChuYW1lKSkge1xuICAgICAgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNOYU4obmFtZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUkMSA9IHdhcm5WYWxpZFN0eWxlO1xuXG4vLyBjb2RlIGNvcGllZCBhbmQgbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbFxudmFyIG1hdGNoSHRtbFJlZ0V4cCA9IC9bXCInJjw+XS87XG4vKipcbiAqIEVzY2FwZXMgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBIVE1MIGVudGl0aWVzIGluIGEgZ2l2ZW4gaHRtbCBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJpbmcgSFRNTCBzdHJpbmcgdG8gZXNjYXBlIGZvciBsYXRlciBpbnNlcnRpb25cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xuICB7XG4gICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oc3RyaW5nKTtcbiAgfVxuXG4gIHZhciBzdHIgPSAnJyArIHN0cmluZztcbiAgdmFyIG1hdGNoID0gbWF0Y2hIdG1sUmVnRXhwLmV4ZWMoc3RyKTtcblxuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHZhciBlc2NhcGU7XG4gIHZhciBodG1sID0gJyc7XG4gIHZhciBpbmRleDtcbiAgdmFyIGxhc3RJbmRleCA9IDA7XG5cbiAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgY2FzZSAzNDpcbiAgICAgICAgLy8gXCJcbiAgICAgICAgZXNjYXBlID0gJyZxdW90Oyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM4OlxuICAgICAgICAvLyAmXG4gICAgICAgIGVzY2FwZSA9ICcmYW1wOyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM5OlxuICAgICAgICAvLyAnXG4gICAgICAgIGVzY2FwZSA9ICcmI3gyNzsnOyAvLyBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sOyB1c2VkIHRvIGJlICcmIzM5J1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDYwOlxuICAgICAgICAvLyA8XG4gICAgICAgIGVzY2FwZSA9ICcmbHQ7JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNjI6XG4gICAgICAgIC8vID5cbiAgICAgICAgZXNjYXBlID0gJyZndDsnO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGh0bWwgKz0gc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgaHRtbCArPSBlc2NhcGU7XG4gIH1cblxuICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbn0gLy8gZW5kIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGVzY2FwZVRleHRGb3JCcm93c2VyKHRleHQpIHtcbiAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHRleHQgPT09ICdudW1iZXInKSB7XG4gICAgLy8gdGhpcyBzaG9ydGNpcmN1aXQgaGVscHMgcGVyZiBmb3IgdHlwZXMgdGhhdCB3ZSBrbm93IHdpbGwgbmV2ZXIgaGF2ZVxuICAgIC8vIHNwZWNpYWwgY2hhcmFjdGVycywgZXNwZWNpYWxseSBnaXZlbiB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBvZnRlblxuICAgIC8vIGZvciBudW1lcmljIGRvbSBpZHMuXG4gICAgcmV0dXJuICcnICsgdGV4dDtcbiAgfVxuXG4gIHJldHVybiBlc2NhcGVIdG1sKHRleHQpO1xufVxuXG52YXIgdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG52YXIgbXNQYXR0ZXJuJDEgPSAvXm1zLS87XG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqL1xuXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUobmFtZSkge1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKHVwcGVyY2FzZVBhdHRlcm4sICctJDEnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UobXNQYXR0ZXJuJDEsICctbXMtJyk7XG59XG5cbi8vIGFuZCBhbnkgbmV3bGluZSBvciB0YWIgYXJlIGZpbHRlcmVkIG91dCBhcyBpZiB0aGV5J3JlIG5vdCBwYXJ0IG9mIHRoZSBVUkwuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybC1wYXJzaW5nXG4vLyBUYWIgb3IgbmV3bGluZSBhcmUgZGVmaW5lZCBhcyBcXHJcXG5cXHQ6XG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYXNjaWktdGFiLW9yLW5ld2xpbmVcbi8vIEEgQzAgY29udHJvbCBpcyBhIGNvZGUgcG9pbnQgaW4gdGhlIHJhbmdlIFxcdTAwMDAgTlVMTCB0byBcXHUwMDFGXG4vLyBJTkZPUk1BVElPTiBTRVBBUkFUT1IgT05FLCBpbmNsdXNpdmU6XG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYzAtY29udHJvbC1vci1zcGFjZVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbnZhciBpc0phdmFTY3JpcHRQcm90b2NvbCA9IC9eW1xcdTAwMDAtXFx1MDAxRiBdKmpbXFxyXFxuXFx0XSphW1xcclxcblxcdF0qdltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSpzW1xcclxcblxcdF0qY1tcXHJcXG5cXHRdKnJbXFxyXFxuXFx0XSppW1xcclxcblxcdF0qcFtcXHJcXG5cXHRdKnRbXFxyXFxuXFx0XSpcXDovaTtcbnZhciBkaWRXYXJuID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHNhbml0aXplVVJMKHVybCkge1xuICB7XG4gICAgaWYgKCFkaWRXYXJuICYmIGlzSmF2YVNjcmlwdFByb3RvY29sLnRlc3QodXJsKSkge1xuICAgICAgZGlkV2FybiA9IHRydWU7XG5cbiAgICAgIGVycm9yKCdBIGZ1dHVyZSB2ZXJzaW9uIG9mIFJlYWN0IHdpbGwgYmxvY2sgamF2YXNjcmlwdDogVVJMcyBhcyBhIHNlY3VyaXR5IHByZWNhdXRpb24uICcgKyAnVXNlIGV2ZW50IGhhbmRsZXJzIGluc3RlYWQgaWYgeW91IGNhbi4gSWYgeW91IG5lZWQgdG8gZ2VuZXJhdGUgdW5zYWZlIEhUTUwgdHJ5ICcgKyAndXNpbmcgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgaW5zdGVhZC4gUmVhY3Qgd2FzIHBhc3NlZCAlcy4nLCBKU09OLnN0cmluZ2lmeSh1cmwpKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG52YXIgc3RhcnRJbmxpbmVTY3JpcHQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxzY3JpcHQ+Jyk7XG52YXIgZW5kSW5saW5lU2NyaXB0ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L3NjcmlwdD4nKTtcbnZhciBzdGFydFNjcmlwdFNyYyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHNjcmlwdCBzcmM9XCInKTtcbnZhciBzdGFydE1vZHVsZVNyYyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHNjcmlwdCB0eXBlPVwibW9kdWxlXCIgc3JjPVwiJyk7XG52YXIgZW5kQXN5bmNTY3JpcHQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiIGFzeW5jPVwiXCI+PC9zY3JpcHQ+Jyk7XG4vKipcbiAqIFRoaXMgZXNjYXBpbmcgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gd29yayB3aXRoIGJvb3RzdHJhcFNjcmlwdENvbnRlbnQgb25seS5cbiAqIGJlY2F1c2Ugd2Uga25vdyB3ZSBhcmUgZXNjYXBpbmcgdGhlIGVudGlyZSBzY3JpcHQuIFdlIGNhbiBhdm9pZCBmb3IgaW5zdGFuY2VcbiAqIGVzY2FwaW5nIGh0bWwgY29tbWVudCBzdHJpbmcgc2VxdWVuY2VzIHRoYXQgYXJlIHZhbGlkIGphdmFzY3JpcHQgYXMgd2VsbCBiZWNhdXNlXG4gKiBpZiB0aGVyZSBhcmUgbm8gc2Vic2VxdWVudCA8c2NyaXB0IHNlcXVlbmNlcyB0aGUgaHRtbCBwYXJzZXIgd2lsbCBuZXZlciBlbnRlclxuICogc2NyaXB0IGRhdGEgZG91YmxlIGVzY2FwZWQgc3RhdGUgKHNlZTogaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1My9zeW50YXguaHRtbCNzY3JpcHQtZGF0YS1kb3VibGUtZXNjYXBlZC1zdGF0ZSlcbiAqXG4gKiBXaGlsZSB1bnRydXN0ZWQgc2NyaXB0IGNvbnRlbnQgc2hvdWxkIGJlIG1hZGUgc2FmZSBiZWZvcmUgdXNpbmcgdGhpcyBhcGkgaXQgd2lsbFxuICogZW5zdXJlIHRoYXQgdGhlIHNjcmlwdCBjYW5ub3QgYmUgZWFybHkgdGVybWluYXRlZCBvciBuZXZlciB0ZXJtaW5hdGVkIHN0YXRlXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlQm9vdHN0cmFwU2NyaXB0Q29udGVudChzY3JpcHRUZXh0KSB7XG4gIHtcbiAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihzY3JpcHRUZXh0KTtcbiAgfVxuXG4gIHJldHVybiAoJycgKyBzY3JpcHRUZXh0KS5yZXBsYWNlKHNjcmlwdFJlZ2V4LCBzY3JpcHRSZXBsYWNlcik7XG59XG5cbnZhciBzY3JpcHRSZWdleCA9IC8oPFxcL3w8KShzKShjcmlwdCkvZ2k7XG5cbnZhciBzY3JpcHRSZXBsYWNlciA9IGZ1bmN0aW9uIChtYXRjaCwgcHJlZml4LCBzLCBzdWZmaXgpIHtcbiAgcmV0dXJuIFwiXCIgKyBwcmVmaXggKyAocyA9PT0gJ3MnID8gXCJcXFxcdTAwNzNcIiA6IFwiXFxcXHUwMDUzXCIpICsgc3VmZml4O1xufTsgLy8gQWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2Ygd2hhdCB3ZSd2ZSBhbHJlYWR5IHdyaXR0ZW4gc28gd2UgY2FuIHJlZmVyIGJhY2sgdG8gaXQuXG5cblxuZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2VTdGF0ZShpZGVudGlmaWVyUHJlZml4LCBub25jZSwgYm9vdHN0cmFwU2NyaXB0Q29udGVudCwgYm9vdHN0cmFwU2NyaXB0cywgYm9vdHN0cmFwTW9kdWxlcykge1xuICB2YXIgaWRQcmVmaXggPSBpZGVudGlmaWVyUHJlZml4ID09PSB1bmRlZmluZWQgPyAnJyA6IGlkZW50aWZpZXJQcmVmaXg7XG4gIHZhciBpbmxpbmVTY3JpcHRXaXRoTm9uY2UgPSBub25jZSA9PT0gdW5kZWZpbmVkID8gc3RhcnRJbmxpbmVTY3JpcHQgOiBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzxzY3JpcHQgbm9uY2U9XCInICsgZXNjYXBlVGV4dEZvckJyb3dzZXIobm9uY2UpICsgJ1wiPicpO1xuICB2YXIgYm9vdHN0cmFwQ2h1bmtzID0gW107XG5cbiAgaWYgKGJvb3RzdHJhcFNjcmlwdENvbnRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKGlubGluZVNjcmlwdFdpdGhOb25jZSwgc3RyaW5nVG9DaHVuayhlc2NhcGVCb290c3RyYXBTY3JpcHRDb250ZW50KGJvb3RzdHJhcFNjcmlwdENvbnRlbnQpKSwgZW5kSW5saW5lU2NyaXB0KTtcbiAgfVxuXG4gIGlmIChib290c3RyYXBTY3JpcHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb3RzdHJhcFNjcmlwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKHN0YXJ0U2NyaXB0U3JjLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGJvb3RzdHJhcFNjcmlwdHNbaV0pKSwgZW5kQXN5bmNTY3JpcHQpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChib290c3RyYXBNb2R1bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYm9vdHN0cmFwTW9kdWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIGJvb3RzdHJhcENodW5rcy5wdXNoKHN0YXJ0TW9kdWxlU3JjLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGJvb3RzdHJhcE1vZHVsZXNbX2ldKSksIGVuZEFzeW5jU2NyaXB0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJvb3RzdHJhcENodW5rczogYm9vdHN0cmFwQ2h1bmtzLFxuICAgIHN0YXJ0SW5saW5lU2NyaXB0OiBpbmxpbmVTY3JpcHRXaXRoTm9uY2UsXG4gICAgcGxhY2Vob2xkZXJQcmVmaXg6IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhpZFByZWZpeCArICdQOicpLFxuICAgIHNlZ21lbnRQcmVmaXg6IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhpZFByZWZpeCArICdTOicpLFxuICAgIGJvdW5kYXJ5UHJlZml4OiBpZFByZWZpeCArICdCOicsXG4gICAgaWRQcmVmaXg6IGlkUHJlZml4LFxuICAgIG5leHRTdXNwZW5zZUlEOiAwLFxuICAgIHNlbnRDb21wbGV0ZVNlZ21lbnRGdW5jdGlvbjogZmFsc2UsXG4gICAgc2VudENvbXBsZXRlQm91bmRhcnlGdW5jdGlvbjogZmFsc2UsXG4gICAgc2VudENsaWVudFJlbmRlckZ1bmN0aW9uOiBmYWxzZVxuICB9O1xufSAvLyBDb25zdGFudHMgZm9yIHRoZSBpbnNlcnRpb24gbW9kZSB3ZSdyZSBjdXJyZW50bHkgd3JpdGluZyBpbi4gV2UgZG9uJ3QgZW5jb2RlIGFsbCBIVE1MNSBpbnNlcnRpb25cbi8vIG1vZGVzLiBXZSBvbmx5IGluY2x1ZGUgdGhlIHZhcmlhbnRzIGFzIHRoZXkgbWF0dGVyIGZvciB0aGUgc2FrZSBvZiBvdXIgcHVycG9zZXMuXG4vLyBXZSBkb24ndCBhY3R1YWxseSBwcm92aWRlIHRoZSBuYW1lc3BhY2UgdGhlcmVmb3JlIHdlIHVzZSBjb25zdGFudHMgaW5zdGVhZCBvZiB0aGUgc3RyaW5nLlxuXG52YXIgUk9PVF9IVE1MX01PREUgPSAwOyAvLyBVc2VkIGZvciB0aGUgcm9vdCBtb3N0IGVsZW1lbnQgdGFnLlxuXG52YXIgSFRNTF9NT0RFID0gMTtcbnZhciBTVkdfTU9ERSA9IDI7XG52YXIgTUFUSE1MX01PREUgPSAzO1xudmFyIEhUTUxfVEFCTEVfTU9ERSA9IDQ7XG52YXIgSFRNTF9UQUJMRV9CT0RZX01PREUgPSA1O1xudmFyIEhUTUxfVEFCTEVfUk9XX01PREUgPSA2O1xudmFyIEhUTUxfQ09MR1JPVVBfTU9ERSA9IDc7IC8vIFdlIGhhdmUgYSBncmVhdGVyIHRoYW4gSFRNTF9UQUJMRV9NT0RFIGNoZWNrIGVsc2V3aGVyZS4gSWYgeW91IGFkZCBtb3JlIGNhc2VzIGhlcmUsIG1ha2Ugc3VyZSBpdFxuLy8gc3RpbGwgbWFrZXMgc2Vuc2VcblxuZnVuY3Rpb24gY3JlYXRlRm9ybWF0Q29udGV4dChpbnNlcnRpb25Nb2RlLCBzZWxlY3RlZFZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgaW5zZXJ0aW9uTW9kZTogaW5zZXJ0aW9uTW9kZSxcbiAgICBzZWxlY3RlZFZhbHVlOiBzZWxlY3RlZFZhbHVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvb3RGb3JtYXRDb250ZXh0KG5hbWVzcGFjZVVSSSkge1xuICB2YXIgaW5zZXJ0aW9uTW9kZSA9IG5hbWVzcGFjZVVSSSA9PT0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyA/IFNWR19NT0RFIDogbmFtZXNwYWNlVVJJID09PSAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCcgPyBNQVRITUxfTU9ERSA6IFJPT1RfSFRNTF9NT0RFO1xuICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChpbnNlcnRpb25Nb2RlLCBudWxsKTtcbn1cbmZ1bmN0aW9uIGdldENoaWxkRm9ybWF0Q29udGV4dChwYXJlbnRDb250ZXh0LCB0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBwcm9wcy52YWx1ZSAhPSBudWxsID8gcHJvcHMudmFsdWUgOiBwcm9wcy5kZWZhdWx0VmFsdWUpO1xuXG4gICAgY2FzZSAnc3ZnJzpcbiAgICAgIHJldHVybiBjcmVhdGVGb3JtYXRDb250ZXh0KFNWR19NT0RFLCBudWxsKTtcblxuICAgIGNhc2UgJ21hdGgnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoTUFUSE1MX01PREUsIG51bGwpO1xuXG4gICAgY2FzZSAnZm9yZWlnbk9iamVjdCc6XG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX01PREUsIG51bGwpO1xuICAgIC8vIFRhYmxlIHBhcmVudHMgYXJlIHNwZWNpYWwgaW4gdGhhdCB0aGVpciBjaGlsZHJlbiBjYW4gb25seSBiZSBjcmVhdGVkIGF0IGFsbCBpZiB0aGV5J3JlXG4gICAgLy8gd3JhcHBlZCBpbiBhIHRhYmxlIHBhcmVudC4gU28gd2UgbmVlZCB0byBlbmNvZGUgdGhhdCB3ZSdyZSBlbnRlcmluZyB0aGlzIG1vZGUuXG5cbiAgICBjYXNlICd0YWJsZSc6XG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX1RBQkxFX01PREUsIG51bGwpO1xuXG4gICAgY2FzZSAndGhlYWQnOlxuICAgIGNhc2UgJ3Rib2R5JzpcbiAgICBjYXNlICd0Zm9vdCc6XG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX1RBQkxFX0JPRFlfTU9ERSwgbnVsbCk7XG5cbiAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX0NPTEdST1VQX01PREUsIG51bGwpO1xuXG4gICAgY2FzZSAndHInOlxuICAgICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9UQUJMRV9ST1dfTU9ERSwgbnVsbCk7XG4gIH1cblxuICBpZiAocGFyZW50Q29udGV4dC5pbnNlcnRpb25Nb2RlID49IEhUTUxfVEFCTEVfTU9ERSkge1xuICAgIC8vIFdoYXRldmVyIHRhZyB0aGlzIHdhcywgaXQgd2Fzbid0IGEgdGFibGUgcGFyZW50IG9yIG90aGVyIHNwZWNpYWwgcGFyZW50LCBzbyB3ZSBtdXN0IGhhdmVcbiAgICAvLyBlbnRlcmVkIHBsYWluIEhUTUwgYWdhaW4uXG4gICAgcmV0dXJuIGNyZWF0ZUZvcm1hdENvbnRleHQoSFRNTF9NT0RFLCBudWxsKTtcbiAgfVxuXG4gIGlmIChwYXJlbnRDb250ZXh0Lmluc2VydGlvbk1vZGUgPT09IFJPT1RfSFRNTF9NT0RFKSB7XG4gICAgLy8gV2UndmUgZW1pdHRlZCB0aGUgcm9vdCBhbmQgaXMgbm93IGluIHBsYWluIEhUTUwgbW9kZS5cbiAgICByZXR1cm4gY3JlYXRlRm9ybWF0Q29udGV4dChIVE1MX01PREUsIG51bGwpO1xuICB9XG5cbiAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG59XG52YXIgVU5JTklUSUFMSVpFRF9TVVNQRU5TRV9CT1VOREFSWV9JRCA9IG51bGw7XG5mdW5jdGlvbiBhc3NpZ25TdXNwZW5zZUJvdW5kYXJ5SUQocmVzcG9uc2VTdGF0ZSkge1xuICB2YXIgZ2VuZXJhdGVkSUQgPSByZXNwb25zZVN0YXRlLm5leHRTdXNwZW5zZUlEKys7XG4gIHJldHVybiBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsocmVzcG9uc2VTdGF0ZS5ib3VuZGFyeVByZWZpeCArIGdlbmVyYXRlZElELnRvU3RyaW5nKDE2KSk7XG59XG5mdW5jdGlvbiBtYWtlSWQocmVzcG9uc2VTdGF0ZSwgdHJlZUlkLCBsb2NhbElkKSB7XG4gIHZhciBpZFByZWZpeCA9IHJlc3BvbnNlU3RhdGUuaWRQcmVmaXg7XG4gIHZhciBpZCA9ICc6JyArIGlkUHJlZml4ICsgJ1InICsgdHJlZUlkOyAvLyBVbmxlc3MgdGhpcyBpcyB0aGUgZmlyc3QgaWQgYXQgdGhpcyBsZXZlbCwgYXBwZW5kIGEgbnVtYmVyIGF0IHRoZSBlbmRcbiAgLy8gdGhhdCByZXByZXNlbnRzIHRoZSBwb3NpdGlvbiBvZiB0aGlzIHVzZUlkIGhvb2sgYW1vbmcgYWxsIHRoZSB1c2VJZFxuICAvLyBob29rcyBmb3IgdGhpcyBmaWJlci5cblxuICBpZiAobG9jYWxJZCA+IDApIHtcbiAgICBpZCArPSAnSCcgKyBsb2NhbElkLnRvU3RyaW5nKDMyKTtcbiAgfVxuXG4gIHJldHVybiBpZCArICc6Jztcbn1cblxuZnVuY3Rpb24gZW5jb2RlSFRNTFRleHROb2RlKHRleHQpIHtcbiAgcmV0dXJuIGVzY2FwZVRleHRGb3JCcm93c2VyKHRleHQpO1xufVxuXG52YXIgdGV4dFNlcGFyYXRvciA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPCEtLSAtLT4nKTtcbmZ1bmN0aW9uIHB1c2hUZXh0SW5zdGFuY2UodGFyZ2V0LCB0ZXh0LCByZXNwb25zZVN0YXRlLCB0ZXh0RW1iZWRkZWQpIHtcbiAgaWYgKHRleHQgPT09ICcnKSB7XG4gICAgLy8gRW1wdHkgdGV4dCBkb2Vzbid0IGhhdmUgYSBET00gbm9kZSByZXByZXNlbnRhdGlvbiBhbmQgdGhlIGh5ZHJhdGlvbiBpcyBhd2FyZSBvZiB0aGlzLlxuICAgIHJldHVybiB0ZXh0RW1iZWRkZWQ7XG4gIH1cblxuICBpZiAodGV4dEVtYmVkZGVkKSB7XG4gICAgdGFyZ2V0LnB1c2godGV4dFNlcGFyYXRvcik7XG4gIH1cblxuICB0YXJnZXQucHVzaChzdHJpbmdUb0NodW5rKGVuY29kZUhUTUxUZXh0Tm9kZSh0ZXh0KSkpO1xuICByZXR1cm4gdHJ1ZTtcbn0gLy8gQ2FsbGVkIHdoZW4gRml6eiBpcyBkb25lIHdpdGggYSBTZWdtZW50LiBDdXJyZW50bHkgdGhlIG9ubHkgcHVycG9zZSBpcyB0byBjb25kaXRpb25hbGx5XG4vLyBlbWl0IGEgdGV4dCBzZXBhcmF0b3Igd2hlbiB3ZSBkb24ndCBrbm93IGZvciBzdXJlIGl0IGlzIHNhZmUgdG8gb21pdFxuXG5mdW5jdGlvbiBwdXNoU2VnbWVudEZpbmFsZSh0YXJnZXQsIHJlc3BvbnNlU3RhdGUsIGxhc3RQdXNoZWRUZXh0LCB0ZXh0RW1iZWRkZWQpIHtcbiAgaWYgKGxhc3RQdXNoZWRUZXh0ICYmIHRleHRFbWJlZGRlZCkge1xuICAgIHRhcmdldC5wdXNoKHRleHRTZXBhcmF0b3IpO1xuICB9XG59XG52YXIgc3R5bGVOYW1lQ2FjaGUgPSBuZXcgTWFwKCk7XG5cbmZ1bmN0aW9uIHByb2Nlc3NTdHlsZU5hbWUoc3R5bGVOYW1lKSB7XG4gIHZhciBjaHVuayA9IHN0eWxlTmFtZUNhY2hlLmdldChzdHlsZU5hbWUpO1xuXG4gIGlmIChjaHVuayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGNodW5rO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKSkpO1xuICBzdHlsZU5hbWVDYWNoZS5zZXQoc3R5bGVOYW1lLCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgc3R5bGVBdHRyaWJ1dGVTdGFydCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnIHN0eWxlPVwiJyk7XG52YXIgc3R5bGVBc3NpZ24gPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzonKTtcbnZhciBzdHlsZVNlcGFyYXRvciA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnOycpO1xuXG5mdW5jdGlvbiBwdXNoU3R5bGUodGFyZ2V0LCByZXNwb25zZVN0YXRlLCBzdHlsZSkge1xuICBpZiAodHlwZW9mIHN0eWxlICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCAnICsgXCJub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgJ2VtJ319IHdoZW4gXCIgKyAndXNpbmcgSlNYLicpO1xuICB9XG5cbiAgdmFyIGlzRmlyc3QgPSB0cnVlO1xuXG4gIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZSkge1xuICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChzdHlsZSwgc3R5bGVOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBJZiB5b3UgcHJvdmlkZSB1bnNhZmUgdXNlciBkYXRhIGhlcmUgdGhleSBjYW4gaW5qZWN0IGFyYml0cmFyeSBDU1NcbiAgICAvLyB3aGljaCBtYXkgYmUgcHJvYmxlbWF0aWMgKEkgY291bGRuJ3QgcmVwcm8gdGhpcyk6XG4gICAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXRcbiAgICAvLyBodHRwOi8vd3d3LnRoZXNwYW5uZXIuY28udWsvMjAwNy8xMS8yNi91bHRpbWF0ZS14c3MtY3NzLWluamVjdGlvbi9cbiAgICAvLyBUaGlzIGlzIG5vdCBhbiBYU1MgaG9sZSBidXQgaW5zdGVhZCBhIHBvdGVudGlhbCBDU1MgaW5qZWN0aW9uIGlzc3VlXG4gICAgLy8gd2hpY2ggaGFzIGxlYWQgdG8gYSBncmVhdGVyIGRpc2N1c3Npb24gYWJvdXQgaG93IHdlJ3JlIGdvaW5nIHRvXG4gICAgLy8gdHJ1c3QgVVJMcyBtb3ZpbmcgZm9yd2FyZC4gU2VlICMyMTE1OTAxXG5cblxuICAgIHZhciBzdHlsZVZhbHVlID0gc3R5bGVbc3R5bGVOYW1lXTtcblxuICAgIGlmIChzdHlsZVZhbHVlID09IG51bGwgfHwgdHlwZW9mIHN0eWxlVmFsdWUgPT09ICdib29sZWFuJyB8fCBzdHlsZVZhbHVlID09PSAnJykge1xuICAgICAgLy8gVE9ETzogV2UgdXNlZCB0byBzZXQgZW1wdHkgc3RyaW5nIGFzIGEgc3R5bGUgd2l0aCBhbiBlbXB0eSB2YWx1ZS4gRG9lcyB0aGF0IGV2ZXIgbWFrZSBzZW5zZT9cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBuYW1lQ2h1bmsgPSB2b2lkIDA7XG4gICAgdmFyIHZhbHVlQ2h1bmsgPSB2b2lkIDA7XG4gICAgdmFyIGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcblxuICAgIGlmIChpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICBuYW1lQ2h1bmsgPSBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHN0eWxlTmFtZSkpO1xuXG4gICAgICB7XG4gICAgICAgIGNoZWNrQ1NTUHJvcGVydHlTdHJpbmdDb2VyY2lvbihzdHlsZVZhbHVlLCBzdHlsZU5hbWUpO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZUNodW5rID0gc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcigoJycgKyBzdHlsZVZhbHVlKS50cmltKCkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZSQxKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIG5hbWVDaHVuayA9IHByb2Nlc3NTdHlsZU5hbWUoc3R5bGVOYW1lKTtcblxuICAgICAgaWYgKHR5cGVvZiBzdHlsZVZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoc3R5bGVWYWx1ZSAhPT0gMCAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChpc1VuaXRsZXNzTnVtYmVyLCBzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgdmFsdWVDaHVuayA9IHN0cmluZ1RvQ2h1bmsoc3R5bGVWYWx1ZSArICdweCcpOyAvLyBQcmVzdW1lcyBpbXBsaWNpdCAncHgnIHN1ZmZpeCBmb3IgdW5pdGxlc3MgbnVtYmVyc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlQ2h1bmsgPSBzdHJpbmdUb0NodW5rKCcnICsgc3R5bGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24oc3R5bGVWYWx1ZSwgc3R5bGVOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlQ2h1bmsgPSBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKCgnJyArIHN0eWxlVmFsdWUpLnRyaW0oKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICBpc0ZpcnN0ID0gZmFsc2U7IC8vIElmIGl0J3MgZmlyc3QsIHdlIGRvbid0IG5lZWQgYW55IHNlcGFyYXRvcnMgcHJlZml4ZWQuXG5cbiAgICAgIHRhcmdldC5wdXNoKHN0eWxlQXR0cmlidXRlU3RhcnQsIG5hbWVDaHVuaywgc3R5bGVBc3NpZ24sIHZhbHVlQ2h1bmspO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQucHVzaChzdHlsZVNlcGFyYXRvciwgbmFtZUNodW5rLCBzdHlsZUFzc2lnbiwgdmFsdWVDaHVuayk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFpc0ZpcnN0KSB7XG4gICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlRW5kKTtcbiAgfVxufVxuXG52YXIgYXR0cmlidXRlU2VwYXJhdG9yID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgJyk7XG52YXIgYXR0cmlidXRlQXNzaWduID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc9XCInKTtcbnZhciBhdHRyaWJ1dGVFbmQgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiJyk7XG52YXIgYXR0cmlidXRlRW1wdHlTdHJpbmcgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJz1cIlwiJyk7XG5cbmZ1bmN0aW9uIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCByZXNwb25zZVN0YXRlLCBuYW1lLCB2YWx1ZSkge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdzdHlsZSc6XG4gICAgICB7XG4gICAgICAgIHB1c2hTdHlsZSh0YXJnZXQsIHJlc3BvbnNlU3RhdGUsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZGVmYXVsdFZhbHVlJzpcbiAgICBjYXNlICdkZWZhdWx0Q2hlY2tlZCc6IC8vIFRoZXNlIHNob3VsZG4ndCBiZSBzZXQgYXMgYXR0cmlidXRlcyBvbiBnZW5lcmljIEhUTUwgZWxlbWVudHMuXG5cbiAgICBjYXNlICdpbm5lckhUTUwnOiAvLyBNdXN0IHVzZSBkYW5nZXJvdXNseVNldElubmVySFRNTCBpbnN0ZWFkLlxuXG4gICAgY2FzZSAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJzpcbiAgICBjYXNlICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnOlxuICAgICAgLy8gSWdub3JlZC4gVGhlc2UgYXJlIGJ1aWx0LWluIHRvIFJlYWN0IG9uIHRoZSBjbGllbnQuXG4gICAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIC8vIHNob3VsZElnbm9yZUF0dHJpYnV0ZVxuICAvLyBXZSBoYXZlIGFscmVhZHkgZmlsdGVyZWQgb3V0IG51bGwvdW5kZWZpbmVkIGFuZCByZXNlcnZlZCB3b3Jkcy5cbiAgbmFtZS5sZW5ndGggPiAyICYmIChuYW1lWzBdID09PSAnbycgfHwgbmFtZVswXSA9PT0gJ08nKSAmJiAobmFtZVsxXSA9PT0gJ24nIHx8IG5hbWVbMV0gPT09ICdOJykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuXG4gIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICAvLyBzaG91bGRSZW1vdmVBdHRyaWJ1dGVcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgY2FzZSAnZnVuY3Rpb24nOiAvLyAkRmxvd0lzc3VlIHN5bWJvbCBpcyBwZXJmZWN0bHkgdmFsaWQgaGVyZVxuXG4gICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIXByb3BlcnR5SW5mby5hY2NlcHRzQm9vbGVhbnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgIHZhciBhdHRyaWJ1dGVOYW1lQ2h1bmsgPSBzdHJpbmdUb0NodW5rKGF0dHJpYnV0ZU5hbWUpOyAvLyBUT0RPOiBJZiBpdCdzIGtub3duIHdlIGNhbiBjYWNoZSB0aGUgY2h1bmsuXG5cbiAgICBzd2l0Y2ggKHByb3BlcnR5SW5mby50eXBlKSB7XG4gICAgICBjYXNlIEJPT0xFQU46XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgYXR0cmlidXRlTmFtZUNodW5rLCBhdHRyaWJ1dGVFbXB0eVN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgT1ZFUkxPQURFRF9CT09MRUFOOlxuICAgICAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIGF0dHJpYnV0ZU5hbWVDaHVuaywgYXR0cmlidXRlRW1wdHlTdHJpbmcpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBmYWxzZSkgOyBlbHNlIHtcbiAgICAgICAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIGF0dHJpYnV0ZU5hbWVDaHVuaywgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksIGF0dHJpYnV0ZUVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgTlVNRVJJQzpcbiAgICAgICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICB0YXJnZXQucHVzaChhdHRyaWJ1dGVTZXBhcmF0b3IsIGF0dHJpYnV0ZU5hbWVDaHVuaywgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSksIGF0dHJpYnV0ZUVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBQT1NJVElWRV9OVU1FUklDOlxuICAgICAgICBpZiAoIWlzTmFOKHZhbHVlKSAmJiB2YWx1ZSA+PSAxKSB7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBhdHRyaWJ1dGVOYW1lQ2h1bmssIGF0dHJpYnV0ZUFzc2lnbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSkpLCBhdHRyaWJ1dGVFbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8uc2FuaXRpemVVUkwpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICAgICAgc2FuaXRpemVVUkwodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBhdHRyaWJ1dGVOYW1lQ2h1bmssIGF0dHJpYnV0ZUFzc2lnbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSkpLCBhdHRyaWJ1dGVFbmQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgLy8gc2hvdWxkUmVtb3ZlQXR0cmlidXRlXG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzogLy8gJEZsb3dJc3N1ZSBzeW1ib2wgaXMgcGVyZmVjdGx5IHZhbGlkIGhlcmVcblxuICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByZWZpeCA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLCA1KTtcblxuICAgICAgICAgIGlmIChwcmVmaXggIT09ICdkYXRhLScgJiYgcHJlZml4ICE9PSAnYXJpYS0nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGFyZ2V0LnB1c2goYXR0cmlidXRlU2VwYXJhdG9yLCBzdHJpbmdUb0NodW5rKG5hbWUpLCBhdHRyaWJ1dGVBc3NpZ24sIHN0cmluZ1RvQ2h1bmsoZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpKSwgYXR0cmlidXRlRW5kKTtcbiAgfVxufVxuXG52YXIgZW5kT2ZTdGFydFRhZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPicpO1xudmFyIGVuZE9mU3RhcnRUYWdTZWxmQ2xvc2luZyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnLz4nKTtcblxuZnVuY3Rpb24gcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pIHtcbiAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbm5lckhUTUwgIT09ICdvYmplY3QnIHx8ICEoJ19faHRtbCcgaW4gaW5uZXJIVE1MKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiAnICsgJ1BsZWFzZSB2aXNpdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgJyArICdmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgaHRtbCA9IGlubmVySFRNTC5fX2h0bWw7XG5cbiAgICBpZiAoaHRtbCAhPT0gbnVsbCAmJiBodG1sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oaHRtbCk7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC5wdXNoKHN0cmluZ1RvQ2h1bmsoJycgKyBodG1sKSk7XG4gICAgfVxuICB9XG59IC8vIFRPRE86IE1vdmUgdGhlc2UgdG8gUmVzcG9uc2VTdGF0ZSBzbyB0aGF0IHdlIHdhcm4gZm9yIGV2ZXJ5IHJlcXVlc3QuXG4vLyBJdCB3b3VsZCBoZWxwIGRlYnVnZ2luZyBpbiBzdGF0ZWZ1bCBzZXJ2ZXJzIChlLmcuIHNlcnZpY2Ugd29ya2VyKS5cblxuXG52YXIgZGlkV2FybkRlZmF1bHRJbnB1dFZhbHVlID0gZmFsc2U7XG52YXIgZGlkV2FybkRlZmF1bHRDaGVja2VkID0gZmFsc2U7XG52YXIgZGlkV2FybkRlZmF1bHRTZWxlY3RWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSBmYWxzZTtcbnZhciBkaWRXYXJuSW52YWxpZE9wdGlvbklubmVySFRNTCA9IGZhbHNlO1xudmFyIGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGNoZWNrU2VsZWN0UHJvcChwcm9wcywgcHJvcE5hbWUpIHtcbiAge1xuICAgIHZhciB2YWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcblxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICB2YXIgYXJyYXkgPSBpc0FycmF5KHZhbHVlKTtcblxuICAgICAgaWYgKHByb3BzLm11bHRpcGxlICYmICFhcnJheSkge1xuICAgICAgICBlcnJvcignVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcgKyAnYG11bHRpcGxlYCBpcyB0cnVlLicsIHByb3BOYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoIXByb3BzLm11bHRpcGxlICYmIGFycmF5KSB7XG4gICAgICAgIGVycm9yKCdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgJyArICd2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLicsIHByb3BOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaFN0YXJ0U2VsZWN0KHRhcmdldCwgcHJvcHMsIHJlc3BvbnNlU3RhdGUpIHtcbiAge1xuICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoJ3NlbGVjdCcsIHByb3BzKTtcbiAgICBjaGVja1NlbGVjdFByb3AocHJvcHMsICd2YWx1ZScpO1xuICAgIGNoZWNrU2VsZWN0UHJvcChwcm9wcywgJ2RlZmF1bHRWYWx1ZScpO1xuXG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUpIHtcbiAgICAgIGVycm9yKCdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG5cbiAgICAgIGRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ3NlbGVjdCcpKTtcbiAgdmFyIGNoaWxkcmVuID0gbnVsbDtcbiAgdmFyIGlubmVySFRNTCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIC8vIFRPRE86IFRoaXMgZG9lc24ndCByZWFsbHkgbWFrZSBzZW5zZSBmb3Igc2VsZWN0IHNpbmNlIGl0IGNhbid0IHVzZSB0aGUgY29udHJvbGxlZFxuICAgICAgICAgIC8vIHZhbHVlIGluIHRoZSBpbm5lckhUTUwuXG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2RlZmF1bHRWYWx1ZSc6XG4gICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICAvLyBUaGVzZSBhcmUgc2V0IG9uIHRoZSBDb250ZXh0IGluc3RlYWQgYW5kIGFwcGxpZWQgdG8gdGhlIG5lc3RlZCBvcHRpb25zLlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHJlc3BvbnNlU3RhdGUsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gIHB1c2hJbm5lckhUTUwodGFyZ2V0LCBpbm5lckhUTUwsIGNoaWxkcmVuKTtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuT3B0aW9uQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIGNvbnRlbnQgPSAnJzsgLy8gRmxhdHRlbiBjaGlsZHJlbiBhbmQgd2FybiBpZiB0aGV5IGFyZW4ndCBzdHJpbmdzIG9yIG51bWJlcnM7XG4gIC8vIGludmFsaWQgdHlwZXMgYXJlIGlnbm9yZWQuXG5cbiAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250ZW50ICs9IGNoaWxkO1xuXG4gICAge1xuICAgICAgaWYgKCFkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuICYmIHR5cGVvZiBjaGlsZCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGNoaWxkICE9PSAnbnVtYmVyJykge1xuICAgICAgICBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignQ2Fubm90IGluZmVyIHRoZSBvcHRpb24gdmFsdWUgb2YgY29tcGxleCBjaGlsZHJlbi4gJyArICdQYXNzIGEgYHZhbHVlYCBwcm9wIG9yIHVzZSBhIHBsYWluIHN0cmluZyBhcyBjaGlsZHJlbiB0byA8b3B0aW9uPi4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY29udGVudDtcbn1cblxudmFyIHNlbGVjdGVkTWFya2VyQXR0cmlidXRlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgc2VsZWN0ZWQ9XCJcIicpO1xuXG5mdW5jdGlvbiBwdXNoU3RhcnRPcHRpb24odGFyZ2V0LCBwcm9wcywgcmVzcG9uc2VTdGF0ZSwgZm9ybWF0Q29udGV4dCkge1xuICB2YXIgc2VsZWN0ZWRWYWx1ZSA9IGZvcm1hdENvbnRleHQuc2VsZWN0ZWRWYWx1ZTtcbiAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZygnb3B0aW9uJykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICB2YXIgdmFsdWUgPSBudWxsO1xuICB2YXIgc2VsZWN0ZWQgPSBudWxsO1xuICB2YXIgaW5uZXJIVE1MID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgICBjaGlsZHJlbiA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzZWxlY3RlZCc6XG4gICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgc2VsZWN0ZWQgPSBwcm9wVmFsdWU7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cbiAgICAgICAgICAgIGlmICghZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24pIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpO1xuXG4gICAgICAgICAgICAgIGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgaW5uZXJIVE1MID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUtbm8tZmFsbHRocm91Z2hcblxuICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgdmFsdWUgPSBwcm9wVmFsdWU7XG4gICAgICAgIC8vIFdlIGludGVudGlvbmFsbHkgZmFsbHRocm91Z2ggdG8gYWxzbyBzZXQgdGhlIGF0dHJpYnV0ZSBvbiB0aGUgbm9kZS5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lLW5vLWZhbGx0aHJvdWdoXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcmVzcG9uc2VTdGF0ZSwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc2VsZWN0ZWRWYWx1ZSAhPSBudWxsKSB7XG4gICAgdmFyIHN0cmluZ1ZhbHVlO1xuXG4gICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsICd2YWx1ZScpO1xuICAgICAgfVxuXG4gICAgICBzdHJpbmdWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGlubmVySFRNTCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICghZGlkV2FybkludmFsaWRPcHRpb25Jbm5lckhUTUwpIHtcbiAgICAgICAgICAgIGRpZFdhcm5JbnZhbGlkT3B0aW9uSW5uZXJIVE1MID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1Bhc3MgYSBgdmFsdWVgIHByb3AgaWYgeW91IHNldCBkYW5nZXJvdXNseUlubmVySFRNTCBzbyBSZWFjdCBrbm93cyAnICsgJ3doaWNoIHZhbHVlIHNob3VsZCBiZSBzZWxlY3RlZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RyaW5nVmFsdWUgPSBmbGF0dGVuT3B0aW9uQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KHNlbGVjdGVkVmFsdWUpKSB7XG4gICAgICAvLyBtdWx0aXBsZVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uKHNlbGVjdGVkVmFsdWVbaV0sICd2YWx1ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHYgPSAnJyArIHNlbGVjdGVkVmFsdWVbaV07XG5cbiAgICAgICAgaWYgKHYgPT09IHN0cmluZ1ZhbHVlKSB7XG4gICAgICAgICAgdGFyZ2V0LnB1c2goc2VsZWN0ZWRNYXJrZXJBdHRyaWJ1dGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihzZWxlY3RlZFZhbHVlLCAnc2VsZWN0LnZhbHVlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICgnJyArIHNlbGVjdGVkVmFsdWUgPT09IHN0cmluZ1ZhbHVlKSB7XG4gICAgICAgIHRhcmdldC5wdXNoKHNlbGVjdGVkTWFya2VyQXR0cmlidXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoc2VsZWN0ZWQpIHtcbiAgICB0YXJnZXQucHVzaChzZWxlY3RlZE1hcmtlckF0dHJpYnV0ZSk7XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIHB1c2hJbnB1dCh0YXJnZXQsIHByb3BzLCByZXNwb25zZVN0YXRlKSB7XG4gIHtcbiAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKCdpbnB1dCcsIHByb3BzKTtcblxuICAgIGlmIChwcm9wcy5jaGVja2VkICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkRlZmF1bHRDaGVja2VkKSB7XG4gICAgICBlcnJvcignJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggY2hlY2tlZCBhbmQgZGVmYXVsdENoZWNrZWQgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIGNoZWNrZWQgcHJvcCwgb3IgdGhlIGRlZmF1bHRDaGVja2VkIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJywgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG5cbiAgICAgIGRpZFdhcm5EZWZhdWx0Q2hlY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5EZWZhdWx0SW5wdXRWYWx1ZSkge1xuICAgICAgZXJyb3IoJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnLCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcblxuICAgICAgZGlkV2FybkRlZmF1bHRJbnB1dFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKCdpbnB1dCcpKTtcbiAgdmFyIHZhbHVlID0gbnVsbDtcbiAgdmFyIGRlZmF1bHRWYWx1ZSA9IG51bGw7XG4gIHZhciBjaGVja2VkID0gbnVsbDtcbiAgdmFyIGRlZmF1bHRDaGVja2VkID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQnICsgXCIgaXMgYSBzZWxmLWNsb3NpbmcgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciBcIiArICd1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lLW5vLWZhbGx0aHJvdWdoXG5cbiAgICAgICAgY2FzZSAnZGVmYXVsdENoZWNrZWQnOlxuICAgICAgICAgIGRlZmF1bHRDaGVja2VkID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2RlZmF1bHRWYWx1ZSc6XG4gICAgICAgICAgZGVmYXVsdFZhbHVlID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICAgIGNoZWNrZWQgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIHZhbHVlID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHJlc3BvbnNlU3RhdGUsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGNoZWNrZWQgIT09IG51bGwpIHtcbiAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcmVzcG9uc2VTdGF0ZSwgJ2NoZWNrZWQnLCBjaGVja2VkKTtcbiAgfSBlbHNlIGlmIChkZWZhdWx0Q2hlY2tlZCAhPT0gbnVsbCkge1xuICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCByZXNwb25zZVN0YXRlLCAnY2hlY2tlZCcsIGRlZmF1bHRDaGVja2VkKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCByZXNwb25zZVN0YXRlLCAndmFsdWUnLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZGVmYXVsdFZhbHVlICE9PSBudWxsKSB7XG4gICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHJlc3BvbnNlU3RhdGUsICd2YWx1ZScsIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXJ0VGV4dEFyZWEodGFyZ2V0LCBwcm9wcywgcmVzcG9uc2VTdGF0ZSkge1xuICB7XG4gICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygndGV4dGFyZWEnLCBwcm9wcyk7XG5cbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkRlZmF1bHRUZXh0YXJlYVZhbHVlKSB7XG4gICAgICBlcnJvcignVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHRleHRhcmVhICcgKyAnYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG5cbiAgICAgIGRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZygndGV4dGFyZWEnKSk7XG4gIHZhciB2YWx1ZSA9IG51bGw7XG4gIHZhciBkZWZhdWx0VmFsdWUgPSBudWxsO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICB2YWx1ZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkZWZhdWx0VmFsdWUnOlxuICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYW5nZXJvdXNseVNldElubmVySFRNTCc6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi4nKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lLW5vLWZhbGx0aHJvdWdoXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcmVzcG9uc2VTdGF0ZSwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodmFsdWUgPT09IG51bGwgJiYgZGVmYXVsdFZhbHVlICE9PSBudWxsKSB7XG4gICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTsgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cblxuICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgIHtcbiAgICAgIGVycm9yKCdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgaW5zdGVhZCBvZiBzZXR0aW5nICcgKyAnY2hpbGRyZW4gb24gPHRleHRhcmVhPi4nKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJZiB5b3Ugc3VwcGx5IGBkZWZhdWx0VmFsdWVgIG9uIGEgPHRleHRhcmVhPiwgZG8gbm90IHBhc3MgY2hpbGRyZW4uJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKTtcbiAgICAgIH0gLy8gVE9ETzogcmVtb3ZlIHRoZSBjb2VyY2lvbiBhbmQgdGhlIERFViBjaGVjayBiZWxvdyBiZWNhdXNlIGl0IHdpbGxcbiAgICAgIC8vIGFsd2F5cyBiZSBvdmVyd3JpdHRlbiBieSB0aGUgY29lcmNpb24gc2V2ZXJhbCBsaW5lcyBiZWxvdyBpdC4gIzIyMzA5XG5cblxuICAgICAge1xuICAgICAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihjaGlsZHJlblswXSk7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gJycgKyBjaGlsZHJlblswXTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbihjaGlsZHJlbik7XG4gICAgfVxuXG4gICAgdmFsdWUgPSAnJyArIGNoaWxkcmVuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWVbMF0gPT09ICdcXG4nKSB7XG4gICAgLy8gdGV4dC9odG1sIGlnbm9yZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGVzZSB0YWdzIGlmIGl0J3MgYSBuZXdsaW5lXG4gICAgLy8gUHJlZmVyIHRvIGJyZWFrIGFwcGxpY2F0aW9uL3htbCBvdmVyIHRleHQvaHRtbCAoZm9yIG5vdykgYnkgYWRkaW5nXG4gICAgLy8gYSBuZXdsaW5lIHNwZWNpZmljYWxseSB0byBnZXQgZWF0ZW4gYnkgdGhlIHBhcnNlci4gKEFsdGVybmF0ZWx5IGZvclxuICAgIC8vIHRleHRhcmVhcywgcmVwbGFjaW5nIFwiXlxcblwiIHdpdGggXCJcXHJcXG5cIiBkb2Vzbid0IGdldCBlYXRlbiwgYW5kIHRoZSBmaXJzdFxuICAgIC8vIFxcciBpcyBub3JtYWxpemVkIG91dCBieSBIVE1MVGV4dEFyZWFFbGVtZW50I3ZhbHVlLilcbiAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sLXBvbHlnbG90LyNuZXdsaW5lcy1pbi10ZXh0YXJlYS1hbmQtcHJlPlxuICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2VsZW1lbnQtcmVzdHJpY3Rpb25zPlxuICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI25ld2xpbmVzPlxuICAgIC8vIFNlZTogUGFyc2luZyBvZiBcInRleHRhcmVhXCIgXCJsaXN0aW5nXCIgYW5kIFwicHJlXCIgZWxlbWVudHNcbiAgICAvLyAgZnJvbSA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keT5cbiAgICB0YXJnZXQucHVzaChsZWFkaW5nTmV3bGluZSk7XG4gIH0gLy8gVG9TdHJpbmcgYW5kIHB1c2ggZGlyZWN0bHkgaW5zdGVhZCBvZiByZWN1cnNlIG92ZXIgY2hpbGRyZW4uXG4gIC8vIFdlIGRvbid0IHJlYWxseSBzdXBwb3J0IGNvbXBsZXggY2hpbGRyZW4gaW4gdGhlIHZhbHVlIGFueXdheS5cbiAgLy8gVGhpcyBhbHNvIGN1cnJlbnRseSBhdm9pZHMgYSB0cmFpbGluZyBjb21tZW50IG5vZGUgd2hpY2ggYnJlYWtzIHRleHRhcmVhLlxuXG5cbiAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAge1xuICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgJ3ZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlbmNvZGVIVE1MVGV4dE5vZGUoJycgKyB2YWx1ZSkpKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwdXNoU2VsZkNsb3NpbmcodGFyZ2V0LCBwcm9wcywgdGFnLCByZXNwb25zZVN0YXRlKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSk7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGFnICsgXCIgaXMgYSBzZWxmLWNsb3NpbmcgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciBcIiArICd1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lLW5vLWZhbGx0aHJvdWdoXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcmVzcG9uc2VTdGF0ZSwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmcpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXJ0TWVudUl0ZW0odGFyZ2V0LCBwcm9wcywgcmVzcG9uc2VTdGF0ZSkge1xuICB0YXJnZXQucHVzaChzdGFydENodW5rRm9yVGFnKCdtZW51aXRlbScpKTtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgIGNhc2UgJ2NoaWxkcmVuJzpcbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWVudWl0ZW1zIGNhbm5vdCBoYXZlIGBjaGlsZHJlbmAgbm9yIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZS1uby1mYWxsdGhyb3VnaFxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaEF0dHJpYnV0ZSh0YXJnZXQsIHJlc3BvbnNlU3RhdGUsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0LnB1c2goZW5kT2ZTdGFydFRhZyk7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwdXNoU3RhcnRUaXRsZSh0YXJnZXQsIHByb3BzLCByZXNwb25zZVN0YXRlKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcoJ3RpdGxlJykpO1xuICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BkYW5nZXJvdXNseVNldElubmVySFRNTGAgZG9lcyBub3QgbWFrZSBzZW5zZSBvbiA8dGl0bGU+LicpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUtbm8tZmFsbHRocm91Z2hcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCByZXNwb25zZVN0YXRlLCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuXG4gIHtcbiAgICB2YXIgY2hpbGQgPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPCAyID8gY2hpbGRyZW5bMF0gfHwgbnVsbCA6IGNoaWxkcmVuO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIGVycm9yKCdBIHRpdGxlIGVsZW1lbnQgcmVjZWl2ZWQgYW4gYXJyYXkgd2l0aCBtb3JlIHRoYW4gMSBlbGVtZW50IGFzIGNoaWxkcmVuLiAnICsgJ0luIGJyb3dzZXJzIHRpdGxlIEVsZW1lbnRzIGNhbiBvbmx5IGhhdmUgVGV4dCBOb2RlcyBhcyBjaGlsZHJlbi4gSWYgJyArICd0aGUgY2hpbGRyZW4gYmVpbmcgcmVuZGVyZWQgb3V0cHV0IG1vcmUgdGhhbiBhIHNpbmdsZSB0ZXh0IG5vZGUgaW4gYWdncmVnYXRlIHRoZSBicm93c2VyICcgKyAnd2lsbCBkaXNwbGF5IG1hcmt1cCBhbmQgY29tbWVudHMgYXMgdGV4dCBpbiB0aGUgdGl0bGUgYW5kIGh5ZHJhdGlvbiB3aWxsIGxpa2VseSBmYWlsIGFuZCAnICsgJ2ZhbGwgYmFjayB0byBjbGllbnQgcmVuZGVyaW5nJyk7XG4gICAgfSBlbHNlIGlmIChjaGlsZCAhPSBudWxsICYmIGNoaWxkLiQkdHlwZW9mICE9IG51bGwpIHtcbiAgICAgIGVycm9yKCdBIHRpdGxlIGVsZW1lbnQgcmVjZWl2ZWQgYSBSZWFjdCBlbGVtZW50IGZvciBjaGlsZHJlbi4gJyArICdJbiB0aGUgYnJvd3NlciB0aXRsZSBFbGVtZW50cyBjYW4gb25seSBoYXZlIFRleHQgTm9kZXMgYXMgY2hpbGRyZW4uIElmICcgKyAndGhlIGNoaWxkcmVuIGJlaW5nIHJlbmRlcmVkIG91dHB1dCBtb3JlIHRoYW4gYSBzaW5nbGUgdGV4dCBub2RlIGluIGFnZ3JlZ2F0ZSB0aGUgYnJvd3NlciAnICsgJ3dpbGwgZGlzcGxheSBtYXJrdXAgYW5kIGNvbW1lbnRzIGFzIHRleHQgaW4gdGhlIHRpdGxlIGFuZCBoeWRyYXRpb24gd2lsbCBsaWtlbHkgZmFpbCBhbmQgJyArICdmYWxsIGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZycpO1xuICAgIH0gZWxzZSBpZiAoY2hpbGQgIT0gbnVsbCAmJiB0eXBlb2YgY2hpbGQgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBjaGlsZCAhPT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdBIHRpdGxlIGVsZW1lbnQgcmVjZWl2ZWQgYSB2YWx1ZSB0aGF0IHdhcyBub3QgYSBzdHJpbmcgb3IgbnVtYmVyIGZvciBjaGlsZHJlbi4gJyArICdJbiB0aGUgYnJvd3NlciB0aXRsZSBFbGVtZW50cyBjYW4gb25seSBoYXZlIFRleHQgTm9kZXMgYXMgY2hpbGRyZW4uIElmICcgKyAndGhlIGNoaWxkcmVuIGJlaW5nIHJlbmRlcmVkIG91dHB1dCBtb3JlIHRoYW4gYSBzaW5nbGUgdGV4dCBub2RlIGluIGFnZ3JlZ2F0ZSB0aGUgYnJvd3NlciAnICsgJ3dpbGwgZGlzcGxheSBtYXJrdXAgYW5kIGNvbW1lbnRzIGFzIHRleHQgaW4gdGhlIHRpdGxlIGFuZCBoeWRyYXRpb24gd2lsbCBsaWtlbHkgZmFpbCBhbmQgJyArICdmYWxsIGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQodGFyZ2V0LCBwcm9wcywgdGFnLCByZXNwb25zZVN0YXRlKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSk7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXNoQXR0cmlidXRlKHRhcmdldCwgcmVzcG9uc2VTdGF0ZSwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0YXJnZXQucHVzaChlbmRPZlN0YXJ0VGFnKTtcbiAgcHVzaElubmVySFRNTCh0YXJnZXQsIGlubmVySFRNTCwgY2hpbGRyZW4pO1xuXG4gIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlIGNoaWxkcmVuIGFzIGEgc3RyaW5nIHRvIGF2b2lkIHRoZSB1bm5lY2Vzc2FyeSBjb21tZW50LlxuICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIHNwZWNpYWwgY2FzZSBhZnRlciB0aGUgZ2VuZXJhbCBvcHRpbWl6YXRpb24gaXMgaW4gcGxhY2UuXG4gICAgdGFyZ2V0LnB1c2goc3RyaW5nVG9DaHVuayhlbmNvZGVIVE1MVGV4dE5vZGUoY2hpbGRyZW4pKSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGFydEN1c3RvbUVsZW1lbnQodGFyZ2V0LCBwcm9wcywgdGFnLCByZXNwb25zZVN0YXRlKSB7XG4gIHRhcmdldC5wdXNoKHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSk7XG4gIHZhciBjaGlsZHJlbiA9IG51bGw7XG4gIHZhciBpbm5lckhUTUwgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgcHJvcEtleSkpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHByb3BLZXkpIHtcbiAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgIGNoaWxkcmVuID0gcHJvcFZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJzpcbiAgICAgICAgICBpbm5lckhUTUwgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc3R5bGUnOlxuICAgICAgICAgIHB1c2hTdHlsZSh0YXJnZXQsIHJlc3BvbnNlU3RhdGUsIHByb3BWYWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJzpcbiAgICAgICAgY2FzZSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJzpcbiAgICAgICAgICAvLyBJZ25vcmVkLiBUaGVzZSBhcmUgYnVpbHQtaW4gdG8gUmVhY3Qgb24gdGhlIGNsaWVudC5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChpc0F0dHJpYnV0ZU5hbWVTYWZlKHByb3BLZXkpICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKGF0dHJpYnV0ZVNlcGFyYXRvciwgc3RyaW5nVG9DaHVuayhwcm9wS2V5KSwgYXR0cmlidXRlQXNzaWduLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKHByb3BWYWx1ZSkpLCBhdHRyaWJ1dGVFbmQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpO1xuICBwdXNoSW5uZXJIVE1MKHRhcmdldCwgaW5uZXJIVE1MLCBjaGlsZHJlbik7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxudmFyIGxlYWRpbmdOZXdsaW5lID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcXG4nKTtcblxuZnVuY3Rpb24gcHVzaFN0YXJ0UHJlZm9ybWF0dGVkRWxlbWVudCh0YXJnZXQsIHByb3BzLCB0YWcsIHJlc3BvbnNlU3RhdGUpIHtcbiAgdGFyZ2V0LnB1c2goc3RhcnRDaHVua0ZvclRhZyh0YWcpKTtcbiAgdmFyIGNoaWxkcmVuID0gbnVsbDtcbiAgdmFyIGlubmVySFRNTCA9IG51bGw7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocHJvcEtleSkge1xuICAgICAgICBjYXNlICdjaGlsZHJlbic6XG4gICAgICAgICAgY2hpbGRyZW4gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnOlxuICAgICAgICAgIGlubmVySFRNTCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHB1c2hBdHRyaWJ1dGUodGFyZ2V0LCByZXNwb25zZVN0YXRlLCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRhcmdldC5wdXNoKGVuZE9mU3RhcnRUYWcpOyAvLyB0ZXh0L2h0bWwgaWdub3JlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZXNlIHRhZ3MgaWYgaXQncyBhIG5ld2xpbmVcbiAgLy8gUHJlZmVyIHRvIGJyZWFrIGFwcGxpY2F0aW9uL3htbCBvdmVyIHRleHQvaHRtbCAoZm9yIG5vdykgYnkgYWRkaW5nXG4gIC8vIGEgbmV3bGluZSBzcGVjaWZpY2FsbHkgdG8gZ2V0IGVhdGVuIGJ5IHRoZSBwYXJzZXIuIChBbHRlcm5hdGVseSBmb3JcbiAgLy8gdGV4dGFyZWFzLCByZXBsYWNpbmcgXCJeXFxuXCIgd2l0aCBcIlxcclxcblwiIGRvZXNuJ3QgZ2V0IGVhdGVuLCBhbmQgdGhlIGZpcnN0XG4gIC8vIFxcciBpcyBub3JtYWxpemVkIG91dCBieSBIVE1MVGV4dEFyZWFFbGVtZW50I3ZhbHVlLilcbiAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbC1wb2x5Z2xvdC8jbmV3bGluZXMtaW4tdGV4dGFyZWEtYW5kLXByZT5cbiAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjZWxlbWVudC1yZXN0cmljdGlvbnM+XG4gIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI25ld2xpbmVzPlxuICAvLyBTZWU6IFBhcnNpbmcgb2YgXCJ0ZXh0YXJlYVwiIFwibGlzdGluZ1wiIGFuZCBcInByZVwiIGVsZW1lbnRzXG4gIC8vICBmcm9tIDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5PlxuICAvLyBUT0RPOiBUaGlzIGRvZXNuJ3QgZGVhbCB3aXRoIHRoZSBjYXNlIHdoZXJlIHRoZSBjaGlsZCBpcyBhbiBhcnJheVxuICAvLyBvciBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgc3RyaW5nLlxuXG4gIGlmIChpbm5lckhUTUwgIT0gbnVsbCkge1xuICAgIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5uZXJIVE1MICE9PSAnb2JqZWN0JyB8fCAhKCdfX2h0bWwnIGluIGlubmVySFRNTCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gJyArICdQbGVhc2UgdmlzaXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rhbmdlcm91c2x5LXNldC1pbm5lci1odG1sICcgKyAnZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgfVxuXG4gICAgdmFyIGh0bWwgPSBpbm5lckhUTUwuX19odG1sO1xuXG4gICAgaWYgKGh0bWwgIT09IG51bGwgJiYgaHRtbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIGh0bWwgPT09ICdzdHJpbmcnICYmIGh0bWwubGVuZ3RoID4gMCAmJiBodG1sWzBdID09PSAnXFxuJykge1xuICAgICAgICB0YXJnZXQucHVzaChsZWFkaW5nTmV3bGluZSwgc3RyaW5nVG9DaHVuayhodG1sKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24oaHRtbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXQucHVzaChzdHJpbmdUb0NodW5rKCcnICsgaHRtbCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnICYmIGNoaWxkcmVuWzBdID09PSAnXFxuJykge1xuICAgIHRhcmdldC5wdXNoKGxlYWRpbmdOZXdsaW5lKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn0gLy8gV2UgYWNjZXB0IGFueSB0YWcgdG8gYmUgcmVuZGVyZWQgYnV0IHNpbmNlIHRoaXMgZ2V0cyBpbmplY3RlZCBpbnRvIGFyYml0cmFyeVxuLy8gSFRNTCwgd2Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCBpdCdzIGEgc2FmZSB0YWcuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLyNOVC1OYW1lXG5cblxudmFyIFZBTElEX1RBR19SRUdFWCA9IC9eW2EtekEtWl1bYS16QS1aOl9cXC5cXC1cXGRdKiQvOyAvLyBTaW1wbGlmaWVkIHN1YnNldFxuXG52YXIgdmFsaWRhdGVkVGFnQ2FjaGUgPSBuZXcgTWFwKCk7XG5cbmZ1bmN0aW9uIHN0YXJ0Q2h1bmtGb3JUYWcodGFnKSB7XG4gIHZhciB0YWdTdGFydENodW5rID0gdmFsaWRhdGVkVGFnQ2FjaGUuZ2V0KHRhZyk7XG5cbiAgaWYgKHRhZ1N0YXJ0Q2h1bmsgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmICghVkFMSURfVEFHX1JFR0VYLnRlc3QodGFnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0YWc6IFwiICsgdGFnKTtcbiAgICB9XG5cbiAgICB0YWdTdGFydENodW5rID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8JyArIHRhZyk7XG4gICAgdmFsaWRhdGVkVGFnQ2FjaGUuc2V0KHRhZywgdGFnU3RhcnRDaHVuayk7XG4gIH1cblxuICByZXR1cm4gdGFnU3RhcnRDaHVuaztcbn1cblxudmFyIERPQ1RZUEUgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwhRE9DVFlQRSBodG1sPicpO1xuZnVuY3Rpb24gcHVzaFN0YXJ0SW5zdGFuY2UodGFyZ2V0LCB0eXBlLCBwcm9wcywgcmVzcG9uc2VTdGF0ZSwgZm9ybWF0Q29udGV4dCkge1xuICB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMsIG51bGwpO1xuXG4gICAgaWYgKCFwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgJiYgcHJvcHMuY29udGVudEVkaXRhYmxlICYmIHByb3BzLmNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIGVycm9yKCdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgKyAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJyArICd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJyArICdwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuJyk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdENvbnRleHQuaW5zZXJ0aW9uTW9kZSAhPT0gU1ZHX01PREUgJiYgZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlICE9PSBNQVRITUxfTU9ERSkge1xuICAgICAgaWYgKHR5cGUuaW5kZXhPZignLScpID09PSAtMSAmJiB0eXBlb2YgcHJvcHMuaXMgIT09ICdzdHJpbmcnICYmIHR5cGUudG9Mb3dlckNhc2UoKSAhPT0gdHlwZSkge1xuICAgICAgICBlcnJvcignPCVzIC8+IGlzIHVzaW5nIGluY29ycmVjdCBjYXNpbmcuICcgKyAnVXNlIFBhc2NhbENhc2UgZm9yIFJlYWN0IGNvbXBvbmVudHMsICcgKyAnb3IgbG93ZXJjYXNlIGZvciBIVE1MIGVsZW1lbnRzLicsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIC8vIFNwZWNpYWwgdGFnc1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICByZXR1cm4gcHVzaFN0YXJ0U2VsZWN0KHRhcmdldCwgcHJvcHMsIHJlc3BvbnNlU3RhdGUpO1xuXG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHJldHVybiBwdXNoU3RhcnRPcHRpb24odGFyZ2V0LCBwcm9wcywgcmVzcG9uc2VTdGF0ZSwgZm9ybWF0Q29udGV4dCk7XG5cbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXR1cm4gcHVzaFN0YXJ0VGV4dEFyZWEodGFyZ2V0LCBwcm9wcywgcmVzcG9uc2VTdGF0ZSk7XG5cbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICByZXR1cm4gcHVzaElucHV0KHRhcmdldCwgcHJvcHMsIHJlc3BvbnNlU3RhdGUpO1xuXG4gICAgY2FzZSAnbWVudWl0ZW0nOlxuICAgICAgcmV0dXJuIHB1c2hTdGFydE1lbnVJdGVtKHRhcmdldCwgcHJvcHMsIHJlc3BvbnNlU3RhdGUpO1xuXG4gICAgY2FzZSAndGl0bGUnOlxuICAgICAgcmV0dXJuIHB1c2hTdGFydFRpdGxlKHRhcmdldCwgcHJvcHMsIHJlc3BvbnNlU3RhdGUpO1xuICAgIC8vIE5ld2xpbmUgZWF0aW5nIHRhZ3NcblxuICAgIGNhc2UgJ2xpc3RpbmcnOlxuICAgIGNhc2UgJ3ByZSc6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBwdXNoU3RhcnRQcmVmb3JtYXR0ZWRFbGVtZW50KHRhcmdldCwgcHJvcHMsIHR5cGUsIHJlc3BvbnNlU3RhdGUpO1xuICAgICAgfVxuICAgIC8vIE9taXR0ZWQgY2xvc2UgdGFnc1xuXG4gICAgY2FzZSAnYXJlYSc6XG4gICAgY2FzZSAnYmFzZSc6XG4gICAgY2FzZSAnYnInOlxuICAgIGNhc2UgJ2NvbCc6XG4gICAgY2FzZSAnZW1iZWQnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdpbWcnOlxuICAgIGNhc2UgJ2tleWdlbic6XG4gICAgY2FzZSAnbGluayc6XG4gICAgY2FzZSAnbWV0YSc6XG4gICAgY2FzZSAncGFyYW0nOlxuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgY2FzZSAndHJhY2snOlxuICAgIGNhc2UgJ3dicic6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBwdXNoU2VsZkNsb3NpbmcodGFyZ2V0LCBwcm9wcywgdHlwZSwgcmVzcG9uc2VTdGF0ZSk7XG4gICAgICB9XG4gICAgLy8gVGhlc2UgYXJlIHJlc2VydmVkIFNWRyBhbmQgTWF0aE1MIGVsZW1lbnRzLCB0aGF0IGFyZSBuZXZlciBjdXN0b20gZWxlbWVudHMuXG4gICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9jdXN0b20vI2N1c3RvbS1lbGVtZW50cy1jb3JlLWNvbmNlcHRzXG5cbiAgICBjYXNlICdhbm5vdGF0aW9uLXhtbCc6XG4gICAgY2FzZSAnY29sb3ItcHJvZmlsZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICBjYXNlICdmb250LWZhY2Utc3JjJzpcbiAgICBjYXNlICdmb250LWZhY2UtdXJpJzpcbiAgICBjYXNlICdmb250LWZhY2UtZm9ybWF0JzpcbiAgICBjYXNlICdmb250LWZhY2UtbmFtZSc6XG4gICAgY2FzZSAnbWlzc2luZy1nbHlwaCc6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBwdXNoU3RhcnRHZW5lcmljRWxlbWVudCh0YXJnZXQsIHByb3BzLCB0eXBlLCByZXNwb25zZVN0YXRlKTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2h0bWwnOlxuICAgICAge1xuICAgICAgICBpZiAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlID09PSBST09UX0hUTUxfTU9ERSkge1xuICAgICAgICAgIC8vIElmIHdlJ3JlIHJlbmRlcmluZyB0aGUgaHRtbCB0YWcgYW5kIHdlJ3JlIGF0IHRoZSByb290IChpLmUuIG5vdCBpbiBmb3JlaWduT2JqZWN0KVxuICAgICAgICAgIC8vIHRoZW4gd2UgYWxzbyBlbWl0IHRoZSBET0NUWVBFIGFzIHBhcnQgb2YgdGhlIHJvb3QgY29udGVudCBhcyBhIGNvbnZlbmllbmNlIGZvclxuICAgICAgICAgIC8vIHJlbmRlcmluZyB0aGUgd2hvbGUgZG9jdW1lbnQuXG4gICAgICAgICAgdGFyZ2V0LnB1c2goRE9DVFlQRSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQodGFyZ2V0LCBwcm9wcywgdHlwZSwgcmVzcG9uc2VTdGF0ZSk7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBpZiAodHlwZS5pbmRleE9mKCctJykgPT09IC0xICYmIHR5cGVvZiBwcm9wcy5pcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyBHZW5lcmljIGVsZW1lbnRcbiAgICAgICAgICByZXR1cm4gcHVzaFN0YXJ0R2VuZXJpY0VsZW1lbnQodGFyZ2V0LCBwcm9wcywgdHlwZSwgcmVzcG9uc2VTdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ3VzdG9tIGVsZW1lbnRcbiAgICAgICAgICByZXR1cm4gcHVzaFN0YXJ0Q3VzdG9tRWxlbWVudCh0YXJnZXQsIHByb3BzLCB0eXBlLCByZXNwb25zZVN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICB9XG59XG52YXIgZW5kVGFnMSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC8nKTtcbnZhciBlbmRUYWcyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc+Jyk7XG5mdW5jdGlvbiBwdXNoRW5kSW5zdGFuY2UodGFyZ2V0LCB0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAvLyBPbWl0dGVkIGNsb3NlIHRhZ3NcbiAgICAvLyBUT0RPOiBJbnN0ZWFkIG9mIHJlcGVhdGluZyB0aGlzIHN3aXRjaCB3ZSBjb3VsZCB0cnkgdG8gcGFzcyBhIGZsYWcgZnJvbSBhYm92ZS5cbiAgICAvLyBUaGF0IHdvdWxkIHJlcXVpcmUgcmV0dXJuaW5nIGEgdHVwbGUuIFdoaWNoIG1pZ2h0IGJlIG9rIGlmIGl0IGdldHMgaW5saW5lZC5cbiAgICBjYXNlICdhcmVhJzpcbiAgICBjYXNlICdiYXNlJzpcbiAgICBjYXNlICdicic6XG4gICAgY2FzZSAnY29sJzpcbiAgICBjYXNlICdlbWJlZCc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgIGNhc2UgJ2tleWdlbic6XG4gICAgY2FzZSAnbGluayc6XG4gICAgY2FzZSAnbWV0YSc6XG4gICAgY2FzZSAncGFyYW0nOlxuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgY2FzZSAndHJhY2snOlxuICAgIGNhc2UgJ3dicic6XG4gICAgICB7XG4gICAgICAgIC8vIE5vIGNsb3NlIHRhZyBuZWVkZWQuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgdGFyZ2V0LnB1c2goZW5kVGFnMSwgc3RyaW5nVG9DaHVuayh0eXBlKSwgZW5kVGFnMik7XG4gICAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHdyaXRlQ29tcGxldGVkUm9vdChkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZSkge1xuICB2YXIgYm9vdHN0cmFwQ2h1bmtzID0gcmVzcG9uc2VTdGF0ZS5ib290c3RyYXBDaHVua3M7XG4gIHZhciBpID0gMDtcblxuICBmb3IgKDsgaSA8IGJvb3RzdHJhcENodW5rcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBib290c3RyYXBDaHVua3NbaV0pO1xuICB9XG5cbiAgaWYgKGkgPCBib290c3RyYXBDaHVua3MubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGJvb3RzdHJhcENodW5rc1tpXSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn0gLy8gU3RydWN0dXJhbCBOb2Rlc1xuLy8gQSBwbGFjZWhvbGRlciBpcyBhIG5vZGUgaW5zaWRlIGEgaGlkZGVuIHBhcnRpYWwgdHJlZSB0aGF0IGNhbiBiZSBmaWxsZWQgaW4gbGF0ZXIsIGJ1dCBiZWZvcmVcbi8vIGRpc3BsYXkuIEl0J3MgbmV2ZXIgdmlzaWJsZSB0byB1c2Vycy4gV2UgdXNlIHRoZSB0ZW1wbGF0ZSB0YWcgYmVjYXVzZSBpdCBjYW4gYmUgdXNlZCBpbiBldmVyeVxuLy8gdHlwZSBvZiBwYXJlbnQuIDxzY3JpcHQ+IHRhZ3MgYWxzbyB3b3JrIGluIGV2ZXJ5IG90aGVyIHRhZyBleGNlcHQgPGNvbGdyb3VwPi5cblxudmFyIHBsYWNlaG9sZGVyMSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRlbXBsYXRlIGlkPVwiJyk7XG52YXIgcGxhY2Vob2xkZXIyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj48L3RlbXBsYXRlPicpO1xuZnVuY3Rpb24gd3JpdGVQbGFjZWhvbGRlcihkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZSwgaWQpIHtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcGxhY2Vob2xkZXIxKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZS5wbGFjZWhvbGRlclByZWZpeCk7XG4gIHZhciBmb3JtYXR0ZWRJRCA9IHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZm9ybWF0dGVkSUQpO1xuICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgcGxhY2Vob2xkZXIyKTtcbn0gLy8gU3VzcGVuc2UgYm91bmRhcmllcyBhcmUgZW5jb2RlZCBhcyBjb21tZW50cy5cblxudmFyIHN0YXJ0Q29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPCEtLSQtLT4nKTtcbnZhciBzdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5MSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPCEtLSQ/LS0+PHRlbXBsYXRlIGlkPVwiJyk7XG52YXIgc3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeTIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPjwvdGVtcGxhdGU+Jyk7XG52YXIgc3RhcnRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwhLS0kIS0tPicpO1xudmFyIGVuZFN1c3BlbnNlQm91bmRhcnkgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwhLS0vJC0tPicpO1xudmFyIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMSA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRlbXBsYXRlJyk7XG52YXIgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3JBdHRySW50ZXJzdGl0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIicpO1xudmFyIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyBkYXRhLWRnc3Q9XCInKTtcbnZhciBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFCID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgZGF0YS1tc2c9XCInKTtcbnZhciBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFDID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcgZGF0YS1zdGNrPVwiJyk7XG52YXIgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc+PC90ZW1wbGF0ZT4nKTtcbmZ1bmN0aW9uIHdyaXRlU3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlKSB7XG4gIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkpO1xufVxuZnVuY3Rpb24gd3JpdGVTdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLCBpZCkge1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5MSk7XG5cbiAgaWYgKGlkID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBbiBJRCBtdXN0IGhhdmUgYmVlbiBhc3NpZ25lZCBiZWZvcmUgd2UgY2FuIGNvbXBsZXRlIHRoZSBib3VuZGFyeS4nKTtcbiAgfVxuXG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGlkKTtcbiAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkyKTtcbn1cbmZ1bmN0aW9uIHdyaXRlU3RhcnRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUsIGVycm9yRGlnZXN0LCBlcnJvck1lc3NzYWdlLCBlcnJvckNvbXBvbmVudFN0YWNrKSB7XG4gIHZhciByZXN1bHQ7XG4gIHJlc3VsdCA9IHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0Q2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5KTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxKTtcblxuICBpZiAoZXJyb3JEaWdlc3QpIHtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFBKTtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGVycm9yRGlnZXN0KSkpO1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yQXR0ckludGVyc3RpdGlhbCk7XG4gIH1cblxuICB7XG4gICAgaWYgKGVycm9yTWVzc3NhZ2UpIHtcbiAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUIpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhlc2NhcGVUZXh0Rm9yQnJvd3NlcihlcnJvck1lc3NzYWdlKSkpO1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3JBdHRySW50ZXJzdGl0aWFsKTtcbiAgICB9XG5cbiAgICBpZiAoZXJyb3JDb21wb25lbnRTdGFjaykge1xuICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQyk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZVRleHRGb3JCcm93c2VyKGVycm9yQ29tcG9uZW50U3RhY2spKSk7XG4gICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvckF0dHJJbnRlcnN0aXRpYWwpO1xuICAgIH1cbiAgfVxuXG4gIHJlc3VsdCA9IHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB3cml0ZUVuZENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUpIHtcbiAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFN1c3BlbnNlQm91bmRhcnkpO1xufVxuZnVuY3Rpb24gd3JpdGVFbmRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZSkge1xuICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU3VzcGVuc2VCb3VuZGFyeSk7XG59XG5mdW5jdGlvbiB3cml0ZUVuZENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZSkge1xuICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU3VzcGVuc2VCb3VuZGFyeSk7XG59XG52YXIgc3RhcnRTZWdtZW50SFRNTCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPGRpdiBoaWRkZW4gaWQ9XCInKTtcbnZhciBzdGFydFNlZ21lbnRIVE1MMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgZW5kU2VnbWVudEhUTUwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvZGl2PicpO1xudmFyIHN0YXJ0U2VnbWVudFNWRyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHN2ZyBhcmlhLWhpZGRlbj1cInRydWVcIiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiIGlkPVwiJyk7XG52YXIgc3RhcnRTZWdtZW50U1ZHMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgZW5kU2VnbWVudFNWRyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC9zdmc+Jyk7XG52YXIgc3RhcnRTZWdtZW50TWF0aE1MID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8bWF0aCBhcmlhLWhpZGRlbj1cInRydWVcIiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiIGlkPVwiJyk7XG52YXIgc3RhcnRTZWdtZW50TWF0aE1MMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgZW5kU2VnbWVudE1hdGhNTCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC9tYXRoPicpO1xudmFyIHN0YXJ0U2VnbWVudFRhYmxlID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGFibGUgaGlkZGVuIGlkPVwiJyk7XG52YXIgc3RhcnRTZWdtZW50VGFibGUyID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCdcIj4nKTtcbnZhciBlbmRTZWdtZW50VGFibGUgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvdGFibGU+Jyk7XG52YXIgc3RhcnRTZWdtZW50VGFibGVCb2R5ID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGFibGUgaGlkZGVuPjx0Ym9keSBpZD1cIicpO1xudmFyIHN0YXJ0U2VnbWVudFRhYmxlQm9keTIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGVuZFNlZ21lbnRUYWJsZUJvZHkgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJzwvdGJvZHk+PC90YWJsZT4nKTtcbnZhciBzdGFydFNlZ21lbnRUYWJsZVJvdyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPHRhYmxlIGhpZGRlbj48dHIgaWQ9XCInKTtcbnZhciBzdGFydFNlZ21lbnRUYWJsZVJvdzIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiPicpO1xudmFyIGVuZFNlZ21lbnRUYWJsZVJvdyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnPC90cj48L3RhYmxlPicpO1xudmFyIHN0YXJ0U2VnbWVudENvbEdyb3VwID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8dGFibGUgaGlkZGVuPjxjb2xncm91cCBpZD1cIicpO1xudmFyIHN0YXJ0U2VnbWVudENvbEdyb3VwMiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCI+Jyk7XG52YXIgZW5kU2VnbWVudENvbEdyb3VwID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCc8L2NvbGdyb3VwPjwvdGFibGU+Jyk7XG5mdW5jdGlvbiB3cml0ZVN0YXJ0U2VnbWVudChkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZSwgZm9ybWF0Q29udGV4dCwgaWQpIHtcbiAgc3dpdGNoIChmb3JtYXRDb250ZXh0Lmluc2VydGlvbk1vZGUpIHtcbiAgICBjYXNlIFJPT1RfSFRNTF9NT0RFOlxuICAgIGNhc2UgSFRNTF9NT0RFOlxuICAgICAge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRIVE1MKTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZS5zZWdtZW50UHJlZml4KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudEhUTUwyKTtcbiAgICAgIH1cblxuICAgIGNhc2UgU1ZHX01PREU6XG4gICAgICB7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFNWRyk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUuc2VnbWVudFByZWZpeCk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSk7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRTVkcyKTtcbiAgICAgIH1cblxuICAgIGNhc2UgTUFUSE1MX01PREU6XG4gICAgICB7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudE1hdGhNTCk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUuc2VnbWVudFByZWZpeCk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSk7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRNYXRoTUwyKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSFRNTF9UQUJMRV9NT0RFOlxuICAgICAge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZSk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUuc2VnbWVudFByZWZpeCk7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0cmluZ1RvQ2h1bmsoaWQudG9TdHJpbmcoMTYpKSk7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZTIpO1xuICAgICAgfVxuICAgIC8vIFRPRE86IEZvciB0aGUgcmVzdCBvZiB0aGVzZSwgdGhlcmUgd2lsbCBiZSBleHRyYSB3cmFwcGVyIG5vZGVzIHRoYXQgbmV2ZXJcbiAgICAvLyBnZXQgZGVsZXRlZCBmcm9tIHRoZSBkb2N1bWVudC4gV2UgbmVlZCB0byBkZWxldGUgdGhlIHRhYmxlIHRvbyBhcyBwYXJ0XG4gICAgLy8gb2YgdGhlIGluamVjdGVkIHNjcmlwdHMuIFRoZXkgYXJlIGludmlzaWJsZSB0aG91Z2ggc28gaXQncyBub3QgdG9vIHRlcnJpYmxlXG4gICAgLy8gYW5kIGl0J3Mga2luZCBvZiBhbiBlZGdlIGNhc2UgdG8gc3VzcGVuZCBpbiBhIHRhYmxlLiBUb3RhbGx5IHN1cHBvcnRlZCB0aG91Z2guXG5cbiAgICBjYXNlIEhUTUxfVEFCTEVfQk9EWV9NT0RFOlxuICAgICAge1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdGFydFNlZ21lbnRUYWJsZUJvZHkpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLnNlZ21lbnRQcmVmaXgpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpO1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50VGFibGVCb2R5Mik7XG4gICAgICB9XG5cbiAgICBjYXNlIEhUTUxfVEFCTEVfUk9XX01PREU6XG4gICAgICB7XG4gICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFRhYmxlUm93KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZS5zZWdtZW50UHJlZml4KTtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RyaW5nVG9DaHVuayhpZC50b1N0cmluZygxNikpKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIHN0YXJ0U2VnbWVudFRhYmxlUm93Mik7XG4gICAgICB9XG5cbiAgICBjYXNlIEhUTUxfQ09MR1JPVVBfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50Q29sR3JvdXApO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLnNlZ21lbnRQcmVmaXgpO1xuICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGlkLnRvU3RyaW5nKDE2KSkpO1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgc3RhcnRTZWdtZW50Q29sR3JvdXAyKTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBpbnNlcnRpb24gbW9kZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gd3JpdGVFbmRTZWdtZW50KGRlc3RpbmF0aW9uLCBmb3JtYXRDb250ZXh0KSB7XG4gIHN3aXRjaCAoZm9ybWF0Q29udGV4dC5pbnNlcnRpb25Nb2RlKSB7XG4gICAgY2FzZSBST09UX0hUTUxfTU9ERTpcbiAgICBjYXNlIEhUTUxfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRIVE1MKTtcbiAgICAgIH1cblxuICAgIGNhc2UgU1ZHX01PREU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50U1ZHKTtcbiAgICAgIH1cblxuICAgIGNhc2UgTUFUSE1MX01PREU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50TWF0aE1MKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSFRNTF9UQUJMRV9NT0RFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgZW5kU2VnbWVudFRhYmxlKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSFRNTF9UQUJMRV9CT0RZX01PREU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB3cml0ZUNodW5rQW5kUmV0dXJuKGRlc3RpbmF0aW9uLCBlbmRTZWdtZW50VGFibGVCb2R5KTtcbiAgICAgIH1cblxuICAgIGNhc2UgSFRNTF9UQUJMRV9ST1dfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRUYWJsZVJvdyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEhUTUxfQ09MR1JPVVBfTU9ERTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGVuZFNlZ21lbnRDb2xHcm91cCk7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gaW5zZXJ0aW9uIG1vZGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG4gIH1cbn0gLy8gSW5zdHJ1Y3Rpb24gU2V0XG4vLyBUaGUgZm9sbG93aW5nIGNvZGUgaXMgdGhlIHNvdXJjZSBzY3JpcHRzIHRoYXQgd2UgdGhlbiBtaW5pZnkgYW5kIGlubGluZSBiZWxvdyxcbi8vIHdpdGggcmVuYW1lZCBmdW5jdGlvbiBuYW1lcyB0aGF0IHdlIGhvcGUgZG9uJ3QgY29sbGlkZTpcbi8vIGNvbnN0IENPTU1FTlRfTk9ERSA9IDg7XG4vLyBjb25zdCBTVVNQRU5TRV9TVEFSVF9EQVRBID0gJyQnO1xuLy8gY29uc3QgU1VTUEVOU0VfRU5EX0RBVEEgPSAnLyQnO1xuLy8gY29uc3QgU1VTUEVOU0VfUEVORElOR19TVEFSVF9EQVRBID0gJyQ/Jztcbi8vIGNvbnN0IFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEEgPSAnJCEnO1xuLy9cbi8vIGZ1bmN0aW9uIGNsaWVudFJlbmRlckJvdW5kYXJ5KHN1c3BlbnNlQm91bmRhcnlJRCwgZXJyb3JEaWdlc3QsIGVycm9yTXNnLCBlcnJvckNvbXBvbmVudFN0YWNrKSB7XG4vLyAgIC8vIEZpbmQgdGhlIGZhbGxiYWNrJ3MgZmlyc3QgZWxlbWVudC5cbi8vICAgY29uc3Qgc3VzcGVuc2VJZE5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzdXNwZW5zZUJvdW5kYXJ5SUQpO1xuLy8gICBpZiAoIXN1c3BlbnNlSWROb2RlKSB7XG4vLyAgICAgLy8gVGhlIHVzZXIgbXVzdCBoYXZlIGFscmVhZHkgbmF2aWdhdGVkIGF3YXkgZnJvbSB0aGlzIHRyZWUuXG4vLyAgICAgLy8gRS5nLiBiZWNhdXNlIHRoZSBwYXJlbnQgd2FzIGh5ZHJhdGVkLlxuLy8gICAgIHJldHVybjtcbi8vICAgfVxuLy8gICAvLyBGaW5kIHRoZSBib3VuZGFyeSBhcm91bmQgdGhlIGZhbGxiYWNrLiBUaGlzIGlzIGFsd2F5cyB0aGUgcHJldmlvdXMgbm9kZS5cbi8vICAgY29uc3Qgc3VzcGVuc2VOb2RlID0gc3VzcGVuc2VJZE5vZGUucHJldmlvdXNTaWJsaW5nO1xuLy8gICAvLyBUYWcgaXQgdG8gYmUgY2xpZW50IHJlbmRlcmVkLlxuLy8gICBzdXNwZW5zZU5vZGUuZGF0YSA9IFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEE7XG4vLyAgIC8vIGFzc2lnbiBlcnJvciBtZXRhZGF0YSB0byBmaXJzdCBzaWJsaW5nXG4vLyAgIGxldCBkYXRhc2V0ID0gc3VzcGVuc2VJZE5vZGUuZGF0YXNldDtcbi8vICAgaWYgKGVycm9yRGlnZXN0KSBkYXRhc2V0LmRnc3QgPSBlcnJvckRpZ2VzdDtcbi8vICAgaWYgKGVycm9yTXNnKSBkYXRhc2V0Lm1zZyA9IGVycm9yTXNnO1xuLy8gICBpZiAoZXJyb3JDb21wb25lbnRTdGFjaykgZGF0YXNldC5zdGNrID0gZXJyb3JDb21wb25lbnRTdGFjaztcbi8vICAgLy8gVGVsbCBSZWFjdCB0byByZXRyeSBpdCBpZiB0aGUgcGFyZW50IGFscmVhZHkgaHlkcmF0ZWQuXG4vLyAgIGlmIChzdXNwZW5zZU5vZGUuX3JlYWN0UmV0cnkpIHtcbi8vICAgICBzdXNwZW5zZU5vZGUuX3JlYWN0UmV0cnkoKTtcbi8vICAgfVxuLy8gfVxuLy9cbi8vIGZ1bmN0aW9uIGNvbXBsZXRlQm91bmRhcnkoc3VzcGVuc2VCb3VuZGFyeUlELCBjb250ZW50SUQpIHtcbi8vICAgLy8gRmluZCB0aGUgZmFsbGJhY2sncyBmaXJzdCBlbGVtZW50LlxuLy8gICBjb25zdCBzdXNwZW5zZUlkTm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHN1c3BlbnNlQm91bmRhcnlJRCk7XG4vLyAgIGNvbnN0IGNvbnRlbnROb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29udGVudElEKTtcbi8vICAgLy8gV2UnbGwgZGV0YWNoIHRoZSBjb250ZW50IG5vZGUgc28gdGhhdCByZWdhcmRsZXNzIG9mIHdoYXQgaGFwcGVucyBuZXh0IHdlIGRvbid0IGxlYXZlIGluIHRoZSB0cmVlLlxuLy8gICAvLyBUaGlzIG1pZ2h0IGFsc28gaGVscCBieSBub3QgY2F1c2luZyByZWNhbGNpbmcgZWFjaCB0aW1lIHdlIG1vdmUgYSBjaGlsZCBmcm9tIGhlcmUgdG8gdGhlIHRhcmdldC5cbi8vICAgY29udGVudE5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb250ZW50Tm9kZSk7XG4vLyAgIGlmICghc3VzcGVuc2VJZE5vZGUpIHtcbi8vICAgICAvLyBUaGUgdXNlciBtdXN0IGhhdmUgYWxyZWFkeSBuYXZpZ2F0ZWQgYXdheSBmcm9tIHRoaXMgdHJlZS5cbi8vICAgICAvLyBFLmcuIGJlY2F1c2UgdGhlIHBhcmVudCB3YXMgaHlkcmF0ZWQuIFRoYXQncyBmaW5lIHRoZXJlJ3Mgbm90aGluZyB0byBkb1xuLy8gICAgIC8vIGJ1dCB3ZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IHdlIGFscmVhZHkgZGVsZXRlZCB0aGUgY29udGFpbmVyIG5vZGUuXG4vLyAgICAgcmV0dXJuO1xuLy8gICB9XG4vLyAgIC8vIEZpbmQgdGhlIGJvdW5kYXJ5IGFyb3VuZCB0aGUgZmFsbGJhY2suIFRoaXMgaXMgYWx3YXlzIHRoZSBwcmV2aW91cyBub2RlLlxuLy8gICBjb25zdCBzdXNwZW5zZU5vZGUgPSBzdXNwZW5zZUlkTm9kZS5wcmV2aW91c1NpYmxpbmc7XG4vL1xuLy8gICAvLyBDbGVhciBhbGwgdGhlIGV4aXN0aW5nIGNoaWxkcmVuLiBUaGlzIGlzIGNvbXBsaWNhdGVkIGJlY2F1c2Vcbi8vICAgLy8gdGhlcmUgY2FuIGJlIGVtYmVkZGVkIFN1c3BlbnNlIGJvdW5kYXJpZXMgaW4gdGhlIGZhbGxiYWNrLlxuLy8gICAvLyBUaGlzIGlzIHNpbWlsYXIgdG8gY2xlYXJTdXNwZW5zZUJvdW5kYXJ5IGluIFJlYWN0RE9NSG9zdENvbmZpZy5cbi8vICAgLy8gVE9ETzogV2UgY291bGQgYXZvaWQgdGhpcyBpZiB3ZSBuZXZlciBlbWl0dGVkIHN1c3BlbnNlIGJvdW5kYXJpZXMgaW4gZmFsbGJhY2sgdHJlZXMuXG4vLyAgIC8vIFRoZXkgbmV2ZXIgaHlkcmF0ZSBhbnl3YXkuIEhvd2V2ZXIsIGN1cnJlbnRseSB3ZSBzdXBwb3J0IGluY3JlbWVudGFsbHkgbG9hZGluZyB0aGUgZmFsbGJhY2suXG4vLyAgIGNvbnN0IHBhcmVudEluc3RhbmNlID0gc3VzcGVuc2VOb2RlLnBhcmVudE5vZGU7XG4vLyAgIGxldCBub2RlID0gc3VzcGVuc2VOb2RlLm5leHRTaWJsaW5nO1xuLy8gICBsZXQgZGVwdGggPSAwO1xuLy8gICBkbyB7XG4vLyAgICAgaWYgKG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4vLyAgICAgICBjb25zdCBkYXRhID0gbm9kZS5kYXRhO1xuLy8gICAgICAgaWYgKGRhdGEgPT09IFNVU1BFTlNFX0VORF9EQVRBKSB7XG4vLyAgICAgICAgIGlmIChkZXB0aCA9PT0gMCkge1xuLy8gICAgICAgICAgIGJyZWFrO1xuLy8gICAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAgIGRlcHRoLS07XG4vLyAgICAgICAgIH1cbi8vICAgICAgIH0gZWxzZSBpZiAoXG4vLyAgICAgICAgIGRhdGEgPT09IFNVU1BFTlNFX1NUQVJUX0RBVEEgfHxcbi8vICAgICAgICAgZGF0YSA9PT0gU1VTUEVOU0VfUEVORElOR19TVEFSVF9EQVRBIHx8XG4vLyAgICAgICAgIGRhdGEgPT09IFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEFcbi8vICAgICAgICkge1xuLy8gICAgICAgICBkZXB0aCsrO1xuLy8gICAgICAgfVxuLy8gICAgIH1cbi8vXG4vLyAgICAgY29uc3QgbmV4dE5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuLy8gICAgIHBhcmVudEluc3RhbmNlLnJlbW92ZUNoaWxkKG5vZGUpO1xuLy8gICAgIG5vZGUgPSBuZXh0Tm9kZTtcbi8vICAgfSB3aGlsZSAobm9kZSk7XG4vL1xuLy8gICBjb25zdCBlbmRPZkJvdW5kYXJ5ID0gbm9kZTtcbi8vXG4vLyAgIC8vIEluc2VydCBhbGwgdGhlIGNoaWxkcmVuIGZyb20gdGhlIGNvbnRlbnROb2RlIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgb2Ygc3VzcGVuc2UgYm91bmRhcnkuXG4vLyAgIHdoaWxlIChjb250ZW50Tm9kZS5maXJzdENoaWxkKSB7XG4vLyAgICAgcGFyZW50SW5zdGFuY2UuaW5zZXJ0QmVmb3JlKGNvbnRlbnROb2RlLmZpcnN0Q2hpbGQsIGVuZE9mQm91bmRhcnkpO1xuLy8gICB9XG4vLyAgIHN1c3BlbnNlTm9kZS5kYXRhID0gU1VTUEVOU0VfU1RBUlRfREFUQTtcbi8vICAgaWYgKHN1c3BlbnNlTm9kZS5fcmVhY3RSZXRyeSkge1xuLy8gICAgIHN1c3BlbnNlTm9kZS5fcmVhY3RSZXRyeSgpO1xuLy8gICB9XG4vLyB9XG4vL1xuLy8gZnVuY3Rpb24gY29tcGxldGVTZWdtZW50KGNvbnRhaW5lcklELCBwbGFjZWhvbGRlcklEKSB7XG4vLyAgIGNvbnN0IHNlZ21lbnRDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb250YWluZXJJRCk7XG4vLyAgIGNvbnN0IHBsYWNlaG9sZGVyTm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHBsYWNlaG9sZGVySUQpO1xuLy8gICAvLyBXZSBhbHdheXMgZXhwZWN0IGJvdGggbm9kZXMgdG8gZXhpc3QgaGVyZSBiZWNhdXNlLCB3aGlsZSB3ZSBtaWdodFxuLy8gICAvLyBoYXZlIG5hdmlnYXRlZCBhd2F5IGZyb20gdGhlIG1haW4gdHJlZSwgd2Ugc3RpbGwgZXhwZWN0IHRoZSBkZXRhY2hlZFxuLy8gICAvLyB0cmVlIHRvIGV4aXN0LlxuLy8gICBzZWdtZW50Q29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2VnbWVudENvbnRhaW5lcik7XG4vLyAgIHdoaWxlIChzZWdtZW50Q29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcbi8vICAgICBwbGFjZWhvbGRlck5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoXG4vLyAgICAgICBzZWdtZW50Q29udGFpbmVyLmZpcnN0Q2hpbGQsXG4vLyAgICAgICBwbGFjZWhvbGRlck5vZGUsXG4vLyAgICAgKTtcbi8vICAgfVxuLy8gICBwbGFjZWhvbGRlck5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwbGFjZWhvbGRlck5vZGUpO1xuLy8gfVxuXG52YXIgY29tcGxldGVTZWdtZW50RnVuY3Rpb24gPSAnZnVuY3Rpb24gJFJTKGEsYil7YT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChhKTtiPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGIpO2ZvcihhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSk7YS5maXJzdENoaWxkOyliLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEuZmlyc3RDaGlsZCxiKTtiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYil9JztcbnZhciBjb21wbGV0ZUJvdW5kYXJ5RnVuY3Rpb24gPSAnZnVuY3Rpb24gJFJDKGEsYil7YT1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChhKTtiPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGIpO2IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKTtpZihhKXthPWEucHJldmlvdXNTaWJsaW5nO3ZhciBmPWEucGFyZW50Tm9kZSxjPWEubmV4dFNpYmxpbmcsZT0wO2Rve2lmKGMmJjg9PT1jLm5vZGVUeXBlKXt2YXIgZD1jLmRhdGE7aWYoXCIvJFwiPT09ZClpZigwPT09ZSlicmVhaztlbHNlIGUtLTtlbHNlXCIkXCIhPT1kJiZcIiQ/XCIhPT1kJiZcIiQhXCIhPT1kfHxlKyt9ZD1jLm5leHRTaWJsaW5nO2YucmVtb3ZlQ2hpbGQoYyk7Yz1kfXdoaWxlKGMpO2Zvcig7Yi5maXJzdENoaWxkOylmLmluc2VydEJlZm9yZShiLmZpcnN0Q2hpbGQsYyk7YS5kYXRhPVwiJFwiO2EuX3JlYWN0UmV0cnkmJmEuX3JlYWN0UmV0cnkoKX19JztcbnZhciBjbGllbnRSZW5kZXJGdW5jdGlvbiA9ICdmdW5jdGlvbiAkUlgoYixjLGQsZSl7dmFyIGE9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYik7YSYmKGI9YS5wcmV2aW91c1NpYmxpbmcsYi5kYXRhPVwiJCFcIixhPWEuZGF0YXNldCxjJiYoYS5kZ3N0PWMpLGQmJihhLm1zZz1kKSxlJiYoYS5zdGNrPWUpLGIuX3JlYWN0UmV0cnkmJmIuX3JlYWN0UmV0cnkoKSl9JztcbnZhciBjb21wbGV0ZVNlZ21lbnRTY3JpcHQxRnVsbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuayhjb21wbGV0ZVNlZ21lbnRGdW5jdGlvbiArICc7JFJTKFwiJyk7XG52YXIgY29tcGxldGVTZWdtZW50U2NyaXB0MVBhcnRpYWwgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJyRSUyhcIicpO1xudmFyIGNvbXBsZXRlU2VnbWVudFNjcmlwdDIgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiLFwiJyk7XG52YXIgY29tcGxldGVTZWdtZW50U2NyaXB0MyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIpPC9zY3JpcHQ+Jyk7XG5mdW5jdGlvbiB3cml0ZUNvbXBsZXRlZFNlZ21lbnRJbnN0cnVjdGlvbihkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZSwgY29udGVudFNlZ21lbnRJRCkge1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLnN0YXJ0SW5saW5lU2NyaXB0KTtcblxuICBpZiAoIXJlc3BvbnNlU3RhdGUuc2VudENvbXBsZXRlU2VnbWVudEZ1bmN0aW9uKSB7XG4gICAgLy8gVGhlIGZpcnN0IHRpbWUgd2Ugd3JpdGUgdGhpcywgd2UnbGwgbmVlZCB0byBpbmNsdWRlIHRoZSBmdWxsIGltcGxlbWVudGF0aW9uLlxuICAgIHJlc3BvbnNlU3RhdGUuc2VudENvbXBsZXRlU2VnbWVudEZ1bmN0aW9uID0gdHJ1ZTtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZVNlZ21lbnRTY3JpcHQxRnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRnV0dXJlIGNhbGxzIGNhbiBqdXN0IHJldXNlIHRoZSBzYW1lIGZ1bmN0aW9uLlxuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlU2VnbWVudFNjcmlwdDFQYXJ0aWFsKTtcbiAgfVxuXG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUuc2VnbWVudFByZWZpeCk7XG4gIHZhciBmb3JtYXR0ZWRJRCA9IHN0cmluZ1RvQ2h1bmsoY29udGVudFNlZ21lbnRJRC50b1N0cmluZygxNikpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBmb3JtYXR0ZWRJRCk7XG4gIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNvbXBsZXRlU2VnbWVudFNjcmlwdDIpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLnBsYWNlaG9sZGVyUHJlZml4KTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgZm9ybWF0dGVkSUQpO1xuICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY29tcGxldGVTZWdtZW50U2NyaXB0Myk7XG59XG52YXIgY29tcGxldGVCb3VuZGFyeVNjcmlwdDFGdWxsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGNvbXBsZXRlQm91bmRhcnlGdW5jdGlvbiArICc7JFJDKFwiJyk7XG52YXIgY29tcGxldGVCb3VuZGFyeVNjcmlwdDFQYXJ0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCckUkMoXCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIsXCInKTtcbnZhciBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MyA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnXCIpPC9zY3JpcHQ+Jyk7XG5mdW5jdGlvbiB3cml0ZUNvbXBsZXRlZEJvdW5kYXJ5SW5zdHJ1Y3Rpb24oZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUsIGJvdW5kYXJ5SUQsIGNvbnRlbnRTZWdtZW50SUQpIHtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZS5zdGFydElubGluZVNjcmlwdCk7XG5cbiAgaWYgKCFyZXNwb25zZVN0YXRlLnNlbnRDb21wbGV0ZUJvdW5kYXJ5RnVuY3Rpb24pIHtcbiAgICAvLyBUaGUgZmlyc3QgdGltZSB3ZSB3cml0ZSB0aGlzLCB3ZSdsbCBuZWVkIHRvIGluY2x1ZGUgdGhlIGZ1bGwgaW1wbGVtZW50YXRpb24uXG4gICAgcmVzcG9uc2VTdGF0ZS5zZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uID0gdHJ1ZTtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MUZ1bGwpO1xuICB9IGVsc2Uge1xuICAgIC8vIEZ1dHVyZSBjYWxscyBjYW4ganVzdCByZXVzZSB0aGUgc2FtZSBmdW5jdGlvbi5cbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MVBhcnRpYWwpO1xuICB9XG5cbiAgaWYgKGJvdW5kYXJ5SUQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIElEIG11c3QgaGF2ZSBiZWVuIGFzc2lnbmVkIGJlZm9yZSB3ZSBjYW4gY29tcGxldGUgdGhlIGJvdW5kYXJ5LicpO1xuICB9XG5cbiAgdmFyIGZvcm1hdHRlZENvbnRlbnRJRCA9IHN0cmluZ1RvQ2h1bmsoY29udGVudFNlZ21lbnRJRC50b1N0cmluZygxNikpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBib3VuZGFyeUlEKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdDIpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCByZXNwb25zZVN0YXRlLnNlZ21lbnRQcmVmaXgpO1xuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBmb3JtYXR0ZWRDb250ZW50SUQpO1xuICByZXR1cm4gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY29tcGxldGVCb3VuZGFyeVNjcmlwdDMpO1xufVxudmFyIGNsaWVudFJlbmRlclNjcmlwdDFGdWxsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKGNsaWVudFJlbmRlckZ1bmN0aW9uICsgJzskUlgoXCInKTtcbnZhciBjbGllbnRSZW5kZXJTY3JpcHQxUGFydGlhbCA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnJFJYKFwiJyk7XG52YXIgY2xpZW50UmVuZGVyU2NyaXB0MUEgPSBzdHJpbmdUb1ByZWNvbXB1dGVkQ2h1bmsoJ1wiJyk7XG52YXIgY2xpZW50UmVuZGVyU2NyaXB0MiA9IHN0cmluZ1RvUHJlY29tcHV0ZWRDaHVuaygnKTwvc2NyaXB0PicpO1xudmFyIGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsID0gc3RyaW5nVG9QcmVjb21wdXRlZENodW5rKCcsJyk7XG5mdW5jdGlvbiB3cml0ZUNsaWVudFJlbmRlckJvdW5kYXJ5SW5zdHJ1Y3Rpb24oZGVzdGluYXRpb24sIHJlc3BvbnNlU3RhdGUsIGJvdW5kYXJ5SUQsIGVycm9yRGlnZXN0LCBlcnJvck1lc3NhZ2UsIGVycm9yQ29tcG9uZW50U3RhY2spIHtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgcmVzcG9uc2VTdGF0ZS5zdGFydElubGluZVNjcmlwdCk7XG5cbiAgaWYgKCFyZXNwb25zZVN0YXRlLnNlbnRDbGllbnRSZW5kZXJGdW5jdGlvbikge1xuICAgIC8vIFRoZSBmaXJzdCB0aW1lIHdlIHdyaXRlIHRoaXMsIHdlJ2xsIG5lZWQgdG8gaW5jbHVkZSB0aGUgZnVsbCBpbXBsZW1lbnRhdGlvbi5cbiAgICByZXNwb25zZVN0YXRlLnNlbnRDbGllbnRSZW5kZXJGdW5jdGlvbiA9IHRydWU7XG4gICAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyU2NyaXB0MUZ1bGwpO1xuICB9IGVsc2Uge1xuICAgIC8vIEZ1dHVyZSBjYWxscyBjYW4ganVzdCByZXVzZSB0aGUgc2FtZSBmdW5jdGlvbi5cbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjbGllbnRSZW5kZXJTY3JpcHQxUGFydGlhbCk7XG4gIH1cblxuICBpZiAoYm91bmRhcnlJRCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQW4gSUQgbXVzdCBoYXZlIGJlZW4gYXNzaWduZWQgYmVmb3JlIHdlIGNhbiBjb21wbGV0ZSB0aGUgYm91bmRhcnkuJyk7XG4gIH1cblxuICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBib3VuZGFyeUlEKTtcbiAgd3JpdGVDaHVuayhkZXN0aW5hdGlvbiwgY2xpZW50UmVuZGVyU2NyaXB0MUEpO1xuXG4gIGlmIChlcnJvckRpZ2VzdCB8fCBlcnJvck1lc3NhZ2UgfHwgZXJyb3JDb21wb25lbnRTdGFjaykge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsKTtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyhlcnJvckRpZ2VzdCB8fCAnJykpKTtcbiAgfVxuXG4gIGlmIChlcnJvck1lc3NhZ2UgfHwgZXJyb3JDb21wb25lbnRTdGFjaykge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsKTtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyhlcnJvck1lc3NhZ2UgfHwgJycpKSk7XG4gIH1cblxuICBpZiAoZXJyb3JDb21wb25lbnRTdGFjaykge1xuICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNsaWVudFJlbmRlckVycm9yU2NyaXB0QXJnSW50ZXJzdGl0aWFsKTtcbiAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBzdHJpbmdUb0NodW5rKGVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyhlcnJvckNvbXBvbmVudFN0YWNrKSkpO1xuICB9XG5cbiAgcmV0dXJuIHdyaXRlQ2h1bmtBbmRSZXR1cm4oZGVzdGluYXRpb24sIGNsaWVudFJlbmRlclNjcmlwdDIpO1xufVxudmFyIHJlZ2V4Rm9ySlNTdHJpbmdzSW5TY3JpcHRzID0gL1s8XFx1MjAyOFxcdTIwMjldL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZUpTU3RyaW5nc0Zvckluc3RydWN0aW9uU2NyaXB0cyhpbnB1dCkge1xuICB2YXIgZXNjYXBlZCA9IEpTT04uc3RyaW5naWZ5KGlucHV0KTtcbiAgcmV0dXJuIGVzY2FwZWQucmVwbGFjZShyZWdleEZvckpTU3RyaW5nc0luU2NyaXB0cywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgc3dpdGNoIChtYXRjaCkge1xuICAgICAgLy8gc2FudGl6aW5nIGJyZWFraW5nIG91dCBvZiBzdHJpbmdzIGFuZCBzY3JpcHQgdGFnc1xuICAgICAgY2FzZSAnPCc6XG4gICAgICAgIHJldHVybiBcIlxcXFx1MDAzY1wiO1xuXG4gICAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgICByZXR1cm4gXCJcXFxcdTIwMjhcIjtcblxuICAgICAgY2FzZSBcIlxcdTIwMjlcIjpcbiAgICAgICAgcmV0dXJuIFwiXFxcXHUyMDI5XCI7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXNjYXBlSlNTdHJpbmdzRm9ySW5zdHJ1Y3Rpb25TY3JpcHRzIGVuY291bnRlcmVkIGEgbWF0Y2ggaXQgZG9lcyBub3Qga25vdyBob3cgdG8gcmVwbGFjZS4gdGhpcyBtZWFucyB0aGUgbWF0Y2ggcmVnZXggYW5kIHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGFyZSBubyBsb25nZXIgaW4gc3luYy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdCcpO1xuICAgICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zY29wZScpO1xudmFyIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZGVidWdfdHJhY2VfbW9kZScpO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbnZhciBSRUFDVF9TRVJWRVJfQ09OVEVYVF9ERUZBVUxUX1ZBTFVFX05PVF9MT0FERUQgPSBTeW1ib2wuZm9yKCdyZWFjdC5kZWZhdWx0X3ZhbHVlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcblxuICAgICAgICBpZiAob3V0ZXJOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnTWVtbyc7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoICFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlQ2xhc3NDb21wb25lbnRGcmFtZShjdG9yLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGN0b3IsIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQ7XG5cbntcbiAgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0ID0ge307XG59XG5cbnZhciBlbXB0eUNvbnRleHRPYmplY3QgPSB7fTtcblxue1xuICBPYmplY3QuZnJlZXplKGVtcHR5Q29udGV4dE9iamVjdCk7XG59XG5cbmZ1bmN0aW9uIGdldE1hc2tlZENvbnRleHQodHlwZSwgdW5tYXNrZWRDb250ZXh0KSB7XG4gIHtcbiAgICB2YXIgY29udGV4dFR5cGVzID0gdHlwZS5jb250ZXh0VHlwZXM7XG5cbiAgICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgICAgcmV0dXJuIGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICB9XG5cbiAgICB2YXIgY29udGV4dCA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIGNvbnRleHRUeXBlcykge1xuICAgICAgY29udGV4dFtrZXldID0gdW5tYXNrZWRDb250ZXh0W2tleV07XG4gICAgfVxuXG4gICAge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ1Vua25vd24nO1xuICAgICAgY2hlY2tQcm9wVHlwZXMoY29udGV4dFR5cGVzLCBjb250ZXh0LCAnY29udGV4dCcsIG5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzQ2hpbGRDb250ZXh0KGluc3RhbmNlLCB0eXBlLCBwYXJlbnRDb250ZXh0LCBjaGlsZENvbnRleHRUeXBlcykge1xuICB7XG4gICAgLy8gVE9ETyAoYnZhdWdobikgUmVwbGFjZSB0aGlzIGJlaGF2aW9yIHdpdGggYW4gaW52YXJpYW50KCkgaW4gdGhlIGZ1dHVyZS5cbiAgICAvLyBJdCBoYXMgb25seSBiZWVuIGFkZGVkIGluIEZpYmVyIHRvIG1hdGNoIHRoZSAodW5pbnRlbnRpb25hbCkgYmVoYXZpb3IgaW4gU3RhY2suXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgIGlmICghd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCclcy5jaGlsZENvbnRleHRUeXBlcyBpcyBzcGVjaWZpZWQgYnV0IHRoZXJlIGlzIG5vIGdldENoaWxkQ29udGV4dCgpIG1ldGhvZCAnICsgJ29uIHRoZSBpbnN0YW5jZS4gWW91IGNhbiBlaXRoZXIgZGVmaW5lIGdldENoaWxkQ29udGV4dCgpIG9uICVzIG9yIHJlbW92ZSAnICsgJ2NoaWxkQ29udGV4dFR5cGVzIGZyb20gaXQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkQ29udGV4dCA9IGluc3RhbmNlLmdldENoaWxkQ29udGV4dCgpO1xuXG4gICAgZm9yICh2YXIgY29udGV4dEtleSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAgIGlmICghKGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0VHlwZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8ICdVbmtub3duJykgKyBcIi5nZXRDaGlsZENvbnRleHQoKToga2V5IFxcXCJcIiArIGNvbnRleHRLZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8ICdVbmtub3duJztcbiAgICAgIGNoZWNrUHJvcFR5cGVzKGNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHQsICdjaGlsZCBjb250ZXh0JywgbmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzc2lnbih7fSwgcGFyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbiAgfVxufVxuXG52YXIgcmVuZGVyZXJTaWdpbDtcblxue1xuICAvLyBVc2UgdGhpcyB0byBkZXRlY3QgbXVsdGlwbGUgcmVuZGVyZXJzIHVzaW5nIHRoZSBzYW1lIGNvbnRleHRcbiAgcmVuZGVyZXJTaWdpbCA9IHt9O1xufSAvLyBVc2VkIHRvIHN0b3JlIHRoZSBwYXJlbnQgcGF0aCBvZiBhbGwgY29udGV4dCBvdmVycmlkZXMgaW4gYSBzaGFyZWQgbGlua2VkIGxpc3QuXG4vLyBGb3JtaW5nIGEgcmV2ZXJzZSB0cmVlLlxuXG5cbnZhciByb290Q29udGV4dFNuYXBzaG90ID0gbnVsbDsgLy8gV2UgYXNzdW1lIHRoYXQgdGhpcyBydW50aW1lIG93bnMgdGhlIFwiY3VycmVudFwiIGZpZWxkIG9uIGFsbCBSZWFjdENvbnRleHQgaW5zdGFuY2VzLlxuLy8gVGhpcyBnbG9iYWwgKGFjdHVhbGx5IHRocmVhZCBsb2NhbCkgc3RhdGUgcmVwcmVzZW50cyB3aGF0IHN0YXRlIGFsbCB0aG9zZSBcImN1cnJlbnRcIixcbi8vIGZpZWxkcyBhcmUgY3VycmVudGx5IGluLlxuXG52YXIgY3VycmVudEFjdGl2ZVNuYXBzaG90ID0gbnVsbDtcblxuZnVuY3Rpb24gcG9wTm9kZShwcmV2KSB7XG4gIHtcbiAgICBwcmV2LmNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IHByZXYucGFyZW50VmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaE5vZGUobmV4dCkge1xuICB7XG4gICAgbmV4dC5jb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBuZXh0LnZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIG5leHQpIHtcbiAgaWYgKHByZXYgPT09IG5leHQpIDsgZWxzZSB7XG4gICAgcG9wTm9kZShwcmV2KTtcbiAgICB2YXIgcGFyZW50UHJldiA9IHByZXYucGFyZW50O1xuICAgIHZhciBwYXJlbnROZXh0ID0gbmV4dC5wYXJlbnQ7XG5cbiAgICBpZiAocGFyZW50UHJldiA9PT0gbnVsbCkge1xuICAgICAgaWYgKHBhcmVudE5leHQgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc3RhY2tzIG11c3QgcmVhY2ggdGhlIHJvb3QgYXQgdGhlIHNhbWUgdGltZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBhcmVudE5leHQgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc3RhY2tzIG11c3QgcmVhY2ggdGhlIHJvb3QgYXQgdGhlIHNhbWUgdGltZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cblxuICAgICAgcG9wVG9OZWFyZXN0Q29tbW9uQW5jZXN0b3IocGFyZW50UHJldiwgcGFyZW50TmV4dCk7XG4gICAgfSAvLyBPbiB0aGUgd2F5IGJhY2ssIHdlIHB1c2ggdGhlIG5ldyBvbmVzIHRoYXQgd2VyZW4ndCBjb21tb24uXG5cblxuICAgIHB1c2hOb2RlKG5leHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvcEFsbFByZXZpb3VzKHByZXYpIHtcbiAgcG9wTm9kZShwcmV2KTtcbiAgdmFyIHBhcmVudFByZXYgPSBwcmV2LnBhcmVudDtcblxuICBpZiAocGFyZW50UHJldiAhPT0gbnVsbCkge1xuICAgIHBvcEFsbFByZXZpb3VzKHBhcmVudFByZXYpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hBbGxOZXh0KG5leHQpIHtcbiAgdmFyIHBhcmVudE5leHQgPSBuZXh0LnBhcmVudDtcblxuICBpZiAocGFyZW50TmV4dCAhPT0gbnVsbCkge1xuICAgIHB1c2hBbGxOZXh0KHBhcmVudE5leHQpO1xuICB9XG5cbiAgcHVzaE5vZGUobmV4dCk7XG59XG5cbmZ1bmN0aW9uIHBvcFByZXZpb3VzVG9Db21tb25MZXZlbChwcmV2LCBuZXh0KSB7XG4gIHBvcE5vZGUocHJldik7XG4gIHZhciBwYXJlbnRQcmV2ID0gcHJldi5wYXJlbnQ7XG5cbiAgaWYgKHBhcmVudFByZXYgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkZXB0aCBtdXN0IGVxdWFsIGF0IGxlYXN0IGF0IHplcm8gYmVmb3JlIHJlYWNoaW5nIHRoZSByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICB9XG5cbiAgaWYgKHBhcmVudFByZXYuZGVwdGggPT09IG5leHQuZGVwdGgpIHtcbiAgICAvLyBXZSBmb3VuZCB0aGUgc2FtZSBsZXZlbC4gTm93IHdlIGp1c3QgbmVlZCB0byBmaW5kIGEgc2hhcmVkIGFuY2VzdG9yLlxuICAgIHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHBhcmVudFByZXYsIG5leHQpO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIG11c3Qgc3RpbGwgYmUgZGVlcGVyLlxuICAgIHBvcFByZXZpb3VzVG9Db21tb25MZXZlbChwYXJlbnRQcmV2LCBuZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BOZXh0VG9Db21tb25MZXZlbChwcmV2LCBuZXh0KSB7XG4gIHZhciBwYXJlbnROZXh0ID0gbmV4dC5wYXJlbnQ7XG5cbiAgaWYgKHBhcmVudE5leHQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBkZXB0aCBtdXN0IGVxdWFsIGF0IGxlYXN0IGF0IHplcm8gYmVmb3JlIHJlYWNoaW5nIHRoZSByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICB9XG5cbiAgaWYgKHByZXYuZGVwdGggPT09IHBhcmVudE5leHQuZGVwdGgpIHtcbiAgICAvLyBXZSBmb3VuZCB0aGUgc2FtZSBsZXZlbC4gTm93IHdlIGp1c3QgbmVlZCB0byBmaW5kIGEgc2hhcmVkIGFuY2VzdG9yLlxuICAgIHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIHBhcmVudE5leHQpO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIG11c3Qgc3RpbGwgYmUgZGVlcGVyLlxuICAgIHBvcE5leHRUb0NvbW1vbkxldmVsKHByZXYsIHBhcmVudE5leHQpO1xuICB9XG5cbiAgcHVzaE5vZGUobmV4dCk7XG59IC8vIFBlcmZvcm0gY29udGV4dCBzd2l0Y2hpbmcgdG8gdGhlIG5ldyBzbmFwc2hvdC5cbi8vIFRvIG1ha2UgaXQgY2hlYXAgdG8gcmVhZCBtYW55IGNvbnRleHRzLCB3aGlsZSBub3Qgc3VzcGVuZGluZywgd2UgbWFrZSB0aGUgc3dpdGNoIGVhZ2VybHkgYnlcbi8vIHVwZGF0aW5nIGFsbCB0aGUgY29udGV4dCdzIGN1cnJlbnQgdmFsdWVzLiBUaGF0IHdheSByZWFkcywgYWx3YXlzIGp1c3QgcmVhZCB0aGUgY3VycmVudCB2YWx1ZS5cbi8vIEF0IHRoZSBjb3N0IG9mIHVwZGF0aW5nIGNvbnRleHRzIGV2ZW4gaWYgdGhleSdyZSBuZXZlciByZWFkIGJ5IHRoaXMgc3VidHJlZS5cblxuXG5mdW5jdGlvbiBzd2l0Y2hDb250ZXh0KG5ld1NuYXBzaG90KSB7XG4gIC8vIFRoZSBiYXNpYyBhbGdvcml0aG0gd2UgbmVlZCB0byBkbyBpcyB0byBwb3AgYmFjayBhbnkgY29udGV4dHMgdGhhdCBhcmUgbm8gbG9uZ2VyIG9uIHRoZSBzdGFjay5cbiAgLy8gV2UgYWxzbyBuZWVkIHRvIHVwZGF0ZSBhbnkgbmV3IGNvbnRleHRzIHRoYXQgYXJlIG5vdyBvbiB0aGUgc3RhY2sgd2l0aCB0aGUgZGVlcGVzdCB2YWx1ZS5cbiAgLy8gVGhlIGVhc2llc3Qgd2F5IHRvIHVwZGF0ZSBuZXcgY29udGV4dHMgaXMgdG8ganVzdCByZWFwcGx5IHRoZW0gaW4gcmV2ZXJzZSBvcmRlciBmcm9tIHRoZVxuICAvLyBwZXJzcGVjdGl2ZSBvZiB0aGUgYmFja3BvaW50ZXJzLiBUbyBhdm9pZCBhbGxvY2F0aW5nIGEgbG90IHdoZW4gc3dpdGNoaW5nLCB3ZSB1c2UgdGhlIHN0YWNrXG4gIC8vIGZvciB0aGF0LiBUaGVyZWZvcmUgdGhpcyBhbGdvcml0aG0gaXMgcmVjdXJzaXZlLlxuICAvLyAxKSBGaXJzdCB3ZSBwb3Agd2hpY2ggZXZlciBzbmFwc2hvdCB0cmVlIHdhcyBkZWVwZXN0LiBQb3BwaW5nIG9sZCBjb250ZXh0cyBhcyB3ZSBnby5cbiAgLy8gMikgVGhlbiB3ZSBmaW5kIHRoZSBuZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBmcm9tIHRoZXJlLiBQb3BwaW5nIG9sZCBjb250ZXh0cyBhcyB3ZSBnby5cbiAgLy8gMykgVGhlbiB3ZSByZWFwcGx5IG5ldyBjb250ZXh0cyBvbiB0aGUgd2F5IGJhY2sgdXAgdGhlIHN0YWNrLlxuICB2YXIgcHJldiA9IGN1cnJlbnRBY3RpdmVTbmFwc2hvdDtcbiAgdmFyIG5leHQgPSBuZXdTbmFwc2hvdDtcblxuICBpZiAocHJldiAhPT0gbmV4dCkge1xuICAgIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lOiBUaGlzIGhhcyB0byBiZSBub24tbnVsbCBzaW5jZSBpdCdzIG5vdCBlcXVhbCB0byBwcmV2LlxuICAgICAgcHVzaEFsbE5leHQobmV4dCk7XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICBwb3BBbGxQcmV2aW91cyhwcmV2KTtcbiAgICB9IGVsc2UgaWYgKHByZXYuZGVwdGggPT09IG5leHQuZGVwdGgpIHtcbiAgICAgIHBvcFRvTmVhcmVzdENvbW1vbkFuY2VzdG9yKHByZXYsIG5leHQpO1xuICAgIH0gZWxzZSBpZiAocHJldi5kZXB0aCA+IG5leHQuZGVwdGgpIHtcbiAgICAgIHBvcFByZXZpb3VzVG9Db21tb25MZXZlbChwcmV2LCBuZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9wTmV4dFRvQ29tbW9uTGV2ZWwocHJldiwgbmV4dCk7XG4gICAgfVxuXG4gICAgY3VycmVudEFjdGl2ZVNuYXBzaG90ID0gbmV4dDtcbiAgfVxufVxuZnVuY3Rpb24gcHVzaFByb3ZpZGVyKGNvbnRleHQsIG5leHRWYWx1ZSkge1xuICB2YXIgcHJldlZhbHVlO1xuXG4gIHtcbiAgICBwcmV2VmFsdWUgPSBjb250ZXh0Ll9jdXJyZW50VmFsdWU7XG4gICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gbmV4dFZhbHVlO1xuXG4gICAge1xuICAgICAgaWYgKGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAhPT0gdW5kZWZpbmVkICYmIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAhPT0gbnVsbCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IHJlbmRlcmVyU2lnaWwpIHtcbiAgICAgICAgZXJyb3IoJ0RldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSAnICsgJ3NhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IHJlbmRlcmVyU2lnaWw7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByZXZOb2RlID0gY3VycmVudEFjdGl2ZVNuYXBzaG90O1xuICB2YXIgbmV3Tm9kZSA9IHtcbiAgICBwYXJlbnQ6IHByZXZOb2RlLFxuICAgIGRlcHRoOiBwcmV2Tm9kZSA9PT0gbnVsbCA/IDAgOiBwcmV2Tm9kZS5kZXB0aCArIDEsXG4gICAgY29udGV4dDogY29udGV4dCxcbiAgICBwYXJlbnRWYWx1ZTogcHJldlZhbHVlLFxuICAgIHZhbHVlOiBuZXh0VmFsdWVcbiAgfTtcbiAgY3VycmVudEFjdGl2ZVNuYXBzaG90ID0gbmV3Tm9kZTtcbiAgcmV0dXJuIG5ld05vZGU7XG59XG5mdW5jdGlvbiBwb3BQcm92aWRlcihjb250ZXh0KSB7XG4gIHZhciBwcmV2U25hcHNob3QgPSBjdXJyZW50QWN0aXZlU25hcHNob3Q7XG5cbiAgaWYgKHByZXZTbmFwc2hvdCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJpZWQgdG8gcG9wIGEgQ29udGV4dCBhdCB0aGUgcm9vdCBvZiB0aGUgYXBwLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICB9XG5cbiAge1xuICAgIGlmIChwcmV2U25hcHNob3QuY29udGV4dCAhPT0gY29udGV4dCkge1xuICAgICAgZXJyb3IoJ1RoZSBwYXJlbnQgY29udGV4dCBpcyBub3QgdGhlIGV4cGVjdGVkIGNvbnRleHQuIFRoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIHZhciB2YWx1ZSA9IHByZXZTbmFwc2hvdC5wYXJlbnRWYWx1ZTtcblxuICAgIGlmICh2YWx1ZSA9PT0gUkVBQ1RfU0VSVkVSX0NPTlRFWFRfREVGQVVMVF9WQUxVRV9OT1RfTE9BREVEKSB7XG4gICAgICBwcmV2U25hcHNob3QuY29udGV4dC5fY3VycmVudFZhbHVlID0gcHJldlNuYXBzaG90LmNvbnRleHQuX2RlZmF1bHRWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldlNuYXBzaG90LmNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IG51bGwgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSByZW5kZXJlclNpZ2lsKSB7XG4gICAgICAgIGVycm9yKCdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArICdzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLicpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSByZW5kZXJlclNpZ2lsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjdXJyZW50QWN0aXZlU25hcHNob3QgPSBwcmV2U25hcHNob3QucGFyZW50O1xufVxuZnVuY3Rpb24gZ2V0QWN0aXZlQ29udGV4dCgpIHtcbiAgcmV0dXJuIGN1cnJlbnRBY3RpdmVTbmFwc2hvdDtcbn1cbmZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQpIHtcbiAgdmFyIHZhbHVlID0gIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBgUmVhY3RJbnN0YW5jZU1hcGAgbWFpbnRhaW5zIGEgbWFwcGluZyBmcm9tIGEgcHVibGljIGZhY2luZyBzdGF0ZWZ1bFxuICogaW5zdGFuY2UgKGtleSkgYW5kIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiAodmFsdWUpLiBUaGlzIGFsbG93cyBwdWJsaWNcbiAqIG1ldGhvZHMgdG8gYWNjZXB0IHRoZSB1c2VyIGZhY2luZyBpbnN0YW5jZSBhcyBhbiBhcmd1bWVudCBhbmQgbWFwIHRoZW0gYmFja1xuICogdG8gaW50ZXJuYWwgbWV0aG9kcy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBtb2R1bGUgaXMgY3VycmVudGx5IHNoYXJlZCBhbmQgYXNzdW1lZCB0byBiZSBzdGF0ZWxlc3MuXG4gKiBJZiB0aGlzIGJlY29tZXMgYW4gYWN0dWFsIE1hcCwgdGhhdCB3aWxsIGJyZWFrLlxuICovXG5mdW5jdGlvbiBnZXQoa2V5KSB7XG4gIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxzO1xufVxuZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAga2V5Ll9yZWFjdEludGVybmFscyA9IHZhbHVlO1xufVxuXG52YXIgZGlkV2FybkFib3V0Tm9vcFVwZGF0ZUZvckNvbXBvbmVudCA9IHt9O1xudmFyIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRXaWxsTW91bnQgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGU7XG52YXIgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlO1xudmFyIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGU7XG52YXIgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlO1xudmFyIHdhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZTtcbnZhciB3YXJuT25JbnZhbGlkQ2FsbGJhY2s7XG52YXIgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGU7XG52YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXM7XG52YXIgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlO1xuXG57XG4gIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcyA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlID0gbmV3IFNldCgpO1xuICB2YXIgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrID0gbmV3IFNldCgpO1xuXG4gIHdhcm5PbkludmFsaWRDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIGlmIChjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIga2V5ID0gY2FsbGVyTmFtZSArICdfJyArIGNhbGxiYWNrO1xuXG4gICAgaWYgKCFkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suaGFzKGtleSkpIHtcbiAgICAgIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5hZGQoa2V5KTtcblxuICAgICAgZXJyb3IoJyVzKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsZXJOYW1lLCBjYWxsYmFjayk7XG4gICAgfVxuICB9O1xuXG4gIHdhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IGZ1bmN0aW9uICh0eXBlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICBpZiAocGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignJXMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCk6IEEgdmFsaWQgc3RhdGUgb2JqZWN0IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiAnICsgJ1lvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgX2NvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBfY29uc3RydWN0b3IgJiYgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKF9jb25zdHJ1Y3RvcikgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArICcuJyArIGNhbGxlck5hbWU7XG5cbiAgICBpZiAoZGlkV2FybkFib3V0Tm9vcFVwZGF0ZUZvckNvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVycm9yKCclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvdXRzaWRlIGNvbXBvbmVudFdpbGxNb3VudCgpIG9uIHRoZSBzZXJ2ZXIuICcgKyAnVGhpcyBpcyBhIG5vLW9wLlxcblxcblBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBjb21wb25lbnROYW1lKTtcblxuICAgIGRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnRbd2FybmluZ0tleV0gPSB0cnVlO1xuICB9XG59XG5cbnZhciBjbGFzc0NvbXBvbmVudFVwZGF0ZXIgPSB7XG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKGluc3QpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGludGVybmFscyA9IGdldChpbnN0KTtcblxuICAgIGlmIChpbnRlcm5hbHMucXVldWUgPT09IG51bGwpIHtcbiAgICAgIHdhcm5Ob29wKGluc3QsICdzZXRTdGF0ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcm5hbHMucXVldWUucHVzaChwYXlsb2FkKTtcblxuICAgICAge1xuICAgICAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBpbnRlcm5hbHMgPSBnZXQoaW5zdCk7XG4gICAgaW50ZXJuYWxzLnJlcGxhY2UgPSB0cnVlO1xuICAgIGludGVybmFscy5xdWV1ZSA9IFtwYXlsb2FkXTtcblxuICAgIHtcbiAgICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChpbnN0LCBjYWxsYmFjaykge1xuICAgIHZhciBpbnRlcm5hbHMgPSBnZXQoaW5zdCk7XG5cbiAgICBpZiAoaW50ZXJuYWxzLnF1ZXVlID09PSBudWxsKSB7XG4gICAgICB3YXJuTm9vcChpbnN0LCAnZm9yY2VVcGRhdGUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKGluc3RhbmNlLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIHByZXZTdGF0ZSwgbmV4dFByb3BzKSB7XG4gIHZhciBwYXJ0aWFsU3RhdGUgPSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuXG4gIHtcbiAgICB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUoY3RvciwgcGFydGlhbFN0YXRlKTtcbiAgfSAvLyBNZXJnZSB0aGUgcGFydGlhbCBzdGF0ZSBhbmQgdGhlIHByZXZpb3VzIHN0YXRlLlxuXG5cbiAgdmFyIG5ld1N0YXRlID0gcGFydGlhbFN0YXRlID09PSBudWxsIHx8IHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkID8gcHJldlN0YXRlIDogYXNzaWduKHt9LCBwcmV2U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0Q2xhc3NJbnN0YW5jZShjdG9yLCBwcm9wcywgbWFza2VkTGVnYWN5Q29udGV4dCkge1xuICB2YXIgY29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcblxuICB7XG4gICAgaWYgKCdjb250ZXh0VHlwZScgaW4gY3Rvcikge1xuICAgICAgdmFyIGlzVmFsaWQgPSAvLyBBbGxvdyBudWxsIGZvciBjb25kaXRpb25hbCBkZWNsYXJhdGlvblxuICAgICAgY29udGV4dFR5cGUgPT09IG51bGwgfHwgY29udGV4dFR5cGUgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFICYmIGNvbnRleHRUeXBlLl9jb250ZXh0ID09PSB1bmRlZmluZWQ7IC8vIE5vdCBhIDxDb250ZXh0LkNvbnN1bWVyPlxuXG4gICAgICBpZiAoIWlzVmFsaWQgJiYgIWRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5oYXMoY3RvcikpIHtcbiAgICAgICAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmFkZChjdG9yKTtcbiAgICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG5cbiAgICAgICAgaWYgKGNvbnRleHRUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIHVuZGVmaW5lZC4gJyArICdUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSB0eXBvIG9yIGJ5IG1peGluZyB1cCBuYW1lZCBhbmQgZGVmYXVsdCBpbXBvcnRzLiAnICsgJ1RoaXMgY2FuIGFsc28gaGFwcGVuIGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHNvICcgKyAndHJ5IG1vdmluZyB0aGUgY3JlYXRlQ29udGV4dCgpIGNhbGwgdG8gYSBzZXBhcmF0ZSBmaWxlLic7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRleHRUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYSAnICsgdHlwZW9mIGNvbnRleHRUeXBlICsgJy4nO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFKSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuUHJvdmlkZXIgaW5zdGVhZD8nO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLl9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyA8Q29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgICBhZGRlbmR1bSA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Db25zdW1lciBpbnN0ZWFkPyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhbiBvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY29udGV4dFR5cGUpLmpvaW4oJywgJykgKyAnfS4nO1xuICAgICAgICB9XG5cbiAgICAgICAgZXJyb3IoJyVzIGRlZmluZXMgYW4gaW52YWxpZCBjb250ZXh0VHlwZS4gJyArICdjb250ZXh0VHlwZSBzaG91bGQgcG9pbnQgdG8gdGhlIENvbnRleHQgb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZUNvbnRleHQoKS4lcycsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JywgYWRkZW5kdW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgY29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0ID0gbWFza2VkTGVnYWN5Q29udGV4dDtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IG5ldyBjdG9yKHByb3BzLCBjb250ZXh0KTtcblxuICB7XG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAoaW5zdGFuY2Uuc3RhdGUgPT09IG51bGwgfHwgaW5zdGFuY2Uuc3RhdGUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignYCVzYCB1c2VzIGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGJ1dCBpdHMgaW5pdGlhbCBzdGF0ZSBpcyAnICsgJyVzLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZC4gSW5zdGVhZCwgZGVmaW5lIHRoZSBpbml0aWFsIHN0YXRlIGJ5ICcgKyAnYXNzaWduaW5nIGFuIG9iamVjdCB0byBgdGhpcy5zdGF0ZWAgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIGAlc2AuICcgKyAnVGhpcyBlbnN1cmVzIHRoYXQgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYXJndW1lbnRzIGhhdmUgYSBjb25zaXN0ZW50IHNoYXBlLicsIGNvbXBvbmVudE5hbWUsIGluc3RhbmNlLnN0YXRlID09PSBudWxsID8gJ251bGwnIDogJ3VuZGVmaW5lZCcsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH0gLy8gSWYgbmV3IGNvbXBvbmVudCBBUElzIGFyZSBkZWZpbmVkLCBcInVuc2FmZVwiIGxpZmVjeWNsZXMgd29uJ3QgYmUgY2FsbGVkLlxuICAgIC8vIFdhcm4gYWJvdXQgdGhlc2UgbGlmZWN5Y2xlcyBpZiB0aGV5IGFyZSBwcmVzZW50LlxuICAgIC8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBtZXRob2RzIHRob3VnaC5cblxuXG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBmb3VuZFdpbGxNb3VudE5hbWUgPSBudWxsO1xuICAgICAgdmFyIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSBudWxsO1xuICAgICAgdmFyIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBudWxsO1xuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxNb3VudE5hbWUgPSAnY29tcG9uZW50V2lsbE1vdW50JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsTW91bnQnO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gJ2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgfHwgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCB8fCBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgICB2YXIgbmV3QXBpTmFtZSA9IHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyA/ICdnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKScgOiAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSc7XG5cbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmhhcyhfY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmFkZChfY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgICBlcnJvcignVW5zYWZlIGxlZ2FjeSBsaWZlY3ljbGVzIHdpbGwgbm90IGJlIGNhbGxlZCBmb3IgY29tcG9uZW50cyB1c2luZyBuZXcgY29tcG9uZW50IEFQSXMuXFxuXFxuJyArICclcyB1c2VzICVzIGJ1dCBhbHNvIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgbGVnYWN5IGxpZmVjeWNsZXM6JXMlcyVzXFxuXFxuJyArICdUaGUgYWJvdmUgbGlmZWN5Y2xlcyBzaG91bGQgYmUgcmVtb3ZlZC4gTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTpcXG4nICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMnLCBfY29tcG9uZW50TmFtZSwgbmV3QXBpTmFtZSwgZm91bmRXaWxsTW91bnROYW1lICE9PSBudWxsID8gXCJcXG4gIFwiICsgZm91bmRXaWxsTW91bnROYW1lIDogJycsIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIDogJycsIGZvdW5kV2lsbFVwZGF0ZU5hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxVcGRhdGVOYW1lIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBjaGVja0NsYXNzSW5zdGFuY2UoaW5zdGFuY2UsIGN0b3IsIG5ld1Byb3BzKSB7XG4gIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JztcbiAgICB2YXIgcmVuZGVyUHJlc2VudCA9IGluc3RhbmNlLnJlbmRlcjtcblxuICAgIGlmICghcmVuZGVyUHJlc2VudCkge1xuICAgICAgaWYgKGN0b3IucHJvdG90eXBlICYmIHR5cGVvZiBjdG9yLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/JywgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmdldEluaXRpYWxTdGF0ZSAmJiAhaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmICFpbnN0YW5jZS5zdGF0ZSkge1xuICAgICAgZXJyb3IoJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzICYmICFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcFR5cGVzKSB7XG4gICAgICBlcnJvcigncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmNvbnRleHRUeXBlKSB7XG4gICAgICBlcnJvcignY29udGV4dFR5cGUgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZSBpbnN0ZWFkLicsIG5hbWUpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChpbnN0YW5jZS5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgZXJyb3IoJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3Rvci5jb250ZXh0VHlwZSAmJiBjdG9yLmNvbnRleHRUeXBlcyAmJiAhZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMuaGFzKGN0b3IpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzLmFkZChjdG9yKTtcblxuICAgICAgICBlcnJvcignJXMgZGVjbGFyZXMgYm90aCBjb250ZXh0VHlwZXMgYW5kIGNvbnRleHRUeXBlIHN0YXRpYyBwcm9wZXJ0aWVzLiAnICsgJ1RoZSBsZWdhY3kgY29udGV4dFR5cGVzIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZC4nLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChjdG9yLnByb3RvdHlwZSAmJiBjdG9yLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJiB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkuICcgKyAnc2hvdWxkQ29tcG9uZW50VXBkYXRlIHNob3VsZCBub3QgYmUgdXNlZCB3aGVuIGV4dGVuZGluZyBSZWFjdC5QdXJlQ29tcG9uZW50LiAnICsgJ1BsZWFzZSBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB1c2VkLicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQSBwdXJlIGNvbXBvbmVudCcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzKCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnSWYgeW91IG1lYW50IHRvIHVwZGF0ZSB0aGUgc3RhdGUgaW4gcmVzcG9uc2UgdG8gY2hhbmdpbmcgcHJvcHMsICcgKyAndXNlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKS4gSWYgeW91IG1lYW50IHRvIGZldGNoIGRhdGEgb3IgJyArICdydW4gc2lkZS1lZmZlY3RzIG9yIG11dGF0aW9ucyBhZnRlciBSZWFjdCBoYXMgdXBkYXRlZCB0aGUgVUksIHVzZSBjb21wb25lbnREaWRVcGRhdGUoKS4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIGhhc011dGF0ZWRQcm9wcyA9IGluc3RhbmNlLnByb3BzICE9PSBuZXdQcm9wcztcblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gdW5kZWZpbmVkICYmIGhhc011dGF0ZWRQcm9wcykge1xuICAgICAgZXJyb3IoJyVzKC4uLik6IFdoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzICcgKyBcInVwIHRoZSBzYW1lIHByb3BzIHRoYXQgeW91ciBjb21wb25lbnQncyBjb25zdHJ1Y3RvciB3YXMgcGFzc2VkLlwiLCBuYW1lLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZGVmYXVsdFByb3BzKSB7XG4gICAgICBlcnJvcignU2V0dGluZyBkZWZhdWx0UHJvcHMgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSBpZ25vcmVkLicgKyAnIEluc3RlYWQsIGRlZmluZSBkZWZhdWx0UHJvcHMgYXMgYSBzdGF0aWMgcHJvcGVydHkgb24gJXMuJywgbmFtZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmICFkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuaGFzKGN0b3IpKSB7XG4gICAgICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuYWRkKGN0b3IpO1xuXG4gICAgICBlcnJvcignJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgc2hvdWxkIGJlIHVzZWQgd2l0aCBjb21wb25lbnREaWRVcGRhdGUoKS4gJyArICdUaGlzIGNvbXBvbmVudCBkZWZpbmVzIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgb25seS4nLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXM6IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclczogZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGN0b3IuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBpcyBkZWZpbmVkIGFzIGEgc3RhdGljIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kLicsIG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBfc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcblxuICAgIGlmIChfc3RhdGUgJiYgKHR5cGVvZiBfc3RhdGUgIT09ICdvYmplY3QnIHx8IGlzQXJyYXkoX3N0YXRlKSkpIHtcbiAgICAgIGVycm9yKCclcy5zdGF0ZTogbXVzdCBiZSBzZXQgdG8gYW4gb2JqZWN0IG9yIG51bGwnLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY3Rvci5jaGlsZENvbnRleHRUeXBlcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGVycm9yKCclcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvICcgKyAndXNlIGdldENoaWxkQ29udGV4dCgpLicsIG5hbWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHR5cGUsIGluc3RhbmNlKSB7XG4gIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgaWYgKCBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgd2FybiggLy8ga2VlcCB0aGlzIHdhcm5pbmcgaW4gc3luYyB3aXRoIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmcuanNcbiAgICAgICAgICAnY29tcG9uZW50V2lsbE1vdW50IGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBjb2RlIGZyb20gY29tcG9uZW50V2lsbE1vdW50IHRvIGNvbXBvbmVudERpZE1vdW50IChwcmVmZXJyZWQgaW4gbW9zdCBjYXNlcykgJyArICdvciB0aGUgY29uc3RydWN0b3IuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRXaWxsTW91bnRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCk7XG4gIH1cblxuICBpZiAob2xkU3RhdGUgIT09IGluc3RhbmNlLnN0YXRlKSB7XG4gICAge1xuICAgICAgZXJyb3IoJyVzLmNvbXBvbmVudFdpbGxNb3VudCgpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gdGhpcy5zdGF0ZSBpcyAnICsgXCJkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgXCIgKyAnY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ0NvbXBvbmVudCcpO1xuICAgIH1cblxuICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGludGVybmFsSW5zdGFuY2UsIGluc3QsIHByb3BzLCBtYXNrZWRMZWdhY3lDb250ZXh0KSB7XG4gIGlmIChpbnRlcm5hbEluc3RhbmNlLnF1ZXVlICE9PSBudWxsICYmIGludGVybmFsSW5zdGFuY2UucXVldWUubGVuZ3RoID4gMCkge1xuICAgIHZhciBvbGRRdWV1ZSA9IGludGVybmFsSW5zdGFuY2UucXVldWU7XG4gICAgdmFyIG9sZFJlcGxhY2UgPSBpbnRlcm5hbEluc3RhbmNlLnJlcGxhY2U7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5xdWV1ZSA9IG51bGw7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5yZXBsYWNlID0gZmFsc2U7XG5cbiAgICBpZiAob2xkUmVwbGFjZSAmJiBvbGRRdWV1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGluc3Quc3RhdGUgPSBvbGRRdWV1ZVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5leHRTdGF0ZSA9IG9sZFJlcGxhY2UgPyBvbGRRdWV1ZVswXSA6IGluc3Quc3RhdGU7XG4gICAgICB2YXIgZG9udE11dGF0ZSA9IHRydWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSBvbGRSZXBsYWNlID8gMSA6IDA7IGkgPCBvbGRRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGFydGlhbCA9IG9sZFF1ZXVlW2ldO1xuICAgICAgICB2YXIgcGFydGlhbFN0YXRlID0gdHlwZW9mIHBhcnRpYWwgPT09ICdmdW5jdGlvbicgPyBwYXJ0aWFsLmNhbGwoaW5zdCwgbmV4dFN0YXRlLCBwcm9wcywgbWFza2VkTGVnYWN5Q29udGV4dCkgOiBwYXJ0aWFsO1xuXG4gICAgICAgIGlmIChwYXJ0aWFsU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChkb250TXV0YXRlKSB7XG4gICAgICAgICAgICBkb250TXV0YXRlID0gZmFsc2U7XG4gICAgICAgICAgICBuZXh0U3RhdGUgPSBhc3NpZ24oe30sIG5leHRTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXNzaWduKG5leHRTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5zdC5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5xdWV1ZSA9IG51bGw7XG4gIH1cbn0gLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuXG5cbmZ1bmN0aW9uIG1vdW50Q2xhc3NJbnN0YW5jZShpbnN0YW5jZSwgY3RvciwgbmV3UHJvcHMsIG1hc2tlZExlZ2FjeUNvbnRleHQpIHtcbiAge1xuICAgIGNoZWNrQ2xhc3NJbnN0YW5jZShpbnN0YW5jZSwgY3RvciwgbmV3UHJvcHMpO1xuICB9XG5cbiAgdmFyIGluaXRpYWxTdGF0ZSA9IGluc3RhbmNlLnN0YXRlICE9PSB1bmRlZmluZWQgPyBpbnN0YW5jZS5zdGF0ZSA6IG51bGw7XG4gIGluc3RhbmNlLnVwZGF0ZXIgPSBjbGFzc0NvbXBvbmVudFVwZGF0ZXI7XG4gIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gaW5pdGlhbFN0YXRlOyAvLyBXZSBkb24ndCBib3RoZXIgaW5pdGlhbGl6aW5nIHRoZSByZWZzIG9iamVjdCBvbiB0aGUgc2VydmVyLCBzaW5jZSB3ZSdyZSBub3QgZ29pbmcgdG8gcmVzb2x2ZSB0aGVtIGFueXdheS5cbiAgLy8gVGhlIGludGVybmFsIGluc3RhbmNlIHdpbGwgYmUgdXNlZCB0byBtYW5hZ2UgdXBkYXRlcyB0aGF0IGhhcHBlbiBkdXJpbmcgdGhpcyBtb3VudC5cblxuICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IHtcbiAgICBxdWV1ZTogW10sXG4gICAgcmVwbGFjZTogZmFsc2VcbiAgfTtcbiAgc2V0KGluc3RhbmNlLCBpbnRlcm5hbEluc3RhbmNlKTtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcblxuICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIGluc3RhbmNlLmNvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IG1hc2tlZExlZ2FjeUNvbnRleHQ7XG4gIH1cblxuICB7XG4gICAgaWYgKGluc3RhbmNlLnN0YXRlID09PSBuZXdQcm9wcykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignJXM6IEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0byBhc3NpZ24gcHJvcHMgZGlyZWN0bHkgdG8gc3RhdGUgJyArIFwiYmVjYXVzZSB1cGRhdGVzIHRvIHByb3BzIHdvbid0IGJlIHJlZmxlY3RlZCBpbiBzdGF0ZS4gXCIgKyAnSW4gbW9zdCBjYXNlcywgaXQgaXMgYmV0dGVyIHRvIHVzZSBwcm9wcyBkaXJlY3RseS4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG5cbiAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKGluc3RhbmNlLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIGluaXRpYWxTdGF0ZSwgbmV3UHJvcHMpO1xuICB9IC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuXG5cbiAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgIT09ICdmdW5jdGlvbicgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgY2FsbENvbXBvbmVudFdpbGxNb3VudChjdG9yLCBpbnN0YW5jZSk7IC8vIElmIHdlIGhhZCBhZGRpdGlvbmFsIHN0YXRlIHVwZGF0ZXMgZHVyaW5nIHRoaXMgbGlmZS1jeWNsZSwgbGV0J3NcbiAgICAvLyBwcm9jZXNzIHRoZW0gbm93LlxuXG4gICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKGludGVybmFsSW5zdGFuY2UsIGluc3RhbmNlLCBuZXdQcm9wcywgbWFza2VkTGVnYWN5Q29udGV4dCk7XG4gIH1cbn1cblxuLy8gSWRzIGFyZSBiYXNlIDMyIHN0cmluZ3Mgd2hvc2UgYmluYXJ5IHJlcHJlc2VudGF0aW9uIGNvcnJlc3BvbmRzIHRvIHRoZVxuLy8gcG9zaXRpb24gb2YgYSBub2RlIGluIGEgdHJlZS5cbi8vIEV2ZXJ5IHRpbWUgdGhlIHRyZWUgZm9ya3MgaW50byBtdWx0aXBsZSBjaGlsZHJlbiwgd2UgYWRkIGFkZGl0aW9uYWwgYml0cyB0b1xuLy8gdGhlIGxlZnQgb2YgdGhlIHNlcXVlbmNlIHRoYXQgcmVwcmVzZW50IHRoZSBwb3NpdGlvbiBvZiB0aGUgY2hpbGQgd2l0aGluIHRoZVxuLy8gY3VycmVudCBsZXZlbCBvZiBjaGlsZHJlbi5cbi8vXG4vLyAgICAgIDAwMTAxICAgICAgIDAwMDEwMDAxMDExMDEwMTAxXG4vLyAgICAgIOKVsOKUgOKUrOKUgOKVryAgICAgICDilbDilIDilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDila9cbi8vICAgRm9yayA1IG9mIDIwICAgICAgIFBhcmVudCBpZFxuLy9cbi8vIFRoZSBsZWFkaW5nIDBzIGFyZSBpbXBvcnRhbnQuIEluIHRoZSBhYm92ZSBleGFtcGxlLCB5b3Ugb25seSBuZWVkIDMgYml0cyB0b1xuLy8gcmVwcmVzZW50IHNsb3QgNS4gSG93ZXZlciwgeW91IG5lZWQgNSBiaXRzIHRvIHJlcHJlc2VudCBhbGwgdGhlIGZvcmtzIGF0XG4vLyB0aGUgY3VycmVudCBsZXZlbCwgc28gd2UgbXVzdCBhY2NvdW50IGZvciB0aGUgZW1wdHkgYml0cyBhdCB0aGUgZW5kLlxuLy9cbi8vIEZvciB0aGlzIHNhbWUgcmVhc29uLCBzbG90cyBhcmUgMS1pbmRleGVkIGluc3RlYWQgb2YgMC1pbmRleGVkLiBPdGhlcndpc2UsXG4vLyB0aGUgemVyb3RoIGlkIGF0IGEgbGV2ZWwgd291bGQgYmUgaW5kaXN0aW5ndWlzaGFibGUgZnJvbSBpdHMgcGFyZW50LlxuLy9cbi8vIElmIGEgbm9kZSBoYXMgb25seSBvbmUgY2hpbGQsIGFuZCBkb2VzIG5vdCBtYXRlcmlhbGl6ZSBhbiBpZCAoaS5lLiBkb2VzIG5vdFxuLy8gY29udGFpbiBhIHVzZUlkIGhvb2spLCB0aGVuIHdlIGRvbid0IG5lZWQgdG8gYWxsb2NhdGUgYW55IHNwYWNlIGluIHRoZVxuLy8gc2VxdWVuY2UuIEl0J3MgdHJlYXRlZCBhcyBhIHRyYW5zcGFyZW50IGluZGlyZWN0aW9uLiBGb3IgZXhhbXBsZSwgdGhlc2UgdHdvXG4vLyB0cmVlcyBwcm9kdWNlIHRoZSBzYW1lIGlkczpcbi8vXG4vLyA8PiAgICAgICAgICAgICAgICAgICAgICAgICAgPD5cbi8vICAgPEluZGlyZWN0aW9uPiAgICAgICAgICAgICAgIDxBIC8+XG4vLyAgICAgPEEgLz4gICAgICAgICAgICAgICAgICAgICA8QiAvPlxuLy8gICA8L0luZGlyZWN0aW9uPiAgICAgICAgICAgIDwvPlxuLy8gICA8QiAvPlxuLy8gPC8+XG4vL1xuLy8gSG93ZXZlciwgd2UgY2Fubm90IHNraXAgYW55IG5vZGUgdGhhdCBtYXRlcmlhbGl6ZXMgYW4gaWQuIE90aGVyd2lzZSwgYSBwYXJlbnRcbi8vIGlkIHRoYXQgZG9lcyBub3QgZm9yayB3b3VsZCBiZSBpbmRpc3Rpbmd1aXNoYWJsZSBmcm9tIGl0cyBjaGlsZCBpZC4gRm9yXG4vLyBleGFtcGxlLCB0aGlzIHRyZWUgZG9lcyBub3QgZm9yaywgYnV0IHRoZSBwYXJlbnQgYW5kIGNoaWxkIG11c3QgaGF2ZVxuLy8gZGlmZmVyZW50IGlkcy5cbi8vXG4vLyA8UGFyZW50PlxuLy8gICA8Q2hpbGQgLz5cbi8vIDwvUGFyZW50PlxuLy9cbi8vIFRvIGhhbmRsZSB0aGlzIHNjZW5hcmlvLCBldmVyeSB0aW1lIHdlIG1hdGVyaWFsaXplIGFuIGlkLCB3ZSBhbGxvY2F0ZSBhXG4vLyBuZXcgbGV2ZWwgd2l0aCBhIHNpbmdsZSBzbG90LiBZb3UgY2FuIHRoaW5rIG9mIHRoaXMgYXMgYSBmb3JrIHdpdGggb25seSBvbmVcbi8vIHByb25nLCBvciBhbiBhcnJheSBvZiBjaGlsZHJlbiB3aXRoIGxlbmd0aCAxLlxuLy9cbi8vIEl0J3MgcG9zc2libGUgZm9yIHRoZSBzaXplIG9mIHRoZSBzZXF1ZW5jZSB0byBleGNlZWQgMzIgYml0cywgdGhlIG1heFxuLy8gc2l6ZSBmb3IgYml0d2lzZSBvcGVyYXRpb25zLiBXaGVuIHRoaXMgaGFwcGVucywgd2UgbWFrZSBtb3JlIHJvb20gYnlcbi8vIGNvbnZlcnRpbmcgdGhlIHJpZ2h0IHBhcnQgb2YgdGhlIGlkIHRvIGEgc3RyaW5nIGFuZCBzdG9yaW5nIGl0IGluIGFuIG92ZXJmbG93XG4vLyB2YXJpYWJsZS4gV2UgdXNlIGEgYmFzZSAzMiBzdHJpbmcgcmVwcmVzZW50YXRpb24sIGJlY2F1c2UgMzIgaXMgdGhlIGxhcmdlc3Rcbi8vIHBvd2VyIG9mIDIgdGhhdCBpcyBzdXBwb3J0ZWQgYnkgdG9TdHJpbmcoKS4gV2Ugd2FudCB0aGUgYmFzZSB0byBiZSBsYXJnZSBzb1xuLy8gdGhhdCB0aGUgcmVzdWx0aW5nIGlkcyBhcmUgY29tcGFjdCwgYW5kIHdlIHdhbnQgdGhlIGJhc2UgdG8gYmUgYSBwb3dlciBvZiAyXG4vLyBiZWNhdXNlIGV2ZXJ5IGxvZzIoYmFzZSkgYml0cyBjb3JyZXNwb25kcyB0byBhIHNpbmdsZSBjaGFyYWN0ZXIsIGkuZS4gZXZlcnlcbi8vIGxvZzIoMzIpID0gNSBiaXRzLiBUaGF0IG1lYW5zIHdlIGNhbiBsb3AgYml0cyBvZmYgdGhlIGVuZCA1IGF0IGEgdGltZSB3aXRob3V0XG4vLyBhZmZlY3RpbmcgdGhlIGZpbmFsIHJlc3VsdC5cbnZhciBlbXB0eVRyZWVDb250ZXh0ID0ge1xuICBpZDogMSxcbiAgb3ZlcmZsb3c6ICcnXG59O1xuZnVuY3Rpb24gZ2V0VHJlZUlkKGNvbnRleHQpIHtcbiAgdmFyIG92ZXJmbG93ID0gY29udGV4dC5vdmVyZmxvdztcbiAgdmFyIGlkV2l0aExlYWRpbmdCaXQgPSBjb250ZXh0LmlkO1xuICB2YXIgaWQgPSBpZFdpdGhMZWFkaW5nQml0ICYgfmdldExlYWRpbmdCaXQoaWRXaXRoTGVhZGluZ0JpdCk7XG4gIHJldHVybiBpZC50b1N0cmluZygzMikgKyBvdmVyZmxvdztcbn1cbmZ1bmN0aW9uIHB1c2hUcmVlQ29udGV4dChiYXNlQ29udGV4dCwgdG90YWxDaGlsZHJlbiwgaW5kZXgpIHtcbiAgdmFyIGJhc2VJZFdpdGhMZWFkaW5nQml0ID0gYmFzZUNvbnRleHQuaWQ7XG4gIHZhciBiYXNlT3ZlcmZsb3cgPSBiYXNlQ29udGV4dC5vdmVyZmxvdzsgLy8gVGhlIGxlZnRtb3N0IDEgbWFya3MgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UsIG5vbi1pbmNsdXNpdmUuIEl0J3Mgbm90IHBhcnRcbiAgLy8gb2YgdGhlIGlkOyB3ZSB1c2UgaXQgdG8gYWNjb3VudCBmb3IgbGVhZGluZyAwcy5cblxuICB2YXIgYmFzZUxlbmd0aCA9IGdldEJpdExlbmd0aChiYXNlSWRXaXRoTGVhZGluZ0JpdCkgLSAxO1xuICB2YXIgYmFzZUlkID0gYmFzZUlkV2l0aExlYWRpbmdCaXQgJiB+KDEgPDwgYmFzZUxlbmd0aCk7XG4gIHZhciBzbG90ID0gaW5kZXggKyAxO1xuICB2YXIgbGVuZ3RoID0gZ2V0Qml0TGVuZ3RoKHRvdGFsQ2hpbGRyZW4pICsgYmFzZUxlbmd0aDsgLy8gMzAgaXMgdGhlIG1heCBsZW5ndGggd2UgY2FuIHN0b3JlIHdpdGhvdXQgb3ZlcmZsb3dpbmcsIHRha2luZyBpbnRvXG4gIC8vIGNvbnNpZGVyYXRpb24gdGhlIGxlYWRpbmcgMSB3ZSB1c2UgdG8gbWFyayB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZS5cblxuICBpZiAobGVuZ3RoID4gMzApIHtcbiAgICAvLyBXZSBvdmVyZmxvd2VkIHRoZSBiaXR3aXNlLXNhZmUgcmFuZ2UuIEZhbGwgYmFjayB0byBzbG93ZXIgYWxnb3JpdGhtLlxuICAgIC8vIFRoaXMgYnJhbmNoIGFzc3VtZXMgdGhlIGxlbmd0aCBvZiB0aGUgYmFzZSBpZCBpcyBncmVhdGVyIHRoYW4gNTsgaXQgd29uJ3RcbiAgICAvLyB3b3JrIGZvciBzbWFsbGVyIGlkcywgYmVjYXVzZSB5b3UgbmVlZCA1IGJpdHMgcGVyIGNoYXJhY3Rlci5cbiAgICAvL1xuICAgIC8vIFdlIGVuY29kZSB0aGUgaWQgaW4gbXVsdGlwbGUgc3RlcHM6IGZpcnN0IHRoZSBiYXNlIGlkLCB0aGVuIHRoZVxuICAgIC8vIHJlbWFpbmluZyBkaWdpdHMuXG4gICAgLy9cbiAgICAvLyBFYWNoIDUgYml0IHNlcXVlbmNlIGNvcnJlc3BvbmRzIHRvIGEgc2luZ2xlIGJhc2UgMzIgY2hhcmFjdGVyLiBTbyBmb3JcbiAgICAvLyBleGFtcGxlLCBpZiB0aGUgY3VycmVudCBpZCBpcyAyMyBiaXRzIGxvbmcsIHdlIGNhbiBjb252ZXJ0IDIwIG9mIHRob3NlXG4gICAgLy8gYml0cyBpbnRvIGEgc3RyaW5nIG9mIDQgY2hhcmFjdGVycywgd2l0aCAzIGJpdHMgbGVmdCBvdmVyLlxuICAgIC8vXG4gICAgLy8gRmlyc3QgY2FsY3VsYXRlIGhvdyBtYW55IGJpdHMgaW4gdGhlIGJhc2UgaWQgcmVwcmVzZW50IGEgY29tcGxldGVcbiAgICAvLyBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzLlxuICAgIHZhciBudW1iZXJPZk92ZXJmbG93Qml0cyA9IGJhc2VMZW5ndGggLSBiYXNlTGVuZ3RoICUgNTsgLy8gVGhlbiBjcmVhdGUgYSBiaXRtYXNrIHRoYXQgc2VsZWN0cyBvbmx5IHRob3NlIGJpdHMuXG5cbiAgICB2YXIgbmV3T3ZlcmZsb3dCaXRzID0gKDEgPDwgbnVtYmVyT2ZPdmVyZmxvd0JpdHMpIC0gMTsgLy8gU2VsZWN0IHRoZSBiaXRzLCBhbmQgY29udmVydCB0aGVtIHRvIGEgYmFzZSAzMiBzdHJpbmcuXG5cbiAgICB2YXIgbmV3T3ZlcmZsb3cgPSAoYmFzZUlkICYgbmV3T3ZlcmZsb3dCaXRzKS50b1N0cmluZygzMik7IC8vIE5vdyB3ZSBjYW4gcmVtb3ZlIHRob3NlIGJpdHMgZnJvbSB0aGUgYmFzZSBpZC5cblxuICAgIHZhciByZXN0T2ZCYXNlSWQgPSBiYXNlSWQgPj4gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7XG4gICAgdmFyIHJlc3RPZkJhc2VMZW5ndGggPSBiYXNlTGVuZ3RoIC0gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7IC8vIEZpbmFsbHksIGVuY29kZSB0aGUgcmVzdCBvZiB0aGUgYml0cyB1c2luZyB0aGUgbm9ybWFsIGFsZ29yaXRobS4gQmVjYXVzZVxuICAgIC8vIHdlIG1hZGUgbW9yZSByb29tLCB0aGlzIHRpbWUgaXQgd29uJ3Qgb3ZlcmZsb3cuXG5cbiAgICB2YXIgcmVzdE9mTGVuZ3RoID0gZ2V0Qml0TGVuZ3RoKHRvdGFsQ2hpbGRyZW4pICsgcmVzdE9mQmFzZUxlbmd0aDtcbiAgICB2YXIgcmVzdE9mTmV3Qml0cyA9IHNsb3QgPDwgcmVzdE9mQmFzZUxlbmd0aDtcbiAgICB2YXIgaWQgPSByZXN0T2ZOZXdCaXRzIHwgcmVzdE9mQmFzZUlkO1xuICAgIHZhciBvdmVyZmxvdyA9IG5ld092ZXJmbG93ICsgYmFzZU92ZXJmbG93O1xuICAgIHJldHVybiB7XG4gICAgICBpZDogMSA8PCByZXN0T2ZMZW5ndGggfCBpZCxcbiAgICAgIG92ZXJmbG93OiBvdmVyZmxvd1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gTm9ybWFsIHBhdGhcbiAgICB2YXIgbmV3Qml0cyA9IHNsb3QgPDwgYmFzZUxlbmd0aDtcblxuICAgIHZhciBfaWQgPSBuZXdCaXRzIHwgYmFzZUlkO1xuXG4gICAgdmFyIF9vdmVyZmxvdyA9IGJhc2VPdmVyZmxvdztcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IDEgPDwgbGVuZ3RoIHwgX2lkLFxuICAgICAgb3ZlcmZsb3c6IF9vdmVyZmxvd1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Qml0TGVuZ3RoKG51bWJlcikge1xuICByZXR1cm4gMzIgLSBjbHozMihudW1iZXIpO1xufVxuXG5mdW5jdGlvbiBnZXRMZWFkaW5nQml0KGlkKSB7XG4gIHJldHVybiAxIDw8IGdldEJpdExlbmd0aChpZCkgLSAxO1xufSAvLyBUT0RPOiBNYXRoLmNsejMyIGlzIHN1cHBvcnRlZCBpbiBOb2RlIDEyKy4gTWF5YmUgd2UgY2FuIGRyb3AgdGhlIGZhbGxiYWNrLlxuXG5cbnZhciBjbHozMiA9IE1hdGguY2x6MzIgPyBNYXRoLmNsejMyIDogY2x6MzJGYWxsYmFjazsgLy8gQ291bnQgbGVhZGluZyB6ZXJvcy5cbi8vIEJhc2VkIG9uOlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9jbHozMlxuXG52YXIgbG9nID0gTWF0aC5sb2c7XG52YXIgTE4yID0gTWF0aC5MTjI7XG5cbmZ1bmN0aW9uIGNsejMyRmFsbGJhY2soeCkge1xuICB2YXIgYXNVaW50ID0geCA+Pj4gMDtcblxuICBpZiAoYXNVaW50ID09PSAwKSB7XG4gICAgcmV0dXJuIDMyO1xuICB9XG5cbiAgcmV0dXJuIDMxIC0gKGxvZyhhc1VpbnQpIC8gTE4yIHwgMCkgfCAwO1xufVxuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIHJldHVybiB4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkgfHwgeCAhPT0geCAmJiB5ICE9PSB5IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIDtcbn1cblxudmFyIG9iamVjdElzID0gdHlwZW9mIE9iamVjdC5pcyA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5pcyA6IGlzO1xuXG52YXIgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gbnVsbDtcbnZhciBjdXJyZW50bHlSZW5kZXJpbmdUYXNrID0gbnVsbDtcbnZhciBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG52YXIgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDsgLy8gV2hldGhlciB0aGUgd29yay1pbi1wcm9ncmVzcyBob29rIGlzIGEgcmUtcmVuZGVyZWQgaG9va1xuXG52YXIgaXNSZVJlbmRlciA9IGZhbHNlOyAvLyBXaGV0aGVyIGFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIGR1cmluZyB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyByZW5kZXIgcGFzcy5cblxudmFyIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTsgLy8gQ291bnRzIHRoZSBudW1iZXIgb2YgdXNlSWQgaG9va3MgaW4gdGhpcyBjb21wb25lbnRcblxudmFyIGxvY2FsSWRDb3VudGVyID0gMDsgLy8gTGF6aWx5IGNyZWF0ZWQgbWFwIG9mIHJlbmRlci1waGFzZSB1cGRhdGVzXG5cbnZhciByZW5kZXJQaGFzZVVwZGF0ZXMgPSBudWxsOyAvLyBDb3VudGVyIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMuXG5cbnZhciBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG52YXIgUkVfUkVOREVSX0xJTUlUID0gMjU7XG52YXIgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7IC8vIEluIERFViwgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyBwcmltaXRpdmUgaG9va1xuXG52YXIgY3VycmVudEhvb2tOYW1lSW5EZXY7XG5cbmZ1bmN0aW9uIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKSB7XG4gIGlmIChjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3InICsgJyBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbicgKyAnMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuJyArICcyLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuJyArICczLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS4nKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAoaXNJbkhvb2tVc2VyQ29kZUluRGV2KSB7XG4gICAgICBlcnJvcignRG8gbm90IGNhbGwgSG9va3MgaW5zaWRlIHVzZUVmZmVjdCguLi4pLCB1c2VNZW1vKC4uLiksIG9yIG90aGVyIGJ1aWx0LWluIEhvb2tzLiAnICsgJ1lvdSBjYW4gb25seSBjYWxsIEhvb2tzIGF0IHRoZSB0b3AgbGV2ZWwgb2YgeW91ciBSZWFjdCBmdW5jdGlvbi4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3J1bGVzLW9mLWhvb2tzJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudDtcbn1cblxuZnVuY3Rpb24gYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykge1xuICBpZiAocHJldkRlcHMgPT09IG51bGwpIHtcbiAgICB7XG4gICAgICBlcnJvcignJXMgcmVjZWl2ZWQgYSBmaW5hbCBhcmd1bWVudCBkdXJpbmcgdGhpcyByZW5kZXIsIGJ1dCBub3QgZHVyaW5nICcgKyAndGhlIHByZXZpb3VzIHJlbmRlci4gRXZlbiB0aG91Z2ggdGhlIGZpbmFsIGFyZ3VtZW50IGlzIG9wdGlvbmFsLCAnICsgJ2l0cyB0eXBlIGNhbm5vdCBjaGFuZ2UgYmV0d2VlbiByZW5kZXJzLicsIGN1cnJlbnRIb29rTmFtZUluRGV2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB7XG4gICAgLy8gRG9uJ3QgYm90aGVyIGNvbXBhcmluZyBsZW5ndGhzIGluIHByb2QgYmVjYXVzZSB0aGVzZSBhcnJheXMgc2hvdWxkIGJlXG4gICAgLy8gcGFzc2VkIGlubGluZS5cbiAgICBpZiAobmV4dERlcHMubGVuZ3RoICE9PSBwcmV2RGVwcy5sZW5ndGgpIHtcbiAgICAgIGVycm9yKCdUaGUgZmluYWwgYXJndW1lbnQgcGFzc2VkIHRvICVzIGNoYW5nZWQgc2l6ZSBiZXR3ZWVuIHJlbmRlcnMuIFRoZSAnICsgJ29yZGVyIGFuZCBzaXplIG9mIHRoaXMgYXJyYXkgbXVzdCByZW1haW4gY29uc3RhbnQuXFxuXFxuJyArICdQcmV2aW91czogJXNcXG4nICsgJ0luY29taW5nOiAlcycsIGN1cnJlbnRIb29rTmFtZUluRGV2LCBcIltcIiArIG5leHREZXBzLmpvaW4oJywgJykgKyBcIl1cIiwgXCJbXCIgKyBwcmV2RGVwcy5qb2luKCcsICcpICsgXCJdXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldkRlcHMubGVuZ3RoICYmIGkgPCBuZXh0RGVwcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChvYmplY3RJcyhuZXh0RGVwc1tpXSwgcHJldkRlcHNbaV0pKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSG9vaygpIHtcbiAgaWYgKG51bWJlck9mUmVSZW5kZXJzID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVuZGVyZWQgbW9yZSBob29rcyB0aGFuIGR1cmluZyB0aGUgcHJldmlvdXMgcmVuZGVyJyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1lbW9pemVkU3RhdGU6IG51bGwsXG4gICAgcXVldWU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSB7XG4gIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBob29rIGluIHRoZSBsaXN0XG4gICAgaWYgKGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgICBpc1JlUmVuZGVyID0gZmFsc2U7XG4gICAgICBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZUhvb2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUncyBhbHJlYWR5IGEgd29yay1pbi1wcm9ncmVzcy4gUmV1c2UgaXQuXG4gICAgICBpc1JlUmVuZGVyID0gdHJ1ZTtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPT09IG51bGwpIHtcbiAgICAgIGlzUmVSZW5kZXIgPSBmYWxzZTsgLy8gQXBwZW5kIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RcblxuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPSBjcmVhdGVIb29rKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIHdvcmstaW4tcHJvZ3Jlc3MuIFJldXNlIGl0LlxuICAgICAgaXNSZVJlbmRlciA9IHRydWU7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlVG9Vc2VIb29rcyh0YXNrLCBjb21wb25lbnRJZGVudGl0eSkge1xuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSBjb21wb25lbnRJZGVudGl0eTtcbiAgY3VycmVudGx5UmVuZGVyaW5nVGFzayA9IHRhc2s7XG5cbiAge1xuICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICB9IC8vIFRoZSBmb2xsb3dpbmcgc2hvdWxkIGhhdmUgYWxyZWFkeSBiZWVuIHJlc2V0XG4gIC8vIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgLy8gbG9jYWxJZENvdW50ZXIgPSAwO1xuICAvLyBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gIC8vIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbiAgLy8gcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDtcbiAgLy8gd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxuXG4gIGxvY2FsSWRDb3VudGVyID0gMDtcbn1cbmZ1bmN0aW9uIGZpbmlzaEhvb2tzKENvbXBvbmVudCwgcHJvcHMsIGNoaWxkcmVuLCByZWZPckNvbnRleHQpIHtcbiAgLy8gVGhpcyBtdXN0IGJlIGNhbGxlZCBhZnRlciBldmVyeSBmdW5jdGlvbiBjb21wb25lbnQgdG8gcHJldmVudCBob29rcyBmcm9tXG4gIC8vIGJlaW5nIHVzZWQgaW4gY2xhc3Nlcy5cbiAgd2hpbGUgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICAvLyBVcGRhdGVzIHdlcmUgc2NoZWR1bGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLiBUaGV5IGFyZSBzdG9yZWQgaW5cbiAgICAvLyB0aGUgYHJlbmRlclBoYXNlVXBkYXRlc2AgbWFwLiBDYWxsIHRoZSBjb21wb25lbnQgYWdhaW4sIHJldXNpbmcgdGhlXG4gICAgLy8gd29yay1pbi1wcm9ncmVzcyBob29rcyBhbmQgYXBwbHlpbmcgdGhlIGFkZGl0aW9uYWwgdXBkYXRlcyBvbiB0b3AuIEtlZXBcbiAgICAvLyByZXN0YXJ0aW5nIHVudGlsIG5vIG1vcmUgdXBkYXRlcyBhcmUgc2NoZWR1bGVkLlxuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgICBsb2NhbElkQ291bnRlciA9IDA7XG4gICAgbnVtYmVyT2ZSZVJlbmRlcnMgKz0gMTsgLy8gU3RhcnQgb3ZlciBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RcblxuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gICAgY2hpbGRyZW4gPSBDb21wb25lbnQocHJvcHMsIHJlZk9yQ29udGV4dCk7XG4gIH1cblxuICByZXNldEhvb2tzU3RhdGUoKTtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuZnVuY3Rpb24gY2hlY2tEaWRSZW5kZXJJZEhvb2soKSB7XG4gIC8vIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBldmVyeSBmaW5pc2hIb29rcyBjYWxsLlxuICAvLyBDb25jZXB0dWFsbHksIGl0J3MgcGFydCBvZiB0aGUgcmV0dXJuIHZhbHVlIG9mIGZpbmlzaEhvb2tzOyBpdCdzIG9ubHkgYVxuICAvLyBzZXBhcmF0ZSBmdW5jdGlvbiB0byBhdm9pZCB1c2luZyBhbiBhcnJheSB0dXBsZS5cbiAgdmFyIGRpZFJlbmRlcklkSG9vayA9IGxvY2FsSWRDb3VudGVyICE9PSAwO1xuICByZXR1cm4gZGlkUmVuZGVySWRIb29rO1xufSAvLyBSZXNldCB0aGUgaW50ZXJuYWwgaG9va3Mgc3RhdGUgaWYgYW4gZXJyb3Igb2NjdXJzIHdoaWxlIHJlbmRlcmluZyBhIGNvbXBvbmVudFxuXG5mdW5jdGlvbiByZXNldEhvb2tzU3RhdGUoKSB7XG4gIHtcbiAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTtcbiAgfVxuXG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IG51bGw7XG4gIGN1cnJlbnRseVJlbmRlcmluZ1Rhc2sgPSBudWxsO1xuICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuICByZW5kZXJQaGFzZVVwZGF0ZXMgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xufVxuXG5mdW5jdGlvbiByZWFkQ29udGV4dCQxKGNvbnRleHQpIHtcbiAge1xuICAgIGlmIChpc0luSG9va1VzZXJDb2RlSW5EZXYpIHtcbiAgICAgIGVycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnICsgJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcgKyAnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcgKyAnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIHVzZUNvbnRleHQoY29udGV4dCkge1xuICB7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gIH1cblxuICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gYmFzaWNTdGF0ZVJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAvLyAkRmxvd0ZpeE1lOiBGbG93IGRvZXNuJ3QgbGlrZSBtaXhlZCB0eXBlc1xuICByZXR1cm4gdHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IGFjdGlvbihzdGF0ZSkgOiBhY3Rpb247XG59XG5cbmZ1bmN0aW9uIHVzZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICB7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICB9XG5cbiAgcmV0dXJuIHVzZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIsIC8vIHVzZVJlZHVjZXIgaGFzIGEgc3BlY2lhbCBjYXNlIHRvIHN1cHBvcnQgbGF6eSB1c2VTdGF0ZSBpbml0aWFsaXplcnNcbiAgaW5pdGlhbFN0YXRlKTtcbn1cbmZ1bmN0aW9uIHVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICB7XG4gICAgaWYgKHJlZHVjZXIgIT09IGJhc2ljU3RhdGVSZWR1Y2VyKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICB9XG4gIH1cblxuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuXG4gIGlmIChpc1JlUmVuZGVyKSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlLXJlbmRlci4gQXBwbHkgdGhlIG5ldyByZW5kZXIgcGhhc2UgdXBkYXRlcyB0byB0aGUgcHJldmlvdXNcbiAgICAvLyBjdXJyZW50IGhvb2suXG4gICAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3NIb29rLnF1ZXVlO1xuICAgIHZhciBkaXNwYXRjaCA9IHF1ZXVlLmRpc3BhdGNoO1xuXG4gICAgaWYgKHJlbmRlclBoYXNlVXBkYXRlcyAhPT0gbnVsbCkge1xuICAgICAgLy8gUmVuZGVyIHBoYXNlIHVwZGF0ZXMgYXJlIHN0b3JlZCBpbiBhIG1hcCBvZiBxdWV1ZSAtPiBsaW5rZWQgbGlzdFxuICAgICAgdmFyIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPSByZW5kZXJQaGFzZVVwZGF0ZXMuZ2V0KHF1ZXVlKTtcblxuICAgICAgaWYgKGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZW5kZXJQaGFzZVVwZGF0ZXMuZGVsZXRlKHF1ZXVlKTtcbiAgICAgICAgdmFyIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHZhciB1cGRhdGUgPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvLyBQcm9jZXNzIHRoaXMgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gV2UgZG9uJ3QgaGF2ZSB0byBjaGVjayB0aGVcbiAgICAgICAgICAvLyBwcmlvcml0eSBiZWNhdXNlIGl0IHdpbGwgYWx3YXlzIGJlIHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50XG4gICAgICAgICAgLy8gcmVuZGVyJ3MuXG4gICAgICAgICAgdmFyIGFjdGlvbiA9IHVwZGF0ZS5hY3Rpb247XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgYWN0aW9uKTtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgICAgICB9IHdoaWxlICh1cGRhdGUgIT09IG51bGwpO1xuXG4gICAgICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIHJldHVybiBbbmV3U3RhdGUsIGRpc3BhdGNoXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW3dvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaW5pdGlhbFN0YXRlO1xuXG4gICAgaWYgKHJlZHVjZXIgPT09IGJhc2ljU3RhdGVSZWR1Y2VyKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGB1c2VTdGF0ZWAuXG4gICAgICBpbml0aWFsU3RhdGUgPSB0eXBlb2YgaW5pdGlhbEFyZyA9PT0gJ2Z1bmN0aW9uJyA/IGluaXRpYWxBcmcoKSA6IGluaXRpYWxBcmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXRpYWxTdGF0ZSA9IGluaXQgIT09IHVuZGVmaW5lZCA/IGluaXQoaW5pdGlhbEFyZykgOiBpbml0aWFsQXJnO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gaW5pdGlhbFN0YXRlO1xuXG4gICAgdmFyIF9xdWV1ZSA9IHdvcmtJblByb2dyZXNzSG9vay5xdWV1ZSA9IHtcbiAgICAgIGxhc3Q6IG51bGwsXG4gICAgICBkaXNwYXRjaDogbnVsbFxuICAgIH07XG5cbiAgICB2YXIgX2Rpc3BhdGNoID0gX3F1ZXVlLmRpc3BhdGNoID0gZGlzcGF0Y2hBY3Rpb24uYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQsIF9xdWV1ZSk7XG5cbiAgICByZXR1cm4gW3dvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLCBfZGlzcGF0Y2hdO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzZU1lbW8obmV4dENyZWF0ZSwgZGVwcykge1xuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcblxuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rICE9PSBudWxsKSB7XG4gICAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuXG4gICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5leHREZXBzICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBwcmV2RGVwcyA9IHByZXZTdGF0ZVsxXTtcblxuICAgICAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IHRydWU7XG4gIH1cblxuICB2YXIgbmV4dFZhbHVlID0gbmV4dENyZWF0ZSgpO1xuXG4gIHtcbiAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gW25leHRWYWx1ZSwgbmV4dERlcHNdO1xuICByZXR1cm4gbmV4dFZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBwcmV2aW91c1JlZiA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChwcmV2aW91c1JlZiA9PT0gbnVsbCkge1xuICAgIHZhciByZWYgPSB7XG4gICAgICBjdXJyZW50OiBpbml0aWFsVmFsdWVcbiAgICB9O1xuXG4gICAge1xuICAgICAgT2JqZWN0LnNlYWwocmVmKTtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IHJlZjtcbiAgICByZXR1cm4gcmVmO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmV2aW91c1JlZjtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBpbnB1dHMpIHtcbiAge1xuICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG5cbiAgICBlcnJvcigndXNlTGF5b3V0RWZmZWN0IGRvZXMgbm90aGluZyBvbiB0aGUgc2VydmVyLCBiZWNhdXNlIGl0cyBlZmZlY3QgY2Fubm90ICcgKyBcImJlIGVuY29kZWQgaW50byB0aGUgc2VydmVyIHJlbmRlcmVyJ3Mgb3V0cHV0IGZvcm1hdC4gVGhpcyB3aWxsIGxlYWQgXCIgKyAndG8gYSBtaXNtYXRjaCBiZXR3ZWVuIHRoZSBpbml0aWFsLCBub24taHlkcmF0ZWQgVUkgYW5kIHRoZSBpbnRlbmRlZCAnICsgJ1VJLiBUbyBhdm9pZCB0aGlzLCB1c2VMYXlvdXRFZmZlY3Qgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbiAnICsgJ2NvbXBvbmVudHMgdGhhdCByZW5kZXIgZXhjbHVzaXZlbHkgb24gdGhlIGNsaWVudC4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3VzZWxheW91dGVmZmVjdC1zc3IgZm9yIGNvbW1vbiBmaXhlcy4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEFjdGlvbihjb21wb25lbnRJZGVudGl0eSwgcXVldWUsIGFjdGlvbikge1xuICBpZiAobnVtYmVyT2ZSZVJlbmRlcnMgPj0gUkVfUkVOREVSX0xJTUlUKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUb28gbWFueSByZS1yZW5kZXJzLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiByZW5kZXJzIHRvIHByZXZlbnQgJyArICdhbiBpbmZpbml0ZSBsb29wLicpO1xuICB9XG5cbiAgaWYgKGNvbXBvbmVudElkZW50aXR5ID09PSBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQpIHtcbiAgICAvLyBUaGlzIGlzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gU3Rhc2ggaXQgaW4gYSBsYXppbHktY3JlYXRlZCBtYXAgb2ZcbiAgICAvLyBxdWV1ZSAtPiBsaW5rZWQgbGlzdCBvZiB1cGRhdGVzLiBBZnRlciB0aGlzIHJlbmRlciBwYXNzLCB3ZSdsbCByZXN0YXJ0XG4gICAgLy8gYW5kIGFwcGx5IHRoZSBzdGFzaGVkIHVwZGF0ZXMgb24gdG9wIG9mIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG4gICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IHRydWU7XG4gICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAocmVuZGVyUGhhc2VVcGRhdGVzID09PSBudWxsKSB7XG4gICAgICByZW5kZXJQaGFzZVVwZGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPSByZW5kZXJQaGFzZVVwZGF0ZXMuZ2V0KHF1ZXVlKTtcblxuICAgIGlmIChmaXJzdFJlbmRlclBoYXNlVXBkYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlbmRlclBoYXNlVXBkYXRlcy5zZXQocXVldWUsIHVwZGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFwcGVuZCB0aGUgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gICAgICB2YXIgbGFzdFJlbmRlclBoYXNlVXBkYXRlID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZTtcblxuICAgICAgd2hpbGUgKGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0O1xuICAgICAgfVxuXG4gICAgICBsYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgcmV0dXJuIHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWxsYmFjaztcbiAgfSwgZGVwcyk7XG59IC8vIFRPRE8gRGVjaWRlIG9uIGhvdyB0byBpbXBsZW1lbnQgdGhpcyBob29rIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLlxuLy8gSWYgYSBtdXRhdGlvbiBvY2N1cnMgZHVyaW5nIHJlbmRlciwgY29uc2lkZXIgdHJpZ2dlcmluZyBhIFN1c3BlbnNlIGJvdW5kYXJ5XG4vLyBhbmQgZmFsbGluZyBiYWNrIHRvIGNsaWVudCByZW5kZXJpbmcuXG5cbmZ1bmN0aW9uIHVzZU11dGFibGVTb3VyY2Uoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgcmV0dXJuIGdldFNuYXBzaG90KHNvdXJjZS5fc291cmNlKTtcbn1cblxuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgaWYgKGdldFNlcnZlclNuYXBzaG90ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZ2V0U2VydmVyU25hcHNob3QsIHdoaWNoIGlzIHJlcXVpcmVkIGZvciAnICsgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBXaWxsIHJldmVydCB0byBjbGllbnQgcmVuZGVyaW5nLicpO1xuICB9XG5cbiAgcmV0dXJuIGdldFNlcnZlclNuYXBzaG90KCk7XG59XG5cbmZ1bmN0aW9uIHVzZURlZmVycmVkVmFsdWUodmFsdWUpIHtcbiAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVuc3VwcG9ydGVkU3RhcnRUcmFuc2l0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0VHJhbnNpdGlvbiBjYW5ub3QgYmUgY2FsbGVkIGR1cmluZyBzZXJ2ZXIgcmVuZGVyaW5nLicpO1xufVxuXG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uKCkge1xuICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHJldHVybiBbZmFsc2UsIHVuc3VwcG9ydGVkU3RhcnRUcmFuc2l0aW9uXTtcbn1cblxuZnVuY3Rpb24gdXNlSWQoKSB7XG4gIHZhciB0YXNrID0gY3VycmVudGx5UmVuZGVyaW5nVGFzaztcbiAgdmFyIHRyZWVJZCA9IGdldFRyZWVJZCh0YXNrLnRyZWVDb250ZXh0KTtcbiAgdmFyIHJlc3BvbnNlU3RhdGUgPSBjdXJyZW50UmVzcG9uc2VTdGF0ZTtcblxuICBpZiAocmVzcG9uc2VTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuJyk7XG4gIH1cblxuICB2YXIgbG9jYWxJZCA9IGxvY2FsSWRDb3VudGVyKys7XG4gIHJldHVybiBtYWtlSWQocmVzcG9uc2VTdGF0ZSwgdHJlZUlkLCBsb2NhbElkKTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBEaXNwYXRjaGVyID0ge1xuICByZWFkQ29udGV4dDogcmVhZENvbnRleHQkMSxcbiAgdXNlQ29udGV4dDogdXNlQ29udGV4dCxcbiAgdXNlTWVtbzogdXNlTWVtbyxcbiAgdXNlUmVkdWNlcjogdXNlUmVkdWNlcixcbiAgdXNlUmVmOiB1c2VSZWYsXG4gIHVzZVN0YXRlOiB1c2VTdGF0ZSxcbiAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBub29wLFxuICB1c2VMYXlvdXRFZmZlY3Q6IHVzZUxheW91dEVmZmVjdCxcbiAgdXNlQ2FsbGJhY2s6IHVzZUNhbGxiYWNrLFxuICAvLyB1c2VJbXBlcmF0aXZlSGFuZGxlIGlzIG5vdCBydW4gaW4gdGhlIHNlcnZlciBlbnZpcm9ubWVudFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBub29wLFxuICAvLyBFZmZlY3RzIGFyZSBub3QgcnVuIGluIHRoZSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG4gIHVzZUVmZmVjdDogbm9vcCxcbiAgLy8gRGVidWdnaW5nIGVmZmVjdFxuICB1c2VEZWJ1Z1ZhbHVlOiBub29wLFxuICB1c2VEZWZlcnJlZFZhbHVlOiB1c2VEZWZlcnJlZFZhbHVlLFxuICB1c2VUcmFuc2l0aW9uOiB1c2VUcmFuc2l0aW9uLFxuICB1c2VJZDogdXNlSWQsXG4gIC8vIFN1YnNjcmlwdGlvbnMgYXJlIG5vdCBzZXR1cCBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgdXNlTXV0YWJsZVNvdXJjZTogdXNlTXV0YWJsZVNvdXJjZSxcbiAgdXNlU3luY0V4dGVybmFsU3RvcmU6IHVzZVN5bmNFeHRlcm5hbFN0b3JlXG59O1xuXG52YXIgY3VycmVudFJlc3BvbnNlU3RhdGUgPSBudWxsO1xuZnVuY3Rpb24gc2V0Q3VycmVudFJlc3BvbnNlU3RhdGUocmVzcG9uc2VTdGF0ZSkge1xuICBjdXJyZW50UmVzcG9uc2VTdGF0ZSA9IHJlc3BvbnNlU3RhdGU7XG59XG5cbmZ1bmN0aW9uIGdldFN0YWNrQnlDb21wb25lbnRTdGFja05vZGUoY29tcG9uZW50U3RhY2spIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIHZhciBub2RlID0gY29tcG9uZW50U3RhY2s7XG5cbiAgICBkbyB7XG4gICAgICBzd2l0Y2ggKG5vZGUudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBpbmZvICs9IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5vZGUudHlwZSwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGluZm8gKz0gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKG5vZGUudHlwZSwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGluZm8gKz0gZGVzY3JpYmVDbGFzc0NvbXBvbmVudEZyYW1lKG5vZGUudHlwZSwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICB9IHdoaWxlIChub2RlKTtcblxuICAgIHJldHVybiBpbmZvO1xuICB9IGNhdGNoICh4KSB7XG4gICAgcmV0dXJuICdcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiAnICsgeC5tZXNzYWdlICsgJ1xcbicgKyB4LnN0YWNrO1xuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUEVORElORyA9IDA7XG52YXIgQ09NUExFVEVEID0gMTtcbnZhciBGTFVTSEVEID0gMjtcbnZhciBBQk9SVEVEID0gMztcbnZhciBFUlJPUkVEID0gNDtcbnZhciBPUEVOID0gMDtcbnZhciBDTE9TSU5HID0gMTtcbnZhciBDTE9TRUQgPSAyO1xuLy8gVGhpcyBpcyBhIGRlZmF1bHQgaGV1cmlzdGljIGZvciBob3cgdG8gc3BsaXQgdXAgdGhlIEhUTUwgY29udGVudCBpbnRvIHByb2dyZXNzaXZlXG4vLyBsb2FkaW5nLiBPdXIgZ29hbCBpcyB0byBiZSBhYmxlIHRvIGRpc3BsYXkgYWRkaXRpb25hbCBuZXcgY29udGVudCBhYm91dCBldmVyeSA1MDBtcy5cbi8vIEZhc3RlciB0aGFuIHRoYXQgaXMgdW5uZWNlc3NhcnkgYW5kIHNob3VsZCBiZSB0aHJvdHRsZWQgb24gdGhlIGNsaWVudC4gSXQgYWxzb1xuLy8gYWRkcyB1bm5lY2Vzc2FyeSBvdmVyaGVhZCB0byBkbyBtb3JlIHNwbGl0cy4gV2UgZG9uJ3Qga25vdyBpZiBpdCdzIGEgaGlnaGVyIG9yIGxvd2VyXG4vLyBlbmQgZGV2aWNlIGJ1dCBoaWdoZXIgZW5kIHN1ZmZlciBsZXNzIGZyb20gdGhlIG92ZXJoZWFkIHRoYW4gbG93ZXIgZW5kIGRvZXMgZnJvbVxuLy8gbm90IGdldHRpbmcgc21hbGwgZW5vdWdoIHBpZWNlcy4gV2UgZXJyb3Igb24gdGhlIHNpZGUgb2YgbG93IGVuZC5cbi8vIFdlIGJhc2UgdGhpcyBvbiBsb3cgZW5kIDNHIHNwZWVkcyB3aGljaCBpcyBhYm91dCA1MDBrYml0cyBwZXIgc2Vjb25kLiBXZSBhc3N1bWVcbi8vIHRoYXQgdGhlcmUgY2FuIGJlIGEgcmVhc29uYWJsZSBkcm9wIG9mZiBmcm9tIG1heCBiYW5kd2lkdGggd2hpY2ggbGVhdmVzIHlvdSB3aXRoXG4vLyBhcyBsaXR0bGUgYXMgODAlLiBXZSBjYW4gcmVjZWl2ZSBoYWxmIG9mIHRoYXQgZWFjaCA1MDBtcyAtIGF0IGJlc3QuIEluIHByYWN0aWNlLFxuLy8gYSBsaXR0bGUgYmFuZHdpZHRoIGlzIGxvc3QgdG8gcHJvY2Vzc2luZyBhbmQgY29udGVudGlvbiAtIGUuZy4gQ1NTIGFuZCBpbWFnZXMgdGhhdFxuLy8gYXJlIGRvd25sb2FkZWQgYWxvbmcgd2l0aCB0aGUgbWFpbiBjb250ZW50LiBTbyB3ZSBlc3RpbWF0ZSBhYm91dCBoYWxmIG9mIHRoYXQgdG8gYmVcbi8vIHRoZSBsb3dlciBlbmQgdGhyb3VnaHB1dC4gSW4gb3RoZXIgd29yZHMsIHdlIGV4cGVjdCB0aGF0IHlvdSBjYW4gYXQgbGVhc3Qgc2hvd1xuLy8gYWJvdXQgMTIuNWtiIG9mIGNvbnRlbnQgcGVyIDUwMG1zLiBOb3QgY291bnRpbmcgc3RhcnRpbmcgbGF0ZW5jeSBmb3IgdGhlIGZpcnN0XG4vLyBwYWludC5cbi8vIDUwMCAqIDEwMjQgLyA4ICogLjggKiAwLjUgLyAyXG52YXIgREVGQVVMVF9QUk9HUkVTU0lWRV9DSFVOS19TSVpFID0gMTI4MDA7XG5cbmZ1bmN0aW9uIGRlZmF1bHRFcnJvckhhbmRsZXIoZXJyb3IpIHtcbiAgY29uc29sZVsnZXJyb3InXShlcnJvcik7IC8vIERvbid0IHRyYW5zZm9ybSB0byBvdXIgd3JhcHBlclxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBub29wJDEoKSB7fVxuXG5mdW5jdGlvbiBjcmVhdGVSZXF1ZXN0KGNoaWxkcmVuLCByZXNwb25zZVN0YXRlLCByb290Rm9ybWF0Q29udGV4dCwgcHJvZ3Jlc3NpdmVDaHVua1NpemUsIG9uRXJyb3IsIG9uQWxsUmVhZHksIG9uU2hlbGxSZWFkeSwgb25TaGVsbEVycm9yLCBvbkZhdGFsRXJyb3IpIHtcbiAgdmFyIHBpbmdlZFRhc2tzID0gW107XG4gIHZhciBhYm9ydFNldCA9IG5ldyBTZXQoKTtcbiAgdmFyIHJlcXVlc3QgPSB7XG4gICAgZGVzdGluYXRpb246IG51bGwsXG4gICAgcmVzcG9uc2VTdGF0ZTogcmVzcG9uc2VTdGF0ZSxcbiAgICBwcm9ncmVzc2l2ZUNodW5rU2l6ZTogcHJvZ3Jlc3NpdmVDaHVua1NpemUgPT09IHVuZGVmaW5lZCA/IERFRkFVTFRfUFJPR1JFU1NJVkVfQ0hVTktfU0laRSA6IHByb2dyZXNzaXZlQ2h1bmtTaXplLFxuICAgIHN0YXR1czogT1BFTixcbiAgICBmYXRhbEVycm9yOiBudWxsLFxuICAgIG5leHRTZWdtZW50SWQ6IDAsXG4gICAgYWxsUGVuZGluZ1Rhc2tzOiAwLFxuICAgIHBlbmRpbmdSb290VGFza3M6IDAsXG4gICAgY29tcGxldGVkUm9vdFNlZ21lbnQ6IG51bGwsXG4gICAgYWJvcnRhYmxlVGFza3M6IGFib3J0U2V0LFxuICAgIHBpbmdlZFRhc2tzOiBwaW5nZWRUYXNrcyxcbiAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXM6IFtdLFxuICAgIGNvbXBsZXRlZEJvdW5kYXJpZXM6IFtdLFxuICAgIHBhcnRpYWxCb3VuZGFyaWVzOiBbXSxcbiAgICBvbkVycm9yOiBvbkVycm9yID09PSB1bmRlZmluZWQgPyBkZWZhdWx0RXJyb3JIYW5kbGVyIDogb25FcnJvcixcbiAgICBvbkFsbFJlYWR5OiBvbkFsbFJlYWR5ID09PSB1bmRlZmluZWQgPyBub29wJDEgOiBvbkFsbFJlYWR5LFxuICAgIG9uU2hlbGxSZWFkeTogb25TaGVsbFJlYWR5ID09PSB1bmRlZmluZWQgPyBub29wJDEgOiBvblNoZWxsUmVhZHksXG4gICAgb25TaGVsbEVycm9yOiBvblNoZWxsRXJyb3IgPT09IHVuZGVmaW5lZCA/IG5vb3AkMSA6IG9uU2hlbGxFcnJvcixcbiAgICBvbkZhdGFsRXJyb3I6IG9uRmF0YWxFcnJvciA9PT0gdW5kZWZpbmVkID8gbm9vcCQxIDogb25GYXRhbEVycm9yXG4gIH07IC8vIFRoaXMgc2VnbWVudCByZXByZXNlbnRzIHRoZSByb290IGZhbGxiYWNrLlxuXG4gIHZhciByb290U2VnbWVudCA9IGNyZWF0ZVBlbmRpbmdTZWdtZW50KHJlcXVlc3QsIDAsIG51bGwsIHJvb3RGb3JtYXRDb250ZXh0LCAvLyBSb290IHNlZ21lbnRzIGFyZSBuZXZlciBlbWJlZGRlZCBpbiBUZXh0IG9uIGVpdGhlciBlZGdlXG4gIGZhbHNlLCBmYWxzZSk7IC8vIFRoZXJlIGlzIG5vIHBhcmVudCBzbyBjb25jZXB0dWFsbHksIHdlJ3JlIHVuYmxvY2tlZCB0byBmbHVzaCB0aGlzIHNlZ21lbnQuXG5cbiAgcm9vdFNlZ21lbnQucGFyZW50Rmx1c2hlZCA9IHRydWU7XG4gIHZhciByb290VGFzayA9IGNyZWF0ZVRhc2socmVxdWVzdCwgY2hpbGRyZW4sIG51bGwsIHJvb3RTZWdtZW50LCBhYm9ydFNldCwgZW1wdHlDb250ZXh0T2JqZWN0LCByb290Q29udGV4dFNuYXBzaG90LCBlbXB0eVRyZWVDb250ZXh0KTtcbiAgcGluZ2VkVGFza3MucHVzaChyb290VGFzayk7XG4gIHJldHVybiByZXF1ZXN0O1xufVxuXG5mdW5jdGlvbiBwaW5nVGFzayhyZXF1ZXN0LCB0YXNrKSB7XG4gIHZhciBwaW5nZWRUYXNrcyA9IHJlcXVlc3QucGluZ2VkVGFza3M7XG4gIHBpbmdlZFRhc2tzLnB1c2godGFzayk7XG5cbiAgaWYgKHBpbmdlZFRhc2tzLmxlbmd0aCA9PT0gMSkge1xuICAgIHNjaGVkdWxlV29yayhmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybVdvcmsocmVxdWVzdCk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeShyZXF1ZXN0LCBmYWxsYmFja0Fib3J0YWJsZVRhc2tzKSB7XG4gIHJldHVybiB7XG4gICAgaWQ6IFVOSU5JVElBTElaRURfU1VTUEVOU0VfQk9VTkRBUllfSUQsXG4gICAgcm9vdFNlZ21lbnRJRDogLTEsXG4gICAgcGFyZW50Rmx1c2hlZDogZmFsc2UsXG4gICAgcGVuZGluZ1Rhc2tzOiAwLFxuICAgIGZvcmNlQ2xpZW50UmVuZGVyOiBmYWxzZSxcbiAgICBjb21wbGV0ZWRTZWdtZW50czogW10sXG4gICAgYnl0ZVNpemU6IDAsXG4gICAgZmFsbGJhY2tBYm9ydGFibGVUYXNrczogZmFsbGJhY2tBYm9ydGFibGVUYXNrcyxcbiAgICBlcnJvckRpZ2VzdDogbnVsbFxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUYXNrKHJlcXVlc3QsIG5vZGUsIGJsb2NrZWRCb3VuZGFyeSwgYmxvY2tlZFNlZ21lbnQsIGFib3J0U2V0LCBsZWdhY3lDb250ZXh0LCBjb250ZXh0LCB0cmVlQ29udGV4dCkge1xuICByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcysrO1xuXG4gIGlmIChibG9ja2VkQm91bmRhcnkgPT09IG51bGwpIHtcbiAgICByZXF1ZXN0LnBlbmRpbmdSb290VGFza3MrKztcbiAgfSBlbHNlIHtcbiAgICBibG9ja2VkQm91bmRhcnkucGVuZGluZ1Rhc2tzKys7XG4gIH1cblxuICB2YXIgdGFzayA9IHtcbiAgICBub2RlOiBub2RlLFxuICAgIHBpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBwaW5nVGFzayhyZXF1ZXN0LCB0YXNrKTtcbiAgICB9LFxuICAgIGJsb2NrZWRCb3VuZGFyeTogYmxvY2tlZEJvdW5kYXJ5LFxuICAgIGJsb2NrZWRTZWdtZW50OiBibG9ja2VkU2VnbWVudCxcbiAgICBhYm9ydFNldDogYWJvcnRTZXQsXG4gICAgbGVnYWN5Q29udGV4dDogbGVnYWN5Q29udGV4dCxcbiAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgIHRyZWVDb250ZXh0OiB0cmVlQ29udGV4dFxuICB9O1xuXG4gIHtcbiAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gbnVsbDtcbiAgfVxuXG4gIGFib3J0U2V0LmFkZCh0YXNrKTtcbiAgcmV0dXJuIHRhc2s7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBlbmRpbmdTZWdtZW50KHJlcXVlc3QsIGluZGV4LCBib3VuZGFyeSwgZm9ybWF0Q29udGV4dCwgbGFzdFB1c2hlZFRleHQsIHRleHRFbWJlZGRlZCkge1xuICByZXR1cm4ge1xuICAgIHN0YXR1czogUEVORElORyxcbiAgICBpZDogLTEsXG4gICAgLy8gbGF6aWx5IGFzc2lnbmVkIGxhdGVyXG4gICAgaW5kZXg6IGluZGV4LFxuICAgIHBhcmVudEZsdXNoZWQ6IGZhbHNlLFxuICAgIGNodW5rczogW10sXG4gICAgY2hpbGRyZW46IFtdLFxuICAgIGZvcm1hdENvbnRleHQ6IGZvcm1hdENvbnRleHQsXG4gICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgIGxhc3RQdXNoZWRUZXh0OiBsYXN0UHVzaGVkVGV4dCxcbiAgICB0ZXh0RW1iZWRkZWQ6IHRleHRFbWJlZGRlZFxuICB9O1xufSAvLyBERVYtb25seSBnbG9iYWwgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIHRhc2tcblxuXG52YXIgY3VycmVudFRhc2tJbkRFViA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRTdGFja0luREVWKCkge1xuICB7XG4gICAgaWYgKGN1cnJlbnRUYXNrSW5ERVYgPT09IG51bGwgfHwgY3VycmVudFRhc2tJbkRFVi5jb21wb25lbnRTdGFjayA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRTdGFja0J5Q29tcG9uZW50U3RhY2tOb2RlKGN1cnJlbnRUYXNrSW5ERVYuY29tcG9uZW50U3RhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hCdWlsdEluQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrLCB0eXBlKSB7XG4gIHtcbiAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0ge1xuICAgICAgdGFnOiAwLFxuICAgICAgcGFyZW50OiB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgdHlwZTogdHlwZVxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaEZ1bmN0aW9uQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrLCB0eXBlKSB7XG4gIHtcbiAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0ge1xuICAgICAgdGFnOiAxLFxuICAgICAgcGFyZW50OiB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgdHlwZTogdHlwZVxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaENsYXNzQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrLCB0eXBlKSB7XG4gIHtcbiAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0ge1xuICAgICAgdGFnOiAyLFxuICAgICAgcGFyZW50OiB0YXNrLmNvbXBvbmVudFN0YWNrLFxuICAgICAgdHlwZTogdHlwZVxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKSB7XG4gIHtcbiAgICBpZiAodGFzay5jb21wb25lbnRTdGFjayA9PT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWRseSBwb3BwZWQgdG9vIG1hbnkgc3RhY2sgZnJhbWVzLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gdGFzay5jb21wb25lbnRTdGFjay5wYXJlbnQ7XG4gICAgfVxuICB9XG59IC8vIHN0YXNoIHRoZSBjb21wb25lbnQgc3RhY2sgb2YgYW4gdW53aW5kaW5nIGVycm9yIHVudGlsIGl0IGlzIHByb2Nlc3NlZFxuXG5cbnZhciBsYXN0Qm91bmRhcnlFcnJvckNvbXBvbmVudFN0YWNrRGV2ID0gbnVsbDtcblxuZnVuY3Rpb24gY2FwdHVyZUJvdW5kYXJ5RXJyb3JEZXRhaWxzRGV2KGJvdW5kYXJ5LCBlcnJvcikge1xuICB7XG4gICAgdmFyIGVycm9yTWVzc2FnZTtcblxuICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvcjtcbiAgICB9IGVsc2UgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgICBlcnJvck1lc3NhZ2UgPSBTdHJpbmcoZXJyb3IpO1xuICAgIH1cblxuICAgIHZhciBlcnJvckNvbXBvbmVudFN0YWNrID0gbGFzdEJvdW5kYXJ5RXJyb3JDb21wb25lbnRTdGFja0RldiB8fCBnZXRDdXJyZW50U3RhY2tJbkRFVigpO1xuICAgIGxhc3RCb3VuZGFyeUVycm9yQ29tcG9uZW50U3RhY2tEZXYgPSBudWxsO1xuICAgIGJvdW5kYXJ5LmVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZTtcbiAgICBib3VuZGFyeS5lcnJvckNvbXBvbmVudFN0YWNrID0gZXJyb3JDb21wb25lbnRTdGFjaztcbiAgfVxufVxuXG5mdW5jdGlvbiBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yKSB7XG4gIC8vIElmIHRoaXMgY2FsbGJhY2sgZXJyb3JzLCB3ZSBpbnRlbnRpb25hbGx5IGxldCB0aGF0IGVycm9yIGJ1YmJsZSB1cCB0byBiZWNvbWUgYSBmYXRhbCBlcnJvclxuICAvLyBzbyB0aGF0IHNvbWVvbmUgZml4ZXMgdGhlIGVycm9yIHJlcG9ydGluZyBpbnN0ZWFkIG9mIGhpZGluZyBpdC5cbiAgdmFyIGVycm9yRGlnZXN0ID0gcmVxdWVzdC5vbkVycm9yKGVycm9yKTtcblxuICBpZiAoZXJyb3JEaWdlc3QgIT0gbnVsbCAmJiB0eXBlb2YgZXJyb3JEaWdlc3QgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJvbkVycm9yIHJldHVybmVkIHNvbWV0aGluZyB3aXRoIGEgdHlwZSBvdGhlciB0aGFuIFxcXCJzdHJpbmdcXFwiLiBvbkVycm9yIHNob3VsZCByZXR1cm4gYSBzdHJpbmcgYW5kIG1heSByZXR1cm4gbnVsbCBvciB1bmRlZmluZWQgYnV0IG11c3Qgbm90IHJldHVybiBhbnl0aGluZyBlbHNlLiBJdCByZWNlaXZlZCBzb21ldGhpbmcgb2YgdHlwZSBcXFwiXCIgKyB0eXBlb2YgZXJyb3JEaWdlc3QgKyBcIlxcXCIgaW5zdGVhZFwiKTtcbiAgfVxuXG4gIHJldHVybiBlcnJvckRpZ2VzdDtcbn1cblxuZnVuY3Rpb24gZmF0YWxFcnJvcihyZXF1ZXN0LCBlcnJvcikge1xuICAvLyBUaGlzIGlzIGNhbGxlZCBvdXRzaWRlIGVycm9yIGhhbmRsaW5nIGNvZGUgc3VjaCBhcyBpZiB0aGUgcm9vdCBlcnJvcnMgb3V0c2lkZVxuICAvLyBhIHN1c3BlbnNlIGJvdW5kYXJ5IG9yIGlmIHRoZSByb290IHN1c3BlbnNlIGJvdW5kYXJ5J3MgZmFsbGJhY2sgZXJyb3JzLlxuICAvLyBJdCdzIGFsc28gY2FsbGVkIGlmIFJlYWN0IGl0c2VsZiBvciBpdHMgaG9zdCBjb25maWdzIGVycm9ycy5cbiAgdmFyIG9uU2hlbGxFcnJvciA9IHJlcXVlc3Qub25TaGVsbEVycm9yO1xuICBvblNoZWxsRXJyb3IoZXJyb3IpO1xuICB2YXIgb25GYXRhbEVycm9yID0gcmVxdWVzdC5vbkZhdGFsRXJyb3I7XG4gIG9uRmF0YWxFcnJvcihlcnJvcik7XG5cbiAgaWYgKHJlcXVlc3QuZGVzdGluYXRpb24gIT09IG51bGwpIHtcbiAgICByZXF1ZXN0LnN0YXR1cyA9IENMT1NFRDtcbiAgICBjbG9zZVdpdGhFcnJvcihyZXF1ZXN0LmRlc3RpbmF0aW9uLCBlcnJvcik7XG4gIH0gZWxzZSB7XG4gICAgcmVxdWVzdC5zdGF0dXMgPSBDTE9TSU5HO1xuICAgIHJlcXVlc3QuZmF0YWxFcnJvciA9IGVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlclN1c3BlbnNlQm91bmRhcnkocmVxdWVzdCwgdGFzaywgcHJvcHMpIHtcbiAgcHVzaEJ1aWx0SW5Db21wb25lbnRTdGFja0luREVWKHRhc2ssICdTdXNwZW5zZScpO1xuICB2YXIgcGFyZW50Qm91bmRhcnkgPSB0YXNrLmJsb2NrZWRCb3VuZGFyeTtcbiAgdmFyIHBhcmVudFNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50OyAvLyBFYWNoIHRpbWUgd2UgZW50ZXIgYSBzdXNwZW5zZSBib3VuZGFyeSwgd2Ugc3BsaXQgb3V0IGludG8gYSBuZXcgc2VnbWVudCBmb3JcbiAgLy8gdGhlIGZhbGxiYWNrIHNvIHRoYXQgd2UgY2FuIGxhdGVyIHJlcGxhY2UgdGhhdCBzZWdtZW50IHdpdGggdGhlIGNvbnRlbnQuXG4gIC8vIFRoaXMgYWxzbyBsZXRzIHVzIHNwbGl0IG91dCB0aGUgbWFpbiBjb250ZW50IGV2ZW4gaWYgaXQgZG9lc24ndCBzdXNwZW5kLFxuICAvLyBpbiBjYXNlIGl0IGVuZHMgdXAgZ2VuZXJhdGluZyBhIGxhcmdlIHN1YnRyZWUgb2YgY29udGVudC5cblxuICB2YXIgZmFsbGJhY2sgPSBwcm9wcy5mYWxsYmFjaztcbiAgdmFyIGNvbnRlbnQgPSBwcm9wcy5jaGlsZHJlbjtcbiAgdmFyIGZhbGxiYWNrQWJvcnRTZXQgPSBuZXcgU2V0KCk7XG4gIHZhciBuZXdCb3VuZGFyeSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkocmVxdWVzdCwgZmFsbGJhY2tBYm9ydFNldCk7XG4gIHZhciBpbnNlcnRpb25JbmRleCA9IHBhcmVudFNlZ21lbnQuY2h1bmtzLmxlbmd0aDsgLy8gVGhlIGNoaWxkcmVuIG9mIHRoZSBib3VuZGFyeSBzZWdtZW50IGlzIGFjdHVhbGx5IHRoZSBmYWxsYmFjay5cblxuICB2YXIgYm91bmRhcnlTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQocmVxdWVzdCwgaW5zZXJ0aW9uSW5kZXgsIG5ld0JvdW5kYXJ5LCBwYXJlbnRTZWdtZW50LmZvcm1hdENvbnRleHQsIC8vIGJvdW5kYXJpZXMgbmV2ZXIgcmVxdWlyZSB0ZXh0IGVtYmVkZGluZyBhdCB0aGVpciBlZGdlcyBiZWNhdXNlIGNvbW1lbnQgbm9kZXMgYm91bmQgdGhlbVxuICBmYWxzZSwgZmFsc2UpO1xuICBwYXJlbnRTZWdtZW50LmNoaWxkcmVuLnB1c2goYm91bmRhcnlTZWdtZW50KTsgLy8gVGhlIHBhcmVudFNlZ21lbnQgaGFzIGEgY2hpbGQgU2VnbWVudCBhdCB0aGlzIGluZGV4IHNvIHdlIHJlc2V0IHRoZSBsYXN0UHVzaGVkVGV4dCBtYXJrZXIgb24gdGhlIHBhcmVudFxuXG4gIHBhcmVudFNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSBmYWxzZTsgLy8gVGhpcyBzZWdtZW50IGlzIHRoZSBhY3R1YWwgY2hpbGQgY29udGVudC4gV2UgY2FuIHN0YXJ0IHJlbmRlcmluZyB0aGF0IGltbWVkaWF0ZWx5LlxuXG4gIHZhciBjb250ZW50Um9vdFNlZ21lbnQgPSBjcmVhdGVQZW5kaW5nU2VnbWVudChyZXF1ZXN0LCAwLCBudWxsLCBwYXJlbnRTZWdtZW50LmZvcm1hdENvbnRleHQsIC8vIGJvdW5kYXJpZXMgbmV2ZXIgcmVxdWlyZSB0ZXh0IGVtYmVkZGluZyBhdCB0aGVpciBlZGdlcyBiZWNhdXNlIGNvbW1lbnQgbm9kZXMgYm91bmQgdGhlbVxuICBmYWxzZSwgZmFsc2UpOyAvLyBXZSBtYXJrIHRoZSByb290IHNlZ21lbnQgYXMgaGF2aW5nIGl0cyBwYXJlbnQgZmx1c2hlZC4gSXQncyBub3QgcmVhbGx5IGZsdXNoZWQgYnV0IHRoZXJlIGlzXG4gIC8vIG5vIHBhcmVudCBzZWdtZW50IHNvIHRoZXJlJ3Mgbm90aGluZyB0byB3YWl0IG9uLlxuXG4gIGNvbnRlbnRSb290U2VnbWVudC5wYXJlbnRGbHVzaGVkID0gdHJ1ZTsgLy8gQ3VycmVudGx5IHRoaXMgaXMgcnVubmluZyBzeW5jaHJvbm91c2x5LiBXZSBjb3VsZCBpbnN0ZWFkIHNjaGVkdWxlIHRoaXMgdG8gcGluZ2VkVGFza3MuXG4gIC8vIEkgc3VzcGVjdCB0aGF0IHRoZXJlIG1pZ2h0IGJlIHNvbWUgZWZmaWNpZW5jeSBiZW5lZml0cyBmcm9tIG5vdCBjcmVhdGluZyB0aGUgc3VzcGVuZGVkIHRhc2tcbiAgLy8gYW5kIGluc3RlYWQganVzdCB1c2luZyB0aGUgc3RhY2sgaWYgcG9zc2libGUuXG4gIC8vIFRPRE86IENhbGwgdGhpcyBkaXJlY3RseSBpbnN0ZWFkIG9mIG1lc3Npbmcgd2l0aCBzYXZpbmcgYW5kIHJlc3RvcmluZyBjb250ZXh0cy5cbiAgLy8gV2UgY2FuIHJldXNlIHRoZSBjdXJyZW50IGNvbnRleHQgYW5kIHRhc2sgdG8gcmVuZGVyIHRoZSBjb250ZW50IGltbWVkaWF0ZWx5IHdpdGhvdXRcbiAgLy8gY29udGV4dCBzd2l0Y2hpbmcuIFdlIGp1c3QgbmVlZCB0byB0ZW1wb3JhcmlseSBzd2l0Y2ggd2hpY2ggYm91bmRhcnkgYW5kIHdoaWNoIHNlZ21lbnRcbiAgLy8gd2UncmUgd3JpdGluZyB0by4gSWYgc29tZXRoaW5nIHN1c3BlbmRzLCBpdCdsbCBzcGF3biBuZXcgc3VzcGVuZGVkIHRhc2sgd2l0aCB0aGF0IGNvbnRleHQuXG5cbiAgdGFzay5ibG9ja2VkQm91bmRhcnkgPSBuZXdCb3VuZGFyeTtcbiAgdGFzay5ibG9ja2VkU2VnbWVudCA9IGNvbnRlbnRSb290U2VnbWVudDtcblxuICB0cnkge1xuICAgIC8vIFdlIHVzZSB0aGUgc2FmZSBmb3JtIGJlY2F1c2Ugd2UgZG9uJ3QgaGFuZGxlIHN1c3BlbmRpbmcgaGVyZS4gT25seSBlcnJvciBoYW5kbGluZy5cbiAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNvbnRlbnQpO1xuICAgIHB1c2hTZWdtZW50RmluYWxlKGNvbnRlbnRSb290U2VnbWVudC5jaHVua3MsIHJlcXVlc3QucmVzcG9uc2VTdGF0ZSwgY29udGVudFJvb3RTZWdtZW50Lmxhc3RQdXNoZWRUZXh0LCBjb250ZW50Um9vdFNlZ21lbnQudGV4dEVtYmVkZGVkKTtcbiAgICBjb250ZW50Um9vdFNlZ21lbnQuc3RhdHVzID0gQ09NUExFVEVEO1xuICAgIHF1ZXVlQ29tcGxldGVkU2VnbWVudChuZXdCb3VuZGFyeSwgY29udGVudFJvb3RTZWdtZW50KTtcblxuICAgIGlmIChuZXdCb3VuZGFyeS5wZW5kaW5nVGFza3MgPT09IDApIHtcbiAgICAgIC8vIFRoaXMgbXVzdCBoYXZlIGJlZW4gdGhlIGxhc3Qgc2VnbWVudCB3ZSB3ZXJlIHdhaXRpbmcgb24uIFRoaXMgYm91bmRhcnkgaXMgbm93IGNvbXBsZXRlLlxuICAgICAgLy8gVGhlcmVmb3JlIHdlIHdvbid0IG5lZWQgdGhlIGZhbGxiYWNrLiBXZSBlYXJseSByZXR1cm4gc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGNyZWF0ZVxuICAgICAgLy8gdGhlIGZhbGxiYWNrLlxuICAgICAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29udGVudFJvb3RTZWdtZW50LnN0YXR1cyA9IEVSUk9SRUQ7XG4gICAgbmV3Qm91bmRhcnkuZm9yY2VDbGllbnRSZW5kZXIgPSB0cnVlO1xuICAgIG5ld0JvdW5kYXJ5LmVycm9yRGlnZXN0ID0gbG9nUmVjb3ZlcmFibGVFcnJvcihyZXF1ZXN0LCBlcnJvcik7XG5cbiAgICB7XG4gICAgICBjYXB0dXJlQm91bmRhcnlFcnJvckRldGFpbHNEZXYobmV3Qm91bmRhcnksIGVycm9yKTtcbiAgICB9IC8vIFdlIGRvbid0IG5lZWQgdG8gZGVjcmVtZW50IGFueSB0YXNrIG51bWJlcnMgYmVjYXVzZSB3ZSBkaWRuJ3Qgc3Bhd24gYW55IG5ldyB0YXNrLlxuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gc2NoZWR1bGUgYW55IHRhc2sgYmVjYXVzZSB3ZSBrbm93IHRoZSBwYXJlbnQgaGFzIHdyaXR0ZW4geWV0LlxuICAgIC8vIFdlIGRvIG5lZWQgdG8gZmFsbHRocm91Z2ggdG8gY3JlYXRlIHRoZSBmYWxsYmFjayB0aG91Z2guXG5cbiAgfSBmaW5hbGx5IHtcbiAgICB0YXNrLmJsb2NrZWRCb3VuZGFyeSA9IHBhcmVudEJvdW5kYXJ5O1xuICAgIHRhc2suYmxvY2tlZFNlZ21lbnQgPSBwYXJlbnRTZWdtZW50O1xuICB9IC8vIFdlIGNyZWF0ZSBzdXNwZW5kZWQgdGFzayBmb3IgdGhlIGZhbGxiYWNrIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBhY3R1YWxseSB3b3JrXG4gIC8vIG9uIGl0IHlldCBpbiBjYXNlIHdlIGZpbmlzaCB0aGUgbWFpbiBjb250ZW50LCBzbyB3ZSBxdWV1ZSBmb3IgbGF0ZXIuXG5cblxuICB2YXIgc3VzcGVuZGVkRmFsbGJhY2tUYXNrID0gY3JlYXRlVGFzayhyZXF1ZXN0LCBmYWxsYmFjaywgcGFyZW50Qm91bmRhcnksIGJvdW5kYXJ5U2VnbWVudCwgZmFsbGJhY2tBYm9ydFNldCwgdGFzay5sZWdhY3lDb250ZXh0LCB0YXNrLmNvbnRleHQsIHRhc2sudHJlZUNvbnRleHQpO1xuXG4gIHtcbiAgICBzdXNwZW5kZWRGYWxsYmFja1Rhc2suY29tcG9uZW50U3RhY2sgPSB0YXNrLmNvbXBvbmVudFN0YWNrO1xuICB9IC8vIFRPRE86IFRoaXMgc2hvdWxkIGJlIHF1ZXVlZCBhdCBhIHNlcGFyYXRlIGxvd2VyIHByaW9yaXR5IHF1ZXVlIHNvIHRoYXQgd2Ugb25seSB3b3JrXG4gIC8vIG9uIHByZXBhcmluZyBmYWxsYmFja3MgaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBtYWluIGNvbnRlbnQgdG8gdGFzayBvbi5cblxuXG4gIHJlcXVlc3QucGluZ2VkVGFza3MucHVzaChzdXNwZW5kZWRGYWxsYmFja1Rhc2spO1xuICBwb3BDb21wb25lbnRTdGFja0luREVWKHRhc2spO1xufVxuXG5mdW5jdGlvbiByZW5kZXJIb3N0RWxlbWVudChyZXF1ZXN0LCB0YXNrLCB0eXBlLCBwcm9wcykge1xuICBwdXNoQnVpbHRJbkNvbXBvbmVudFN0YWNrSW5ERVYodGFzaywgdHlwZSk7XG4gIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgdmFyIGNoaWxkcmVuID0gcHVzaFN0YXJ0SW5zdGFuY2Uoc2VnbWVudC5jaHVua3MsIHR5cGUsIHByb3BzLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUsIHNlZ21lbnQuZm9ybWF0Q29udGV4dCk7XG4gIHNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSBmYWxzZTtcbiAgdmFyIHByZXZDb250ZXh0ID0gc2VnbWVudC5mb3JtYXRDb250ZXh0O1xuICBzZWdtZW50LmZvcm1hdENvbnRleHQgPSBnZXRDaGlsZEZvcm1hdENvbnRleHQocHJldkNvbnRleHQsIHR5cGUsIHByb3BzKTsgLy8gV2UgdXNlIHRoZSBub24tZGVzdHJ1Y3RpdmUgZm9ybSBiZWNhdXNlIGlmIHNvbWV0aGluZyBzdXNwZW5kcywgd2Ugc3RpbGxcbiAgLy8gbmVlZCB0byBwb3AgYmFjayB1cCBhbmQgZmluaXNoIHRoaXMgc3VidHJlZSBvZiBIVE1MLlxuXG4gIHJlbmRlck5vZGUocmVxdWVzdCwgdGFzaywgY2hpbGRyZW4pOyAvLyBXZSBleHBlY3QgdGhhdCBlcnJvcnMgd2lsbCBmYXRhbCB0aGUgd2hvbGUgdGFzayBhbmQgdGhhdCB3ZSBkb24ndCBuZWVkXG4gIC8vIHRoZSBjb3JyZWN0IGNvbnRleHQuIFRoZXJlZm9yZSB0aGlzIGlzIG5vdCBpbiBhIGZpbmFsbHkuXG5cbiAgc2VnbWVudC5mb3JtYXRDb250ZXh0ID0gcHJldkNvbnRleHQ7XG4gIHB1c2hFbmRJbnN0YW5jZShzZWdtZW50LmNodW5rcywgdHlwZSk7XG4gIHNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSBmYWxzZTtcbiAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0JDEoQ29tcG9uZW50KSB7XG4gIHJldHVybiBDb21wb25lbnQucHJvdG90eXBlICYmIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudDtcbn1cblxuZnVuY3Rpb24gcmVuZGVyV2l0aEhvb2tzKHJlcXVlc3QsIHRhc2ssIENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZykge1xuICB2YXIgY29tcG9uZW50SWRlbnRpdHkgPSB7fTtcbiAgcHJlcGFyZVRvVXNlSG9va3ModGFzaywgY29tcG9uZW50SWRlbnRpdHkpO1xuICB2YXIgcmVzdWx0ID0gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpO1xuICByZXR1cm4gZmluaXNoSG9va3MoQ29tcG9uZW50LCBwcm9wcywgcmVzdWx0LCBzZWNvbmRBcmcpO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hDbGFzc0NvbXBvbmVudChyZXF1ZXN0LCB0YXNrLCBpbnN0YW5jZSwgQ29tcG9uZW50LCBwcm9wcykge1xuICB2YXIgbmV4dENoaWxkcmVuID0gaW5zdGFuY2UucmVuZGVyKCk7XG5cbiAge1xuICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gcHJvcHMpIHtcbiAgICAgIGlmICghZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcykge1xuICAgICAgICBlcnJvcignSXQgbG9va3MgbGlrZSAlcyBpcyByZWFzc2lnbmluZyBpdHMgb3duIGB0aGlzLnByb3BzYCB3aGlsZSByZW5kZXJpbmcuICcgKyAnVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCBjYW4gbGVhZCB0byBjb25mdXNpbmcgYnVncy4nLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnYSBjb21wb25lbnQnKTtcbiAgICAgIH1cblxuICAgICAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcztcblxuICAgIGlmIChjaGlsZENvbnRleHRUeXBlcyAhPT0gbnVsbCAmJiBjaGlsZENvbnRleHRUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcHJldmlvdXNDb250ZXh0ID0gdGFzay5sZWdhY3lDb250ZXh0O1xuICAgICAgdmFyIG1lcmdlZENvbnRleHQgPSBwcm9jZXNzQ2hpbGRDb250ZXh0KGluc3RhbmNlLCBDb21wb25lbnQsIHByZXZpb3VzQ29udGV4dCwgY2hpbGRDb250ZXh0VHlwZXMpO1xuICAgICAgdGFzay5sZWdhY3lDb250ZXh0ID0gbWVyZ2VkQ29udGV4dDtcbiAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgdGFzay5sZWdhY3lDb250ZXh0ID0gcHJldmlvdXNDb250ZXh0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBuZXh0Q2hpbGRyZW4pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJDbGFzc0NvbXBvbmVudChyZXF1ZXN0LCB0YXNrLCBDb21wb25lbnQsIHByb3BzKSB7XG4gIHB1c2hDbGFzc0NvbXBvbmVudFN0YWNrSW5ERVYodGFzaywgQ29tcG9uZW50KTtcbiAgdmFyIG1hc2tlZENvbnRleHQgPSAgZ2V0TWFza2VkQ29udGV4dChDb21wb25lbnQsIHRhc2subGVnYWN5Q29udGV4dCkgO1xuICB2YXIgaW5zdGFuY2UgPSBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKENvbXBvbmVudCwgcHJvcHMsIG1hc2tlZENvbnRleHQpO1xuICBtb3VudENsYXNzSW5zdGFuY2UoaW5zdGFuY2UsIENvbXBvbmVudCwgcHJvcHMsIG1hc2tlZENvbnRleHQpO1xuICBmaW5pc2hDbGFzc0NvbXBvbmVudChyZXF1ZXN0LCB0YXNrLCBpbnN0YW5jZSwgQ29tcG9uZW50LCBwcm9wcyk7XG4gIHBvcENvbXBvbmVudFN0YWNrSW5ERVYodGFzayk7XG59XG5cbnZhciBkaWRXYXJuQWJvdXRCYWRDbGFzcyA9IHt9O1xudmFyIGRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnQgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG52YXIgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9IGZhbHNlO1xudmFyIGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgPSBmYWxzZTtcbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG52YXIgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyID0gZmFsc2U7IC8vIFRoaXMgd291bGQgdHlwaWNhbGx5IGJlIGEgZnVuY3Rpb24gY29tcG9uZW50IGJ1dCB3ZSBzdGlsbCBzdXBwb3J0IG1vZHVsZSBwYXR0ZXJuXG4vLyBjb21wb25lbnRzIGZvciBzb21lIHJlYXNvbi5cblxuZnVuY3Rpb24gcmVuZGVySW5kZXRlcm1pbmF0ZUNvbXBvbmVudChyZXF1ZXN0LCB0YXNrLCBDb21wb25lbnQsIHByb3BzKSB7XG4gIHZhciBsZWdhY3lDb250ZXh0O1xuXG4gIHtcbiAgICBsZWdhY3lDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dChDb21wb25lbnQsIHRhc2subGVnYWN5Q29udGV4dCk7XG4gIH1cblxuICBwdXNoRnVuY3Rpb25Db21wb25lbnRTdGFja0luREVWKHRhc2ssIENvbXBvbmVudCk7XG5cbiAge1xuICAgIGlmIChDb21wb25lbnQucHJvdG90eXBlICYmIHR5cGVvZiBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB2YWx1ZSA9IHJlbmRlcldpdGhIb29rcyhyZXF1ZXN0LCB0YXNrLCBDb21wb25lbnQsIHByb3BzLCBsZWdhY3lDb250ZXh0KTtcbiAgdmFyIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcblxuICB7XG4gICAgLy8gU3VwcG9ydCBmb3IgbW9kdWxlIGNvbXBvbmVudHMgaXMgZGVwcmVjYXRlZCBhbmQgaXMgcmVtb3ZlZCBiZWhpbmQgYSBmbGFnLlxuICAgIC8vIFdoZXRoZXIgb3Igbm90IGl0IHdvdWxkIGNyYXNoIGxhdGVyLCB3ZSB3YW50IHRvIHNob3cgYSBnb29kIG1lc3NhZ2UgaW4gREVWIGZpcnN0LlxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZS5yZW5kZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsdWUuJCR0eXBlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnRbX2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGJlIGEgZnVuY3Rpb24gY29tcG9uZW50IHRoYXQgcmV0dXJucyBhIGNsYXNzIGluc3RhbmNlLiAnICsgJ0NoYW5nZSAlcyB0byBhIGNsYXNzIHRoYXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4gJyArIFwiSWYgeW91IGNhbid0IHVzZSBhIGNsYXNzIHRyeSBhc3NpZ25pbmcgdGhlIHByb3RvdHlwZSBvbiB0aGUgZnVuY3Rpb24gYXMgYSB3b3JrYXJvdW5kLiBcIiArIFwiYCVzLnByb3RvdHlwZSA9IFJlYWN0LkNvbXBvbmVudC5wcm90b3R5cGVgLiBEb24ndCB1c2UgYW4gYXJyb3cgZnVuY3Rpb24gc2luY2UgaXQgXCIgKyAnY2Fubm90IGJlIGNhbGxlZCB3aXRoIGBuZXdgIGJ5IFJlYWN0LicsIF9jb21wb25lbnROYW1lLCBfY29tcG9uZW50TmFtZSwgX2NvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnRbX2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIC8vIFJ1biB0aGVzZSBjaGVja3MgaW4gcHJvZHVjdGlvbiBvbmx5IGlmIHRoZSBmbGFnIGlzIG9mZi5cbiAgLy8gRXZlbnR1YWxseSB3ZSdsbCBkZWxldGUgdGhpcyBicmFuY2ggYWx0b2dldGhlci5cbiAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZS4kJHR5cGVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lMiA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lMl0pIHtcbiAgICAgICAgZXJyb3IoJ1RoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2UuICcgKyAnQ2hhbmdlICVzIHRvIGEgY2xhc3MgdGhhdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLiAnICsgXCJJZiB5b3UgY2FuJ3QgdXNlIGEgY2xhc3MgdHJ5IGFzc2lnbmluZyB0aGUgcHJvdG90eXBlIG9uIHRoZSBmdW5jdGlvbiBhcyBhIHdvcmthcm91bmQuIFwiICsgXCJgJXMucHJvdG90eXBlID0gUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZWAuIERvbid0IHVzZSBhbiBhcnJvdyBmdW5jdGlvbiBzaW5jZSBpdCBcIiArICdjYW5ub3QgYmUgY2FsbGVkIHdpdGggYG5ld2AgYnkgUmVhY3QuJywgX2NvbXBvbmVudE5hbWUyLCBfY29tcG9uZW50TmFtZTIsIF9jb21wb25lbnROYW1lMik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtb3VudENsYXNzSW5zdGFuY2UodmFsdWUsIENvbXBvbmVudCwgcHJvcHMsIGxlZ2FjeUNvbnRleHQpO1xuICAgIGZpbmlzaENsYXNzQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIHZhbHVlLCBDb21wb25lbnQsIHByb3BzKTtcbiAgfSBlbHNlIHtcblxuICAgIHtcbiAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldihDb21wb25lbnQpO1xuICAgIH0gLy8gV2UncmUgbm93IHN1Y2Nlc3NmdWxseSBwYXN0IHRoaXMgdGFzaywgYW5kIHdlIGRvbid0IGhhdmUgdG8gcG9wIGJhY2sgdG9cbiAgICAvLyB0aGUgcHJldmlvdXMgdGFzayBldmVyeSBhZ2Fpbiwgc28gd2UgY2FuIHVzZSB0aGUgZGVzdHJ1Y3RpdmUgcmVjdXJzaXZlIGZvcm0uXG5cblxuICAgIGlmIChoYXNJZCkge1xuICAgICAgLy8gVGhpcyBjb21wb25lbnQgbWF0ZXJpYWxpemVkIGFuIGlkLiBXZSB0cmVhdCB0aGlzIGFzIGl0cyBvd24gbGV2ZWwsIHdpdGhcbiAgICAgIC8vIGEgc2luZ2xlIFwiY2hpbGRcIiBzbG90LlxuICAgICAgdmFyIHByZXZUcmVlQ29udGV4dCA9IHRhc2sudHJlZUNvbnRleHQ7XG4gICAgICB2YXIgdG90YWxDaGlsZHJlbiA9IDE7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdGFzay50cmVlQ29udGV4dCA9IHB1c2hUcmVlQ29udGV4dChwcmV2VHJlZUNvbnRleHQsIHRvdGFsQ2hpbGRyZW4sIGluZGV4KTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIHZhbHVlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRhc2sudHJlZUNvbnRleHQgPSBwcmV2VHJlZUNvbnRleHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KENvbXBvbmVudCkge1xuICB7XG4gICAgaWYgKENvbXBvbmVudCkge1xuICAgICAgaWYgKENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcykge1xuICAgICAgICBlcnJvcignJXMoLi4uKTogY2hpbGRDb250ZXh0VHlwZXMgY2Fubm90IGJlIGRlZmluZWQgb24gYSBmdW5jdGlvbiBjb21wb25lbnQuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTMgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTNdKSB7XG4gICAgICAgIGVycm9yKCclczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuJywgX2NvbXBvbmVudE5hbWUzKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM10gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgQ29tcG9uZW50LmNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBDb21wb25lbnQuY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTQgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lNF0pIHtcbiAgICAgICAgZXJyb3IoJyVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGNvbnRleHRUeXBlLicsIF9jb21wb25lbnROYW1lNCk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lNF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgYmFzZVByb3BzKSB7XG4gIGlmIChDb21wb25lbnQgJiYgQ29tcG9uZW50LmRlZmF1bHRQcm9wcykge1xuICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wcy4gVGFrZW4gZnJvbSBSZWFjdEVsZW1lbnRcbiAgICB2YXIgcHJvcHMgPSBhc3NpZ24oe30sIGJhc2VQcm9wcyk7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IENvbXBvbmVudC5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcm9wcztcbiAgfVxuXG4gIHJldHVybiBiYXNlUHJvcHM7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckZvcndhcmRSZWYocmVxdWVzdCwgdGFzaywgdHlwZSwgcHJvcHMsIHJlZikge1xuICBwdXNoRnVuY3Rpb25Db21wb25lbnRTdGFja0luREVWKHRhc2ssIHR5cGUucmVuZGVyKTtcbiAgdmFyIGNoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKHJlcXVlc3QsIHRhc2ssIHR5cGUucmVuZGVyLCBwcm9wcywgcmVmKTtcbiAgdmFyIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcblxuICBpZiAoaGFzSWQpIHtcbiAgICAvLyBUaGlzIGNvbXBvbmVudCBtYXRlcmlhbGl6ZWQgYW4gaWQuIFdlIHRyZWF0IHRoaXMgYXMgaXRzIG93biBsZXZlbCwgd2l0aFxuICAgIC8vIGEgc2luZ2xlIFwiY2hpbGRcIiBzbG90LlxuICAgIHZhciBwcmV2VHJlZUNvbnRleHQgPSB0YXNrLnRyZWVDb250ZXh0O1xuICAgIHZhciB0b3RhbENoaWxkcmVuID0gMTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHRhc2sudHJlZUNvbnRleHQgPSBwdXNoVHJlZUNvbnRleHQocHJldlRyZWVDb250ZXh0LCB0b3RhbENoaWxkcmVuLCBpbmRleCk7XG5cbiAgICB0cnkge1xuICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGFzay50cmVlQ29udGV4dCA9IHByZXZUcmVlQ29udGV4dDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuKTtcbiAgfVxuXG4gIHBvcENvbXBvbmVudFN0YWNrSW5ERVYodGFzayk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlck1lbW8ocmVxdWVzdCwgdGFzaywgdHlwZSwgcHJvcHMsIHJlZikge1xuICB2YXIgaW5uZXJUeXBlID0gdHlwZS50eXBlO1xuICB2YXIgcmVzb2x2ZWRQcm9wcyA9IHJlc29sdmVEZWZhdWx0UHJvcHMoaW5uZXJUeXBlLCBwcm9wcyk7XG4gIHJlbmRlckVsZW1lbnQocmVxdWVzdCwgdGFzaywgaW5uZXJUeXBlLCByZXNvbHZlZFByb3BzLCByZWYpO1xufVxuXG5mdW5jdGlvbiByZW5kZXJDb250ZXh0Q29uc3VtZXIocmVxdWVzdCwgdGFzaywgY29udGV4dCwgcHJvcHMpIHtcbiAgLy8gVGhlIGxvZ2ljIGJlbG93IGZvciBDb250ZXh0IGRpZmZlcnMgZGVwZW5kaW5nIG9uIFBST0Qgb3IgREVWIG1vZGUuIEluXG4gIC8vIERFViBtb2RlLCB3ZSBjcmVhdGUgYSBzZXBhcmF0ZSBvYmplY3QgZm9yIENvbnRleHQuQ29uc3VtZXIgdGhhdCBhY3RzXG4gIC8vIGxpa2UgYSBwcm94eSB0byBDb250ZXh0LiBUaGlzIHByb3h5IG9iamVjdCBhZGRzIHVubmVjZXNzYXJ5IGNvZGUgaW4gUFJPRFxuICAvLyBzbyB3ZSB1c2UgdGhlIG9sZCBiZWhhdmlvdXIgKENvbnRleHQuQ29uc3VtZXIgcmVmZXJlbmNlcyBDb250ZXh0KSB0b1xuICAvLyByZWR1Y2Ugc2l6ZSBhbmQgb3ZlcmhlYWQuIFRoZSBzZXBhcmF0ZSBvYmplY3QgcmVmZXJlbmNlcyBjb250ZXh0IHZpYVxuICAvLyBhIHByb3BlcnR5IGNhbGxlZCBcIl9jb250ZXh0XCIsIHdoaWNoIGFsc28gZ2l2ZXMgdXMgdGhlIGFiaWxpdHkgdG8gY2hlY2tcbiAgLy8gaW4gREVWIG1vZGUgaWYgdGhpcyBwcm9wZXJ0eSBleGlzdHMgb3Igbm90IGFuZCB3YXJuIGlmIGl0IGRvZXMgbm90LlxuICB7XG4gICAgaWYgKGNvbnRleHQuX2NvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gVGhpcyBtYXkgYmUgYmVjYXVzZSBpdCdzIGEgQ29udGV4dCAocmF0aGVyIHRoYW4gYSBDb25zdW1lcikuXG4gICAgICAvLyBPciBpdCBtYXkgYmUgYmVjYXVzZSBpdCdzIG9sZGVyIFJlYWN0IHdoZXJlIHRoZXkncmUgdGhlIHNhbWUgdGhpbmcuXG4gICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gd2FybiBpZiB3ZSdyZSBzdXJlIGl0J3MgYSBuZXcgUmVhY3QuXG4gICAgICBpZiAoY29udGV4dCAhPT0gY29udGV4dC5Db25zdW1lcikge1xuICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lcikge1xuICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lciA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0PiBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LkNvbnN1bWVyPiBpbnN0ZWFkPycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQgPSBjb250ZXh0Ll9jb250ZXh0O1xuICAgIH1cbiAgfVxuXG4gIHZhciByZW5kZXIgPSBwcm9wcy5jaGlsZHJlbjtcblxuICB7XG4gICAgaWYgKHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdBIGNvbnRleHQgY29uc3VtZXIgd2FzIHJlbmRlcmVkIHdpdGggbXVsdGlwbGUgY2hpbGRyZW4sIG9yIGEgY2hpbGQgJyArIFwidGhhdCBpc24ndCBhIGZ1bmN0aW9uLiBBIGNvbnRleHQgY29uc3VtZXIgZXhwZWN0cyBhIHNpbmdsZSBjaGlsZCBcIiArICd0aGF0IGlzIGEgZnVuY3Rpb24uIElmIHlvdSBkaWQgcGFzcyBhIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdGhlcmUgJyArICdpcyBubyB0cmFpbGluZyBvciBsZWFkaW5nIHdoaXRlc3BhY2UgYXJvdW5kIGl0LicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBuZXdWYWx1ZSA9IHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICB2YXIgbmV3Q2hpbGRyZW4gPSByZW5kZXIobmV3VmFsdWUpO1xuICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgbmV3Q2hpbGRyZW4pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJDb250ZXh0UHJvdmlkZXIocmVxdWVzdCwgdGFzaywgdHlwZSwgcHJvcHMpIHtcbiAgdmFyIGNvbnRleHQgPSB0eXBlLl9jb250ZXh0O1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gIHZhciBwcmV2U25hcHNob3Q7XG5cbiAge1xuICAgIHByZXZTbmFwc2hvdCA9IHRhc2suY29udGV4dDtcbiAgfVxuXG4gIHRhc2suY29udGV4dCA9IHB1c2hQcm92aWRlcihjb250ZXh0LCB2YWx1ZSk7XG4gIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbik7XG4gIHRhc2suY29udGV4dCA9IHBvcFByb3ZpZGVyKGNvbnRleHQpO1xuXG4gIHtcbiAgICBpZiAocHJldlNuYXBzaG90ICE9PSB0YXNrLmNvbnRleHQpIHtcbiAgICAgIGVycm9yKCdQb3BwaW5nIHRoZSBjb250ZXh0IHByb3ZpZGVyIGRpZCBub3QgcmV0dXJuIGJhY2sgdG8gdGhlIG9yaWdpbmFsIHNuYXBzaG90LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJMYXp5Q29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIGxhenlDb21wb25lbnQsIHByb3BzLCByZWYpIHtcbiAgcHVzaEJ1aWx0SW5Db21wb25lbnRTdGFja0luREVWKHRhc2ssICdMYXp5Jyk7XG4gIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuICB2YXIgQ29tcG9uZW50ID0gaW5pdChwYXlsb2FkKTtcbiAgdmFyIHJlc29sdmVkUHJvcHMgPSByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgcHJvcHMpO1xuICByZW5kZXJFbGVtZW50KHJlcXVlc3QsIHRhc2ssIENvbXBvbmVudCwgcmVzb2x2ZWRQcm9wcywgcmVmKTtcbiAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCB0eXBlLCBwcm9wcywgcmVmKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChzaG91bGRDb25zdHJ1Y3QkMSh0eXBlKSkge1xuICAgICAgcmVuZGVyQ2xhc3NDb21wb25lbnQocmVxdWVzdCwgdGFzaywgdHlwZSwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW5kZXJJbmRldGVybWluYXRlQ29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIHR5cGUsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVuZGVySG9zdEVsZW1lbnQocmVxdWVzdCwgdGFzaywgdHlwZSwgcHJvcHMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIC8vIFRPRE86IExlZ2FjeUhpZGRlbiBhY3RzIHRoZSBzYW1lIGFzIGEgZnJhZ21lbnQuIFRoaXMgb25seSB3b3Jrc1xuICAgIC8vIGJlY2F1c2Ugd2UgY3VycmVudGx5IGFzc3VtZSB0aGF0IGV2ZXJ5IGluc3RhbmNlIG9mIExlZ2FjeUhpZGRlbiBpc1xuICAgIC8vIGFjY29tcGFuaWVkIGJ5IGEgaG9zdCBjb21wb25lbnQgd3JhcHBlci4gSW4gdGhlIGhpZGRlbiBtb2RlLCB0aGUgaG9zdFxuICAgIC8vIGNvbXBvbmVudCBpcyBnaXZlbiBhIGBoaWRkZW5gIGF0dHJpYnV0ZSwgd2hpY2ggZW5zdXJlcyB0aGF0IHRoZVxuICAgIC8vIGluaXRpYWwgSFRNTCBpcyBub3QgdmlzaWJsZS4gVG8gc3VwcG9ydCB0aGUgdXNlIG9mIExlZ2FjeUhpZGRlbiBhcyBhXG4gICAgLy8gdHJ1ZSBmcmFnbWVudCwgd2l0aG91dCBhbiBleHRyYSBET00gbm9kZSwgd2Ugd291bGQgaGF2ZSB0byBoaWRlIHRoZVxuICAgIC8vIGluaXRpYWwgSFRNTCBpbiBzb21lIG90aGVyIHdheS5cbiAgICAvLyBUT0RPOiBBZGQgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgaGVyZSB0b28gd2l0aCB0aGUgc2FtZSBjYXBhYmlsaXR5LlxuICAgIGNhc2UgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFOlxuICAgIGNhc2UgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEU6XG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICB7XG4gICAgICAgIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBwcm9wcy5jaGlsZHJlbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAge1xuICAgICAgICBwdXNoQnVpbHRJbkNvbXBvbmVudFN0YWNrSW5ERVYodGFzaywgJ1N1c3BlbnNlTGlzdCcpOyAvLyBUT0RPOiBTdXNwZW5zZUxpc3Qgc2hvdWxkIGNvbnRyb2wgdGhlIGJvdW5kYXJpZXMuXG5cbiAgICAgICAgcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIHByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgcG9wQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBSRUFDVF9TQ09QRV9UWVBFOlxuICAgICAge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVhY3RET01TZXJ2ZXIgZG9lcyBub3QgeWV0IHN1cHBvcnQgc2NvcGUgY29tcG9uZW50cy4nKTtcbiAgICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUtbm8tZmFsbHRocm91Z2hcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHJlbmRlclN1c3BlbnNlQm91bmRhcnkocmVxdWVzdCwgdGFzaywgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICByZW5kZXJGb3J3YXJkUmVmKHJlcXVlc3QsIHRhc2ssIHR5cGUsIHByb3BzLCByZWYpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHJlbmRlck1lbW8ocmVxdWVzdCwgdGFzaywgdHlwZSwgcHJvcHMsIHJlZik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHJlbmRlckNvbnRleHRQcm92aWRlcihyZXF1ZXN0LCB0YXNrLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmVuZGVyQ29udGV4dENvbnN1bWVyKHJlcXVlc3QsIHRhc2ssIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICByZW5kZXJMYXp5Q29tcG9uZW50KHJlcXVlc3QsIHRhc2ssIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaW5mbyA9ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgXCIgKyAnbmFtZWQgaW1wb3J0cy4nO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gJyArICdjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpICcgKyAoXCJidXQgZ290OiBcIiArICh0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUpICsgXCIuXCIgKyBpbmZvKSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlSXRlcmFibGUoaXRlcmFibGUsIGl0ZXJhdG9yRm4pIHtcbiAge1xuICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgcmVuZGVyaW5nIEdlbmVyYXRvcnMgYmVjYXVzZSBpdCdzIGEgbXV0YXRpb24uXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTI5OTVcbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IHRvU3RyaW5nVGFnXG4gICAgaXRlcmFibGVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0dlbmVyYXRvcicpIHtcbiAgICAgIGlmICghZGlkV2FybkFib3V0R2VuZXJhdG9ycykge1xuICAgICAgICBlcnJvcignVXNpbmcgR2VuZXJhdG9ycyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMgYmVjYXVzZSBlbnVtZXJhdGluZyBhIGdlbmVyYXRvciBtdXRhdGVzIGl0LiAnICsgJ1lvdSBtYXkgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIGBBcnJheS5mcm9tKClgIG9yIHRoZSAnICsgJ2BbLi4uc3ByZWFkXWAgb3BlcmF0b3IgYmVmb3JlIHJlbmRlcmluZy4gS2VlcCBpbiBtaW5kICcgKyAneW91IG1pZ2h0IG5lZWQgdG8gcG9seWZpbGwgdGhlc2UgZmVhdHVyZXMgZm9yIG9sZGVyIGJyb3dzZXJzLicpO1xuICAgICAgfVxuXG4gICAgICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gdHJ1ZTtcbiAgICB9IC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuXG5cbiAgICBpZiAoaXRlcmFibGUuZW50cmllcyA9PT0gaXRlcmF0b3JGbikge1xuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNYXBzKSB7XG4gICAgICAgIGVycm9yKCdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKTtcbiAgICAgIH1cblxuICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlck5vZGVEZXN0cnVjdGl2ZShyZXF1ZXN0LCB0YXNrLCBub2RlKSB7XG4gIHtcbiAgICAvLyBJbiBEZXYgd2Ugd3JhcCByZW5kZXJOb2RlRGVzdHJ1Y3RpdmVJbXBsIGluIGEgdHJ5IC8gY2F0Y2ggc28gd2UgY2FuIGNhcHR1cmVcbiAgICAvLyBhIGNvbXBvbmVudCBzdGFjayBhdCB0aGUgcmlnaHQgcGxhY2UgaW4gdGhlIHRyZWUuIFdlIGRvbid0IGRvIHRoaXMgaW4gcmVuZGVyTm9kZVxuICAgIC8vIGJlY3Vhc2UgaXQgaXMgbm90IGNhbGxlZCBhdCBldmVyeSBsYXllciBvZiB0aGUgdHJlZSBhbmQgd2UgbWF5IGxvc2UgZnJhbWVzXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmVJbXBsKHJlcXVlc3QsIHRhc2ssIG5vZGUpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCAmJiB0eXBlb2YgeC50aGVuID09PSAnZnVuY3Rpb24nKSA7IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIGVycm9yLCBzdGFzaCB0aGUgY29tcG9uZW50IHN0YWNrIGlmIGl0IGlzIG51bGwuXG4gICAgICAgIGxhc3RCb3VuZGFyeUVycm9yQ29tcG9uZW50U3RhY2tEZXYgPSBsYXN0Qm91bmRhcnlFcnJvckNvbXBvbmVudFN0YWNrRGV2ICE9PSBudWxsID8gbGFzdEJvdW5kYXJ5RXJyb3JDb21wb25lbnRTdGFja0RldiA6IGdldEN1cnJlbnRTdGFja0luREVWKCk7XG4gICAgICB9IC8vIHJldGhyb3cgc28gbm9ybWFsIHN1c3BlbnNlIGxvZ2ljIGNhbiBoYW5kbGUgdGhyb3duIHZhbHVlIGFjY29yZGluZ2x5XG5cblxuICAgICAgdGhyb3cgeDtcbiAgICB9XG4gIH1cbn0gLy8gVGhpcyBmdW5jdGlvbiBieSBpdCBzZWxmIHJlbmRlcnMgYSBub2RlIGFuZCBjb25zdW1lcyB0aGUgdGFzayBieSBtdXRhdGluZyBpdFxuLy8gdG8gdXBkYXRlIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBzdGF0ZS5cblxuXG5mdW5jdGlvbiByZW5kZXJOb2RlRGVzdHJ1Y3RpdmVJbXBsKHJlcXVlc3QsIHRhc2ssIG5vZGUpIHtcbiAgLy8gU3Rhc2ggdGhlIG5vZGUgd2UncmUgd29ya2luZyBvbi4gV2UnbGwgcGljayB1cCBmcm9tIHRoaXMgdGFzayBpbiBjYXNlXG4gIC8vIHNvbWV0aGluZyBzdXNwZW5kcy5cbiAgdGFzay5ub2RlID0gbm9kZTsgLy8gSGFuZGxlIG9iamVjdCB0eXBlc1xuXG4gIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZSAhPT0gbnVsbCkge1xuICAgIHN3aXRjaCAobm9kZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IG5vZGU7XG4gICAgICAgICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgICAgICAgdmFyIHByb3BzID0gZWxlbWVudC5wcm9wcztcbiAgICAgICAgICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gICAgICAgICAgcmVuZGVyRWxlbWVudChyZXF1ZXN0LCB0YXNrLCB0eXBlLCBwcm9wcywgcmVmKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3J0YWxzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSB0aGUgc2VydmVyIHJlbmRlcmVyLiAnICsgJ1JlbmRlciB0aGVtIGNvbmRpdGlvbmFsbHkgc28gdGhhdCB0aGV5IG9ubHkgYXBwZWFyIG9uIHRoZSBjbGllbnQgcmVuZGVyLicpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lLW5vLWZhbGx0aHJvdWdoXG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlOb2RlID0gbm9kZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlOb2RlLl9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eU5vZGUuX2luaXQ7XG4gICAgICAgICAgdmFyIHJlc29sdmVkTm9kZTtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlc29sdmVkTm9kZSA9IGluaXQocGF5bG9hZCk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCAmJiB0eXBlb2YgeC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBMYXp5IGluaXRpYWxpemVyIGlzIHN1c3BlbmRpbmcuIHB1c2ggYSB0ZW1wb3JhcnkgZnJhbWUgb250byB0aGUgc3RhY2sgc28gaXQgY2FuIGJlXG4gICAgICAgICAgICAgICAgLy8gcG9wcGVkIG9mZiBpbiBzcGF3bk5ld1N1c3BlbmRlZFRhc2suIFRoaXMgYWxpZ25zIHN0YWNrIGJlaGF2aW9yIGJldHdlZW4gTGF6eSBpbiBlbGVtZW50IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgLy8gdnMgQ29tcG9uZW50IHBvc2l0aW9uLiBXZSBkbyBub3Qgd2FudCB0aGUgZnJhbWUgZm9yIEVycm9ycyBzbyB3ZSBleGNsdXNpdmVseSBkbyB0aGlzIGluXG4gICAgICAgICAgICAgICAgLy8gdGhlIHdha2VhYmxlIGJyYW5jaFxuICAgICAgICAgICAgICAgIHB1c2hCdWlsdEluQ29tcG9uZW50U3RhY2tJbkRFVih0YXNrLCAnTGF6eScpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhyb3cgeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgcmVzb2x2ZWROb2RlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0LCB0YXNrLCBub2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAge1xuICAgICAgICB2YWxpZGF0ZUl0ZXJhYmxlKG5vZGUsIGl0ZXJhdG9yRm4pO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG5cbiAgICAgIGlmIChpdGVyYXRvcikge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGtub3cgaG93IG1hbnkgdG90YWwgY2hpbGRyZW4gYXJlIGluIHRoaXMgc2V0LCBzbyB0aGF0IHdlXG4gICAgICAgIC8vIGNhbiBhbGxvY2F0ZSBlbm91Z2ggaWQgc2xvdHMgdG8gYWNvbW1vZGF0ZSB0aGVtLiBTbyB3ZSBtdXN0IGV4aGF1c3RcbiAgICAgICAgLy8gdGhlIGl0ZXJhdG9yIGJlZm9yZSB3ZSBzdGFydCByZWN1cnNpdmVseSByZW5kZXJpbmcgdGhlIGNoaWxkcmVuLlxuICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIG5vdCBncmVhdCBidXQgSSB0aGluayBpdCdzIGluaGVyZW50IHRvIHRoZSBpZFxuICAgICAgICAvLyBnZW5lcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7IC8vIElmIHRoZXJlIGFyZSBub3QgZW50cmllcywgd2UgbmVlZCB0byBwdXNoIGFuIGVtcHR5IHNvIHdlIHN0YXJ0IGJ5IGNoZWNraW5nIHRoYXQuXG5cbiAgICAgICAgaWYgKCFzdGVwLmRvbmUpIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goc3RlcC52YWx1ZSk7XG4gICAgICAgICAgICBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIH0gd2hpbGUgKCFzdGVwLmRvbmUpO1xuXG4gICAgICAgICAgcmVuZGVyQ2hpbGRyZW5BcnJheShyZXF1ZXN0LCB0YXNrLCBjaGlsZHJlbik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGlsZFN0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChub2RlKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICsgKGNoaWxkU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMobm9kZSkuam9pbignLCAnKSArICd9JyA6IGNoaWxkU3RyaW5nKSArIFwiKS4gXCIgKyAnSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQuJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgIHNlZ21lbnQubGFzdFB1c2hlZFRleHQgPSBwdXNoVGV4dEluc3RhbmNlKHRhc2suYmxvY2tlZFNlZ21lbnQuY2h1bmtzLCBub2RlLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUsIHNlZ21lbnQubGFzdFB1c2hlZFRleHQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgX3NlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICAgIF9zZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gcHVzaFRleHRJbnN0YW5jZSh0YXNrLmJsb2NrZWRTZWdtZW50LmNodW5rcywgJycgKyBub2RlLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUsIF9zZWdtZW50Lmxhc3RQdXNoZWRUZXh0KTtcbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmICcgKyAneW91IHJldHVybiBhIENvbXBvbmVudCBpbnN0ZWFkIG9mIDxDb21wb25lbnQgLz4gZnJvbSByZW5kZXIuICcgKyAnT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNoaWxkcmVuQXJyYXkocmVxdWVzdCwgdGFzaywgY2hpbGRyZW4pIHtcbiAgdmFyIHRvdGFsQ2hpbGRyZW4gPSBjaGlsZHJlbi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbENoaWxkcmVuOyBpKyspIHtcbiAgICB2YXIgcHJldlRyZWVDb250ZXh0ID0gdGFzay50cmVlQ29udGV4dDtcbiAgICB0YXNrLnRyZWVDb250ZXh0ID0gcHVzaFRyZWVDb250ZXh0KHByZXZUcmVlQ29udGV4dCwgdG90YWxDaGlsZHJlbiwgaSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gV2UgbmVlZCB0byB1c2UgdGhlIG5vbi1kZXN0cnVjdGl2ZSBmb3JtIHNvIHRoYXQgd2UgY2FuIHNhZmVseSBwb3AgYmFja1xuICAgICAgLy8gdXAgYW5kIHJlbmRlciB0aGUgc2libGluZyBpZiBzb21ldGhpbmcgc3VzcGVuZHMuXG4gICAgICByZW5kZXJOb2RlKHJlcXVlc3QsIHRhc2ssIGNoaWxkcmVuW2ldKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGFzay50cmVlQ29udGV4dCA9IHByZXZUcmVlQ29udGV4dDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3Bhd25OZXdTdXNwZW5kZWRUYXNrKHJlcXVlc3QsIHRhc2ssIHgpIHtcbiAgLy8gU29tZXRoaW5nIHN1c3BlbmRlZCwgd2UnbGwgbmVlZCB0byBjcmVhdGUgYSBuZXcgc2VnbWVudCBhbmQgcmVzb2x2ZSBpdCBsYXRlci5cbiAgdmFyIHNlZ21lbnQgPSB0YXNrLmJsb2NrZWRTZWdtZW50O1xuICB2YXIgaW5zZXJ0aW9uSW5kZXggPSBzZWdtZW50LmNodW5rcy5sZW5ndGg7XG4gIHZhciBuZXdTZWdtZW50ID0gY3JlYXRlUGVuZGluZ1NlZ21lbnQocmVxdWVzdCwgaW5zZXJ0aW9uSW5kZXgsIG51bGwsIHNlZ21lbnQuZm9ybWF0Q29udGV4dCwgLy8gQWRvcHQgdGhlIHBhcmVudCBzZWdtZW50J3MgbGVhZGluZyB0ZXh0IGVtYmVkXG4gIHNlZ21lbnQubGFzdFB1c2hlZFRleHQsIC8vIEFzc3VtZSB3ZSBhcmUgdGV4dCBlbWJlZGRlZCBhdCB0aGUgdHJhaWxpbmcgZWRnZVxuICB0cnVlKTtcbiAgc2VnbWVudC5jaGlsZHJlbi5wdXNoKG5ld1NlZ21lbnQpOyAvLyBSZXNldCBsYXN0UHVzaGVkVGV4dCBmb3IgY3VycmVudCBTZWdtZW50IHNpbmNlIHRoZSBuZXcgU2VnbWVudCBcImNvbnN1bWVkXCIgaXRcblxuICBzZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gZmFsc2U7XG4gIHZhciBuZXdUYXNrID0gY3JlYXRlVGFzayhyZXF1ZXN0LCB0YXNrLm5vZGUsIHRhc2suYmxvY2tlZEJvdW5kYXJ5LCBuZXdTZWdtZW50LCB0YXNrLmFib3J0U2V0LCB0YXNrLmxlZ2FjeUNvbnRleHQsIHRhc2suY29udGV4dCwgdGFzay50cmVlQ29udGV4dCk7XG5cbiAge1xuICAgIGlmICh0YXNrLmNvbXBvbmVudFN0YWNrICE9PSBudWxsKSB7XG4gICAgICAvLyBXZSBwb3Agb25lIHRhc2sgb2ZmIHRoZSBzdGFjayBiZWNhdXNlIHRoZSBub2RlIHRoYXQgc3VzcGVuZGVkIHdpbGwgYmUgdHJpZWQgYWdhaW4sXG4gICAgICAvLyB3aGljaCB3aWxsIGFkZCBpdCBiYWNrIG9udG8gdGhlIHN0YWNrLlxuICAgICAgbmV3VGFzay5jb21wb25lbnRTdGFjayA9IHRhc2suY29tcG9uZW50U3RhY2sucGFyZW50O1xuICAgIH1cbiAgfVxuXG4gIHZhciBwaW5nID0gbmV3VGFzay5waW5nO1xuICB4LnRoZW4ocGluZywgcGluZyk7XG59IC8vIFRoaXMgaXMgYSBub24tZGVzdHJ1Y3RpdmUgZm9ybSBvZiByZW5kZXJpbmcgYSBub2RlLiBJZiBpdCBzdXNwZW5kcyBpdCBzcGF3bnNcbi8vIGEgbmV3IHRhc2sgYW5kIHJlc3RvcmVzIHRoZSBjb250ZXh0IG9mIHRoaXMgdGFzayB0byB3aGF0IGl0IHdhcyBiZWZvcmUuXG5cblxuZnVuY3Rpb24gcmVuZGVyTm9kZShyZXF1ZXN0LCB0YXNrLCBub2RlKSB7XG4gIC8vIFRPRE86IFN0b3JlIHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoIGhlcmUgYW5kIHJlc2V0IGl0IGluIGNhc2Ugc29tZXRoaW5nXG4gIC8vIHN1c3BlbmRlZCBwYXJ0aWFsbHkgdGhyb3VnaCB3cml0aW5nIHNvbWV0aGluZy5cbiAgLy8gU25hcHNob3QgdGhlIGN1cnJlbnQgY29udGV4dCBpbiBjYXNlIHNvbWV0aGluZyB0aHJvd3MgdG8gaW50ZXJydXB0IHRoZVxuICAvLyBwcm9jZXNzLlxuICB2YXIgcHJldmlvdXNGb3JtYXRDb250ZXh0ID0gdGFzay5ibG9ja2VkU2VnbWVudC5mb3JtYXRDb250ZXh0O1xuICB2YXIgcHJldmlvdXNMZWdhY3lDb250ZXh0ID0gdGFzay5sZWdhY3lDb250ZXh0O1xuICB2YXIgcHJldmlvdXNDb250ZXh0ID0gdGFzay5jb250ZXh0O1xuICB2YXIgcHJldmlvdXNDb21wb25lbnRTdGFjayA9IG51bGw7XG5cbiAge1xuICAgIHByZXZpb3VzQ29tcG9uZW50U3RhY2sgPSB0YXNrLmNvbXBvbmVudFN0YWNrO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gcmVuZGVyTm9kZURlc3RydWN0aXZlKHJlcXVlc3QsIHRhc2ssIG5vZGUpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgcmVzZXRIb29rc1N0YXRlKCk7XG5cbiAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwgJiYgdHlwZW9mIHgudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3Bhd25OZXdTdXNwZW5kZWRUYXNrKHJlcXVlc3QsIHRhc2ssIHgpOyAvLyBSZXN0b3JlIHRoZSBjb250ZXh0LiBXZSBhc3N1bWUgdGhhdCB0aGlzIHdpbGwgYmUgcmVzdG9yZWQgYnkgdGhlIGlubmVyXG4gICAgICAvLyBmdW5jdGlvbnMgaW4gY2FzZSBub3RoaW5nIHRocm93cyBzbyB3ZSBkb24ndCB1c2UgXCJmaW5hbGx5XCIgaGVyZS5cblxuICAgICAgdGFzay5ibG9ja2VkU2VnbWVudC5mb3JtYXRDb250ZXh0ID0gcHJldmlvdXNGb3JtYXRDb250ZXh0O1xuICAgICAgdGFzay5sZWdhY3lDb250ZXh0ID0gcHJldmlvdXNMZWdhY3lDb250ZXh0O1xuICAgICAgdGFzay5jb250ZXh0ID0gcHJldmlvdXNDb250ZXh0OyAvLyBSZXN0b3JlIGFsbCBhY3RpdmUgUmVhY3RDb250ZXh0cyB0byB3aGF0IHRoZXkgd2VyZSBiZWZvcmUuXG5cbiAgICAgIHN3aXRjaENvbnRleHQocHJldmlvdXNDb250ZXh0KTtcblxuICAgICAge1xuICAgICAgICB0YXNrLmNvbXBvbmVudFN0YWNrID0gcHJldmlvdXNDb21wb25lbnRTdGFjaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXN0b3JlIHRoZSBjb250ZXh0LiBXZSBhc3N1bWUgdGhhdCB0aGlzIHdpbGwgYmUgcmVzdG9yZWQgYnkgdGhlIGlubmVyXG4gICAgICAvLyBmdW5jdGlvbnMgaW4gY2FzZSBub3RoaW5nIHRocm93cyBzbyB3ZSBkb24ndCB1c2UgXCJmaW5hbGx5XCIgaGVyZS5cbiAgICAgIHRhc2suYmxvY2tlZFNlZ21lbnQuZm9ybWF0Q29udGV4dCA9IHByZXZpb3VzRm9ybWF0Q29udGV4dDtcbiAgICAgIHRhc2subGVnYWN5Q29udGV4dCA9IHByZXZpb3VzTGVnYWN5Q29udGV4dDtcbiAgICAgIHRhc2suY29udGV4dCA9IHByZXZpb3VzQ29udGV4dDsgLy8gUmVzdG9yZSBhbGwgYWN0aXZlIFJlYWN0Q29udGV4dHMgdG8gd2hhdCB0aGV5IHdlcmUgYmVmb3JlLlxuXG4gICAgICBzd2l0Y2hDb250ZXh0KHByZXZpb3VzQ29udGV4dCk7XG5cbiAgICAgIHtcbiAgICAgICAgdGFzay5jb21wb25lbnRTdGFjayA9IHByZXZpb3VzQ29tcG9uZW50U3RhY2s7XG4gICAgICB9IC8vIFdlIGFzc3VtZSB0aGF0IHdlIGRvbid0IG5lZWQgdGhlIGNvcnJlY3QgY29udGV4dC5cbiAgICAgIC8vIExldCdzIHRlcm1pbmF0ZSB0aGUgcmVzdCBvZiB0aGUgdHJlZSBhbmQgZG9uJ3QgcmVuZGVyIGFueSBzaWJsaW5ncy5cblxuXG4gICAgICB0aHJvdyB4O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBlcnJvcmVkVGFzayhyZXF1ZXN0LCBib3VuZGFyeSwgc2VnbWVudCwgZXJyb3IpIHtcbiAgLy8gUmVwb3J0IHRoZSBlcnJvciB0byBhIGdsb2JhbCBoYW5kbGVyLlxuICB2YXIgZXJyb3JEaWdlc3QgPSBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yKTtcblxuICBpZiAoYm91bmRhcnkgPT09IG51bGwpIHtcbiAgICBmYXRhbEVycm9yKHJlcXVlc3QsIGVycm9yKTtcbiAgfSBlbHNlIHtcbiAgICBib3VuZGFyeS5wZW5kaW5nVGFza3MtLTtcblxuICAgIGlmICghYm91bmRhcnkuZm9yY2VDbGllbnRSZW5kZXIpIHtcbiAgICAgIGJvdW5kYXJ5LmZvcmNlQ2xpZW50UmVuZGVyID0gdHJ1ZTtcbiAgICAgIGJvdW5kYXJ5LmVycm9yRGlnZXN0ID0gZXJyb3JEaWdlc3Q7XG5cbiAgICAgIHtcbiAgICAgICAgY2FwdHVyZUJvdW5kYXJ5RXJyb3JEZXRhaWxzRGV2KGJvdW5kYXJ5LCBlcnJvcik7XG4gICAgICB9IC8vIFJlZ2FyZGxlc3Mgb2Ygd2hhdCBoYXBwZW5zIG5leHQsIHRoaXMgYm91bmRhcnkgd29uJ3QgYmUgZGlzcGxheWVkLFxuICAgICAgLy8gc28gd2UgY2FuIGZsdXNoIGl0LCBpZiB0aGUgcGFyZW50IGFscmVhZHkgZmx1c2hlZC5cblxuXG4gICAgICBpZiAoYm91bmRhcnkucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGEgcHJlZmVyZW5jZSB3aGVyZSBpbiB0aGUgcXVldWUgdGhpcyBnb2VzIHNpbmNlIGl0J3MgbGlrZWx5XG4gICAgICAgIC8vIHRvIGVycm9yIG9uIHRoZSBjbGllbnQgYW55d2F5LiBIb3dldmVyLCBpbnRlbnRpb25hbGx5IGNsaWVudC1yZW5kZXJlZFxuICAgICAgICAvLyBib3VuZGFyaWVzIHNob3VsZCBiZSBmbHVzaGVkIGVhcmxpZXIgc28gdGhhdCB0aGV5IGNhbiBzdGFydCBvbiB0aGUgY2xpZW50LlxuICAgICAgICAvLyBXZSByZXVzZSB0aGUgc2FtZSBxdWV1ZSBmb3IgZXJyb3JzLlxuICAgICAgICByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcy0tO1xuXG4gIGlmIChyZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcyA9PT0gMCkge1xuICAgIHZhciBvbkFsbFJlYWR5ID0gcmVxdWVzdC5vbkFsbFJlYWR5O1xuICAgIG9uQWxsUmVhZHkoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhYm9ydFRhc2tTb2Z0KHRhc2spIHtcbiAgLy8gVGhpcyBhYm9ydHMgdGFzayB3aXRob3V0IGFib3J0aW5nIHRoZSBwYXJlbnQgYm91bmRhcnkgdGhhdCBpdCBibG9ja3MuXG4gIC8vIEl0J3MgdXNlZCBmb3Igd2hlbiB3ZSBkaWRuJ3QgbmVlZCB0aGlzIHRhc2sgdG8gY29tcGxldGUgdGhlIHRyZWUuXG4gIC8vIElmIHRhc2sgd2FzIG5lZWRlZCwgdGhlbiBpdCBzaG91bGQgdXNlIGFib3J0VGFzayBpbnN0ZWFkLlxuICB2YXIgcmVxdWVzdCA9IHRoaXM7XG4gIHZhciBib3VuZGFyeSA9IHRhc2suYmxvY2tlZEJvdW5kYXJ5O1xuICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG4gIHNlZ21lbnQuc3RhdHVzID0gQUJPUlRFRDtcbiAgZmluaXNoZWRUYXNrKHJlcXVlc3QsIGJvdW5kYXJ5LCBzZWdtZW50KTtcbn1cblxuZnVuY3Rpb24gYWJvcnRUYXNrKHRhc2ssIHJlcXVlc3QsIHJlYXNvbikge1xuICAvLyBUaGlzIGFib3J0cyB0aGUgdGFzayBhbmQgYWJvcnRzIHRoZSBwYXJlbnQgdGhhdCBpdCBibG9ja3MsIHB1dHRpbmcgaXQgaW50b1xuICAvLyBjbGllbnQgcmVuZGVyZWQgbW9kZS5cbiAgdmFyIGJvdW5kYXJ5ID0gdGFzay5ibG9ja2VkQm91bmRhcnk7XG4gIHZhciBzZWdtZW50ID0gdGFzay5ibG9ja2VkU2VnbWVudDtcbiAgc2VnbWVudC5zdGF0dXMgPSBBQk9SVEVEO1xuXG4gIGlmIChib3VuZGFyeSA9PT0gbnVsbCkge1xuICAgIHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzLS07IC8vIFdlIGRpZG4ndCBjb21wbGV0ZSB0aGUgcm9vdCBzbyB3ZSBoYXZlIG5vdGhpbmcgdG8gc2hvdy4gV2UgY2FuIGNsb3NlXG4gICAgLy8gdGhlIHJlcXVlc3Q7XG5cbiAgICBpZiAocmVxdWVzdC5zdGF0dXMgIT09IENMT1NFRCkge1xuICAgICAgcmVxdWVzdC5zdGF0dXMgPSBDTE9TRUQ7XG5cbiAgICAgIGlmIChyZXF1ZXN0LmRlc3RpbmF0aW9uICE9PSBudWxsKSB7XG4gICAgICAgIGNsb3NlKHJlcXVlc3QuZGVzdGluYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBib3VuZGFyeS5wZW5kaW5nVGFza3MtLTtcblxuICAgIGlmICghYm91bmRhcnkuZm9yY2VDbGllbnRSZW5kZXIpIHtcbiAgICAgIGJvdW5kYXJ5LmZvcmNlQ2xpZW50UmVuZGVyID0gdHJ1ZTtcblxuICAgICAgdmFyIF9lcnJvciA9IHJlYXNvbiA9PT0gdW5kZWZpbmVkID8gbmV3IEVycm9yKCdUaGUgcmVuZGVyIHdhcyBhYm9ydGVkIGJ5IHRoZSBzZXJ2ZXIgd2l0aG91dCBhIHJlYXNvbi4nKSA6IHJlYXNvbjtcblxuICAgICAgYm91bmRhcnkuZXJyb3JEaWdlc3QgPSByZXF1ZXN0Lm9uRXJyb3IoX2Vycm9yKTtcblxuICAgICAge1xuICAgICAgICB2YXIgZXJyb3JQcmVmaXggPSAnVGhlIHNlcnZlciBkaWQgbm90IGZpbmlzaCB0aGlzIFN1c3BlbnNlIGJvdW5kYXJ5OiAnO1xuXG4gICAgICAgIGlmIChfZXJyb3IgJiYgdHlwZW9mIF9lcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIF9lcnJvciA9IGVycm9yUHJlZml4ICsgX2Vycm9yLm1lc3NhZ2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgICAgICAgX2Vycm9yID0gZXJyb3JQcmVmaXggKyBTdHJpbmcoX2Vycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmV2aW91c1Rhc2tJbkRldiA9IGN1cnJlbnRUYXNrSW5ERVY7XG4gICAgICAgIGN1cnJlbnRUYXNrSW5ERVYgPSB0YXNrO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2FwdHVyZUJvdW5kYXJ5RXJyb3JEZXRhaWxzRGV2KGJvdW5kYXJ5LCBfZXJyb3IpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGN1cnJlbnRUYXNrSW5ERVYgPSBwcmV2aW91c1Rhc2tJbkRldjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYm91bmRhcnkucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICByZXF1ZXN0LmNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KTtcbiAgICAgIH1cbiAgICB9IC8vIElmIHRoaXMgYm91bmRhcnkgd2FzIHN0aWxsIHBlbmRpbmcgdGhlbiB3ZSBoYXZlbid0IGFscmVhZHkgY2FuY2VsbGVkIGl0cyBmYWxsYmFja3MuXG4gICAgLy8gV2UnbGwgbmVlZCB0byBhYm9ydCB0aGUgZmFsbGJhY2tzLCB3aGljaCB3aWxsIGFsc28gZXJyb3IgdGhhdCBwYXJlbnQgYm91bmRhcnkuXG5cblxuICAgIGJvdW5kYXJ5LmZhbGxiYWNrQWJvcnRhYmxlVGFza3MuZm9yRWFjaChmdW5jdGlvbiAoZmFsbGJhY2tUYXNrKSB7XG4gICAgICByZXR1cm4gYWJvcnRUYXNrKGZhbGxiYWNrVGFzaywgcmVxdWVzdCwgcmVhc29uKTtcbiAgICB9KTtcbiAgICBib3VuZGFyeS5mYWxsYmFja0Fib3J0YWJsZVRhc2tzLmNsZWFyKCk7XG4gICAgcmVxdWVzdC5hbGxQZW5kaW5nVGFza3MtLTtcblxuICAgIGlmIChyZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcyA9PT0gMCkge1xuICAgICAgdmFyIG9uQWxsUmVhZHkgPSByZXF1ZXN0Lm9uQWxsUmVhZHk7XG4gICAgICBvbkFsbFJlYWR5KCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHF1ZXVlQ29tcGxldGVkU2VnbWVudChib3VuZGFyeSwgc2VnbWVudCkge1xuICBpZiAoc2VnbWVudC5jaHVua3MubGVuZ3RoID09PSAwICYmIHNlZ21lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIHNlZ21lbnQuY2hpbGRyZW5bMF0uYm91bmRhcnkgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIGFuIGVtcHR5IHNlZ21lbnQuIFRoZXJlJ3Mgbm90aGluZyB0byB3cml0ZSwgc28gd2UgY2FuIGluc3RlYWQgdHJhbnNmZXIgdGhlIElEXG4gICAgLy8gdG8gdGhlIGNoaWxkLiBUaGF0IHdheSBhbnkgZXhpc3RpbmcgcmVmZXJlbmNlcyBwb2ludCB0byB0aGUgY2hpbGQuXG4gICAgdmFyIGNoaWxkU2VnbWVudCA9IHNlZ21lbnQuY2hpbGRyZW5bMF07XG4gICAgY2hpbGRTZWdtZW50LmlkID0gc2VnbWVudC5pZDtcbiAgICBjaGlsZFNlZ21lbnQucGFyZW50Rmx1c2hlZCA9IHRydWU7XG5cbiAgICBpZiAoY2hpbGRTZWdtZW50LnN0YXR1cyA9PT0gQ09NUExFVEVEKSB7XG4gICAgICBxdWV1ZUNvbXBsZXRlZFNlZ21lbnQoYm91bmRhcnksIGNoaWxkU2VnbWVudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjb21wbGV0ZWRTZWdtZW50cyA9IGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzO1xuICAgIGNvbXBsZXRlZFNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoZWRUYXNrKHJlcXVlc3QsIGJvdW5kYXJ5LCBzZWdtZW50KSB7XG4gIGlmIChib3VuZGFyeSA9PT0gbnVsbCkge1xuICAgIGlmIChzZWdtZW50LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgIGlmIChyZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlcmUgY2FuIG9ubHkgYmUgb25lIHJvb3Qgc2VnbWVudC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5jb21wbGV0ZWRSb290U2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgfVxuXG4gICAgcmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzLS07XG5cbiAgICBpZiAocmVxdWVzdC5wZW5kaW5nUm9vdFRhc2tzID09PSAwKSB7XG4gICAgICAvLyBXZSBoYXZlIGNvbXBsZXRlZCB0aGUgc2hlbGwgc28gdGhlIHNoZWxsIGNhbid0IGVycm9yIGFueW1vcmUuXG4gICAgICByZXF1ZXN0Lm9uU2hlbGxFcnJvciA9IG5vb3AkMTtcbiAgICAgIHZhciBvblNoZWxsUmVhZHkgPSByZXF1ZXN0Lm9uU2hlbGxSZWFkeTtcbiAgICAgIG9uU2hlbGxSZWFkeSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBib3VuZGFyeS5wZW5kaW5nVGFza3MtLTtcblxuICAgIGlmIChib3VuZGFyeS5mb3JjZUNsaWVudFJlbmRlcikgOyBlbHNlIGlmIChib3VuZGFyeS5wZW5kaW5nVGFza3MgPT09IDApIHtcbiAgICAgIC8vIFRoaXMgbXVzdCBoYXZlIGJlZW4gdGhlIGxhc3Qgc2VnbWVudCB3ZSB3ZXJlIHdhaXRpbmcgb24uIFRoaXMgYm91bmRhcnkgaXMgbm93IGNvbXBsZXRlLlxuICAgICAgaWYgKHNlZ21lbnQucGFyZW50Rmx1c2hlZCkge1xuICAgICAgICAvLyBPdXIgcGFyZW50IHNlZ21lbnQgYWxyZWFkeSBmbHVzaGVkLCBzbyB3ZSBuZWVkIHRvIHNjaGVkdWxlIHRoaXMgc2VnbWVudCB0byBiZSBlbWl0dGVkLlxuICAgICAgICAvLyBJZiBpdCBpcyBhIHNlZ21lbnQgdGhhdCB3YXMgYWJvcnRlZCwgd2UnbGwgd3JpdGUgb3RoZXIgY29udGVudCBpbnN0ZWFkIHNvIHdlIGRvbid0IG5lZWRcbiAgICAgICAgLy8gdG8gZW1pdCBpdC5cbiAgICAgICAgaWYgKHNlZ21lbnQuc3RhdHVzID09PSBDT01QTEVURUQpIHtcbiAgICAgICAgICBxdWV1ZUNvbXBsZXRlZFNlZ21lbnQoYm91bmRhcnksIHNlZ21lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChib3VuZGFyeS5wYXJlbnRGbHVzaGVkKSB7XG4gICAgICAgIC8vIFRoZSBzZWdtZW50IG1pZ2h0IGJlIHBhcnQgb2YgYSBzZWdtZW50IHRoYXQgZGlkbid0IGZsdXNoIHlldCwgYnV0IGlmIHRoZSBib3VuZGFyeSdzXG4gICAgICAgIC8vIHBhcmVudCBmbHVzaGVkLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIHRoZSBib3VuZGFyeSB0byBiZSBlbWl0dGVkLlxuICAgICAgICByZXF1ZXN0LmNvbXBsZXRlZEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSk7XG4gICAgICB9IC8vIFdlIGNhbiBub3cgY2FuY2VsIGFueSBwZW5kaW5nIHRhc2sgb24gdGhlIGZhbGxiYWNrIHNpbmNlIHdlIHdvbid0IG5lZWQgdG8gc2hvdyBpdCBhbnltb3JlLlxuICAgICAgLy8gVGhpcyBuZWVkcyB0byBoYXBwZW4gYWZ0ZXIgd2UgcmVhZCB0aGUgcGFyZW50Rmx1c2hlZCBmbGFncyBiZWNhdXNlIGFib3J0aW5nIGNhbiBmaW5pc2hcbiAgICAgIC8vIHdvcmsgd2hpY2ggY2FuIHRyaWdnZXIgdXNlciBjb2RlLCB3aGljaCBjYW4gc3RhcnQgZmx1c2hpbmcsIHdoaWNoIGNhbiBjaGFuZ2UgdGhvc2UgZmxhZ3MuXG5cblxuICAgICAgYm91bmRhcnkuZmFsbGJhY2tBYm9ydGFibGVUYXNrcy5mb3JFYWNoKGFib3J0VGFza1NvZnQsIHJlcXVlc3QpO1xuICAgICAgYm91bmRhcnkuZmFsbGJhY2tBYm9ydGFibGVUYXNrcy5jbGVhcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc2VnbWVudC5wYXJlbnRGbHVzaGVkKSB7XG4gICAgICAgIC8vIE91ciBwYXJlbnQgYWxyZWFkeSBmbHVzaGVkLCBzbyB3ZSBuZWVkIHRvIHNjaGVkdWxlIHRoaXMgc2VnbWVudCB0byBiZSBlbWl0dGVkLlxuICAgICAgICAvLyBJZiBpdCBpcyBhIHNlZ21lbnQgdGhhdCB3YXMgYWJvcnRlZCwgd2UnbGwgd3JpdGUgb3RoZXIgY29udGVudCBpbnN0ZWFkIHNvIHdlIGRvbid0IG5lZWRcbiAgICAgICAgLy8gdG8gZW1pdCBpdC5cbiAgICAgICAgaWYgKHNlZ21lbnQuc3RhdHVzID09PSBDT01QTEVURUQpIHtcbiAgICAgICAgICBxdWV1ZUNvbXBsZXRlZFNlZ21lbnQoYm91bmRhcnksIHNlZ21lbnQpO1xuICAgICAgICAgIHZhciBjb21wbGV0ZWRTZWdtZW50cyA9IGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzO1xuXG4gICAgICAgICAgaWYgKGNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgdGltZSBzaW5jZSB3ZSBsYXN0IGZsdXNoZWQgdGhhdCB3ZSBjb21wbGV0ZWQgYW55dGhpbmcuXG4gICAgICAgICAgICAvLyBXZSBjYW4gc2NoZWR1bGUgdGhpcyBib3VuZGFyeSB0byBlbWl0IGl0cyBwYXJ0aWFsbHkgY29tcGxldGVkIHNlZ21lbnRzIGVhcmx5XG4gICAgICAgICAgICAvLyBpbiBjYXNlIHRoZSBwYXJlbnQgaGFzIGFscmVhZHkgYmVlbiBmbHVzaGVkLlxuICAgICAgICAgICAgaWYgKGJvdW5kYXJ5LnBhcmVudEZsdXNoZWQpIHtcbiAgICAgICAgICAgICAgcmVxdWVzdC5wYXJ0aWFsQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcy0tO1xuXG4gIGlmIChyZXF1ZXN0LmFsbFBlbmRpbmdUYXNrcyA9PT0gMCkge1xuICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgY2FsbGVkIGF0IHRoZSB2ZXJ5IGVuZCBzbyB0aGF0IHdlIGNhbiBzeW5jaHJvbm91c2x5IHdyaXRlIHRoZSByZXN1bHRcbiAgICAvLyBpbiB0aGUgY2FsbGJhY2sgaWYgbmVlZGVkLlxuICAgIHZhciBvbkFsbFJlYWR5ID0gcmVxdWVzdC5vbkFsbFJlYWR5O1xuICAgIG9uQWxsUmVhZHkoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyeVRhc2socmVxdWVzdCwgdGFzaykge1xuICB2YXIgc2VnbWVudCA9IHRhc2suYmxvY2tlZFNlZ21lbnQ7XG5cbiAgaWYgKHNlZ21lbnQuc3RhdHVzICE9PSBQRU5ESU5HKSB7XG4gICAgLy8gV2UgY29tcGxldGVkIHRoaXMgYnkgb3RoZXIgbWVhbnMgYmVmb3JlIHdlIGhhZCBhIGNoYW5jZSB0byByZXRyeSBpdC5cbiAgICByZXR1cm47XG4gIH0gLy8gV2UgcmVzdG9yZSB0aGUgY29udGV4dCB0byB3aGF0IGl0IHdhcyB3aGVuIHdlIHN1c3BlbmRlZC5cbiAgLy8gV2UgZG9uJ3QgcmVzdG9yZSBpdCBhZnRlciB3ZSBsZWF2ZSBiZWNhdXNlIGl0J3MgbGlrZWx5IHRoYXQgd2UnbGwgZW5kIHVwXG4gIC8vIG5lZWRpbmcgYSB2ZXJ5IHNpbWlsYXIgY29udGV4dCBzb29uIGFnYWluLlxuXG5cbiAgc3dpdGNoQ29udGV4dCh0YXNrLmNvbnRleHQpO1xuICB2YXIgcHJldlRhc2tJbkRFViA9IG51bGw7XG5cbiAge1xuICAgIHByZXZUYXNrSW5ERVYgPSBjdXJyZW50VGFza0luREVWO1xuICAgIGN1cnJlbnRUYXNrSW5ERVYgPSB0YXNrO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBXZSBjYWxsIHRoZSBkZXN0cnVjdGl2ZSBmb3JtIHRoYXQgbXV0YXRlcyB0aGlzIHRhc2suIFRoYXQgd2F5IGlmIHNvbWV0aGluZ1xuICAgIC8vIHN1c3BlbmRzIGFnYWluLCB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdGFzayBpbnN0ZWFkIG9mIHNwYXduaW5nIGEgbmV3IG9uZS5cbiAgICByZW5kZXJOb2RlRGVzdHJ1Y3RpdmUocmVxdWVzdCwgdGFzaywgdGFzay5ub2RlKTtcbiAgICBwdXNoU2VnbWVudEZpbmFsZShzZWdtZW50LmNodW5rcywgcmVxdWVzdC5yZXNwb25zZVN0YXRlLCBzZWdtZW50Lmxhc3RQdXNoZWRUZXh0LCBzZWdtZW50LnRleHRFbWJlZGRlZCk7XG4gICAgdGFzay5hYm9ydFNldC5kZWxldGUodGFzayk7XG4gICAgc2VnbWVudC5zdGF0dXMgPSBDT01QTEVURUQ7XG4gICAgZmluaXNoZWRUYXNrKHJlcXVlc3QsIHRhc2suYmxvY2tlZEJvdW5kYXJ5LCBzZWdtZW50KTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIHJlc2V0SG9va3NTdGF0ZSgpO1xuXG4gICAgaWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsICYmIHR5cGVvZiB4LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzdXNwZW5kZWQgYWdhaW4sIGxldCdzIHBpY2sgaXQgYmFjayB1cCBsYXRlci5cbiAgICAgIHZhciBwaW5nID0gdGFzay5waW5nO1xuICAgICAgeC50aGVuKHBpbmcsIHBpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXNrLmFib3J0U2V0LmRlbGV0ZSh0YXNrKTtcbiAgICAgIHNlZ21lbnQuc3RhdHVzID0gRVJST1JFRDtcbiAgICAgIGVycm9yZWRUYXNrKHJlcXVlc3QsIHRhc2suYmxvY2tlZEJvdW5kYXJ5LCBzZWdtZW50LCB4KTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAge1xuICAgICAgY3VycmVudFRhc2tJbkRFViA9IHByZXZUYXNrSW5ERVY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1Xb3JrKHJlcXVlc3QpIHtcbiAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSBDTE9TRUQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcHJldkNvbnRleHQgPSBnZXRBY3RpdmVDb250ZXh0KCk7XG4gIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IERpc3BhdGNoZXI7XG4gIHZhciBwcmV2R2V0Q3VycmVudFN0YWNrSW1wbDtcblxuICB7XG4gICAgcHJldkdldEN1cnJlbnRTdGFja0ltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuZ2V0Q3VycmVudFN0YWNrO1xuICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5nZXRDdXJyZW50U3RhY2sgPSBnZXRDdXJyZW50U3RhY2tJbkRFVjtcbiAgfVxuXG4gIHZhciBwcmV2UmVzcG9uc2VTdGF0ZSA9IGN1cnJlbnRSZXNwb25zZVN0YXRlO1xuICBzZXRDdXJyZW50UmVzcG9uc2VTdGF0ZShyZXF1ZXN0LnJlc3BvbnNlU3RhdGUpO1xuXG4gIHRyeSB7XG4gICAgdmFyIHBpbmdlZFRhc2tzID0gcmVxdWVzdC5waW5nZWRUYXNrcztcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBwaW5nZWRUYXNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRhc2sgPSBwaW5nZWRUYXNrc1tpXTtcbiAgICAgIHJldHJ5VGFzayhyZXF1ZXN0LCB0YXNrKTtcbiAgICB9XG5cbiAgICBwaW5nZWRUYXNrcy5zcGxpY2UoMCwgaSk7XG5cbiAgICBpZiAocmVxdWVzdC5kZXN0aW5hdGlvbiAhPT0gbnVsbCkge1xuICAgICAgZmx1c2hDb21wbGV0ZWRRdWV1ZXMocmVxdWVzdCwgcmVxdWVzdC5kZXN0aW5hdGlvbik7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ1JlY292ZXJhYmxlRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICAgIGZhdGFsRXJyb3IocmVxdWVzdCwgZXJyb3IpO1xuICB9IGZpbmFsbHkge1xuICAgIHNldEN1cnJlbnRSZXNwb25zZVN0YXRlKHByZXZSZXNwb25zZVN0YXRlKTtcbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuXG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLmdldEN1cnJlbnRTdGFjayA9IHByZXZHZXRDdXJyZW50U3RhY2tJbXBsO1xuICAgIH1cblxuICAgIGlmIChwcmV2RGlzcGF0Y2hlciA9PT0gRGlzcGF0Y2hlcikge1xuICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IHdlIHdlcmUgaW4gYSByZWVudHJhbnQgd29yayBsb29wLiBUaGlzIGNvdWxkIGhhcHBlblxuICAgICAgLy8gaW4gYSByZW5kZXJlciB0aGF0IHN1cHBvcnRzIHN5bmNocm9ub3VzIHdvcmsgbGlrZSByZW5kZXJUb1N0cmluZyxcbiAgICAgIC8vIHdoZW4gaXQncyBjYWxsZWQgZnJvbSB3aXRoaW4gYW5vdGhlciByZW5kZXJlci5cbiAgICAgIC8vIE5vcm1hbGx5IHdlIGRvbid0IGJvdGhlciBzd2l0Y2hpbmcgdGhlIGNvbnRleHRzIHRvIHRoZWlyIHJvb3QvZGVmYXVsdFxuICAgICAgLy8gdmFsdWVzIHdoZW4gbGVhdmluZyBiZWNhdXNlIHdlJ2xsIGxpa2VseSBuZWVkIHRoZSBzYW1lIG9yIHNpbWlsYXJcbiAgICAgIC8vIGNvbnRleHQgYWdhaW4uIEhvd2V2ZXIsIHdoZW4gd2UncmUgaW5zaWRlIGEgc3luY2hyb25vdXMgbG9vcCBsaWtlIHRoaXNcbiAgICAgIC8vIHdlJ2xsIHRvIHJlc3RvcmUgdGhlIGNvbnRleHQgdG8gd2hhdCBpdCB3YXMgYmVmb3JlIHJldHVybmluZy5cbiAgICAgIHN3aXRjaENvbnRleHQocHJldkNvbnRleHQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFN1YnRyZWUocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQpIHtcbiAgc2VnbWVudC5wYXJlbnRGbHVzaGVkID0gdHJ1ZTtcblxuICBzd2l0Y2ggKHNlZ21lbnQuc3RhdHVzKSB7XG4gICAgY2FzZSBQRU5ESU5HOlxuICAgICAge1xuICAgICAgICAvLyBXZSdyZSBlbWl0dGluZyBhIHBsYWNlaG9sZGVyIGZvciB0aGlzIHNlZ21lbnQgdG8gYmUgZmlsbGVkIGluIGxhdGVyLlxuICAgICAgICAvLyBUaGVyZWZvcmUgd2UnbGwgbmVlZCB0byBhc3NpZ24gaXQgYW4gSUQgLSB0byByZWZlciB0byBpdCBieS5cbiAgICAgICAgdmFyIHNlZ21lbnRJRCA9IHNlZ21lbnQuaWQgPSByZXF1ZXN0Lm5leHRTZWdtZW50SWQrKzsgLy8gV2hlbiB0aGlzIHNlZ21lbnQgZmluYWxseSBjb21wbGV0ZXMgaXQgd29uJ3QgYmUgZW1iZWRkZWQgaW4gdGV4dCBzaW5jZSBpdCB3aWxsIGZsdXNoIHNlcGFyYXRlbHlcblxuICAgICAgICBzZWdtZW50Lmxhc3RQdXNoZWRUZXh0ID0gZmFsc2U7XG4gICAgICAgIHNlZ21lbnQudGV4dEVtYmVkZGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB3cml0ZVBsYWNlaG9sZGVyKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUsIHNlZ21lbnRJRCk7XG4gICAgICB9XG5cbiAgICBjYXNlIENPTVBMRVRFRDpcbiAgICAgIHtcbiAgICAgICAgc2VnbWVudC5zdGF0dXMgPSBGTFVTSEVEO1xuICAgICAgICB2YXIgciA9IHRydWU7XG4gICAgICAgIHZhciBjaHVua3MgPSBzZWdtZW50LmNodW5rcztcbiAgICAgICAgdmFyIGNodW5rSWR4ID0gMDtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gc2VnbWVudC5jaGlsZHJlbjtcblxuICAgICAgICBmb3IgKHZhciBjaGlsZElkeCA9IDA7IGNoaWxkSWR4IDwgY2hpbGRyZW4ubGVuZ3RoOyBjaGlsZElkeCsrKSB7XG4gICAgICAgICAgdmFyIG5leHRDaGlsZCA9IGNoaWxkcmVuW2NoaWxkSWR4XTsgLy8gV3JpdGUgYWxsIHRoZSBjaHVua3MgdXAgdW50aWwgdGhlIG5leHQgY2hpbGQuXG5cbiAgICAgICAgICBmb3IgKDsgY2h1bmtJZHggPCBuZXh0Q2hpbGQuaW5kZXg7IGNodW5rSWR4KyspIHtcbiAgICAgICAgICAgIHdyaXRlQ2h1bmsoZGVzdGluYXRpb24sIGNodW5rc1tjaHVua0lkeF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHIgPSBmbHVzaFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIG5leHRDaGlsZCk7XG4gICAgICAgIH0gLy8gRmluYWxseSBqdXN0IHdyaXRlIGFsbCB0aGUgcmVtYWluaW5nIGNodW5rc1xuXG5cbiAgICAgICAgZm9yICg7IGNodW5rSWR4IDwgY2h1bmtzLmxlbmd0aCAtIDE7IGNodW5rSWR4KyspIHtcbiAgICAgICAgICB3cml0ZUNodW5rKGRlc3RpbmF0aW9uLCBjaHVua3NbY2h1bmtJZHhdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaHVua0lkeCA8IGNodW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICByID0gd3JpdGVDaHVua0FuZFJldHVybihkZXN0aW5hdGlvbiwgY2h1bmtzW2NodW5rSWR4XSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQWJvcnRlZCwgZXJyb3JlZCBvciBhbHJlYWR5IGZsdXNoZWQgYm91bmRhcmllcyBzaG91bGQgbm90IGJlIGZsdXNoZWQgYWdhaW4uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KSB7XG4gIHZhciBib3VuZGFyeSA9IHNlZ21lbnQuYm91bmRhcnk7XG5cbiAgaWYgKGJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgLy8gTm90IGEgc3VzcGVuc2UgYm91bmRhcnkuXG4gICAgcmV0dXJuIGZsdXNoU3VidHJlZShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCk7XG4gIH1cblxuICBib3VuZGFyeS5wYXJlbnRGbHVzaGVkID0gdHJ1ZTsgLy8gVGhpcyBzZWdtZW50IGlzIGEgU3VzcGVuc2UgYm91bmRhcnkuIFdlIG5lZWQgdG8gZGVjaWRlIHdoZXRoZXIgdG9cbiAgLy8gZW1pdCB0aGUgY29udGVudCBvciB0aGUgZmFsbGJhY2sgbm93LlxuXG4gIGlmIChib3VuZGFyeS5mb3JjZUNsaWVudFJlbmRlcikge1xuICAgIC8vIEVtaXQgYSBjbGllbnQgcmVuZGVyZWQgc3VzcGVuc2UgYm91bmRhcnkgd3JhcHBlci5cbiAgICAvLyBXZSBuZXZlciBxdWV1ZSB0aGUgaW5uZXIgYm91bmRhcnkgc28gd2UnbGwgbmV2ZXIgZW1pdCBpdHMgY29udGVudCBvciBwYXJ0aWFsIHNlZ21lbnRzLlxuICAgIHdyaXRlU3RhcnRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlcXVlc3QucmVzcG9uc2VTdGF0ZSwgYm91bmRhcnkuZXJyb3JEaWdlc3QsIGJvdW5kYXJ5LmVycm9yTWVzc2FnZSwgYm91bmRhcnkuZXJyb3JDb21wb25lbnRTdGFjayk7IC8vIEZsdXNoIHRoZSBmYWxsYmFjay5cblxuICAgIGZsdXNoU3VidHJlZShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCk7XG4gICAgcmV0dXJuIHdyaXRlRW5kQ2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUpO1xuICB9IGVsc2UgaWYgKGJvdW5kYXJ5LnBlbmRpbmdUYXNrcyA+IDApIHtcbiAgICAvLyBUaGlzIGJvdW5kYXJ5IGlzIHN0aWxsIGxvYWRpbmcuIEVtaXQgYSBwZW5kaW5nIHN1c3BlbnNlIGJvdW5kYXJ5IHdyYXBwZXIuXG4gICAgLy8gQXNzaWduIGFuIElEIHRvIHJlZmVyIHRvIHRoZSBmdXR1cmUgY29udGVudCBieS5cbiAgICBib3VuZGFyeS5yb290U2VnbWVudElEID0gcmVxdWVzdC5uZXh0U2VnbWVudElkKys7XG5cbiAgICBpZiAoYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gSWYgdGhpcyBpcyBhdCBsZWFzdCBwYXJ0aWFsbHkgY29tcGxldGUsIHdlIGNhbiBxdWV1ZSBpdCB0byBiZSBwYXJ0aWFsbHkgZW1pdHRlZCBlYXJseS5cbiAgICAgIHJlcXVlc3QucGFydGlhbEJvdW5kYXJpZXMucHVzaChib3VuZGFyeSk7XG4gICAgfSAvLy8gVGhpcyBpcyB0aGUgZmlyc3QgdGltZSB3ZSBzaG91bGQgaGF2ZSByZWZlcmVuY2VkIHRoaXMgSUQuXG5cblxuICAgIHZhciBpZCA9IGJvdW5kYXJ5LmlkID0gYXNzaWduU3VzcGVuc2VCb3VuZGFyeUlEKHJlcXVlc3QucmVzcG9uc2VTdGF0ZSk7XG4gICAgd3JpdGVTdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUsIGlkKTsgLy8gRmx1c2ggdGhlIGZhbGxiYWNrLlxuXG4gICAgZmx1c2hTdWJ0cmVlKHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KTtcbiAgICByZXR1cm4gd3JpdGVFbmRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXNwb25zZVN0YXRlKTtcbiAgfSBlbHNlIGlmIChib3VuZGFyeS5ieXRlU2l6ZSA+IHJlcXVlc3QucHJvZ3Jlc3NpdmVDaHVua1NpemUpIHtcbiAgICAvLyBUaGlzIGJvdW5kYXJ5IGlzIGxhcmdlIGFuZCB3aWxsIGJlIGVtaXR0ZWQgc2VwYXJhdGVseSBzbyB0aGF0IHdlIGNhbiBwcm9ncmVzc2l2ZWx5IHNob3dcbiAgICAvLyBvdGhlciBjb250ZW50LiBXZSBhZGQgaXQgdG8gdGhlIHF1ZXVlIGR1cmluZyB0aGUgZmx1c2ggYmVjYXVzZSB3ZSBoYXZlIHRvIGVuc3VyZSB0aGF0XG4gICAgLy8gdGhlIHBhcmVudCBmbHVzaGVzIGZpcnN0IHNvIHRoYXQgdGhlcmUncyBzb21ldGhpbmcgdG8gaW5qZWN0IGl0IGludG8uXG4gICAgLy8gV2UgYWxzbyBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IGl0J3MgZW1pdHRlZCBpbnRvIHRoZSBxdWV1ZSBpbiBhIGRldGVybWluaXN0aWMgc2xvdC5cbiAgICAvLyBJLmUuIHdlIGNhbid0IGluc2VydCBpdCBoZXJlIHdoZW4gaXQgY29tcGxldGVzLlxuICAgIC8vIEFzc2lnbiBhbiBJRCB0byByZWZlciB0byB0aGUgZnV0dXJlIGNvbnRlbnQgYnkuXG4gICAgYm91bmRhcnkucm9vdFNlZ21lbnRJRCA9IHJlcXVlc3QubmV4dFNlZ21lbnRJZCsrO1xuICAgIHJlcXVlc3QuY29tcGxldGVkQm91bmRhcmllcy5wdXNoKGJvdW5kYXJ5KTsgLy8gRW1pdCBhIHBlbmRpbmcgcmVuZGVyZWQgc3VzcGVuc2UgYm91bmRhcnkgd3JhcHBlci5cblxuICAgIHdyaXRlU3RhcnRQZW5kaW5nU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXNwb25zZVN0YXRlLCBib3VuZGFyeS5pZCk7IC8vIEZsdXNoIHRoZSBmYWxsYmFjay5cblxuICAgIGZsdXNoU3VidHJlZShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCk7XG4gICAgcmV0dXJuIHdyaXRlRW5kUGVuZGluZ1N1c3BlbnNlQm91bmRhcnkoZGVzdGluYXRpb24sIHJlcXVlc3QucmVzcG9uc2VTdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgY2FuIGlubGluZSB0aGlzIGJvdW5kYXJ5J3MgY29udGVudCBhcyBhIGNvbXBsZXRlIGJvdW5kYXJ5LlxuICAgIHdyaXRlU3RhcnRDb21wbGV0ZWRTdXNwZW5zZUJvdW5kYXJ5KGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUpO1xuICAgIHZhciBjb21wbGV0ZWRTZWdtZW50cyA9IGJvdW5kYXJ5LmNvbXBsZXRlZFNlZ21lbnRzO1xuXG4gICAgaWYgKGNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIHByZXZpb3VzbHkgdW52aXNpdGVkIGJvdW5kYXJ5IG11c3QgaGF2ZSBleGFjdGx5IG9uZSByb290IHNlZ21lbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRlbnRTZWdtZW50ID0gY29tcGxldGVkU2VnbWVudHNbMF07XG4gICAgZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBjb250ZW50U2VnbWVudCk7XG4gICAgcmV0dXJuIHdyaXRlRW5kQ29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeShkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXNwb25zZVN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaENsaWVudFJlbmRlcmVkQm91bmRhcnkocmVxdWVzdCwgZGVzdGluYXRpb24sIGJvdW5kYXJ5KSB7XG4gIHJldHVybiB3cml0ZUNsaWVudFJlbmRlckJvdW5kYXJ5SW5zdHJ1Y3Rpb24oZGVzdGluYXRpb24sIHJlcXVlc3QucmVzcG9uc2VTdGF0ZSwgYm91bmRhcnkuaWQsIGJvdW5kYXJ5LmVycm9yRGlnZXN0LCBib3VuZGFyeS5lcnJvck1lc3NhZ2UsIGJvdW5kYXJ5LmVycm9yQ29tcG9uZW50U3RhY2spO1xufVxuXG5mdW5jdGlvbiBmbHVzaFNlZ21lbnRDb250YWluZXIocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQpIHtcbiAgd3JpdGVTdGFydFNlZ21lbnQoZGVzdGluYXRpb24sIHJlcXVlc3QucmVzcG9uc2VTdGF0ZSwgc2VnbWVudC5mb3JtYXRDb250ZXh0LCBzZWdtZW50LmlkKTtcbiAgZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBzZWdtZW50KTtcbiAgcmV0dXJuIHdyaXRlRW5kU2VnbWVudChkZXN0aW5hdGlvbiwgc2VnbWVudC5mb3JtYXRDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gZmx1c2hDb21wbGV0ZWRCb3VuZGFyeShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgYm91bmRhcnkpIHtcbiAgdmFyIGNvbXBsZXRlZFNlZ21lbnRzID0gYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHM7XG4gIHZhciBpID0gMDtcblxuICBmb3IgKDsgaSA8IGNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNlZ21lbnQgPSBjb21wbGV0ZWRTZWdtZW50c1tpXTtcbiAgICBmbHVzaFBhcnRpYWxseUNvbXBsZXRlZFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIGJvdW5kYXJ5LCBzZWdtZW50KTtcbiAgfVxuXG4gIGNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aCA9IDA7XG4gIHJldHVybiB3cml0ZUNvbXBsZXRlZEJvdW5kYXJ5SW5zdHJ1Y3Rpb24oZGVzdGluYXRpb24sIHJlcXVlc3QucmVzcG9uc2VTdGF0ZSwgYm91bmRhcnkuaWQsIGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQpO1xufVxuXG5mdW5jdGlvbiBmbHVzaFBhcnRpYWxCb3VuZGFyeShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgYm91bmRhcnkpIHtcbiAgdmFyIGNvbXBsZXRlZFNlZ21lbnRzID0gYm91bmRhcnkuY29tcGxldGVkU2VnbWVudHM7XG4gIHZhciBpID0gMDtcblxuICBmb3IgKDsgaSA8IGNvbXBsZXRlZFNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNlZ21lbnQgPSBjb21wbGV0ZWRTZWdtZW50c1tpXTtcblxuICAgIGlmICghZmx1c2hQYXJ0aWFsbHlDb21wbGV0ZWRTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBib3VuZGFyeSwgc2VnbWVudCkpIHtcbiAgICAgIGkrKztcbiAgICAgIGNvbXBsZXRlZFNlZ21lbnRzLnNwbGljZSgwLCBpKTsgLy8gT25seSB3cml0ZSBhcyBtdWNoIGFzIHRoZSBidWZmZXIgd2FudHMuIFNvbWV0aGluZyBoaWdoZXIgcHJpb3JpdHlcbiAgICAgIC8vIG1pZ2h0IHdhbnQgdG8gd3JpdGUgbGF0ZXIuXG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBjb21wbGV0ZWRTZWdtZW50cy5zcGxpY2UoMCwgaSk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmbHVzaFBhcnRpYWxseUNvbXBsZXRlZFNlZ21lbnQocmVxdWVzdCwgZGVzdGluYXRpb24sIGJvdW5kYXJ5LCBzZWdtZW50KSB7XG4gIGlmIChzZWdtZW50LnN0YXR1cyA9PT0gRkxVU0hFRCkge1xuICAgIC8vIFdlJ3ZlIGFscmVhZHkgZmx1c2hlZCB0aGlzIGlubGluZS5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBzZWdtZW50SUQgPSBzZWdtZW50LmlkO1xuXG4gIGlmIChzZWdtZW50SUQgPT09IC0xKSB7XG4gICAgLy8gVGhpcyBzZWdtZW50IHdhc24ndCBwcmV2aW91c2x5IHJlZmVycmVkIHRvLiBUaGlzIGhhcHBlbnMgYXQgdGhlIHJvb3Qgb2ZcbiAgICAvLyBhIGJvdW5kYXJ5LiBXZSBtYWtlIGtpbmQgb2YgYSBsZWFwIGhlcmUgYW5kIGFzc3VtZSB0aGlzIGlzIHRoZSByb290LlxuICAgIHZhciByb290U2VnbWVudElEID0gc2VnbWVudC5pZCA9IGJvdW5kYXJ5LnJvb3RTZWdtZW50SUQ7XG5cbiAgICBpZiAocm9vdFNlZ21lbnRJRCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQSByb290IHNlZ21lbnQgSUQgbXVzdCBoYXZlIGJlZW4gYXNzaWduZWQgYnkgbm93LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH1cblxuICAgIHJldHVybiBmbHVzaFNlZ21lbnRDb250YWluZXIocmVxdWVzdCwgZGVzdGluYXRpb24sIHNlZ21lbnQpO1xuICB9IGVsc2Uge1xuICAgIGZsdXNoU2VnbWVudENvbnRhaW5lcihyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgc2VnbWVudCk7XG4gICAgcmV0dXJuIHdyaXRlQ29tcGxldGVkU2VnbWVudEluc3RydWN0aW9uKGRlc3RpbmF0aW9uLCByZXF1ZXN0LnJlc3BvbnNlU3RhdGUsIHNlZ21lbnRJRCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hDb21wbGV0ZWRRdWV1ZXMocmVxdWVzdCwgZGVzdGluYXRpb24pIHtcbiAgYmVnaW5Xcml0aW5nKCk7XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGUgc3RydWN0dXJlIG9mIHRoaXMgaXMgdG8gZ28gdGhyb3VnaCBlYWNoIHF1ZXVlIG9uZSBieSBvbmUgYW5kIHdyaXRlXG4gICAgLy8gdW50aWwgdGhlIHNpbmsgdGVsbHMgdXMgdG8gc3RvcC4gV2hlbiB3ZSBzaG91bGQgc3RvcCwgd2Ugc3RpbGwgZmluaXNoIHdyaXRpbmdcbiAgICAvLyB0aGF0IGl0ZW0gZnVsbHkgYW5kIHRoZW4geWllbGQuIEF0IHRoYXQgcG9pbnQgd2UgcmVtb3ZlIHRoZSBhbHJlYWR5IGNvbXBsZXRlZFxuICAgIC8vIGl0ZW1zIHVwIHVudGlsIHRoZSBwb2ludCB3ZSBjb21wbGV0ZWQgdGhlbS5cbiAgICAvLyBUT0RPOiBFbWl0IHByZWxvYWRpbmcuXG4gICAgLy8gVE9ETzogSXQncyBraW5kIG9mIHVuZm9ydHVuYXRlIHRvIGtlZXAgY2hlY2tpbmcgdGhpcyBhcnJheSBhZnRlciB3ZSd2ZSBhbHJlYWR5XG4gICAgLy8gZW1pdHRlZCB0aGUgcm9vdC5cbiAgICB2YXIgY29tcGxldGVkUm9vdFNlZ21lbnQgPSByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50O1xuXG4gICAgaWYgKGNvbXBsZXRlZFJvb3RTZWdtZW50ICE9PSBudWxsICYmIHJlcXVlc3QucGVuZGluZ1Jvb3RUYXNrcyA9PT0gMCkge1xuICAgICAgZmx1c2hTZWdtZW50KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBjb21wbGV0ZWRSb290U2VnbWVudCk7XG4gICAgICByZXF1ZXN0LmNvbXBsZXRlZFJvb3RTZWdtZW50ID0gbnVsbDtcbiAgICAgIHdyaXRlQ29tcGxldGVkUm9vdChkZXN0aW5hdGlvbiwgcmVxdWVzdC5yZXNwb25zZVN0YXRlKTtcbiAgICB9IC8vIFdlIGVtaXQgY2xpZW50IHJlbmRlcmluZyBpbnN0cnVjdGlvbnMgZm9yIGFscmVhZHkgZW1pdHRlZCBib3VuZGFyaWVzIGZpcnN0LlxuICAgIC8vIFRoaXMgaXMgc28gdGhhdCB3ZSBjYW4gc2lnbmFsIHRvIHRoZSBjbGllbnQgdG8gc3RhcnQgY2xpZW50IHJlbmRlcmluZyB0aGVtIGFzXG4gICAgLy8gc29vbiBhcyBwb3NzaWJsZS5cblxuXG4gICAgdmFyIGNsaWVudFJlbmRlcmVkQm91bmRhcmllcyA9IHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzO1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGJvdW5kYXJ5ID0gY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzW2ldO1xuXG4gICAgICBpZiAoIWZsdXNoQ2xpZW50UmVuZGVyZWRCb3VuZGFyeShyZXF1ZXN0LCBkZXN0aW5hdGlvbiwgYm91bmRhcnkpKSB7XG4gICAgICAgIHJlcXVlc3QuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICBpKys7XG4gICAgICAgIGNsaWVudFJlbmRlcmVkQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpOyAvLyBOZXh0IHdlIGVtaXQgYW55IGNvbXBsZXRlIGJvdW5kYXJpZXMuIEl0J3MgYmV0dGVyIHRvIGZhdm9yIGJvdW5kYXJpZXNcbiAgICAvLyB0aGF0IGFyZSBjb21wbGV0ZWx5IGRvbmUgc2luY2Ugd2UgY2FuIGFjdHVhbGx5IHNob3cgdGhlbSwgdGhhbiBpdCBpcyB0byBlbWl0XG4gICAgLy8gYW55IGluZGl2aWR1YWwgc2VnbWVudHMgZnJvbSBhIHBhcnRpYWxseSBjb21wbGV0ZSBib3VuZGFyeS5cblxuICAgIHZhciBjb21wbGV0ZWRCb3VuZGFyaWVzID0gcmVxdWVzdC5jb21wbGV0ZWRCb3VuZGFyaWVzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGNvbXBsZXRlZEJvdW5kYXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfYm91bmRhcnkgPSBjb21wbGV0ZWRCb3VuZGFyaWVzW2ldO1xuXG4gICAgICBpZiAoIWZsdXNoQ29tcGxldGVkQm91bmRhcnkocmVxdWVzdCwgZGVzdGluYXRpb24sIF9ib3VuZGFyeSkpIHtcbiAgICAgICAgcmVxdWVzdC5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgIGkrKztcbiAgICAgICAgY29tcGxldGVkQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wbGV0ZWRCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTsgLy8gQWxsb3cgYW55dGhpbmcgd3JpdHRlbiBzbyBmYXIgdG8gZmx1c2ggdG8gdGhlIHVuZGVybHlpbmcgc2luayBiZWZvcmVcbiAgICAvLyB3ZSBjb250aW51ZSB3aXRoIGxvd2VyIHByaW9yaXRpZXMuXG5cbiAgICBjb21wbGV0ZVdyaXRpbmcoZGVzdGluYXRpb24pO1xuICAgIGJlZ2luV3JpdGluZyhkZXN0aW5hdGlvbik7IC8vIFRPRE86IEhlcmUgd2UnbGwgZW1pdCBkYXRhIHVzZWQgYnkgaHlkcmF0aW9uLlxuICAgIC8vIE5leHQgd2UgZW1pdCBhbnkgc2VnbWVudHMgb2YgYW55IGJvdW5kYXJpZXMgdGhhdCBhcmUgcGFydGlhbGx5IGNvbXBsZXRlXG4gICAgLy8gYnV0IG5vdCBkZWVwbHkgY29tcGxldGUuXG5cbiAgICB2YXIgcGFydGlhbEJvdW5kYXJpZXMgPSByZXF1ZXN0LnBhcnRpYWxCb3VuZGFyaWVzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHBhcnRpYWxCb3VuZGFyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX2JvdW5kYXJ5MiA9IHBhcnRpYWxCb3VuZGFyaWVzW2ldO1xuXG4gICAgICBpZiAoIWZsdXNoUGFydGlhbEJvdW5kYXJ5KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBfYm91bmRhcnkyKSkge1xuICAgICAgICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgICAgaSsrO1xuICAgICAgICBwYXJ0aWFsQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJ0aWFsQm91bmRhcmllcy5zcGxpY2UoMCwgaSk7IC8vIE5leHQgd2UgY2hlY2sgdGhlIGNvbXBsZXRlZCBib3VuZGFyaWVzIGFnYWluLiBUaGlzIG1heSBoYXZlIGhhZFxuICAgIC8vIGJvdW5kYXJpZXMgYWRkZWQgdG8gaXQgaW4gY2FzZSB0aGV5IHdlcmUgdG9vIGxhcmdlZCB0byBiZSBpbmxpbmVkLlxuICAgIC8vIE5ldyBvbmVzIG1pZ2h0IGJlIGFkZGVkIGluIHRoaXMgbG9vcC5cblxuICAgIHZhciBsYXJnZUJvdW5kYXJpZXMgPSByZXF1ZXN0LmNvbXBsZXRlZEJvdW5kYXJpZXM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGFyZ2VCb3VuZGFyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX2JvdW5kYXJ5MyA9IGxhcmdlQm91bmRhcmllc1tpXTtcblxuICAgICAgaWYgKCFmbHVzaENvbXBsZXRlZEJvdW5kYXJ5KHJlcXVlc3QsIGRlc3RpbmF0aW9uLCBfYm91bmRhcnkzKSkge1xuICAgICAgICByZXF1ZXN0LmRlc3RpbmF0aW9uID0gbnVsbDtcbiAgICAgICAgaSsrO1xuICAgICAgICBsYXJnZUJvdW5kYXJpZXMuc3BsaWNlKDAsIGkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGFyZ2VCb3VuZGFyaWVzLnNwbGljZSgwLCBpKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjb21wbGV0ZVdyaXRpbmcoZGVzdGluYXRpb24pO1xuICAgIGZsdXNoQnVmZmVyZWQoZGVzdGluYXRpb24pO1xuXG4gICAgaWYgKHJlcXVlc3QuYWxsUGVuZGluZ1Rhc2tzID09PSAwICYmIHJlcXVlc3QucGluZ2VkVGFza3MubGVuZ3RoID09PSAwICYmIHJlcXVlc3QuY2xpZW50UmVuZGVyZWRCb3VuZGFyaWVzLmxlbmd0aCA9PT0gMCAmJiByZXF1ZXN0LmNvbXBsZXRlZEJvdW5kYXJpZXMubGVuZ3RoID09PSAwIC8vIFdlIGRvbid0IG5lZWQgdG8gY2hlY2sgYW55IHBhcnRpYWxseSBjb21wbGV0ZWQgc2VnbWVudHMgYmVjYXVzZVxuICAgIC8vIGVpdGhlciB0aGV5IGhhdmUgcGVuZGluZyB0YXNrIG9yIHRoZXkncmUgY29tcGxldGUuXG4gICAgKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAocmVxdWVzdC5hYm9ydGFibGVUYXNrcy5zaXplICE9PSAwKSB7XG4gICAgICAgICAgICBlcnJvcignVGhlcmUgd2FzIHN0aWxsIGFib3J0YWJsZSB0YXNrIGF0IHRoZSByb290IHdoZW4gd2UgY2xvc2VkLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBXZSdyZSBkb25lLlxuXG5cbiAgICAgICAgY2xvc2UoZGVzdGluYXRpb24pO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V29yayhyZXF1ZXN0KSB7XG4gIHNjaGVkdWxlV29yayhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBlcmZvcm1Xb3JrKHJlcXVlc3QpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHN0YXJ0Rmxvd2luZyhyZXF1ZXN0LCBkZXN0aW5hdGlvbikge1xuICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IENMT1NJTkcpIHtcbiAgICByZXF1ZXN0LnN0YXR1cyA9IENMT1NFRDtcbiAgICBjbG9zZVdpdGhFcnJvcihkZXN0aW5hdGlvbiwgcmVxdWVzdC5mYXRhbEVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IENMT1NFRCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChyZXF1ZXN0LmRlc3RpbmF0aW9uICE9PSBudWxsKSB7XG4gICAgLy8gV2UncmUgYWxyZWFkeSBmbG93aW5nLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHJlcXVlc3QuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcblxuICB0cnkge1xuICAgIGZsdXNoQ29tcGxldGVkUXVldWVzKHJlcXVlc3QsIGRlc3RpbmF0aW9uKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yKTtcbiAgICBmYXRhbEVycm9yKHJlcXVlc3QsIGVycm9yKTtcbiAgfVxufSAvLyBUaGlzIGlzIGNhbGxlZCB0byBlYXJseSB0ZXJtaW5hdGUgYSByZXF1ZXN0LiBJdCBwdXRzIGFsbCBwZW5kaW5nIGJvdW5kYXJpZXMgaW4gY2xpZW50IHJlbmRlcmVkIHN0YXRlLlxuXG5mdW5jdGlvbiBhYm9ydChyZXF1ZXN0LCByZWFzb24pIHtcbiAgdHJ5IHtcbiAgICB2YXIgYWJvcnRhYmxlVGFza3MgPSByZXF1ZXN0LmFib3J0YWJsZVRhc2tzO1xuICAgIGFib3J0YWJsZVRhc2tzLmZvckVhY2goZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgIHJldHVybiBhYm9ydFRhc2sodGFzaywgcmVxdWVzdCwgcmVhc29uKTtcbiAgICB9KTtcbiAgICBhYm9ydGFibGVUYXNrcy5jbGVhcigpO1xuXG4gICAgaWYgKHJlcXVlc3QuZGVzdGluYXRpb24gIT09IG51bGwpIHtcbiAgICAgIGZsdXNoQ29tcGxldGVkUXVldWVzKHJlcXVlc3QsIHJlcXVlc3QuZGVzdGluYXRpb24pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2dSZWNvdmVyYWJsZUVycm9yKHJlcXVlc3QsIGVycm9yKTtcbiAgICBmYXRhbEVycm9yKHJlcXVlc3QsIGVycm9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEcmFpbkhhbmRsZXIoZGVzdGluYXRpb24sIHJlcXVlc3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc3RhcnRGbG93aW5nKHJlcXVlc3QsIGRlc3RpbmF0aW9uKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQWJvcnRIYW5kbGVyKHJlcXVlc3QsIHJlYXNvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhYm9ydChyZXF1ZXN0LCByZWFzb24pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSZXF1ZXN0SW1wbChjaGlsZHJlbiwgb3B0aW9ucykge1xuICByZXR1cm4gY3JlYXRlUmVxdWVzdChjaGlsZHJlbiwgY3JlYXRlUmVzcG9uc2VTdGF0ZShvcHRpb25zID8gb3B0aW9ucy5pZGVudGlmaWVyUHJlZml4IDogdW5kZWZpbmVkLCBvcHRpb25zID8gb3B0aW9ucy5ub25jZSA6IHVuZGVmaW5lZCwgb3B0aW9ucyA/IG9wdGlvbnMuYm9vdHN0cmFwU2NyaXB0Q29udGVudCA6IHVuZGVmaW5lZCwgb3B0aW9ucyA/IG9wdGlvbnMuYm9vdHN0cmFwU2NyaXB0cyA6IHVuZGVmaW5lZCwgb3B0aW9ucyA/IG9wdGlvbnMuYm9vdHN0cmFwTW9kdWxlcyA6IHVuZGVmaW5lZCksIGNyZWF0ZVJvb3RGb3JtYXRDb250ZXh0KG9wdGlvbnMgPyBvcHRpb25zLm5hbWVzcGFjZVVSSSA6IHVuZGVmaW5lZCksIG9wdGlvbnMgPyBvcHRpb25zLnByb2dyZXNzaXZlQ2h1bmtTaXplIDogdW5kZWZpbmVkLCBvcHRpb25zID8gb3B0aW9ucy5vbkVycm9yIDogdW5kZWZpbmVkLCBvcHRpb25zID8gb3B0aW9ucy5vbkFsbFJlYWR5IDogdW5kZWZpbmVkLCBvcHRpb25zID8gb3B0aW9ucy5vblNoZWxsUmVhZHkgOiB1bmRlZmluZWQsIG9wdGlvbnMgPyBvcHRpb25zLm9uU2hlbGxFcnJvciA6IHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyVG9QaXBlYWJsZVN0cmVhbShjaGlsZHJlbiwgb3B0aW9ucykge1xuICB2YXIgcmVxdWVzdCA9IGNyZWF0ZVJlcXVlc3RJbXBsKGNoaWxkcmVuLCBvcHRpb25zKTtcbiAgdmFyIGhhc1N0YXJ0ZWRGbG93aW5nID0gZmFsc2U7XG4gIHN0YXJ0V29yayhyZXF1ZXN0KTtcbiAgcmV0dXJuIHtcbiAgICBwaXBlOiBmdW5jdGlvbiAoZGVzdGluYXRpb24pIHtcbiAgICAgIGlmIChoYXNTdGFydGVkRmxvd2luZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0IGN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIHBpcGluZyB0byBvbmUgd3JpdGFibGUgc3RyZWFtLicpO1xuICAgICAgfVxuXG4gICAgICBoYXNTdGFydGVkRmxvd2luZyA9IHRydWU7XG4gICAgICBzdGFydEZsb3dpbmcocmVxdWVzdCwgZGVzdGluYXRpb24pO1xuICAgICAgZGVzdGluYXRpb24ub24oJ2RyYWluJywgY3JlYXRlRHJhaW5IYW5kbGVyKGRlc3RpbmF0aW9uLCByZXF1ZXN0KSk7XG4gICAgICBkZXN0aW5hdGlvbi5vbignZXJyb3InLCBjcmVhdGVBYm9ydEhhbmRsZXIocmVxdWVzdCwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgIG5ldyBFcnJvcignVGhlIGRlc3RpbmF0aW9uIHN0cmVhbSBlcnJvcmVkIHdoaWxlIHdyaXRpbmcgZGF0YS4nKSkpO1xuICAgICAgZGVzdGluYXRpb24ub24oJ2Nsb3NlJywgY3JlYXRlQWJvcnRIYW5kbGVyKHJlcXVlc3QsIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICBuZXcgRXJyb3IoJ1RoZSBkZXN0aW5hdGlvbiBzdHJlYW0gY2xvc2VkIGVhcmx5LicpKSk7XG4gICAgICByZXR1cm4gZGVzdGluYXRpb247XG4gICAgfSxcbiAgICBhYm9ydDogZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgYWJvcnQocmVxdWVzdCwgcmVhc29uKTtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydHMucmVuZGVyVG9QaXBlYWJsZVN0cmVhbSA9IHJlbmRlclRvUGlwZWFibGVTdHJlYW07XG5leHBvcnRzLnZlcnNpb24gPSBSZWFjdFZlcnNpb247XG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIlJlYWN0IiwicmVxdWlyZSIsInV0aWwiLCJSZWFjdFZlcnNpb24iLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwid2FybiIsImZvcm1hdCIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwicHJpbnRXYXJuaW5nIiwiZXJyb3IiLCJfbGVuMiIsIl9rZXkyIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsInNjaGVkdWxlV29yayIsImNhbGxiYWNrIiwic2V0SW1tZWRpYXRlIiwiZmx1c2hCdWZmZXJlZCIsImRlc3RpbmF0aW9uIiwiZmx1c2giLCJWSUVXX1NJWkUiLCJjdXJyZW50VmlldyIsIndyaXR0ZW5CeXRlcyIsImRlc3RpbmF0aW9uSGFzQ2FwYWNpdHkiLCJiZWdpbldyaXRpbmciLCJVaW50OEFycmF5Iiwid3JpdGVTdHJpbmdDaHVuayIsInN0cmluZ0NodW5rIiwid3JpdGVUb0Rlc3RpbmF0aW9uIiwic3ViYXJyYXkiLCJ0ZXh0RW5jb2RlciIsImVuY29kZSIsInRhcmdldCIsIl90ZXh0RW5jb2RlciRlbmNvZGVJbiIsImVuY29kZUludG8iLCJyZWFkIiwid3JpdHRlbiIsInNsaWNlIiwid3JpdGVWaWV3Q2h1bmsiLCJjaHVuayIsImJ5dGVMZW5ndGgiLCJieXRlc1RvV3JpdGUiLCJhbGxvd2FibGVCeXRlcyIsInNldCIsIndyaXRlQ2h1bmsiLCJ2aWV3IiwiY3VycmVudEhhc0NhcGFjaXR5Iiwid3JpdGUiLCJ3cml0ZUNodW5rQW5kUmV0dXJuIiwiY29tcGxldGVXcml0aW5nIiwiY2xvc2UiLCJlbmQiLCJUZXh0RW5jb2RlciIsInN0cmluZ1RvQ2h1bmsiLCJjb250ZW50Iiwic3RyaW5nVG9QcmVjb21wdXRlZENodW5rIiwiY2xvc2VXaXRoRXJyb3IiLCJkZXN0cm95IiwidHlwZU5hbWUiLCJ2YWx1ZSIsImhhc1RvU3RyaW5nVGFnIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ0eXBlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwid2lsbENvZXJjaW9uVGhyb3ciLCJ0ZXN0U3RyaW5nQ29lcmNpb24iLCJlIiwiY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbiIsImF0dHJpYnV0ZU5hbWUiLCJjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24iLCJwcm9wTmFtZSIsImNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uIiwiaGFzT3duUHJvcGVydHkiLCJPYmplY3QiLCJSRVNFUlZFRCIsIlNUUklORyIsIkJPT0xFQU5JU0hfU1RSSU5HIiwiQk9PTEVBTiIsIk9WRVJMT0FERURfQk9PTEVBTiIsIk5VTUVSSUMiLCJQT1NJVElWRV9OVU1FUklDIiwiQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiIsIkFUVFJJQlVURV9OQU1FX0NIQVIiLCJWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCIsIlJlZ0V4cCIsImlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUiLCJ2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUiLCJpc0F0dHJpYnV0ZU5hbWVTYWZlIiwidGVzdCIsInNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nIiwicHJvcGVydHlJbmZvIiwiaXNDdXN0b21Db21wb25lbnRUYWciLCJhY2NlcHRzQm9vbGVhbnMiLCJwcmVmaXgiLCJ0b0xvd2VyQ2FzZSIsImdldFByb3BlcnR5SW5mbyIsInByb3BlcnRpZXMiLCJQcm9wZXJ0eUluZm9SZWNvcmQiLCJtdXN0VXNlUHJvcGVydHkiLCJhdHRyaWJ1dGVOYW1lc3BhY2UiLCJzYW5pdGl6ZVVSTCIsInJlbW92ZUVtcHR5U3RyaW5nIiwicHJvcGVydHlOYW1lIiwicmVzZXJ2ZWRQcm9wcyIsImZvckVhY2giLCJfcmVmIiwiQ0FNRUxJWkUiLCJjYXBpdGFsaXplIiwidG9rZW4iLCJ0b1VwcGVyQ2FzZSIsInJlcGxhY2UiLCJ4bGlua0hyZWYiLCJpc1VuaXRsZXNzTnVtYmVyIiwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQiLCJhc3BlY3RSYXRpbyIsImJvcmRlckltYWdlT3V0c2V0IiwiYm9yZGVySW1hZ2VTbGljZSIsImJvcmRlckltYWdlV2lkdGgiLCJib3hGbGV4IiwiYm94RmxleEdyb3VwIiwiYm94T3JkaW5hbEdyb3VwIiwiY29sdW1uQ291bnQiLCJjb2x1bW5zIiwiZmxleCIsImZsZXhHcm93IiwiZmxleFBvc2l0aXZlIiwiZmxleFNocmluayIsImZsZXhOZWdhdGl2ZSIsImZsZXhPcmRlciIsImdyaWRBcmVhIiwiZ3JpZFJvdyIsImdyaWRSb3dFbmQiLCJncmlkUm93U3BhbiIsImdyaWRSb3dTdGFydCIsImdyaWRDb2x1bW4iLCJncmlkQ29sdW1uRW5kIiwiZ3JpZENvbHVtblNwYW4iLCJncmlkQ29sdW1uU3RhcnQiLCJmb250V2VpZ2h0IiwibGluZUNsYW1wIiwibGluZUhlaWdodCIsIm9wYWNpdHkiLCJvcmRlciIsIm9ycGhhbnMiLCJ0YWJTaXplIiwid2lkb3dzIiwiekluZGV4Iiwiem9vbSIsImZpbGxPcGFjaXR5IiwiZmxvb2RPcGFjaXR5Iiwic3RvcE9wYWNpdHkiLCJzdHJva2VEYXNoYXJyYXkiLCJzdHJva2VEYXNob2Zmc2V0Iiwic3Ryb2tlTWl0ZXJsaW1pdCIsInN0cm9rZU9wYWNpdHkiLCJzdHJva2VXaWR0aCIsInByZWZpeEtleSIsImtleSIsImNoYXJBdCIsInN1YnN0cmluZyIsInByZWZpeGVzIiwia2V5cyIsInByb3AiLCJoYXNSZWFkT25seVZhbHVlIiwiYnV0dG9uIiwiY2hlY2tib3giLCJpbWFnZSIsImhpZGRlbiIsInJhZGlvIiwicmVzZXQiLCJzdWJtaXQiLCJjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzIiwidGFnTmFtZSIsInByb3BzIiwib25DaGFuZ2UiLCJvbklucHV0IiwicmVhZE9ubHkiLCJkaXNhYmxlZCIsImNoZWNrZWQiLCJpc0N1c3RvbUNvbXBvbmVudCIsImluZGV4T2YiLCJpcyIsImFyaWFQcm9wZXJ0aWVzIiwid2FybmVkUHJvcGVydGllcyIsInJBUklBIiwickFSSUFDYW1lbCIsInZhbGlkYXRlUHJvcGVydHkiLCJhcmlhTmFtZSIsImNvcnJlY3ROYW1lIiwibG93ZXJDYXNlZE5hbWUiLCJzdGFuZGFyZE5hbWUiLCJ3YXJuSW52YWxpZEFSSUFQcm9wcyIsImludmFsaWRQcm9wcyIsImlzVmFsaWQiLCJwdXNoIiwidW5rbm93blByb3BTdHJpbmciLCJqb2luIiwidmFsaWRhdGVQcm9wZXJ0aWVzIiwiZGlkV2FyblZhbHVlTnVsbCIsInZhbGlkYXRlUHJvcGVydGllcyQxIiwibXVsdGlwbGUiLCJwb3NzaWJsZVN0YW5kYXJkTmFtZXMiLCJhY2NlcHQiLCJhY2NlcHRjaGFyc2V0IiwiYWNjZXNza2V5IiwiYWN0aW9uIiwiYWxsb3dmdWxsc2NyZWVuIiwiYWx0IiwiYXMiLCJhc3luYyIsImF1dG9jYXBpdGFsaXplIiwiYXV0b2NvbXBsZXRlIiwiYXV0b2NvcnJlY3QiLCJhdXRvZm9jdXMiLCJhdXRvcGxheSIsImF1dG9zYXZlIiwiY2FwdHVyZSIsImNlbGxwYWRkaW5nIiwiY2VsbHNwYWNpbmciLCJjaGFsbGVuZ2UiLCJjaGFyc2V0IiwiY2hpbGRyZW4iLCJjaXRlIiwiY2xhc3MiLCJjbGFzc2lkIiwiY2xhc3NuYW1lIiwiY29scyIsImNvbHNwYW4iLCJjb250ZW50ZWRpdGFibGUiLCJjb250ZXh0bWVudSIsImNvbnRyb2xzIiwiY29udHJvbHNsaXN0IiwiY29vcmRzIiwiY3Jvc3NvcmlnaW4iLCJkYW5nZXJvdXNseXNldGlubmVyaHRtbCIsImRhdGEiLCJkYXRldGltZSIsImRlZmF1bHQiLCJkZWZhdWx0Y2hlY2tlZCIsImRlZmF1bHR2YWx1ZSIsImRlZmVyIiwiZGlyIiwiZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmUiLCJkaXNhYmxlcmVtb3RlcGxheWJhY2siLCJkb3dubG9hZCIsImRyYWdnYWJsZSIsImVuY3R5cGUiLCJlbnRlcmtleWhpbnQiLCJmb3IiLCJmb3JtIiwiZm9ybW1ldGhvZCIsImZvcm1hY3Rpb24iLCJmb3JtZW5jdHlwZSIsImZvcm1ub3ZhbGlkYXRlIiwiZm9ybXRhcmdldCIsImZyYW1lYm9yZGVyIiwiaGVhZGVycyIsImhlaWdodCIsImhpZ2giLCJocmVmIiwiaHJlZmxhbmciLCJodG1sZm9yIiwiaHR0cGVxdWl2IiwiaWNvbiIsImlkIiwiaW1hZ2VzaXplcyIsImltYWdlc3Jjc2V0IiwiaW5uZXJodG1sIiwiaW5wdXRtb2RlIiwiaW50ZWdyaXR5IiwiaXRlbWlkIiwiaXRlbXByb3AiLCJpdGVtcmVmIiwiaXRlbXNjb3BlIiwiaXRlbXR5cGUiLCJrZXlwYXJhbXMiLCJrZXl0eXBlIiwia2luZCIsImxhYmVsIiwibGFuZyIsImxpc3QiLCJsb29wIiwibG93IiwibWFuaWZlc3QiLCJtYXJnaW53aWR0aCIsIm1hcmdpbmhlaWdodCIsIm1heCIsIm1heGxlbmd0aCIsIm1lZGlhIiwibWVkaWFncm91cCIsIm1ldGhvZCIsIm1pbiIsIm1pbmxlbmd0aCIsIm11dGVkIiwibm9tb2R1bGUiLCJub25jZSIsIm5vdmFsaWRhdGUiLCJvcGVuIiwib3B0aW11bSIsInBhdHRlcm4iLCJwbGFjZWhvbGRlciIsInBsYXlzaW5saW5lIiwicG9zdGVyIiwicHJlbG9hZCIsInByb2ZpbGUiLCJyYWRpb2dyb3VwIiwicmVhZG9ubHkiLCJyZWZlcnJlcnBvbGljeSIsInJlbCIsInJlcXVpcmVkIiwicmV2ZXJzZWQiLCJyb2xlIiwicm93cyIsInJvd3NwYW4iLCJzYW5kYm94Iiwic2NvcGUiLCJzY29wZWQiLCJzY3JvbGxpbmciLCJzZWFtbGVzcyIsInNlbGVjdGVkIiwic2hhcGUiLCJzaXplIiwic2l6ZXMiLCJzcGFuIiwic3BlbGxjaGVjayIsInNyYyIsInNyY2RvYyIsInNyY2xhbmciLCJzcmNzZXQiLCJzdGFydCIsInN0ZXAiLCJzdHlsZSIsInN1bW1hcnkiLCJ0YWJpbmRleCIsInRpdGxlIiwidXNlbWFwIiwid2lkdGgiLCJ3bW9kZSIsIndyYXAiLCJhYm91dCIsImFjY2VudGhlaWdodCIsImFjY3VtdWxhdGUiLCJhZGRpdGl2ZSIsImFsaWdubWVudGJhc2VsaW5lIiwiYWxsb3dyZW9yZGVyIiwiYWxwaGFiZXRpYyIsImFtcGxpdHVkZSIsImFyYWJpY2Zvcm0iLCJhc2NlbnQiLCJhdHRyaWJ1dGVuYW1lIiwiYXR0cmlidXRldHlwZSIsImF1dG9yZXZlcnNlIiwiYXppbXV0aCIsImJhc2VmcmVxdWVuY3kiLCJiYXNlbGluZXNoaWZ0IiwiYmFzZXByb2ZpbGUiLCJiYm94IiwiYmVnaW4iLCJiaWFzIiwiYnkiLCJjYWxjbW9kZSIsImNhcGhlaWdodCIsImNsaXAiLCJjbGlwcGF0aCIsImNsaXBwYXRodW5pdHMiLCJjbGlwcnVsZSIsImNvbG9yIiwiY29sb3JpbnRlcnBvbGF0aW9uIiwiY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVycyIsImNvbG9ycHJvZmlsZSIsImNvbG9ycmVuZGVyaW5nIiwiY29udGVudHNjcmlwdHR5cGUiLCJjb250ZW50c3R5bGV0eXBlIiwiY3Vyc29yIiwiY3giLCJjeSIsImQiLCJkYXRhdHlwZSIsImRlY2VsZXJhdGUiLCJkZXNjZW50IiwiZGlmZnVzZWNvbnN0YW50IiwiZGlyZWN0aW9uIiwiZGlzcGxheSIsImRpdmlzb3IiLCJkb21pbmFudGJhc2VsaW5lIiwiZHVyIiwiZHgiLCJkeSIsImVkZ2Vtb2RlIiwiZWxldmF0aW9uIiwiZW5hYmxlYmFja2dyb3VuZCIsImV4cG9uZW50IiwiZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZCIsImZpbGwiLCJmaWxsb3BhY2l0eSIsImZpbGxydWxlIiwiZmlsdGVyIiwiZmlsdGVycmVzIiwiZmlsdGVydW5pdHMiLCJmbG9vZG9wYWNpdHkiLCJmbG9vZGNvbG9yIiwiZm9jdXNhYmxlIiwiZm9udGZhbWlseSIsImZvbnRzaXplIiwiZm9udHNpemVhZGp1c3QiLCJmb250c3RyZXRjaCIsImZvbnRzdHlsZSIsImZvbnR2YXJpYW50IiwiZm9udHdlaWdodCIsImZyb20iLCJmeCIsImZ5IiwiZzEiLCJnMiIsImdseXBobmFtZSIsImdseXBob3JpZW50YXRpb25ob3Jpem9udGFsIiwiZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsIiwiZ2x5cGhyZWYiLCJncmFkaWVudHRyYW5zZm9ybSIsImdyYWRpZW50dW5pdHMiLCJoYW5naW5nIiwiaG9yaXphZHZ4IiwiaG9yaXpvcmlnaW54IiwiaWRlb2dyYXBoaWMiLCJpbWFnZXJlbmRlcmluZyIsImluMiIsImluIiwiaW5saXN0IiwiaW50ZXJjZXB0IiwiazEiLCJrMiIsImszIiwiazQiLCJrIiwia2VybmVsbWF0cml4Iiwia2VybmVsdW5pdGxlbmd0aCIsImtlcm5pbmciLCJrZXlwb2ludHMiLCJrZXlzcGxpbmVzIiwia2V5dGltZXMiLCJsZW5ndGhhZGp1c3QiLCJsZXR0ZXJzcGFjaW5nIiwibGlnaHRpbmdjb2xvciIsImxpbWl0aW5nY29uZWFuZ2xlIiwibG9jYWwiLCJtYXJrZXJlbmQiLCJtYXJrZXJoZWlnaHQiLCJtYXJrZXJtaWQiLCJtYXJrZXJzdGFydCIsIm1hcmtlcnVuaXRzIiwibWFya2Vyd2lkdGgiLCJtYXNrIiwibWFza2NvbnRlbnR1bml0cyIsIm1hc2t1bml0cyIsIm1hdGhlbWF0aWNhbCIsIm1vZGUiLCJudW1vY3RhdmVzIiwib2Zmc2V0Iiwib3BlcmF0b3IiLCJvcmllbnQiLCJvcmllbnRhdGlvbiIsIm9yaWdpbiIsIm92ZXJmbG93Iiwib3ZlcmxpbmVwb3NpdGlvbiIsIm92ZXJsaW5ldGhpY2tuZXNzIiwicGFpbnRvcmRlciIsInBhbm9zZTEiLCJwYXRobGVuZ3RoIiwicGF0dGVybmNvbnRlbnR1bml0cyIsInBhdHRlcm50cmFuc2Zvcm0iLCJwYXR0ZXJudW5pdHMiLCJwb2ludGVyZXZlbnRzIiwicG9pbnRzIiwicG9pbnRzYXR4IiwicG9pbnRzYXR5IiwicG9pbnRzYXR6IiwicHJlc2VydmVhbHBoYSIsInByZXNlcnZlYXNwZWN0cmF0aW8iLCJwcmltaXRpdmV1bml0cyIsInByb3BlcnR5IiwiciIsInJhZGl1cyIsInJlZngiLCJyZWZ5IiwicmVuZGVyaW5naW50ZW50IiwicmVwZWF0Y291bnQiLCJyZXBlYXRkdXIiLCJyZXF1aXJlZGV4dGVuc2lvbnMiLCJyZXF1aXJlZGZlYXR1cmVzIiwicmVzb3VyY2UiLCJyZXN0YXJ0IiwicmVzdWx0IiwicmVzdWx0cyIsInJvdGF0ZSIsInJ4IiwicnkiLCJzY2FsZSIsInNlY3VyaXR5Iiwic2VlZCIsInNoYXBlcmVuZGVyaW5nIiwic2xvcGUiLCJzcGFjaW5nIiwic3BlY3VsYXJjb25zdGFudCIsInNwZWN1bGFyZXhwb25lbnQiLCJzcGVlZCIsInNwcmVhZG1ldGhvZCIsInN0YXJ0b2Zmc2V0Iiwic3RkZGV2aWF0aW9uIiwic3RlbWgiLCJzdGVtdiIsInN0aXRjaHRpbGVzIiwic3RvcGNvbG9yIiwic3RvcG9wYWNpdHkiLCJzdHJpa2V0aHJvdWdocG9zaXRpb24iLCJzdHJpa2V0aHJvdWdodGhpY2tuZXNzIiwic3RyaW5nIiwic3Ryb2tlIiwic3Ryb2tlZGFzaGFycmF5Iiwic3Ryb2tlZGFzaG9mZnNldCIsInN0cm9rZWxpbmVjYXAiLCJzdHJva2VsaW5lam9pbiIsInN0cm9rZW1pdGVybGltaXQiLCJzdHJva2V3aWR0aCIsInN0cm9rZW9wYWNpdHkiLCJzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmciLCJzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmciLCJzdXJmYWNlc2NhbGUiLCJzeXN0ZW1sYW5ndWFnZSIsInRhYmxldmFsdWVzIiwidGFyZ2V0eCIsInRhcmdldHkiLCJ0ZXh0YW5jaG9yIiwidGV4dGRlY29yYXRpb24iLCJ0ZXh0bGVuZ3RoIiwidGV4dHJlbmRlcmluZyIsInRvIiwidHJhbnNmb3JtIiwidHlwZW9mIiwidTEiLCJ1MiIsInVuZGVybGluZXBvc2l0aW9uIiwidW5kZXJsaW5ldGhpY2tuZXNzIiwidW5pY29kZSIsInVuaWNvZGViaWRpIiwidW5pY29kZXJhbmdlIiwidW5pdHNwZXJlbSIsInVuc2VsZWN0YWJsZSIsInZhbHBoYWJldGljIiwidmFsdWVzIiwidmVjdG9yZWZmZWN0IiwidmVyc2lvbiIsInZlcnRhZHZ5IiwidmVydG9yaWdpbngiLCJ2ZXJ0b3JpZ2lueSIsInZoYW5naW5nIiwidmlkZW9ncmFwaGljIiwidmlld2JveCIsInZpZXd0YXJnZXQiLCJ2aXNpYmlsaXR5Iiwidm1hdGhlbWF0aWNhbCIsInZvY2FiIiwid2lkdGhzIiwid29yZHNwYWNpbmciLCJ3cml0aW5nbW9kZSIsIngxIiwieDIiLCJ4IiwieGNoYW5uZWxzZWxlY3RvciIsInhoZWlnaHQiLCJ4bGlua2FjdHVhdGUiLCJ4bGlua2FyY3JvbGUiLCJ4bGlua2hyZWYiLCJ4bGlua3JvbGUiLCJ4bGlua3Nob3ciLCJ4bGlua3RpdGxlIiwieGxpbmt0eXBlIiwieG1sYmFzZSIsInhtbGxhbmciLCJ4bWxucyIsInhtbG5zeGxpbmsiLCJ4bWxzcGFjZSIsInkxIiwieTIiLCJ5IiwieWNoYW5uZWxzZWxlY3RvciIsInoiLCJ6b29tYW5kcGFuIiwidmFsaWRhdGVQcm9wZXJ0eSQxIiwid2FybmVkUHJvcGVydGllcyQxIiwiRVZFTlRfTkFNRV9SRUdFWCIsIklOVkFMSURfRVZFTlRfTkFNRV9SRUdFWCIsInJBUklBJDEiLCJyQVJJQUNhbWVsJDEiLCJldmVudFJlZ2lzdHJ5IiwicmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyIsInBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMiLCJyZWdpc3RyYXRpb25OYW1lIiwidW5kZWZpbmVkIiwiaXNOYU4iLCJpc1Jlc2VydmVkIiwid2FyblVua25vd25Qcm9wZXJ0aWVzIiwidW5rbm93blByb3BzIiwidmFsaWRhdGVQcm9wZXJ0aWVzJDIiLCJ3YXJuVmFsaWRTdHlsZSIsImJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiIsIm1zUGF0dGVybiIsImh5cGhlblBhdHRlcm4iLCJiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4iLCJ3YXJuZWRTdHlsZU5hbWVzIiwid2FybmVkU3R5bGVWYWx1ZXMiLCJ3YXJuZWRGb3JOYU5WYWx1ZSIsIndhcm5lZEZvckluZmluaXR5VmFsdWUiLCJjYW1lbGl6ZSIsIl8iLCJjaGFyYWN0ZXIiLCJ3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSIsIndhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSIsIndhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiIsIndhcm5TdHlsZVZhbHVlSXNOYU4iLCJ3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkiLCJpc0Zpbml0ZSIsIndhcm5WYWxpZFN0eWxlJDEiLCJtYXRjaEh0bWxSZWdFeHAiLCJlc2NhcGVIdG1sIiwic3RyIiwibWF0Y2giLCJleGVjIiwiZXNjYXBlIiwiaHRtbCIsImluZGV4IiwibGFzdEluZGV4IiwiY2hhckNvZGVBdCIsImVzY2FwZVRleHRGb3JCcm93c2VyIiwidGV4dCIsInVwcGVyY2FzZVBhdHRlcm4iLCJtc1BhdHRlcm4kMSIsImh5cGhlbmF0ZVN0eWxlTmFtZSIsImlzSmF2YVNjcmlwdFByb3RvY29sIiwiZGlkV2FybiIsInVybCIsIkpTT04iLCJzdHJpbmdpZnkiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwic3RhcnRJbmxpbmVTY3JpcHQiLCJlbmRJbmxpbmVTY3JpcHQiLCJzdGFydFNjcmlwdFNyYyIsInN0YXJ0TW9kdWxlU3JjIiwiZW5kQXN5bmNTY3JpcHQiLCJlc2NhcGVCb290c3RyYXBTY3JpcHRDb250ZW50Iiwic2NyaXB0VGV4dCIsInNjcmlwdFJlZ2V4Iiwic2NyaXB0UmVwbGFjZXIiLCJzIiwic3VmZml4IiwiY3JlYXRlUmVzcG9uc2VTdGF0ZSIsImlkZW50aWZpZXJQcmVmaXgiLCJib290c3RyYXBTY3JpcHRDb250ZW50IiwiYm9vdHN0cmFwU2NyaXB0cyIsImJvb3RzdHJhcE1vZHVsZXMiLCJpZFByZWZpeCIsImlubGluZVNjcmlwdFdpdGhOb25jZSIsImJvb3RzdHJhcENodW5rcyIsImkiLCJfaSIsInBsYWNlaG9sZGVyUHJlZml4Iiwic2VnbWVudFByZWZpeCIsImJvdW5kYXJ5UHJlZml4IiwibmV4dFN1c3BlbnNlSUQiLCJzZW50Q29tcGxldGVTZWdtZW50RnVuY3Rpb24iLCJzZW50Q29tcGxldGVCb3VuZGFyeUZ1bmN0aW9uIiwic2VudENsaWVudFJlbmRlckZ1bmN0aW9uIiwiUk9PVF9IVE1MX01PREUiLCJIVE1MX01PREUiLCJTVkdfTU9ERSIsIk1BVEhNTF9NT0RFIiwiSFRNTF9UQUJMRV9NT0RFIiwiSFRNTF9UQUJMRV9CT0RZX01PREUiLCJIVE1MX1RBQkxFX1JPV19NT0RFIiwiSFRNTF9DT0xHUk9VUF9NT0RFIiwiY3JlYXRlRm9ybWF0Q29udGV4dCIsImluc2VydGlvbk1vZGUiLCJzZWxlY3RlZFZhbHVlIiwiY3JlYXRlUm9vdEZvcm1hdENvbnRleHQiLCJuYW1lc3BhY2VVUkkiLCJnZXRDaGlsZEZvcm1hdENvbnRleHQiLCJwYXJlbnRDb250ZXh0IiwiZGVmYXVsdFZhbHVlIiwiVU5JTklUSUFMSVpFRF9TVVNQRU5TRV9CT1VOREFSWV9JRCIsImFzc2lnblN1c3BlbnNlQm91bmRhcnlJRCIsInJlc3BvbnNlU3RhdGUiLCJnZW5lcmF0ZWRJRCIsInRvU3RyaW5nIiwibWFrZUlkIiwidHJlZUlkIiwibG9jYWxJZCIsImVuY29kZUhUTUxUZXh0Tm9kZSIsInRleHRTZXBhcmF0b3IiLCJwdXNoVGV4dEluc3RhbmNlIiwidGV4dEVtYmVkZGVkIiwicHVzaFNlZ21lbnRGaW5hbGUiLCJsYXN0UHVzaGVkVGV4dCIsInN0eWxlTmFtZUNhY2hlIiwiTWFwIiwicHJvY2Vzc1N0eWxlTmFtZSIsInN0eWxlTmFtZSIsImdldCIsInN0eWxlQXR0cmlidXRlU3RhcnQiLCJzdHlsZUFzc2lnbiIsInN0eWxlU2VwYXJhdG9yIiwicHVzaFN0eWxlIiwiRXJyb3IiLCJpc0ZpcnN0Iiwic3R5bGVWYWx1ZSIsIm5hbWVDaHVuayIsInZhbHVlQ2h1bmsiLCJpc0N1c3RvbVByb3BlcnR5IiwidHJpbSIsImF0dHJpYnV0ZUVuZCIsImF0dHJpYnV0ZVNlcGFyYXRvciIsImF0dHJpYnV0ZUFzc2lnbiIsImF0dHJpYnV0ZUVtcHR5U3RyaW5nIiwicHVzaEF0dHJpYnV0ZSIsImF0dHJpYnV0ZU5hbWVDaHVuayIsImVuZE9mU3RhcnRUYWciLCJlbmRPZlN0YXJ0VGFnU2VsZkNsb3NpbmciLCJwdXNoSW5uZXJIVE1MIiwiaW5uZXJIVE1MIiwiX19odG1sIiwiZGlkV2FybkRlZmF1bHRJbnB1dFZhbHVlIiwiZGlkV2FybkRlZmF1bHRDaGVja2VkIiwiZGlkV2FybkRlZmF1bHRTZWxlY3RWYWx1ZSIsImRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSIsImRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4iLCJkaWRXYXJuSW52YWxpZE9wdGlvbklubmVySFRNTCIsImRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uIiwiY2hlY2tTZWxlY3RQcm9wIiwiYXJyYXkiLCJwdXNoU3RhcnRTZWxlY3QiLCJzdGFydENodW5rRm9yVGFnIiwicHJvcEtleSIsInByb3BWYWx1ZSIsImZsYXR0ZW5PcHRpb25DaGlsZHJlbiIsIkNoaWxkcmVuIiwiY2hpbGQiLCJzZWxlY3RlZE1hcmtlckF0dHJpYnV0ZSIsInB1c2hTdGFydE9wdGlvbiIsImZvcm1hdENvbnRleHQiLCJzdHJpbmdWYWx1ZSIsInYiLCJwdXNoSW5wdXQiLCJkZWZhdWx0Q2hlY2tlZCIsInB1c2hTdGFydFRleHRBcmVhIiwibGVhZGluZ05ld2xpbmUiLCJwdXNoU2VsZkNsb3NpbmciLCJ0YWciLCJwdXNoU3RhcnRNZW51SXRlbSIsInB1c2hTdGFydFRpdGxlIiwiJCR0eXBlb2YiLCJwdXNoU3RhcnRHZW5lcmljRWxlbWVudCIsInB1c2hTdGFydEN1c3RvbUVsZW1lbnQiLCJwdXNoU3RhcnRQcmVmb3JtYXR0ZWRFbGVtZW50IiwiVkFMSURfVEFHX1JFR0VYIiwidmFsaWRhdGVkVGFnQ2FjaGUiLCJ0YWdTdGFydENodW5rIiwiRE9DVFlQRSIsInB1c2hTdGFydEluc3RhbmNlIiwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIiwiY29udGVudEVkaXRhYmxlIiwiZW5kVGFnMSIsImVuZFRhZzIiLCJwdXNoRW5kSW5zdGFuY2UiLCJ3cml0ZUNvbXBsZXRlZFJvb3QiLCJwbGFjZWhvbGRlcjEiLCJwbGFjZWhvbGRlcjIiLCJ3cml0ZVBsYWNlaG9sZGVyIiwiZm9ybWF0dGVkSUQiLCJzdGFydENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkiLCJzdGFydFBlbmRpbmdTdXNwZW5zZUJvdW5kYXJ5MSIsInN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkyIiwic3RhcnRDbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnkiLCJlbmRTdXNwZW5zZUJvdW5kYXJ5IiwiY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxIiwiY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3JBdHRySW50ZXJzdGl0aWFsIiwiY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IxQSIsImNsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeUVycm9yMUIiLCJjbGllbnRSZW5kZXJlZFN1c3BlbnNlQm91bmRhcnlFcnJvcjFDIiwiY2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5RXJyb3IyIiwid3JpdGVTdGFydENvbXBsZXRlZFN1c3BlbnNlQm91bmRhcnkiLCJ3cml0ZVN0YXJ0UGVuZGluZ1N1c3BlbnNlQm91bmRhcnkiLCJ3cml0ZVN0YXJ0Q2xpZW50UmVuZGVyZWRTdXNwZW5zZUJvdW5kYXJ5IiwiZXJyb3JEaWdlc3QiLCJlcnJvck1lc3NzYWdlIiwiZXJyb3JDb21wb25lbnRTdGFjayIsIndyaXRlRW5kQ29tcGxldGVkU3VzcGVuc2VCb3VuZGFyeSIsIndyaXRlRW5kUGVuZGluZ1N1c3BlbnNlQm91bmRhcnkiLCJ3cml0ZUVuZENsaWVudFJlbmRlcmVkU3VzcGVuc2VCb3VuZGFyeSIsInN0YXJ0U2VnbWVudEhUTUwiLCJzdGFydFNlZ21lbnRIVE1MMiIsImVuZFNlZ21lbnRIVE1MIiwic3RhcnRTZWdtZW50U1ZHIiwic3RhcnRTZWdtZW50U1ZHMiIsImVuZFNlZ21lbnRTVkciLCJzdGFydFNlZ21lbnRNYXRoTUwiLCJzdGFydFNlZ21lbnRNYXRoTUwyIiwiZW5kU2VnbWVudE1hdGhNTCIsInN0YXJ0U2VnbWVudFRhYmxlIiwic3RhcnRTZWdtZW50VGFibGUyIiwiZW5kU2VnbWVudFRhYmxlIiwic3RhcnRTZWdtZW50VGFibGVCb2R5Iiwic3RhcnRTZWdtZW50VGFibGVCb2R5MiIsImVuZFNlZ21lbnRUYWJsZUJvZHkiLCJzdGFydFNlZ21lbnRUYWJsZVJvdyIsInN0YXJ0U2VnbWVudFRhYmxlUm93MiIsImVuZFNlZ21lbnRUYWJsZVJvdyIsInN0YXJ0U2VnbWVudENvbEdyb3VwIiwic3RhcnRTZWdtZW50Q29sR3JvdXAyIiwiZW5kU2VnbWVudENvbEdyb3VwIiwid3JpdGVTdGFydFNlZ21lbnQiLCJ3cml0ZUVuZFNlZ21lbnQiLCJjb21wbGV0ZVNlZ21lbnRGdW5jdGlvbiIsImNvbXBsZXRlQm91bmRhcnlGdW5jdGlvbiIsImNsaWVudFJlbmRlckZ1bmN0aW9uIiwiY29tcGxldGVTZWdtZW50U2NyaXB0MUZ1bGwiLCJjb21wbGV0ZVNlZ21lbnRTY3JpcHQxUGFydGlhbCIsImNvbXBsZXRlU2VnbWVudFNjcmlwdDIiLCJjb21wbGV0ZVNlZ21lbnRTY3JpcHQzIiwid3JpdGVDb21wbGV0ZWRTZWdtZW50SW5zdHJ1Y3Rpb24iLCJjb250ZW50U2VnbWVudElEIiwiY29tcGxldGVCb3VuZGFyeVNjcmlwdDFGdWxsIiwiY29tcGxldGVCb3VuZGFyeVNjcmlwdDFQYXJ0aWFsIiwiY29tcGxldGVCb3VuZGFyeVNjcmlwdDIiLCJjb21wbGV0ZUJvdW5kYXJ5U2NyaXB0MyIsIndyaXRlQ29tcGxldGVkQm91bmRhcnlJbnN0cnVjdGlvbiIsImJvdW5kYXJ5SUQiLCJmb3JtYXR0ZWRDb250ZW50SUQiLCJjbGllbnRSZW5kZXJTY3JpcHQxRnVsbCIsImNsaWVudFJlbmRlclNjcmlwdDFQYXJ0aWFsIiwiY2xpZW50UmVuZGVyU2NyaXB0MUEiLCJjbGllbnRSZW5kZXJTY3JpcHQyIiwiY2xpZW50UmVuZGVyRXJyb3JTY3JpcHRBcmdJbnRlcnN0aXRpYWwiLCJ3cml0ZUNsaWVudFJlbmRlckJvdW5kYXJ5SW5zdHJ1Y3Rpb24iLCJlcnJvck1lc3NhZ2UiLCJlc2NhcGVKU1N0cmluZ3NGb3JJbnN0cnVjdGlvblNjcmlwdHMiLCJyZWdleEZvckpTU3RyaW5nc0luU2NyaXB0cyIsImlucHV0IiwiZXNjYXBlZCIsImFzc2lnbiIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfRlJBR01FTlRfVFlQRSIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfUFJPVklERVJfVFlQRSIsIlJFQUNUX0NPTlRFWFRfVFlQRSIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwiUkVBQ1RfU0NPUEVfVFlQRSIsIlJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIiwiUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIiwiUkVBQ1RfU0VSVkVSX0NPTlRFWFRfREVGQVVMVF9WQUxVRV9OT1RfTE9BREVEIiwiTUFZQkVfSVRFUkFUT1JfU1lNQk9MIiwiaXRlcmF0b3IiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCIsImdldEl0ZXJhdG9yRm4iLCJtYXliZUl0ZXJhYmxlIiwibWF5YmVJdGVyYXRvciIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJkaXNwbGF5TmFtZSIsImZ1bmN0aW9uTmFtZSIsImdldENvbnRleHROYW1lIiwiZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlIiwiY29udGV4dCIsInByb3ZpZGVyIiwiX2NvbnRleHQiLCJyZW5kZXIiLCJvdXRlck5hbWUiLCJsYXp5Q29tcG9uZW50IiwicGF5bG9hZCIsIl9wYXlsb2FkIiwiaW5pdCIsIl9pbml0IiwiZGlzYWJsZWREZXB0aCIsInByZXZMb2ciLCJwcmV2SW5mbyIsInByZXZXYXJuIiwicHJldkVycm9yIiwicHJldkdyb3VwIiwicHJldkdyb3VwQ29sbGFwc2VkIiwicHJldkdyb3VwRW5kIiwiZGlzYWJsZWRMb2ciLCJfX3JlYWN0RGlzYWJsZWRMb2ciLCJkaXNhYmxlTG9ncyIsImxvZyIsImluZm8iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicmVlbmFibGVMb2dzIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciIsImRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lIiwic291cmNlIiwib3duZXJGbiIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiY29udHJvbCIsInByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UiLCJwcmVwYXJlU3RhY2tUcmFjZSIsInByZXZpb3VzRGlzcGF0Y2hlciIsImN1cnJlbnQiLCJGYWtlIiwiZGVmaW5lUHJvcGVydHkiLCJSZWZsZWN0Iiwic2FtcGxlIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsImMiLCJfZnJhbWUiLCJpbmNsdWRlcyIsInN5bnRoZXRpY0ZyYW1lIiwiZGVzY3JpYmVDbGFzc0NvbXBvbmVudEZyYW1lIiwiY3RvciIsImRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSIsInNob3VsZENvbnN0cnVjdCIsIkNvbXBvbmVudCIsImlzUmVhY3RDb21wb25lbnQiLCJkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCIsImVsZW1lbnQiLCJvd25lciIsIl9vd25lciIsIl9zb3VyY2UiLCJzZXRFeHRyYVN0YWNrRnJhbWUiLCJjaGVja1Byb3BUeXBlcyIsInR5cGVTcGVjcyIsImxvY2F0aW9uIiwiY29tcG9uZW50TmFtZSIsImhhcyIsImJpbmQiLCJ0eXBlU3BlY05hbWUiLCJlcnJvciQxIiwiZXJyIiwiZXgiLCJtZXNzYWdlIiwid2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0IiwiZW1wdHlDb250ZXh0T2JqZWN0IiwiZnJlZXplIiwiZ2V0TWFza2VkQ29udGV4dCIsInVubWFza2VkQ29udGV4dCIsImNvbnRleHRUeXBlcyIsInByb2Nlc3NDaGlsZENvbnRleHQiLCJpbnN0YW5jZSIsImNoaWxkQ29udGV4dFR5cGVzIiwiZ2V0Q2hpbGRDb250ZXh0IiwiY2hpbGRDb250ZXh0IiwiY29udGV4dEtleSIsInJlbmRlcmVyU2lnaWwiLCJyb290Q29udGV4dFNuYXBzaG90IiwiY3VycmVudEFjdGl2ZVNuYXBzaG90IiwicG9wTm9kZSIsInByZXYiLCJfY3VycmVudFZhbHVlIiwicGFyZW50VmFsdWUiLCJwdXNoTm9kZSIsIm5leHQiLCJwb3BUb05lYXJlc3RDb21tb25BbmNlc3RvciIsInBhcmVudFByZXYiLCJwYXJlbnQiLCJwYXJlbnROZXh0IiwicG9wQWxsUHJldmlvdXMiLCJwdXNoQWxsTmV4dCIsInBvcFByZXZpb3VzVG9Db21tb25MZXZlbCIsImRlcHRoIiwicG9wTmV4dFRvQ29tbW9uTGV2ZWwiLCJzd2l0Y2hDb250ZXh0IiwibmV3U25hcHNob3QiLCJwdXNoUHJvdmlkZXIiLCJuZXh0VmFsdWUiLCJwcmV2VmFsdWUiLCJfY3VycmVudFJlbmRlcmVyIiwicHJldk5vZGUiLCJuZXdOb2RlIiwicG9wUHJvdmlkZXIiLCJwcmV2U25hcHNob3QiLCJfZGVmYXVsdFZhbHVlIiwiZ2V0QWN0aXZlQ29udGV4dCIsInJlYWRDb250ZXh0IiwiX3JlYWN0SW50ZXJuYWxzIiwiZGlkV2FybkFib3V0Tm9vcFVwZGF0ZUZvckNvbXBvbmVudCIsImRpZFdhcm5BYm91dERlcHJlY2F0ZWRXaWxsTW91bnQiLCJkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUiLCJkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUiLCJkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlIiwiZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlIiwid2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlIiwid2Fybk9uSW52YWxpZENhbGxiYWNrIiwiZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUiLCJkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcyIsImRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZSIsIlNldCIsImRpZFdhcm5PbkludmFsaWRDYWxsYmFjayIsImNhbGxlck5hbWUiLCJhZGQiLCJwYXJ0aWFsU3RhdGUiLCJ3YXJuTm9vcCIsInB1YmxpY0luc3RhbmNlIiwiX2NvbnN0cnVjdG9yIiwid2FybmluZ0tleSIsImNsYXNzQ29tcG9uZW50VXBkYXRlciIsImlzTW91bnRlZCIsImluc3QiLCJlbnF1ZXVlU2V0U3RhdGUiLCJpbnRlcm5hbHMiLCJxdWV1ZSIsImVucXVldWVSZXBsYWNlU3RhdGUiLCJlbnF1ZXVlRm9yY2VVcGRhdGUiLCJhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsInByZXZTdGF0ZSIsIm5leHRQcm9wcyIsIm5ld1N0YXRlIiwiY29uc3RydWN0Q2xhc3NJbnN0YW5jZSIsIm1hc2tlZExlZ2FjeUNvbnRleHQiLCJjb250ZXh0VHlwZSIsImFkZGVuZHVtIiwic3RhdGUiLCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsImZvdW5kV2lsbE1vdW50TmFtZSIsImZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUiLCJmb3VuZFdpbGxVcGRhdGVOYW1lIiwiY29tcG9uZW50V2lsbE1vdW50IiwiX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyIsIlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJjb21wb25lbnRXaWxsVXBkYXRlIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUiLCJfY29tcG9uZW50TmFtZSIsIm5ld0FwaU5hbWUiLCJjaGVja0NsYXNzSW5zdGFuY2UiLCJuZXdQcm9wcyIsInJlbmRlclByZXNlbnQiLCJnZXRJbml0aWFsU3RhdGUiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsImdldERlZmF1bHRQcm9wcyIsInByb3BUeXBlcyIsImNvbXBvbmVudFNob3VsZFVwZGF0ZSIsImlzUHVyZVJlYWN0Q29tcG9uZW50Iiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwiY29tcG9uZW50RGlkVW5tb3VudCIsImNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImhhc011dGF0ZWRQcm9wcyIsImRlZmF1bHRQcm9wcyIsImNvbXBvbmVudERpZFVwZGF0ZSIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsIl9zdGF0ZSIsImNhbGxDb21wb25lbnRXaWxsTW91bnQiLCJvbGRTdGF0ZSIsInByb2Nlc3NVcGRhdGVRdWV1ZSIsImludGVybmFsSW5zdGFuY2UiLCJvbGRRdWV1ZSIsIm9sZFJlcGxhY2UiLCJuZXh0U3RhdGUiLCJkb250TXV0YXRlIiwicGFydGlhbCIsIm1vdW50Q2xhc3NJbnN0YW5jZSIsImluaXRpYWxTdGF0ZSIsInVwZGF0ZXIiLCJlbXB0eVRyZWVDb250ZXh0IiwiZ2V0VHJlZUlkIiwiaWRXaXRoTGVhZGluZ0JpdCIsImdldExlYWRpbmdCaXQiLCJwdXNoVHJlZUNvbnRleHQiLCJiYXNlQ29udGV4dCIsInRvdGFsQ2hpbGRyZW4iLCJiYXNlSWRXaXRoTGVhZGluZ0JpdCIsImJhc2VPdmVyZmxvdyIsImJhc2VMZW5ndGgiLCJnZXRCaXRMZW5ndGgiLCJiYXNlSWQiLCJzbG90IiwibnVtYmVyT2ZPdmVyZmxvd0JpdHMiLCJuZXdPdmVyZmxvd0JpdHMiLCJuZXdPdmVyZmxvdyIsInJlc3RPZkJhc2VJZCIsInJlc3RPZkJhc2VMZW5ndGgiLCJyZXN0T2ZMZW5ndGgiLCJyZXN0T2ZOZXdCaXRzIiwibmV3Qml0cyIsIl9pZCIsIl9vdmVyZmxvdyIsIm51bWJlciIsImNsejMyIiwiTWF0aCIsImNsejMyRmFsbGJhY2siLCJMTjIiLCJhc1VpbnQiLCJvYmplY3RJcyIsImN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCIsImN1cnJlbnRseVJlbmRlcmluZ1Rhc2siLCJmaXJzdFdvcmtJblByb2dyZXNzSG9vayIsIndvcmtJblByb2dyZXNzSG9vayIsImlzUmVSZW5kZXIiLCJkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlIiwibG9jYWxJZENvdW50ZXIiLCJyZW5kZXJQaGFzZVVwZGF0ZXMiLCJudW1iZXJPZlJlUmVuZGVycyIsIlJFX1JFTkRFUl9MSU1JVCIsImlzSW5Ib29rVXNlckNvZGVJbkRldiIsImN1cnJlbnRIb29rTmFtZUluRGV2IiwicmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCIsImFyZUhvb2tJbnB1dHNFcXVhbCIsIm5leHREZXBzIiwicHJldkRlcHMiLCJjcmVhdGVIb29rIiwibWVtb2l6ZWRTdGF0ZSIsImNyZWF0ZVdvcmtJblByb2dyZXNzSG9vayIsInByZXBhcmVUb1VzZUhvb2tzIiwidGFzayIsImNvbXBvbmVudElkZW50aXR5IiwiZmluaXNoSG9va3MiLCJyZWZPckNvbnRleHQiLCJyZXNldEhvb2tzU3RhdGUiLCJjaGVja0RpZFJlbmRlcklkSG9vayIsImRpZFJlbmRlcklkSG9vayIsInJlYWRDb250ZXh0JDEiLCJ1c2VDb250ZXh0IiwiYmFzaWNTdGF0ZVJlZHVjZXIiLCJ1c2VTdGF0ZSIsInVzZVJlZHVjZXIiLCJyZWR1Y2VyIiwiaW5pdGlhbEFyZyIsImRpc3BhdGNoIiwiZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSIsImRlbGV0ZSIsInVwZGF0ZSIsIl9xdWV1ZSIsImxhc3QiLCJfZGlzcGF0Y2giLCJkaXNwYXRjaEFjdGlvbiIsInVzZU1lbW8iLCJuZXh0Q3JlYXRlIiwiZGVwcyIsInVzZVJlZiIsImluaXRpYWxWYWx1ZSIsInByZXZpb3VzUmVmIiwicmVmIiwic2VhbCIsInVzZUxheW91dEVmZmVjdCIsImNyZWF0ZSIsImlucHV0cyIsImxhc3RSZW5kZXJQaGFzZVVwZGF0ZSIsInVzZUNhbGxiYWNrIiwidXNlTXV0YWJsZVNvdXJjZSIsImdldFNuYXBzaG90Iiwic3Vic2NyaWJlIiwidXNlU3luY0V4dGVybmFsU3RvcmUiLCJnZXRTZXJ2ZXJTbmFwc2hvdCIsInVzZURlZmVycmVkVmFsdWUiLCJ1bnN1cHBvcnRlZFN0YXJ0VHJhbnNpdGlvbiIsInVzZVRyYW5zaXRpb24iLCJ1c2VJZCIsInRyZWVDb250ZXh0IiwiY3VycmVudFJlc3BvbnNlU3RhdGUiLCJub29wIiwiRGlzcGF0Y2hlciIsInVzZUluc2VydGlvbkVmZmVjdCIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJ1c2VFZmZlY3QiLCJ1c2VEZWJ1Z1ZhbHVlIiwic2V0Q3VycmVudFJlc3BvbnNlU3RhdGUiLCJnZXRTdGFja0J5Q29tcG9uZW50U3RhY2tOb2RlIiwiY29tcG9uZW50U3RhY2siLCJub2RlIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxIiwiUEVORElORyIsIkNPTVBMRVRFRCIsIkZMVVNIRUQiLCJBQk9SVEVEIiwiRVJST1JFRCIsIk9QRU4iLCJDTE9TSU5HIiwiQ0xPU0VEIiwiREVGQVVMVF9QUk9HUkVTU0lWRV9DSFVOS19TSVpFIiwiZGVmYXVsdEVycm9ySGFuZGxlciIsIm5vb3AkMSIsImNyZWF0ZVJlcXVlc3QiLCJyb290Rm9ybWF0Q29udGV4dCIsInByb2dyZXNzaXZlQ2h1bmtTaXplIiwib25FcnJvciIsIm9uQWxsUmVhZHkiLCJvblNoZWxsUmVhZHkiLCJvblNoZWxsRXJyb3IiLCJvbkZhdGFsRXJyb3IiLCJwaW5nZWRUYXNrcyIsImFib3J0U2V0IiwicmVxdWVzdCIsInN0YXR1cyIsImZhdGFsRXJyb3IiLCJuZXh0U2VnbWVudElkIiwiYWxsUGVuZGluZ1Rhc2tzIiwicGVuZGluZ1Jvb3RUYXNrcyIsImNvbXBsZXRlZFJvb3RTZWdtZW50IiwiYWJvcnRhYmxlVGFza3MiLCJjbGllbnRSZW5kZXJlZEJvdW5kYXJpZXMiLCJjb21wbGV0ZWRCb3VuZGFyaWVzIiwicGFydGlhbEJvdW5kYXJpZXMiLCJyb290U2VnbWVudCIsImNyZWF0ZVBlbmRpbmdTZWdtZW50IiwicGFyZW50Rmx1c2hlZCIsInJvb3RUYXNrIiwiY3JlYXRlVGFzayIsInBpbmdUYXNrIiwicGVyZm9ybVdvcmsiLCJjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5IiwiZmFsbGJhY2tBYm9ydGFibGVUYXNrcyIsInJvb3RTZWdtZW50SUQiLCJwZW5kaW5nVGFza3MiLCJmb3JjZUNsaWVudFJlbmRlciIsImNvbXBsZXRlZFNlZ21lbnRzIiwiYnl0ZVNpemUiLCJibG9ja2VkQm91bmRhcnkiLCJibG9ja2VkU2VnbWVudCIsImxlZ2FjeUNvbnRleHQiLCJwaW5nIiwiYm91bmRhcnkiLCJjaHVua3MiLCJjdXJyZW50VGFza0luREVWIiwiZ2V0Q3VycmVudFN0YWNrSW5ERVYiLCJwdXNoQnVpbHRJbkNvbXBvbmVudFN0YWNrSW5ERVYiLCJwdXNoRnVuY3Rpb25Db21wb25lbnRTdGFja0luREVWIiwicHVzaENsYXNzQ29tcG9uZW50U3RhY2tJbkRFViIsInBvcENvbXBvbmVudFN0YWNrSW5ERVYiLCJsYXN0Qm91bmRhcnlFcnJvckNvbXBvbmVudFN0YWNrRGV2IiwiY2FwdHVyZUJvdW5kYXJ5RXJyb3JEZXRhaWxzRGV2IiwibG9nUmVjb3ZlcmFibGVFcnJvciIsInJlbmRlclN1c3BlbnNlQm91bmRhcnkiLCJwYXJlbnRCb3VuZGFyeSIsInBhcmVudFNlZ21lbnQiLCJmYWxsYmFjayIsImZhbGxiYWNrQWJvcnRTZXQiLCJuZXdCb3VuZGFyeSIsImluc2VydGlvbkluZGV4IiwiYm91bmRhcnlTZWdtZW50IiwiY29udGVudFJvb3RTZWdtZW50IiwicmVuZGVyTm9kZSIsInF1ZXVlQ29tcGxldGVkU2VnbWVudCIsInN1c3BlbmRlZEZhbGxiYWNrVGFzayIsInJlbmRlckhvc3RFbGVtZW50Iiwic2VnbWVudCIsInByZXZDb250ZXh0Iiwic2hvdWxkQ29uc3RydWN0JDEiLCJyZW5kZXJXaXRoSG9va3MiLCJzZWNvbmRBcmciLCJmaW5pc2hDbGFzc0NvbXBvbmVudCIsIm5leHRDaGlsZHJlbiIsImRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMiLCJwcmV2aW91c0NvbnRleHQiLCJtZXJnZWRDb250ZXh0IiwicmVuZGVyTm9kZURlc3RydWN0aXZlIiwicmVuZGVyQ2xhc3NDb21wb25lbnQiLCJtYXNrZWRDb250ZXh0IiwiZGlkV2FybkFib3V0QmFkQ2xhc3MiLCJkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50IiwiZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50IiwiZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCIsImRpZFdhcm5BYm91dEdlbmVyYXRvcnMiLCJkaWRXYXJuQWJvdXRNYXBzIiwiaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyIiwicmVuZGVySW5kZXRlcm1pbmF0ZUNvbXBvbmVudCIsImhhc0lkIiwiX2NvbXBvbmVudE5hbWUyIiwidmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2IiwicHJldlRyZWVDb250ZXh0IiwiX2NvbXBvbmVudE5hbWUzIiwiX2NvbXBvbmVudE5hbWU0IiwicmVzb2x2ZURlZmF1bHRQcm9wcyIsImJhc2VQcm9wcyIsInJlbmRlckZvcndhcmRSZWYiLCJyZW5kZXJNZW1vIiwicmVzb2x2ZWRQcm9wcyIsInJlbmRlckVsZW1lbnQiLCJyZW5kZXJDb250ZXh0Q29uc3VtZXIiLCJDb25zdW1lciIsIm5ld1ZhbHVlIiwibmV3Q2hpbGRyZW4iLCJyZW5kZXJDb250ZXh0UHJvdmlkZXIiLCJyZW5kZXJMYXp5Q29tcG9uZW50IiwidmFsaWRhdGVJdGVyYWJsZSIsIml0ZXJhYmxlIiwiaXRlcmF0b3JGbiIsImVudHJpZXMiLCJyZW5kZXJOb2RlRGVzdHJ1Y3RpdmVJbXBsIiwidGhlbiIsImxhenlOb2RlIiwicmVzb2x2ZWROb2RlIiwicmVuZGVyQ2hpbGRyZW5BcnJheSIsImRvbmUiLCJjaGlsZFN0cmluZyIsIl9zZWdtZW50Iiwic3Bhd25OZXdTdXNwZW5kZWRUYXNrIiwibmV3U2VnbWVudCIsIm5ld1Rhc2siLCJwcmV2aW91c0Zvcm1hdENvbnRleHQiLCJwcmV2aW91c0xlZ2FjeUNvbnRleHQiLCJwcmV2aW91c0NvbXBvbmVudFN0YWNrIiwiZXJyb3JlZFRhc2siLCJhYm9ydFRhc2tTb2Z0IiwiZmluaXNoZWRUYXNrIiwiYWJvcnRUYXNrIiwicmVhc29uIiwiX2Vycm9yIiwiZXJyb3JQcmVmaXgiLCJwcmV2aW91c1Rhc2tJbkRldiIsImZhbGxiYWNrVGFzayIsImNsZWFyIiwiY2hpbGRTZWdtZW50IiwicmV0cnlUYXNrIiwicHJldlRhc2tJbkRFViIsInByZXZEaXNwYXRjaGVyIiwicHJldkdldEN1cnJlbnRTdGFja0ltcGwiLCJnZXRDdXJyZW50U3RhY2siLCJwcmV2UmVzcG9uc2VTdGF0ZSIsInNwbGljZSIsImZsdXNoQ29tcGxldGVkUXVldWVzIiwiZmx1c2hTdWJ0cmVlIiwic2VnbWVudElEIiwiY2h1bmtJZHgiLCJjaGlsZElkeCIsIm5leHRDaGlsZCIsImZsdXNoU2VnbWVudCIsImNvbnRlbnRTZWdtZW50IiwiZmx1c2hDbGllbnRSZW5kZXJlZEJvdW5kYXJ5IiwiZmx1c2hTZWdtZW50Q29udGFpbmVyIiwiZmx1c2hDb21wbGV0ZWRCb3VuZGFyeSIsImZsdXNoUGFydGlhbGx5Q29tcGxldGVkU2VnbWVudCIsImZsdXNoUGFydGlhbEJvdW5kYXJ5IiwiX2JvdW5kYXJ5IiwiX2JvdW5kYXJ5MiIsImxhcmdlQm91bmRhcmllcyIsIl9ib3VuZGFyeTMiLCJzdGFydFdvcmsiLCJzdGFydEZsb3dpbmciLCJhYm9ydCIsImNyZWF0ZURyYWluSGFuZGxlciIsImNyZWF0ZUFib3J0SGFuZGxlciIsImNyZWF0ZVJlcXVlc3RJbXBsIiwib3B0aW9ucyIsInJlbmRlclRvUGlwZWFibGVTdHJlYW0iLCJoYXNTdGFydGVkRmxvd2luZyIsInBpcGUiLCJvbiIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/cjs/react-dom-server.node.development.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/server.node.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/server.node.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar l, s;\nif (false) {} else {\n    l = __webpack_require__(/*! ./cjs/react-dom-server-legacy.node.development.js */ \"(rsc)/../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/cjs/react-dom-server-legacy.node.development.js\");\n    s = __webpack_require__(/*! ./cjs/react-dom-server.node.development.js */ \"(rsc)/../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/cjs/react-dom-server.node.development.js\");\n}\nexports.version = l.version;\nexports.renderToString = l.renderToString;\nexports.renderToStaticMarkup = l.renderToStaticMarkup;\nexports.renderToNodeStream = l.renderToNodeStream;\nexports.renderToStaticNodeStream = l.renderToStaticNodeStream;\nexports.renderToPipeableStream = s.renderToPipeableStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vc2VydmVyLm5vZGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxHQUFHQztBQUNQLElBQUlDLEtBQXlCLEVBQWMsRUFHMUMsTUFBTTtJQUNMRixJQUFJRyxtQkFBT0EsQ0FBQztJQUNaRixJQUFJRSxtQkFBT0EsQ0FBQztBQUNkO0FBRUFDLGVBQWUsR0FBR0osRUFBRUssT0FBTztBQUMzQkQsc0JBQXNCLEdBQUdKLEVBQUVNLGNBQWM7QUFDekNGLDRCQUE0QixHQUFHSixFQUFFTyxvQkFBb0I7QUFDckRILDBCQUEwQixHQUFHSixFQUFFUSxrQkFBa0I7QUFDakRKLGdDQUFnQyxHQUFHSixFQUFFUyx3QkFBd0I7QUFDN0RMLDhCQUE4QixHQUFHSCxFQUFFUyxzQkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oaXJlci8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtZG9tQDE4LjIuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9zZXJ2ZXIubm9kZS5qcz8xMWZlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGwsIHM7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBsID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLXNlcnZlci1sZWdhY3kubm9kZS5wcm9kdWN0aW9uLm1pbi5qcycpO1xuICBzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLXNlcnZlci5ub2RlLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBsID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLXNlcnZlci1sZWdhY3kubm9kZS5kZXZlbG9wbWVudC5qcycpO1xuICBzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLXNlcnZlci5ub2RlLmRldmVsb3BtZW50LmpzJyk7XG59XG5cbmV4cG9ydHMudmVyc2lvbiA9IGwudmVyc2lvbjtcbmV4cG9ydHMucmVuZGVyVG9TdHJpbmcgPSBsLnJlbmRlclRvU3RyaW5nO1xuZXhwb3J0cy5yZW5kZXJUb1N0YXRpY01hcmt1cCA9IGwucmVuZGVyVG9TdGF0aWNNYXJrdXA7XG5leHBvcnRzLnJlbmRlclRvTm9kZVN0cmVhbSA9IGwucmVuZGVyVG9Ob2RlU3RyZWFtO1xuZXhwb3J0cy5yZW5kZXJUb1N0YXRpY05vZGVTdHJlYW0gPSBsLnJlbmRlclRvU3RhdGljTm9kZVN0cmVhbTtcbmV4cG9ydHMucmVuZGVyVG9QaXBlYWJsZVN0cmVhbSA9IHMucmVuZGVyVG9QaXBlYWJsZVN0cmVhbTtcbiJdLCJuYW1lcyI6WyJsIiwicyIsInByb2Nlc3MiLCJyZXF1aXJlIiwiZXhwb3J0cyIsInZlcnNpb24iLCJyZW5kZXJUb1N0cmluZyIsInJlbmRlclRvU3RhdGljTWFya3VwIiwicmVuZGVyVG9Ob2RlU3RyZWFtIiwicmVuZGVyVG9TdGF0aWNOb2RlU3RyZWFtIiwicmVuZGVyVG9QaXBlYWJsZVN0cmVhbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/server.node.js\n");

/***/ })

};
;